<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7156e4e610a9d14909a701b75c25fcdefeaf4c8c" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="08/24/2018" /><Meta Name="ms.locfileid" Value="37655530" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type LogRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="be935-101"><see cref="T:System.IO.Log.LogStore" />에 저장된 레코드 시퀀스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="be935-101">Represents a record sequence stored in a <see cref="T:System.IO.Log.LogStore" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-102"><xref:System.IO.Log.LogRecordSequence> 클래스는 CLFS(Common Log File System) 로그 위에 레코드 시퀀스 인터페이스의 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-102">The <xref:System.IO.Log.LogRecordSequence> class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log.</span></span> <span data-ttu-id="be935-103">이 클래스는 표준 레코드 기반 기능 외에도, 로그 공간이 부족해지는 상태를 방지하고 동일한 물리적 파일에서 클라이언트를 멀티플렉싱하기 위한 정책 모델을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-103">In addition to the standard record-oriented features, it provides a policy model for avoiding log-full conditions, and multiplexing of clients on the same physical file.</span></span> <span data-ttu-id="be935-104">이 클래스는 CLFS 로그 파일을 직접 조작하고 관리하는 데 필요한 인터페이스를 제공하는 <xref:System.IO.Log.LogStore> 클래스와 함께 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-104">It works with the <xref:System.IO.Log.LogStore> class, which provides an interface for directly manipulating and managing a CLFS log file.</span></span> <span data-ttu-id="be935-105"><xref:System.IO.Log.LogStore> 클래스와 <xref:System.IO.Log.LogRecordSequence> 클래스의 관계는 디스크 파일과 <xref:System.IO.FileStream> 개체의 관계와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-105">The relationship between the <xref:System.IO.Log.LogStore> class and the <xref:System.IO.Log.LogRecordSequence> class is similar to the relationship between a disk file and a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="be935-106">디스크 파일은 실제 저장소를 제공하고 길이 및 마지막 액세스 시간과 같은 특성이 있으며, <xref:System.IO.FileStream> 개체는 파일에서 읽고 파일에 쓰는 데 사용할 수 있는 파일에 대한 뷰를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-106">The disk file provides the concrete storage, and has attributes such as length and last access time; while the <xref:System.IO.FileStream> object provides a view on the file that can be used to read from it and write to it.</span></span> <span data-ttu-id="be935-107">이와 마찬가지로 <xref:System.IO.Log.LogStore> 클래스는 정책 및 디스크 범위 컬렉션과 같은 특성을 가지며, <xref:System.IO.Log.LogRecordSequence> 클래스는 데이터를 읽고 쓰기 위한 레코드 기반 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-107">Similarly, the <xref:System.IO.Log.LogStore> class has attributes like a policy and a collection of disk extents; and the <xref:System.IO.Log.LogRecordSequence> class provides a record-oriented mechanism for reading and writing data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be935-108">다음 예제에서는 <xref:System.IO.Log.LogRecordSequence> 클래스를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-108">This example shows how to use the <xref:System.IO.Log.LogRecordSequence> class:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be935-109"><see cref="T:System.IO.Log.LogRecordSequence" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-109">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence logStore" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore"><span data-ttu-id="be935-110">이 레코드 시퀀스에서 사용해야 하는 <see cref="T:System.IO.Log.LogStore" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-110">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</span></span></param>
        <summary><span data-ttu-id="be935-111">지정된 로그 저장소를 사용하여 <see cref="T:System.IO.Log.LogRecordSequence" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-111">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-112">버퍼 크기에 따라 추가하거나 읽을 수 있는 최대 레코드 크기가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-112">The buffer size determines the maximum size of the record that can be appended or read.</span></span> <span data-ttu-id="be935-113">이 생성자에는 기본값 64가 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-113">In this constructor, a default value of 64 is set.</span></span> <span data-ttu-id="be935-114">원하는 버퍼 수는 10으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-114">The desired number of buffers is set to 10.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-115"><paramref name="logStore" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-115"><paramref name="logStore" /> is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="be935-116">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-116">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="be935-117">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-117">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <summary><span data-ttu-id="be935-118">지정된 로그 저장소 경로와 액세스 모드를 사용하여 <see cref="T:System.IO.Log.LogRecordSequence" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-118">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-119">이 생성자는 지정된 경로와 모드를 사용하여 여는 새 <xref:System.IO.Log.LogRecordSequence> 개체에서 새로운 <xref:System.IO.Log.LogStore>를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-119">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path and mode.</span></span> <span data-ttu-id="be935-120">저장소에 대한 읽기/쓰기 액세스 권한이 제공되며 저장소는 읽기 권한을 공유하여 열립니다.</span><span class="sxs-lookup"><span data-stu-id="be935-120">It is given read/write access to the store, and the store is opened sharing Read access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-121"><paramref name="path" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-121"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-122"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-122"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="be935-123">또는</span><span class="sxs-lookup"><span data-stu-id="be935-123">-or-</span></span> 
 <span data-ttu-id="be935-124"><paramref name="path" />에 공백만 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-124"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="be935-125">또는</span><span class="sxs-lookup"><span data-stu-id="be935-125">-or-</span></span> 
 <span data-ttu-id="be935-126"><paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-126"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-127"><paramref name="mode" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-127"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be935-128">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-128">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-129">로그 저장소를 열 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-129">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-130">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-130">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-131">이 작업이 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-131">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-132">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-132">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="be935-133">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogRecordSequence" />를 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="be935-133"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="be935-134">사용 중인 플랫폼에 대한 CLFS 구성 요소가 있으면 해당 구성 요소를 설치하거나, <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-134">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (logStore, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore"><span data-ttu-id="be935-135">이 레코드 시퀀스에서 사용해야 하는 <see cref="T:System.IO.Log.LogStore" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-135">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="be935-136">원하는 버퍼 크기(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-136">The desired buffer size in bytes.</span></span> <span data-ttu-id="be935-137">버퍼 크기에 따라 추가하거나 읽을 수 있는 최대 레코드 크기가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-137">The buffer size determines the maximum size of the record that can be appended or read.</span></span></param>
        <param name="bufferCount"><span data-ttu-id="be935-138">원하는 버퍼 수입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-138">The desired number of buffers.</span></span></param>
        <summary><span data-ttu-id="be935-139">지정된 로그 저장소, 각 레코드의 버퍼 크기, 버퍼 수를 사용하여 <see cref="T:System.IO.Log.LogRecordSequence" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-139">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store, buffer size for each record, and buffer number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-140">`bufferSize`와 `bufferCount`의 값을 지정하려 할 때 `bufferSize`와 `bufferCount`에 각각 기본값 64와 기본값 10을 사용하지 않으려는 경우 이 생성자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-140">Use this constructor if you want to specify values for `bufferSize` and `bufferCount` and do not want to use the default value of 64 for `bufferSize` and 10 for `bufferCount`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-141"><paramref name="logStore" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-141"><paramref name="logStore" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-142"><paramref name="bufferSize" />가 음수이거나 0인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-142"><paramref name="bufferSize" /> is negative or zero.</span></span>  
  
<span data-ttu-id="be935-143">또는</span><span class="sxs-lookup"><span data-stu-id="be935-143">-or-</span></span> 
 <span data-ttu-id="be935-144"><paramref name="bufferCount" />가 음수이거나 0인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-144"><paramref name="bufferCount" /> is negative or zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="be935-145">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-145">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="be935-146">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-146">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="be935-147"><see cref="T:System.IO.FileAccess" />에서 파일에 액세스할 수 있는 방법을 결정하는 <see cref="T:System.IO.Log.LogStore" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-147">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <summary><span data-ttu-id="be935-148">지정된 로그 저장소 경로와 액세스 및 공유 모드를 사용하여 <see cref="T:System.IO.Log.LogRecordSequence" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-148">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access and share modes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-149">이 생성자는 지정된 경로, 모드, 액세스를 사용하여, 생성자에서 여는 새 <xref:System.IO.Log.LogRecordSequence> 개체의 새로운 <xref:System.IO.Log.LogStore>를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-149">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="be935-150">저장소는 읽기 권한을 공유하여 열립니다.</span><span class="sxs-lookup"><span data-stu-id="be935-150">The store is opened sharing Read access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-151"><paramref name="path" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-151"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-152"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-152"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="be935-153">또는</span><span class="sxs-lookup"><span data-stu-id="be935-153">-or-</span></span> 
 <span data-ttu-id="be935-154"><paramref name="path" />에 공백만 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-154"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="be935-155">또는</span><span class="sxs-lookup"><span data-stu-id="be935-155">-or-</span></span> 
 <span data-ttu-id="be935-156"><paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-156"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-157"><paramref name="mode" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-157"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be935-158">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-158">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-159">로그 저장소를 열 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-159">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-160">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-160">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-161">이 작업이 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-161">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-162">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-162">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="be935-163">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogRecordSequence" />를 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="be935-163"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="be935-164">사용 중인 플랫폼에 대한 CLFS 구성 요소가 있으면 해당 구성 요소를 설치하거나, <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-164">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="be935-165">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-165">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="be935-166">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-166">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="be935-167"><see cref="T:System.IO.FileAccess" />에서 파일에 액세스할 수 있는 방법을 결정하는 <see cref="T:System.IO.Log.LogStore" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-167">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <param name="share"><span data-ttu-id="be935-168">로그 저장소가 프로세스 간에 공유되는 방법을 결정하는 <see cref="T:System.IO.FileShare" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-168">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span></span></param>
        <summary><span data-ttu-id="be935-169">지정된 로그 저장소 경로와 액세스 모드를 사용하여 <see cref="T:System.IO.Log.LogRecordSequence" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-169">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-170">이 생성자는 지정된 경로, 모드, 액세스를 사용하여, 생성자에서 여는 새 <xref:System.IO.Log.LogRecordSequence> 개체의 새로운 <xref:System.IO.Log.LogStore>를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-170">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="be935-171">저장소는 지정된 액세스 권한을 공유하여 열립니다.</span><span class="sxs-lookup"><span data-stu-id="be935-171">The store is opened sharing the specified access.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be935-172">다음 예제에서는 이 <xref:System.IO.Log.LogRecordSequence> 생성자를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-172">This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-173"><paramref name="path" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-173"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-174"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-174"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="be935-175">또는</span><span class="sxs-lookup"><span data-stu-id="be935-175">-or-</span></span> 
 <span data-ttu-id="be935-176"><paramref name="path" />에 공백만 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-176"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="be935-177">또는</span><span class="sxs-lookup"><span data-stu-id="be935-177">-or-</span></span> 
 <span data-ttu-id="be935-178"><paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-178"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-179"><paramref name="mode" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-179"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be935-180">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-180">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-181">로그 저장소를 열 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-181">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-182">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-182">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-183">이 작업이 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-183">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-184">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-184">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="be935-185">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogRecordSequence" />를 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="be935-185"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="be935-186">사용 중인 플랫폼에 대한 CLFS 구성 요소가 있으면 해당 구성 요소를 설치하거나, <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-186">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="be935-187">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-187">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="be935-188">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-188">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="be935-189"><see cref="T:System.IO.FileAccess" />에서 파일에 액세스할 수 있는 방법을 결정하는 <see cref="T:System.IO.Log.LogStore" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-189">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <param name="share"><span data-ttu-id="be935-190">로그 저장소가 프로세스 간에 공유되는 방법을 결정하는 <see cref="T:System.IO.FileShare" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-190">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="be935-191">원하는 버퍼 크기(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-191">The desired buffer size in bytes.</span></span> <span data-ttu-id="be935-192">버퍼 크기에 따라 추가하거나 읽을 수 있는 최대 레코드 크기가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-192">The buffer size determines the maximum size of the record that can be appended or read.</span></span></param>
        <param name="bufferCount"><span data-ttu-id="be935-193">원하는 버퍼 수입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-193">The desired number of buffers.</span></span></param>
        <summary><span data-ttu-id="be935-194">지정된 로그 저장소 경로, 파일 사용 권한, 액세스 및 공유 모드, 레코드의 버퍼 크기 및 수를 사용하여 <see cref="T:System.IO.Log.LogRecordSequence" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-194">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store, file permission, access and share modes, and the buffer size and count for records.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-195">이 생성자는 지정된 경로, 모드, 액세스를 사용하여, 생성자에서 여는 새 <xref:System.IO.Log.LogRecordSequence> 개체의 새로운 <xref:System.IO.Log.LogStore>를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-195">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="be935-196">저장소는 지정된 액세스 권한을 공유하여 열립니다.</span><span class="sxs-lookup"><span data-stu-id="be935-196">The store is opened sharing the specified access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-197"><paramref name="path" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-197"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-198"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-198"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="be935-199">또는</span><span class="sxs-lookup"><span data-stu-id="be935-199">-or-</span></span> 
 <span data-ttu-id="be935-200"><paramref name="path" />에 공백만 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-200"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="be935-201">또는</span><span class="sxs-lookup"><span data-stu-id="be935-201">-or-</span></span> 
 <span data-ttu-id="be935-202"><paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-202"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-203"><paramref name="mode" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-203"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be935-204">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-204">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-205">로그 저장소를 열 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-205">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-206">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-206">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-207">이 작업이 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-207">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-208">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-208">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="be935-209">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogRecordSequence" />를 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="be935-209"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="be935-210">사용 중인 플랫폼에 대한 CLFS 구성 요소가 있으면 해당 구성 요소를 설치하거나, <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-210">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="be935-211">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-211">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="be935-212">저장소를 열거나 만드는 방법을 결정하는 유효한 <see cref="T:System.IO.FileMode" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-212">A valid <see cref="T:System.IO.FileMode" /> value that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="be935-213">로그 저장소에 액세스할 수 있는 방법을 결정하는 유효한 <see cref="T:System.IO.FileAccess" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-213">A valid <see cref="T:System.IO.FileAccess" /> value that determines how the log store can be accessed.</span></span></param>
        <param name="share"><span data-ttu-id="be935-214">로그 저장소가 프로세스 간에 공유되는 방법을 결정하는 유효한 <see cref="T:System.IO.FileShare" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-214">A valid <see cref="T:System.IO.FileShare" /> value that determines how the log store will be shared among processes.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="be935-215">원하는 버퍼 크기(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-215">The desired buffer size in bytes.</span></span> <span data-ttu-id="be935-216">버퍼 크기에 따라 추가하거나 읽을 수 있는 최대 레코드 크기가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-216">The buffer size determines the maximum size of the record that can be appended or read.</span></span></param>
        <param name="bufferCount"><span data-ttu-id="be935-217">원하는 버퍼 수입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-217">The desired number of buffers.</span></span></param>
        <param name="fileSecurity"><span data-ttu-id="be935-218">저장소를 만들어야 하는 경우 새로 만든 저장소에 설정할 보안을 지정하는 유효한 <see cref="T:System.Security.AccessControl.FileSecurity" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-218">A valid <see cref="T:System.Security.AccessControl.FileSecurity" /> value that specifies the security to set on the newly created store if the store must be created.</span></span></param>
        <summary><span data-ttu-id="be935-219"><see cref="T:System.IO.Log.LogRecordSequence" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-219">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-220"><paramref name="path" />로 지정된 파일이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-220">The file specified by <paramref name="path" /> is not valid.</span></span>  
  
<span data-ttu-id="be935-221">또는</span><span class="sxs-lookup"><span data-stu-id="be935-221">-or-</span></span> 
<span data-ttu-id="be935-222">지정된 로그 저장소 파일 이름이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-222">The specified log store file name is not valid.</span></span>  
  
<span data-ttu-id="be935-223">또는</span><span class="sxs-lookup"><span data-stu-id="be935-223">-or-</span></span> 
 <span data-ttu-id="be935-224"><paramref name="mode" /> 값이 <see cref="F:System.IO.FileMode.CreateNew" />이고 쓰기 액세스 권한 없이 사용할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-224"><paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.CreateNew" />, and cannot be used without write access.</span></span>  
  
<span data-ttu-id="be935-225">또는</span><span class="sxs-lookup"><span data-stu-id="be935-225">-or-</span></span> 
 <span data-ttu-id="be935-226"><paramref name="mode" /> 값이 <see cref="F:System.IO.FileMode.OpenOrCreate" />이고 쓰기 액세스 권한 없이 사용할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-226"><paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.OpenOrCreate" />, and cannot be used without write access.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-227">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-227">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-228">하나 이상의 인수가 범위를 벗어난 경우</span><span class="sxs-lookup"><span data-stu-id="be935-228">One or more of the arguments are out of range.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be935-229"><paramref name="path" />로 지정된 파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-229">The file specified by <paramref name="path" /> cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-230">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-230">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-231">또는</span><span class="sxs-lookup"><span data-stu-id="be935-231">-or-</span></span> 
<span data-ttu-id="be935-232"><paramref name="path" />로 지정된 파일을 다른 프로세스에서 사용 중이기 때문에 액세스할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-232">The file specified by <paramref name="path" /> cannot be accessed because it is in use by another process.</span></span>  
  
<span data-ttu-id="be935-233">또는</span><span class="sxs-lookup"><span data-stu-id="be935-233">-or-</span></span> 
<span data-ttu-id="be935-234"><paramref name="path" />로 지정된 파일이나 디렉터리가 이미 있기 때문에 해당 파일을 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-234">The file specified by <paramref name="path" /> cannot be created because the file or directory already exists.</span></span>  
  
<span data-ttu-id="be935-235">또는</span><span class="sxs-lookup"><span data-stu-id="be935-235">-or-</span></span> 
<span data-ttu-id="be935-236">로그 핸들을 스레드 풀에 바인딩할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-236">The log handle could not be bound to the thread pool.</span></span>  
  
<span data-ttu-id="be935-237">또는</span><span class="sxs-lookup"><span data-stu-id="be935-237">-or-</span></span> 
<span data-ttu-id="be935-238">지정된 로그 파일 형식이나 버전이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-238">The specified log file format or version is invalid.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-239">이 작업이 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-239">This operation is not supported.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-240">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-240">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-241">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-241">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="be935-242">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogRecordSequence" />를 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="be935-242"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="be935-243">사용 중인 플랫폼에 대한 CLFS 구성 요소가 있으면 해당 구성 요소를 설치하거나, <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-243">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-244">레코드 시퀀스가 꽉 찼습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-244">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-245">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-245">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber"><span data-ttu-id="be935-246">로그에 대한 새 기준 <see cref="T:System.IO.Log.SequenceNumber" />를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-246">Specifies the new base <see cref="T:System.IO.Log.SequenceNumber" /> for the log.</span></span> <span data-ttu-id="be935-247">이 번호는 로그의 현재 기준 시퀀스 번호부터 마지막 시퀀스 번호까지의 범위 내에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-247">This must lie in the range between the current base sequence number and the last sequence number of the log inclusively.</span></span></param>
        <summary><span data-ttu-id="be935-248">로그의 기준 시퀀스 번호를 앞으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-248">Moves the base sequence number of the log forward.</span></span> <span data-ttu-id="be935-249">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-249">This method cannot be inherited.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-250">이 메서드는 레코드에서 공간을 확보하기 위해 주로 <xref:System.IO.Log.LogRecordSequence.TailPinned> 이벤트와 함께 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-250">This method is often used with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a record.</span></span> <span data-ttu-id="be935-251"><xref:System.IO.Log.LogRecordSequence.TailPinned> 이벤트는 공간을 확보하기 위해 시퀀스의 테일(기준 시퀀스 번호)을 앞으로 이동해야 함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="be935-251">The <xref:System.IO.Log.LogRecordSequence.TailPinned> event indicates that the tail of the sequence (that is, the base sequence number) needs to be moved forward to free up space.</span></span> <span data-ttu-id="be935-252">공간 확보는 <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> 메서드를 사용하여 재시작 영역을 쓰거나, 로그를 자르고 <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> 메서드를 사용하여 로그의 기준 시퀀스 번호를 `newBaseSequenceNumber` 매개 변수에 지정된 번호로 앞당겨서 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-252">Freeing space can be done by either writing restart areas using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, or truncating the log and using the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method to advance the base sequence number of a log to the one specified by the `newBaseSequenceNumber` parameter.</span></span> <span data-ttu-id="be935-253">예제 부분의 코드 샘플에서는 두 번째 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-253">The code sample in the Example section demonstrates the second approach.</span></span>  
  
 <span data-ttu-id="be935-254">이 메서드를 호출하는 것은 재시작 레코드를 로그에 쓰지 않는다는 점을 제외하고 <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> 메서드를 사용하여 새 기준 시퀀스 번호를 설정하는 것과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-254">Note that calling this method is the same as setting a new base sequence number using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, except that no restart record is written to the log.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be935-255">다음 예제에서는 <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> 메서드를 <xref:System.IO.Log.LogRecordSequence.TailPinned> 이벤트와 함께 사용하여 로그 시퀀스에서 공간을 확보하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-255">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.</span></span>  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-256"><paramref name="newBaseSequenceNumber" />이 이 시퀀스에 유효하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-256"><paramref name="newBaseSequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-257">활성 로그의 기존 또는 새 아카이브 테일이나 베이스가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-257">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
<span data-ttu-id="be935-258">또는</span><span class="sxs-lookup"><span data-stu-id="be935-258">-or-</span></span> 
 <span data-ttu-id="be935-259"><paramref name="newBaseSequenceNumber" />이 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-259"><paramref name="newBaseSequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-260">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-260">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-261">또는</span><span class="sxs-lookup"><span data-stu-id="be935-261">-or-</span></span> 
<span data-ttu-id="be935-262">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-262">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be935-263">지정된 로그에 범위가 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="be935-263">The specified log does not have any extents.</span></span> <span data-ttu-id="be935-264">레코드 시퀀스를 사용하기 전에 범위를 하나 이상 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-264">One or more extents must be created before a record sequence may be used.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-265">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-265">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-266">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-266">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-267">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-267">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-268">레코드 시퀀스가 꽉 찼습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-268">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be935-269">로그 레코드를 <see cref="T:System.IO.Log.IRecordSequence" />에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="be935-269">Writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="be935-270">다음 예제에서는 <xref:System.IO.Log.LogRecordSequence.Append%2A> 멤버를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-270">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.Append%2A> member</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-271">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-271">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="be935-272">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-272">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-273">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-273">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-274">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-274">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <summary><span data-ttu-id="be935-275">로그 레코드를 <see cref="T:System.IO.Log.LogRecordSequence" />에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="be935-275">Writes a log record to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span> <span data-ttu-id="be935-276">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-276">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-277">추가된 로그 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-277">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-278">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-278">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-279">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-279">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-280">일반적으로 이 메서드는 레코드를 쓰기 전에 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-280">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="be935-281">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.LogRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-281">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be935-282">다음 예제에서는 이 메서드를 사용하여 로그 레코드를 시퀀스에 추가하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-282">The following example demonstrates how to use this method to append a log record to the sequence.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-283"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스에 부적합한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-283"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-284">또는</span><span class="sxs-lookup"><span data-stu-id="be935-284">-or-</span></span> 
 <span data-ttu-id="be935-285"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-285"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-286">또는</span><span class="sxs-lookup"><span data-stu-id="be935-286">-or-</span></span> 
 <span data-ttu-id="be935-287">이 레코드 시퀀스를 통해 <paramref name="reservations" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-287"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-288">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-288">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-289"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-289"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-290">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-290">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-291">또는</span><span class="sxs-lookup"><span data-stu-id="be935-291">-or-</span></span> 
<span data-ttu-id="be935-292">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-292">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-293">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-293">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-294">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-294">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-295">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-295">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-296">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-296">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-297">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-297">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-298">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-298">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="be935-299">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-299">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-300">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-300">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-301">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-301">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <summary><span data-ttu-id="be935-302">로그 레코드를 <see cref="T:System.IO.Log.IRecordSequence" />에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-302">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span> <span data-ttu-id="be935-303">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-303">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-304">추가된 로그 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-304">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-305">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-305">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-306">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-306">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-307">일반적으로 이 메서드는 레코드를 쓰기 전에 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-307">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="be935-308">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.LogRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-308">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-309"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스에 부적합한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-309"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-310">또는</span><span class="sxs-lookup"><span data-stu-id="be935-310">-or-</span></span> 
 <span data-ttu-id="be935-311"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-311"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-312">또는</span><span class="sxs-lookup"><span data-stu-id="be935-312">-or-</span></span> 
 <span data-ttu-id="be935-313">이 레코드 시퀀스를 통해 <paramref name="reservations" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-313"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-314">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-314">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-315"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-315"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-316">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-316">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-317">또는</span><span class="sxs-lookup"><span data-stu-id="be935-317">-or-</span></span> 
<span data-ttu-id="be935-318">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-318">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-319">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-319">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-320">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-320">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-321">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-321">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-322">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-322">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-323">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-323">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-324">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-324">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="be935-325">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-325">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-326">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-326">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-327">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-327">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="be935-328">이 레코드에 사용해야 하는 예약이 포함된 <see cref="T:System.IO.Log.ReservationCollection" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-328">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <summary><span data-ttu-id="be935-329">시퀀스에서 이전에 예약된 공간을 사용하여 로그 레코드를 <see cref="T:System.IO.Log.IRecordSequence" />에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-329">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span></span> <span data-ttu-id="be935-330">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-330">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-331">추가된 로그 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-331">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-332">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-332">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-333">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-333">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-334">추가된 레코드는 `reservations` 매개 변수로 지정된 예약을 사용하여 이전에 예약된 공간을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-334">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="be935-335">추가 작업이 성공하면 데이터가 포함될 수 있는 가장 작은 예약 영역을 사용하고 해당 예약 영역이 컬렉션에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-335">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="be935-336">일반적으로 이 메서드는 레코드를 쓰기 전에 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-336">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="be935-337">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.LogRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-337">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-338"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스에 부적합한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-338"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-339">또는</span><span class="sxs-lookup"><span data-stu-id="be935-339">-or-</span></span> 
 <span data-ttu-id="be935-340"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-340"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-341">또는</span><span class="sxs-lookup"><span data-stu-id="be935-341">-or-</span></span> 
 <span data-ttu-id="be935-342">이 레코드 시퀀스를 통해 <paramref name="reservations" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-342"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-343">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-343">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-344"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-344"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-345">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-345">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-346">또는</span><span class="sxs-lookup"><span data-stu-id="be935-346">-or-</span></span> 
<span data-ttu-id="be935-347">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-347">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-348">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-348">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-349">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-349">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-350">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-350">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-351">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-351">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-352">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-352">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="be935-353"><paramref name="data" />에서 <paramref name="reservations" />에 맞는 크기의 예약을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-353">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-354">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-354">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="be935-355">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-355">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-356">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-356">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-357">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-357">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="be935-358">이 레코드에 사용해야 하는 예약이 포함된 <see cref="T:System.IO.Log.ReservationCollection" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-358">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <summary><span data-ttu-id="be935-359">시퀀스에서 이전에 예약된 공간을 사용하여 로그 레코드를 <see cref="T:System.IO.Log.IRecordSequence" />에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-359">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span></span> <span data-ttu-id="be935-360">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-360">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-361">추가된 로그 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-361">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-362">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-362">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-363">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-363">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-364">추가된 레코드는 `reservations` 매개 변수로 지정된 예약을 사용하여 이전에 예약된 공간을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-364">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="be935-365">추가 작업이 성공하면 데이터가 포함될 수 있는 가장 작은 예약 영역을 사용하고 해당 예약 영역이 컬렉션에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-365">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="be935-366">일반적으로 이 메서드는 레코드를 쓰기 전에 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-366">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="be935-367">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.IRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-367">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-368"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스에 부적합한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-368"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-369">또는</span><span class="sxs-lookup"><span data-stu-id="be935-369">-or-</span></span> 
 <span data-ttu-id="be935-370"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-370"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-371">또는</span><span class="sxs-lookup"><span data-stu-id="be935-371">-or-</span></span> 
 <span data-ttu-id="be935-372">이 레코드 시퀀스를 통해 <paramref name="reservations" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-372"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-373">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-373">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-374"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-374"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-375">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-375">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-376">또는</span><span class="sxs-lookup"><span data-stu-id="be935-376">-or-</span></span> 
<span data-ttu-id="be935-377">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-377">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-378">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-378">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-379">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-379">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-380">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-380">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-381">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-381">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-382">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-382">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="be935-383"><paramref name="data" />에서 <paramref name="reservations" />에 맞는 크기의 예약을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-383">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be935-384">현재 <see cref="T:System.IO.Log.LogRecordSequence" />에서 유효한 첫 번째 레코드의 시퀀스 번호를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="be935-384">Gets the sequence number of the first valid record in the current <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></summary>
        <value><span data-ttu-id="be935-385"><see cref="T:System.IO.Log.LogRecordSequence" />에서 유효한 레코드에 해당하는 가장 작은 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-385">The lowest sequence number that corresponds to a valid record in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-386">유효한 시퀀스 번호는 <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>보다 크거나 같고 <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-386">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
 <span data-ttu-id="be935-387"><xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> 메서드 또는 <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> 메서드를 호출하여 이 속성의 값을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-387">The value of this property can be changed by calling the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method or <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be935-388">다음 예제에서는 루프에서 <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> 멤버를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-388">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> member in a loop.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-389">시퀀스가 삭제된 후 속성에 액세스한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-389">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be935-390">비동기 추가 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-390">Begins an asynchronous append operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-391">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-391">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="be935-392">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-392">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-393">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-393">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-394">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-394">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="callback"><span data-ttu-id="be935-395">추가가 완료되면 호출되는 선택적 비동기 콜백입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-395">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="be935-396">이 특정 비동기 추가 요청을 다른 요청과 구별하는 사용자 제공 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-396">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="be935-397">비동기 추가 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-397">Begins an asynchronous append operation.</span></span> <span data-ttu-id="be935-398">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-398">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-399">보류 중일 수 있는 비동기 추가를 나타내는 <see cref="T:System.IAsyncResult" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-399">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-400">이 메서드에서 반환된 <xref:System.IAsyncResult>를 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 메서드에 전달하여 추가 작업을 완료하고 리소스를 적절하게 해제할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-400">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="be935-401">비동기 추가 중에 오류가 발생한 경우 이 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>를 사용하여 <xref:System.IAsyncResult> 메서드를 호출하기 전에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-401">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="be935-402">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-402">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-403">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-403">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-404">일반적으로 이 메서드는 레코드를 쓰기 전에 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-404">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="be935-405">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.LogRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-405">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-406"><paramref name="nextUndoRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스에 부적합한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-406"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-407">또는</span><span class="sxs-lookup"><span data-stu-id="be935-407">-or-</span></span> 
 <span data-ttu-id="be935-408"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-408"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-409">또는</span><span class="sxs-lookup"><span data-stu-id="be935-409">-or-</span></span> 
 <span data-ttu-id="be935-410">이 레코드 시퀀스를 통해 <paramref name="reservations" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-410"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-411">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-411">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-412"><paramref name="nextUndoRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-412"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-413">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-413">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-414">또는</span><span class="sxs-lookup"><span data-stu-id="be935-414">-or-</span></span> 
<span data-ttu-id="be935-415">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-415">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-416">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-416">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-417">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-417">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-418">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-418">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-419">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-419">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-420">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-420">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-421">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-421">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="be935-422">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-422">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-423">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-423">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-424">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-424">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="callback"><span data-ttu-id="be935-425">추가가 완료되면 호출되는 선택적 비동기 콜백입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-425">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="be935-426">이 특정 비동기 추가 요청을 다른 요청과 구별하는 사용자 제공 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-426">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="be935-427">비동기 추가 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-427">Begins an asynchronous append operation.</span></span> <span data-ttu-id="be935-428">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-428">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-429">보류 중일 수 있는 비동기 추가를 나타내는 <see cref="T:System.IAsyncResult" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-429">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-430">이 메서드에서 반환된 <xref:System.IAsyncResult>를 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 메서드에 전달하여 추가 작업을 완료하고 리소스를 적절하게 해제할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-430">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="be935-431">비동기 추가 중에 오류가 발생한 경우 이 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>를 사용하여 <xref:System.IAsyncResult> 메서드를 호출하기 전에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-431">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="be935-432">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-432">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-433">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-433">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-434">일반적으로 이 메서드는 레코드를 쓰기 전에 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-434">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="be935-435">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.LogRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-435">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-436"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스에 부적합한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-436"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-437">또는</span><span class="sxs-lookup"><span data-stu-id="be935-437">-or-</span></span> 
 <span data-ttu-id="be935-438"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-438"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-439">또는</span><span class="sxs-lookup"><span data-stu-id="be935-439">-or-</span></span> 
 <span data-ttu-id="be935-440">이 레코드 시퀀스를 통해 <paramref name="reservations" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-440"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-441">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-441">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-442"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-442"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-443">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-443">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-444">또는</span><span class="sxs-lookup"><span data-stu-id="be935-444">-or-</span></span> 
<span data-ttu-id="be935-445">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-445">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-446">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-446">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-447">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-447">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-448">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-448">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-449">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-449">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-450">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-450">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-451">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-451">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="be935-452">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-452">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-453">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-453">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-454">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-454">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="be935-455">이 레코드에 사용해야 하는 예약이 포함된 <see cref="T:System.IO.Log.ReservationCollection" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-455">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <param name="callback"><span data-ttu-id="be935-456">추가가 완료되면 호출되는 선택적 비동기 콜백입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-456">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="be935-457">이 특정 비동기 추가 요청을 다른 요청과 구별하는 사용자 제공 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-457">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="be935-458">비동기 추가 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-458">Begins an asynchronous append operation.</span></span> <span data-ttu-id="be935-459">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-459">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-460">보류 중일 수 있는 비동기 추가를 나타내는 <see cref="T:System.IAsyncResult" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-460">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-461">이 메서드에서 반환된 <xref:System.IAsyncResult>를 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 메서드에 전달하여 추가 작업을 완료하고 리소스를 적절하게 해제할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-461">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="be935-462">비동기 추가 중에 오류가 발생한 경우 이 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>를 사용하여 <xref:System.IAsyncResult> 메서드를 호출하기 전에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-462">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="be935-463">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-463">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-464">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-464">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-465">추가된 레코드는 `reservations` 매개 변수로 지정된 예약을 사용하여 이전에 예약된 공간을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-465">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="be935-466">추가 작업이 성공하면 데이터가 포함될 수 있는 가장 작은 예약 영역을 사용하고 해당 예약 영역이 컬렉션에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-466">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="be935-467">일반적으로 이 메서드는 레코드를 쓰기 전에 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-467">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="be935-468">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.LogRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-468">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-469"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스에 부적합한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-469"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-470">또는</span><span class="sxs-lookup"><span data-stu-id="be935-470">-or-</span></span> 
 <span data-ttu-id="be935-471"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-471"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-472">또는</span><span class="sxs-lookup"><span data-stu-id="be935-472">-or-</span></span> 
 <span data-ttu-id="be935-473">이 레코드 시퀀스를 통해 <paramref name="reservations" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-473"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-474">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-474">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-475"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-475"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-476">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-476">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-477">또는</span><span class="sxs-lookup"><span data-stu-id="be935-477">-or-</span></span> 
<span data-ttu-id="be935-478">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-478">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-479">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-479">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-480">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-480">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-481">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-481">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-482">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-482">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-483">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-483">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="be935-484"><paramref name="data" />에서 <paramref name="reservations" />에 맞는 크기의 예약을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-484">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-485">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-485">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="be935-486">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-486">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-487">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-487">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-488">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-488">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="be935-489">이 레코드에 사용해야 하는 예약이 포함된 <see cref="T:System.IO.Log.ReservationCollection" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-489">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <param name="callback"><span data-ttu-id="be935-490">추가가 완료되면 호출되는 선택적 비동기 콜백입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-490">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="be935-491">이 특정 비동기 추가 요청을 다른 요청과 구별하는 사용자 제공 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-491">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="be935-492">비동기 추가 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-492">Begins an asynchronous append operation.</span></span> <span data-ttu-id="be935-493">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-493">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-494">보류 중일 수 있는 비동기 추가를 나타내는 <see cref="T:System.IAsyncResult" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-494">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-495">이 메서드에서 반환된 <xref:System.IAsyncResult>를 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 메서드에 전달하여 추가 작업을 완료하고 리소스를 적절하게 해제할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-495">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="be935-496">비동기 추가 중에 오류가 발생한 경우 이 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>를 사용하여 <xref:System.IAsyncResult> 메서드를 호출하기 전에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-496">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="be935-497">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-497">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-498">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-498">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-499">추가된 레코드는 `reservations` 매개 변수로 지정된 예약을 사용하여 이전에 예약된 공간을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-499">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="be935-500">추가 작업이 성공하면 데이터가 포함될 수 있는 가장 작은 예약 영역을 사용하고 해당 예약 영역이 컬렉션에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-500">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="be935-501">일반적으로 이 메서드는 레코드를 쓰기 전에 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-501">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="be935-502">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.LogRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-502">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-503"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스에 부적합한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-503"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-504">또는</span><span class="sxs-lookup"><span data-stu-id="be935-504">-or-</span></span> 
 <span data-ttu-id="be935-505"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-505"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-506">또는</span><span class="sxs-lookup"><span data-stu-id="be935-506">-or-</span></span> 
 <span data-ttu-id="be935-507">이 레코드 시퀀스를 통해 <paramref name="reservations" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-507"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-508">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-508">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-509"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-509"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-510">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-510">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-511">또는</span><span class="sxs-lookup"><span data-stu-id="be935-511">-or-</span></span> 
<span data-ttu-id="be935-512">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-512">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-513">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-513">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-514">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-514">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-515">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-515">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-516">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-516">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-517">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-517">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="be935-518"><paramref name="data" />에서 <paramref name="reservations" />에 맞는 크기의 예약을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-518">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber"><span data-ttu-id="be935-519">써야 하는 최신 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-519">The sequence number of the latest record that must be written.</span></span> <span data-ttu-id="be935-520">이 <see cref="T:System.IO.Log.SequenceNumber" />가 유효하지 않은 경우 모든 레코드를 써야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-520">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span></span></param>
        <param name="callback"><span data-ttu-id="be935-521">플러시가 완료되면 호출되는 선택적 비동기 콜백입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-521">An optional asynchronous callback, to be called when the flush is complete.</span></span></param>
        <param name="state"><span data-ttu-id="be935-522">이 특정 비동기 플러시 요청을 다른 요청과 구별하는 사용자 제공 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-522">A user-provided object that distinguishes this particular asynchronous flush request from other requests.</span></span></param>
        <summary><span data-ttu-id="be935-523">시퀀스에서 이전에 예약된 공간을 사용하여 비동기 플러시 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-523">Begins an asynchronous flush operation, using space previously reserved in the sequence.</span></span> <span data-ttu-id="be935-524">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-524">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-525">보류 중일 수 있는 비동기 플러시 작업을 나타내는 <see cref="T:System.IAsyncResult" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-525">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous flush operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-526">현재 메서드에서 반환된 <xref:System.IAsyncResult>를 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> 메서드에 전달하여 플러시를 완료하고 리소스를 적절하게 해제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-526">You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately.</span></span> <span data-ttu-id="be935-527">비동기 플러시 중에 오류가 발생하는 경우 이 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>를 사용하여 <xref:System.IAsyncResult> 메서드를 호출하기 전에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-527">If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="be935-528">이 메서드를 호출하면 <xref:System.IO.Log.LogRecordSequence>에 추가된 모든 레코드가 영속적으로 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-528">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> are durably written.</span></span>  
  
 <span data-ttu-id="be935-529">레코드 시퀀스가 삭제되었거나 잘못된 인수를 전달하는 경우 이 작업 내에서 즉시 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-529">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="be935-530">비동기 플러시 요청 중에 발생한 오류(예: I/O 요청 중의 디스크 오류)로 인해 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> 메서드를 호출할 때 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-530">Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-531"><paramref name="sequenceNumber" />이 이 시퀀스에 유효하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-531"><paramref name="sequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-532"><paramref name="sequenceNumber" />이 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-532"><paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-533">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-533">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be935-534">지정된 로그에 범위가 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="be935-534">The specified log does not have any extents.</span></span> <span data-ttu-id="be935-535">레코드 시퀀스를 사용하려면 먼저 범위를 하나 이상 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-535">One or more extents must be created before a record sequence can be used.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-536">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-536">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-537">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-537">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-538">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-538">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-539">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-539">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-540">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-540">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be935-541">비동기 예약 및 추가 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-541">Begins an asynchronous reserve and append operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-542">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-542">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="be935-543">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-543">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-544">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-544">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-545">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-545">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="be935-546">예약을 만들 예약 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-546">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="be935-547">만들 예약(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-547">The reservations to make, in bytes.</span></span></param>
        <param name="callback"><span data-ttu-id="be935-548">추가가 완료되면 호출되는 선택적 비동기 콜백입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-548">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="be935-549">이 특정 비동기 추가 요청을 다른 요청과 구별하는 사용자 제공 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-549">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="be935-550">비동기 예약 및 추가 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-550">Begins an asynchronous reserve and append operation.</span></span> <span data-ttu-id="be935-551">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-551">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-552">보류 중일 수 있는 이 비동기 작업을 나타내는 <see cref="T:System.IAsyncResult" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-552">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-553">이 메서드에서 반환된 <xref:System.IAsyncResult>를 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 메서드에 전달하여 추가 작업을 완료하고 리소스를 적절하게 해제할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-553">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="be935-554">비동기 추가 중에 오류가 발생한 경우 이 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>를 사용하여 <xref:System.IAsyncResult> 메서드를 호출하기 전에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-554">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="be935-555">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-555">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-556">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-556">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-557">지정된 예약은 레코드 추가 작업이 포함된 원자 단위 작업에서 제공된 예약 컬렉션에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-557">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="be935-558">추가가 실패하면 공간이 예약되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-558">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="be935-559">일반적으로 이 메서드는 레코드를 쓰기 전에 완료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-559">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="be935-560">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.LogRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-560">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="be935-561">레코드 시퀀스가 삭제되었거나 잘못된 인수를 전달하는 경우 이 작업 내에서 즉시 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-561">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="be935-562">비동기 추가 요청 중에 발생한 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 메서드를 호출할 때 예외로 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-562">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-563"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스에 부적합한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-563"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-564">또는</span><span class="sxs-lookup"><span data-stu-id="be935-564">-or-</span></span> 
 <span data-ttu-id="be935-565"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-565"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-566">또는</span><span class="sxs-lookup"><span data-stu-id="be935-566">-or-</span></span> 
 <span data-ttu-id="be935-567">이 레코드 시퀀스를 통해 <paramref name="reservations" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-567"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-568">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-568">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-569"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-569"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-570">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-570">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-571">또는</span><span class="sxs-lookup"><span data-stu-id="be935-571">-or-</span></span> 
<span data-ttu-id="be935-572">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-572">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-573">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-573">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-574">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-574">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-575">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-575">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-576">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-576">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-577">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-577">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="be935-578"><paramref name="data" />에서 <paramref name="reservations" />에 맞는 크기의 예약을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-578">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-579">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-579">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="be935-580">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-580">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-581">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-581">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-582">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-582">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="be935-583">예약을 만들 예약 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-583">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="be935-584">만들 예약(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-584">The reservations to make, in bytes.</span></span></param>
        <param name="callback"><span data-ttu-id="be935-585">추가가 완료되면 호출되는 선택적 비동기 콜백입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-585">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="be935-586">이 특정 비동기 추가 요청을 다른 요청과 구별하는 사용자 제공 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-586">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="be935-587">비동기 예약 및 추가 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-587">Begins an asynchronous reserve and append operation.</span></span> <span data-ttu-id="be935-588">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-588">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-589">보류 중일 수 있는 이 비동기 작업을 나타내는 <see cref="T:System.IAsyncResult" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-589">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-590">이 메서드에서 반환된 <xref:System.IAsyncResult>를 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 메서드에 전달하여 추가 작업을 완료하고 리소스를 적절하게 해제할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-590">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="be935-591">비동기 추가 중에 오류가 발생한 경우 이 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>를 사용하여 <xref:System.IAsyncResult> 메서드를 호출하기 전에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-591">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="be935-592">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-592">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-593">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-593">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-594">지정된 예약은 레코드 추가 작업이 포함된 원자 단위 작업에서 제공된 예약 컬렉션에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-594">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="be935-595">추가가 실패하면 공간이 예약되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-595">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="be935-596">일반적으로 이 메서드는 레코드를 쓰기 전에 완료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-596">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="be935-597">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.LogRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-597">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="be935-598">레코드 시퀀스가 삭제되었거나 잘못된 인수를 전달하는 경우 이 작업 내에서 즉시 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-598">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="be935-599">비동기 추가 요청 중에 발생한 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 메서드를 호출할 때 예외로 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-599">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-600">하나 이상의 인수가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-600">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-601">레코드를 추가하는 동안 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-601">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-602">레코드 시퀀스에서 새 레코드를 포함하거나 예약을 만들 충분한 여유 공간을 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-602">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-603">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-603">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be935-604">비동기 재시작 영역 쓰기 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-604">Begins an asynchronous restart area write operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-605">연결하여 레코드로 추가할 바이트 배열 세그먼트입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-605">Byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="be935-606">새 기준 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-606">The new base sequence number.</span></span> <span data-ttu-id="be935-607">지정된 시퀀스 번호는 현재 기준 시퀀스 번호보다 크거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-607">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservation"><span data-ttu-id="be935-608">이 재시작 영역에 사용해야 하는 예약이 포함된 <see cref="T:System.IO.Log.ReservationCollection" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-608">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <param name="callback"><span data-ttu-id="be935-609">재시작 영역 쓰기가 완료되면 호출되는 선택적 비동기 콜백입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-609">An optional asynchronous callback, to be called when the restart area write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="be935-610">이 특정 비동기 재시작 영역 쓰기 요청을 다른 요청과 구별하는 사용자 제공 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-610">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span></span></param>
        <summary><span data-ttu-id="be935-611">시퀀스에서 이전에 예약된 공간을 사용하여 비동기 재시작 영역 쓰기 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-611">Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span></span> <span data-ttu-id="be935-612">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-612">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-613">보류 중일 수 있는 비동기 재시작 영역 쓰기 작업을 나타내는 <see cref="T:System.IAsyncResult" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-613">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-614">이 메서드에서 반환된 <xref:System.IAsyncResult>를 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> 메서드에 전달하여 재시작 영역 쓰기 작업을 완료하고 리소스를 적절하게 해제할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-614">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="be935-615">비동기 재시작 영역 쓰기 작업 중에 오류가 발생한 경우 이 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>를 사용하여 <xref:System.IAsyncResult> 메서드를 호출하기 전에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-615">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="be935-616">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-616">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-617">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-617">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-618">작업이 성공적으로 완료되면 기준 세그먼트 번호가 업데이트된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-618">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="be935-619">새 기준 시퀀스 번호보다 작은 시퀀스 번호를 가진 모든 로그 레코드에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-619">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="be935-620"><xref:System.IO.Log.ReservationCollection>을 지정하는 경우 쓴 재시작 영역은 컬렉션에 포함된 예약을 사용하여 이전에 예약된 공간을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-620">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="be935-621">메서드가 성공하면 데이터가 포함될 수 있는 가장 작은 예약을 사용하고 해당 예약이 컬렉션에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-621">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="be935-622">레코드 시퀀스가 삭제되었거나 잘못된 인수를 전달하는 경우 이 작업 내에서 즉시 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-622">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="be935-623">비동기 추가 요청 중에 발생한 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> 메서드를 호출할 때 예외로 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-623">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-624"><paramref name="newBaseSeqNum" />이 이 시퀀스에 유효하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-624"><paramref name="newBaseSeqNum" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-625">또는</span><span class="sxs-lookup"><span data-stu-id="be935-625">-or-</span></span> 
<span data-ttu-id="be935-626">지정된 로그 열거형 시작 시퀀스 번호가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-626">The specified log enumeration start sequence number is invalid.</span></span>  
  
<span data-ttu-id="be935-627">또는</span><span class="sxs-lookup"><span data-stu-id="be935-627">-or-</span></span> 
 <span data-ttu-id="be935-628"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-628"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-629">또는</span><span class="sxs-lookup"><span data-stu-id="be935-629">-or-</span></span> 
 <span data-ttu-id="be935-630">이 레코드 시퀀스를 통해 <paramref name="reservation" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-630"><paramref name="reservation" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-631">매개 변수 중 하나 이상이 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-631">One or more of the parameters is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-632">활성 로그의 기존 또는 새 아카이브 테일이나 베이스가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-632">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
<span data-ttu-id="be935-633">또는</span><span class="sxs-lookup"><span data-stu-id="be935-633">-or-</span></span> 
 <span data-ttu-id="be935-634"><paramref name="newBaseSeqNum" />이 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-634"><paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-635">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-635">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-636">또는</span><span class="sxs-lookup"><span data-stu-id="be935-636">-or-</span></span> 
<span data-ttu-id="be935-637">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-637">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-638">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-638">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-639">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-639">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-640">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-640">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-641">레코드 시퀀스가 꽉 찼습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-641">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservationCollection, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-642">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-642">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="be935-643">새 기준 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-643">The new base sequence number.</span></span> <span data-ttu-id="be935-644">지정된 시퀀스 번호는 현재 기준 시퀀스 번호보다 크거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-644">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="be935-645">이 재시작 영역에 사용해야 하는 예약이 포함된 <see cref="T:System.IO.Log.ReservationCollection" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-645">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <param name="callback"><span data-ttu-id="be935-646">재시작 영역 쓰기가 완료되면 호출되는 선택적 비동기 콜백입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-646">An optional asynchronous callback, to be called when the restart area write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="be935-647">이 특정 비동기 재시작 영역 쓰기 요청을 다른 요청과 구별하는 사용자 제공 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-647">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span></span></param>
        <summary><span data-ttu-id="be935-648">시퀀스에서 이전에 예약된 공간을 사용하여 비동기 재시작 영역 쓰기 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-648">Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span></span> <span data-ttu-id="be935-649">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-649">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-650">보류 중일 수 있는 비동기 재시작 영역 쓰기 작업을 나타내는 <see cref="T:System.IAsyncResult" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-650">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-651">이 메서드에서 반환된 <xref:System.IAsyncResult>를 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> 메서드에 전달하여 재시작 영역 쓰기 작업을 완료하고 리소스를 적절하게 해제할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-651">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="be935-652">비동기 재시작 영역 쓰기 작업 중에 오류가 발생한 경우 이 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>를 사용하여 <xref:System.IAsyncResult> 메서드를 호출하기 전에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-652">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="be935-653">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-653">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-654">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-654">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-655">작업이 성공적으로 완료되면 기준 세그먼트 번호가 업데이트된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-655">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="be935-656">새 기준 시퀀스 번호보다 작은 시퀀스 번호를 가진 모든 로그 레코드에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-656">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="be935-657"><xref:System.IO.Log.ReservationCollection>을 지정하는 경우 쓴 재시작 영역은 컬렉션에 포함된 예약을 사용하여 이전에 예약된 공간을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-657">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="be935-658">메서드가 성공하면 데이터가 포함될 수 있는 가장 작은 예약을 사용하고 해당 예약이 컬렉션에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-658">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="be935-659">레코드 시퀀스가 삭제되었거나 잘못된 인수를 전달하는 경우 이 작업 내에서 즉시 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-659">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="be935-660">비동기 추가 요청 중에 발생한 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> 메서드를 호출할 때 예외로 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-660">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-661"><paramref name="newBaseSeqNum" />이 이 시퀀스에 유효하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-661"><paramref name="newBaseSeqNum" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-662">또는</span><span class="sxs-lookup"><span data-stu-id="be935-662">-or-</span></span> 
<span data-ttu-id="be935-663">지정된 로그 열거형 시작 시퀀스 번호가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-663">The specified log enumeration start sequence number is invalid.</span></span>  
  
<span data-ttu-id="be935-664">또는</span><span class="sxs-lookup"><span data-stu-id="be935-664">-or-</span></span> 
 <span data-ttu-id="be935-665"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-665"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-666">또는</span><span class="sxs-lookup"><span data-stu-id="be935-666">-or-</span></span> 
 <span data-ttu-id="be935-667">이 레코드 시퀀스를 통해 <paramref name="reservationCollection" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-667"><paramref name="reservationCollection" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-668">매개 변수 중 하나 이상이 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-668">One or more of the parameters is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-669">활성 로그의 기존 또는 새 아카이브 테일이나 베이스가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-669">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
<span data-ttu-id="be935-670">또는</span><span class="sxs-lookup"><span data-stu-id="be935-670">-or-</span></span> 
 <span data-ttu-id="be935-671"><paramref name="newBaseSeqNum" />이 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-671"><paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-672">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-672">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-673">또는</span><span class="sxs-lookup"><span data-stu-id="be935-673">-or-</span></span> 
<span data-ttu-id="be935-674">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-674">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-675">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-675">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-676">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-676">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-677">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-677">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-678">레코드 시퀀스가 꽉 찼습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-678">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="logRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be935-679">새 <see cref="T:System.IO.Log.ReservationCollection" />를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="be935-679">Creates a new <see cref="T:System.IO.Log.ReservationCollection" />.</span></span> <span data-ttu-id="be935-680">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-680">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-681">새로 만든 <see cref="T:System.IO.Log.ReservationCollection" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-681">The newly created <see cref="T:System.IO.Log.ReservationCollection" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="be935-682">예약은 다음 예제에 나와 있는 것처럼 두 가지 방법으로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-682">Reservations can be performed in two ways as shown in the following examples.</span></span> <span data-ttu-id="be935-683">확실한 처리를 위해 예제의 방법을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-683">You can adopt the practices in the samples for robust processing.</span></span> <span data-ttu-id="be935-684">이 작업은 CLFS 기반 <xref:System.IO.Log.LogRecordSequence> 클래스를 사용할 때만 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-684">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-685">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-685">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be935-686">구성 요소에서 사용하는 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-686">Releases the resources used by the component.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="be935-687">이 예제에 사용 하는 방법을 보여 줍니다 <xref:System.IO.Log.LogRecordSequence.Dispose%2A> 리소스를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-687">This example shows how to use <xref:System.IO.Log.LogRecordSequence.Dispose%2A> to release resources:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-688">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-688">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-689">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-689">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="be935-690">처리 중인 비동기 I/O 요청에 대한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-690">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="be935-691">비동기 추가 작업을 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="be935-691">Ends an asynchronous append operation.</span></span> <span data-ttu-id="be935-692">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-692">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-693">추가된 로그 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-693">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-694">이 메서드는 I/O 작업이 완료될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-694">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="be935-695">비동기 쓰기 요청 중에 발생하는 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>를 호출할 때 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-695">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="be935-696">이 메서드는 <xref:System.IAsyncResult> 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>마다 정확히 한 번만 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-696">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-697"><paramref name="result" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-697"><paramref name="result" /> is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-698">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-698">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-699">또는</span><span class="sxs-lookup"><span data-stu-id="be935-699">-or-</span></span> 
<span data-ttu-id="be935-700">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-700">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be935-701">이 비동기 작업에 대해 <see langword="End" />가 이미 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-701"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-702">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-702">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-703">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-703">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-704">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-704">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-705">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-705">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-706">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-706">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="be935-707">처리 중인 비동기 I/O 요청에 대한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-707">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="be935-708">비동기 플러시 작업을 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="be935-708">Ends an asynchronous flush operation.</span></span> <span data-ttu-id="be935-709">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-709">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-710">마지막으로 쓴 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-710">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-711">이 메서드는 I/O 작업이 완료될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-711">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="be935-712">비동기 플러시 요청 중에 발생하는 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>를 호출할 때 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-712">Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> is called.</span></span>  
  
 <span data-ttu-id="be935-713">이 메서드는 <xref:System.IAsyncResult> 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>마다 정확히 한 번만 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-713">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-714"><paramref name="result" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-714"><paramref name="result" /> is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-715">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-715">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be935-716">이 비동기 작업에 대해 <see langword="End" />가 이미 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-716"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-717">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-717">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-718">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-718">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-719">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-719">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-720">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-720">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-721">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-721">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="be935-722">처리 중인 비동기 I/O 요청에 대한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-722">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="be935-723">비동기 예약 및 추가 작업을 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="be935-723">Ends an asynchronous reserve and append operation.</span></span> <span data-ttu-id="be935-724">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-724">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-725">추가된 로그 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-725">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-726">이 메서드는 I/O 작업이 완료될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-726">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="be935-727">비동기 쓰기 요청 중에 발생하는 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>를 호출할 때 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-727">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="be935-728">이 메서드는 <xref:System.IAsyncResult> 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>마다 정확히 한 번만 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-728">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-729"><paramref name="result" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-729"><paramref name="result" /> is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-730">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-730">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-731">또는</span><span class="sxs-lookup"><span data-stu-id="be935-731">-or-</span></span> 
<span data-ttu-id="be935-732">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-732">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be935-733">이 비동기 작업에 대해 <see langword="End" />가 이미 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-733"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-734">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-734">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-735">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-735">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-736">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-736">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-737">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-737">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-738">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-738">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="be935-739">처리 중인 비동기 I/O 요청에 대한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-739">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="be935-740">비동기 재시작 영역 쓰기 작업을 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="be935-740">Ends an asynchronous restart area write operation.</span></span> <span data-ttu-id="be935-741">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-741">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-742">쓴 로그 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-742">The sequence number of the written log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-743">이 메서드는 I/O 작업이 완료될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-743">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="be935-744">비동기 쓰기 요청 중에 발생하는 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>를 호출할 때 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-744">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> is called.</span></span>  
  
 <span data-ttu-id="be935-745">이 메서드는 <xref:System.IAsyncResult> 메서드에서 반환된 <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>마다 정확히 한 번만 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-745">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-746"><paramref name="result" />가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-746"><paramref name="result" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-747">활성 로그의 기존 또는 새 아카이브 테일이나 베이스가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-747">A new or existing archive tail or base of the active log is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-748">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-748">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be935-749">이 비동기 작업에 대해 <see langword="End" />가 이미 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-749"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-750">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-750">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-751">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-751">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-752">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-752">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-753">레코드 시퀀스가 꽉 찼습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-753">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be935-754">추가된 레코드를 영속적으로 씁니다.</span><span class="sxs-lookup"><span data-stu-id="be935-754">Writes appended records durably</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be935-755">추가된 모든 레코드를 썼는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-755">Ensures that all appended records have been written.</span></span> <span data-ttu-id="be935-756">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-756">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-757">마지막으로 쓴 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-757">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-758">이 메서드를 호출하면 <xref:System.IO.Log.LogRecordSequence>에 추가된 모든 레코드가 영속적으로 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-758">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-759">데이터를 플러시하는 동안 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-759">An I/O error occurred while flushing the data.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-760">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-760">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-761">이 작업이 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-761">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-762">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-762">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-763">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-763">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-764">레코드 시퀀스에서 새 재시작 영역을 포함할 충분한 여유 공간을 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-764">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be935-765">지정된 로그에 범위가 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="be935-765">The specified log does not have any extents.</span></span> <span data-ttu-id="be935-766">레코드 시퀀스를 사용하려면 먼저 범위를 하나 이상 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-766">One or more extents must be created before a record sequence can be used.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber"><span data-ttu-id="be935-767">써야 하는 최신 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-767">The sequence number of the latest record that must be written.</span></span> <span data-ttu-id="be935-768">이 <see cref="T:System.IO.Log.SequenceNumber" />가 유효하지 않은 경우 모든 레코드를 써야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-768">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span></span></param>
        <summary><span data-ttu-id="be935-769">지정된 시퀀스 번호까지 추가된 모든 레코드를 영속적으로 썼는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-769">Ensures that all appended records up to and including the record with the specified sequence number have been durably written.</span></span> <span data-ttu-id="be935-770">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-770">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-771">마지막으로 쓴 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-771">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-772">이 메서드를 호출하면 지정된 시퀀스 번호 이하의 시퀀스 번호를 가진 모든 레코드가 영속적으로 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-772">Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-773"><paramref name="sequenceNumber" />이 이 시퀀스에 유효하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-773"><paramref name="sequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-774"><paramref name="sequenceNumber" />이 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-774"><paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-775">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-775">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be935-776">지정된 로그에 범위가 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="be935-776">The specified log does not have any extents.</span></span> <span data-ttu-id="be935-777">레코드 시퀀스를 사용하려면 먼저 범위를 하나 이상 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-777">One or more extents must be created before a record sequence can be used.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-778">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-778">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-779">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-779">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-780">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-780">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-781">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-781">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-782">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-782">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be935-783">마지막으로 추가된 레코드보다 큰 시퀀스 번호를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="be935-783">Gets the sequence number which is greater than the last record appended</span></span></summary>
        <value><span data-ttu-id="be935-784">마지막으로 추가된 레코드보다 큰 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-784">A sequence number which is greater than the last record appended.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-785">이 속성에는 마지막으로 추가된 레코드의 시퀀스 번호보다 반드시 큰 시퀀스 번호가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-785">This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span> <span data-ttu-id="be935-786">유효한 시퀀스 번호는 <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>보다 크거나 같고 <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-786">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span></span> <span data-ttu-id="be935-787">그 외의 다른 시퀀스 번호는 유효하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-787">All other sequence numbers are invalid.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-788">시퀀스가 삭제된 후 속성에 액세스한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-788">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogStore : System.IO.Log.LogStore" Usage="System.IO.Log.LogRecordSequence.LogStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be935-789">이 레코드 시퀀스의 데이터가 포함된 <see cref="T:System.IO.Log.LogStore" />를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="be935-789">Gets the <see cref="T:System.IO.Log.LogStore" /> that contains the data for this record sequence.</span></span> <span data-ttu-id="be935-790">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-790">This method cannot be inherited.</span></span></summary>
        <value><span data-ttu-id="be935-791">이 레코드 시퀀스의 데이터가 포함된 <see cref="T:System.IO.Log.LogStore" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-791">The <see cref="T:System.IO.Log.LogStore" /> that contains the data for this record sequence.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="be935-792">다음 예제에서는 <xref:System.IO.Log.LogRecordSequence.LogStore%2A> 멤버를 사용하여 범위를 추가하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-792">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.LogStore%2A> member to add extents.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be935-793">이 레코드 시퀀스에 추가할 수 있는 최대 레코드 크기를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="be935-793">Gets the maximum size of a record that can be added to this record sequence.</span></span></summary>
        <value><span data-ttu-id="be935-794">이 레코드 시퀀스에 추가할 수 있는 최대 레코드 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-794">The maximum size of a record that can be added to this record sequence.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="be935-795">읽기가 시작되는 첫 번째 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-795">The sequence number of the first record where the reading starts.</span></span></param>
        <param name="logRecordEnum"><span data-ttu-id="be935-796"><see cref="T:System.IO.Log.LogRecordEnumeratorType" />에서 레코드를 읽는 방식(즉 앞으로 또는 뒤로)을 지정하는 유효한 <see cref="T:System.IO.Log.LogRecordSequence" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-796">A valid <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> value that specifies the manner (that is, forward or backward) in which records should be read from a <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></param>
        <summary><span data-ttu-id="be935-797">시퀀스에 있는 레코드의 열거 가능한 컬렉션을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-797">Returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="be935-798">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-798">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-799">시퀀스에 있는 레코드의 열거 가능한 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-799">An enumerable collection of records in the sequence.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-800">이 메서드는 시퀀스에 있는 레코드의 열거 가능한 컬렉션을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-800">This method returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="be935-801">열거되는 레코드의 순서는 `logRecordEnum` 매개 변수의 값에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-801">The order of the enumerated records depends on the value of the `logRecordEnum` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be935-802">다음 예제에서는 루프에서 <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A>를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-802">This example shows how to use <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> in a loop.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-803"><paramref name="start" />이 이 시퀀스에 유효하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-803"><paramref name="start" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-804">또는</span><span class="sxs-lookup"><span data-stu-id="be935-804">-or-</span></span> 
 <span data-ttu-id="be935-805"><paramref name="logRecordEnum" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-805"><paramref name="logRecordEnum" /> is invalid.</span></span>  
  
<span data-ttu-id="be935-806">또는</span><span class="sxs-lookup"><span data-stu-id="be935-806">-or-</span></span> 
<span data-ttu-id="be935-807">컬렉션에서 지정된 요소를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-807">The specified element was not found in the collection.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-808"><paramref name="start" />이 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-808"><paramref name="start" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-809">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-809">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-810">또는</span><span class="sxs-lookup"><span data-stu-id="be935-810">-or-</span></span> 
<span data-ttu-id="be935-811">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-811">The request could not be performed because of an I/O device error.</span></span>  
  
<span data-ttu-id="be935-812">-또는-</span><span class="sxs-lookup"><span data-stu-id="be935-812">-or</span></span> 
<span data-ttu-id="be935-813">로그 레코드 쓰기에 사용된 버퍼 크기가 로그 레코드 읽기에 사용되는 버퍼 크기보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="be935-813">The buffer size used to write the log record is larger than the buffer size being used to read it.</span></span>  
  
<span data-ttu-id="be935-814">또는</span><span class="sxs-lookup"><span data-stu-id="be935-814">-or-</span></span> 
<span data-ttu-id="be935-815">레코드 시퀀스가 손상된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-815">The record sequence is corrupted.</span></span>  
  
<span data-ttu-id="be935-816">또는</span><span class="sxs-lookup"><span data-stu-id="be935-816">-or-</span></span> 
<span data-ttu-id="be935-817">지정된 로그 파일 형식이나 버전이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-817">The specified log file format or version is invalid.</span></span>  
  
<span data-ttu-id="be935-818">또는</span><span class="sxs-lookup"><span data-stu-id="be935-818">-or-</span></span> 
<span data-ttu-id="be935-819">호환되지 않는 버전의 레코드 시퀀스를 사용하여 레코드를 쓴 경우</span><span class="sxs-lookup"><span data-stu-id="be935-819">The record was written with an incompatible version of the record sequence.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be935-820">열거형이 시작되지 않았기 때문에 연산이 잘못된 경우.</span><span class="sxs-lookup"><span data-stu-id="be935-820">The operation is invalid because the enumeration has not been started.</span></span> <span data-ttu-id="be935-821"><see cref="M:System.Collections.IEnumerator.MoveNext" />를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-821">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-822">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-822">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-823">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-823">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-824">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-824">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be935-825">시퀀스에 있는 재시작 영역의 열거 가능한 컬렉션을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-825">Returns an enumerable collection of the restart areas in the sequence.</span></span> <span data-ttu-id="be935-826">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-826">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-827">시퀀스에 있는 재시작 영역의 열거 가능한 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-827">An enumerable collection of the restart areas in the sequence.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-828">재시작 영역은 시퀀스 번호의 역순(가장 큰 시퀀스 번호부터 가장 작은 시퀀스 번호까지)으로 열거됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-828">The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</span></span> <span data-ttu-id="be935-829">마지막 시퀀스 번호와 기준 시퀀스 번호 사이의 시퀀스 번호를 가진 재시작 영역만 열거됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-829">Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-830"><paramref name="start" />이 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-830"><paramref name="start" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-831">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-831">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-832">또는</span><span class="sxs-lookup"><span data-stu-id="be935-832">-or-</span></span> 
<span data-ttu-id="be935-833">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-833">The request could not be performed because of an I/O device error.</span></span>  
  
<span data-ttu-id="be935-834">-또는-</span><span class="sxs-lookup"><span data-stu-id="be935-834">-or</span></span> 
<span data-ttu-id="be935-835">로그 레코드 쓰기에 사용된 버퍼 크기가 로그 레코드 읽기에 사용되는 버퍼 크기보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="be935-835">The buffer size used to write the log record is larger than the buffer size being used to read it.</span></span>  
  
<span data-ttu-id="be935-836">또는</span><span class="sxs-lookup"><span data-stu-id="be935-836">-or-</span></span> 
<span data-ttu-id="be935-837">레코드 시퀀스가 손상된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-837">The record sequence is corrupted.</span></span>  
  
<span data-ttu-id="be935-838">또는</span><span class="sxs-lookup"><span data-stu-id="be935-838">-or-</span></span> 
<span data-ttu-id="be935-839">지정된 로그 파일 형식이나 버전이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-839">The specified log file format or version is invalid.</span></span>  
  
<span data-ttu-id="be935-840">또는</span><span class="sxs-lookup"><span data-stu-id="be935-840">-or-</span></span> 
<span data-ttu-id="be935-841">호환되지 않는 버전의 레코드 시퀀스를 사용하여 레코드를 쓴 경우</span><span class="sxs-lookup"><span data-stu-id="be935-841">The record was written with an incompatible version of the record sequence.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be935-842">열거형이 시작되지 않았기 때문에 연산이 잘못된 경우.</span><span class="sxs-lookup"><span data-stu-id="be935-842">The operation is invalid because the enumeration has not been started.</span></span> <span data-ttu-id="be935-843"><see cref="M:System.Collections.IEnumerator.MoveNext" />를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-843">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span></span>  
  
<span data-ttu-id="be935-844">-또는-</span><span class="sxs-lookup"><span data-stu-id="be935-844">-or</span></span> 
<span data-ttu-id="be935-845">열거형이 끝난 경우</span><span class="sxs-lookup"><span data-stu-id="be935-845">The enumeration has ended.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-846">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-846">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-847">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-847">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-848">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-848">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be935-849">자동으로 단일 예약을 만들고 시퀀스에 레코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-849">Automatically makes a single reservation and appends a record to the sequence.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-850">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-850">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="be935-851">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-851">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-852">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-852">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-853">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-853">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="be935-854">예약을 만들 컬렉션이 포함된 <see cref="T:System.IO.Log.ReservationCollection" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-854">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="be935-855">만들 예약(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-855">The reservations to make, in bytes.</span></span></param>
        <summary><span data-ttu-id="be935-856">자동으로 단일 예약을 만들고 시퀀스에 레코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-856">Automatically makes a single reservation and appends a record to the sequence.</span></span> <span data-ttu-id="be935-857">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-857">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-858">추가된 로그 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-858">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-859">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-859">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-860">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-860">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-861">지정된 예약은 레코드 추가 작업이 포함된 원자 단위 작업에서 제공된 예약 컬렉션에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-861">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="be935-862">추가가 실패하면 공간이 예약되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-862">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="be935-863">일반적으로 이 메서드는 레코드를 쓰기 전에 완료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-863">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="be935-864">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.LogRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-864">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be935-865">다음 예제에서는 이 메서드를 사용하여 예약하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-865">The following example shows how to use this method to make reservations.</span></span> <span data-ttu-id="be935-866">이 작업은 CLFS 기반 <xref:System.IO.Log.LogRecordSequence> 클래스를 사용할 때만 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-866">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-867"><paramref name="nextUndoRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스에 부적합한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-867"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-868">또는</span><span class="sxs-lookup"><span data-stu-id="be935-868">-or-</span></span> 
 <span data-ttu-id="be935-869"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-869"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-870">또는</span><span class="sxs-lookup"><span data-stu-id="be935-870">-or-</span></span> 
 <span data-ttu-id="be935-871">이 레코드 시퀀스를 통해 <paramref name="reservations" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-871"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-872">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-872">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-873"><paramref name="nextUndoRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-873"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-874">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-874">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-875">또는</span><span class="sxs-lookup"><span data-stu-id="be935-875">-or-</span></span> 
<span data-ttu-id="be935-876">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-876">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-877">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-877">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-878">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-878">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-879">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-879">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-880">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-880">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-881">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-881">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="be935-882"><paramref name="data" />에서 <paramref name="reservations" />에 맞는 크기의 예약을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-882">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-883">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-883">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="be935-884">사용자가 지정한 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-884">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="be935-885">이전 순서에서 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-885">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="be935-886">데이터를 쓰는 방법을 지정하는 <see cref="T:System.IO.Log.RecordAppendOptions" />의 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-886">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="be935-887">예약을 만들 예약 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-887">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="be935-888">만들 예약(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-888">The reservations to make, in bytes.</span></span></param>
        <summary><span data-ttu-id="be935-889">자동으로 단일 예약을 만들고 시퀀스에 레코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-889">Automatically makes a single reservation and appends a record to the sequence.</span></span> <span data-ttu-id="be935-890">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-890">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-891">추가된 로그 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-891">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-892">`data` 매개 변수에 포함된 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-892">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-893">그러나 레코드를 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-893">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="be935-894">지정된 예약은 레코드 추가 작업이 포함된 원자 단위 작업에서 제공된 예약 컬렉션에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-894">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="be935-895">추가가 실패하면 공간이 예약되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-895">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="be935-896">일반적으로 이 메서드는 레코드를 쓰기 전에 완료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-896">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="be935-897">레코드가 기록되도록 하려면 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 매개 변수를 사용하여 `recordAppendOptions` 플래그를 지정하거나, <xref:System.IO.Log.LogRecordSequence.Flush%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-897">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-898">하나 이상의 인수가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-898">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-899">레코드를 추가하는 동안 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-899">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-900">레코드 시퀀스에서 새 레코드를 포함하거나 예약을 만들 충분한 여유 공간을 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-900">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-901">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-901">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-902">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-902">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-903"><paramref name="userRecord" /> 또는 <paramref name="previousRecord" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-903"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be935-904">읽기 전용 액세스 권한으로 레코드 시퀀스를 열었으므로 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-904">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-905">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-905">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-906">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-906">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="be935-907"><paramref name="data" />에서 <paramref name="reservations" />에 맞는 크기의 예약을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-907">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be935-908">예약된 총 바이트 수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="be935-908">Gets the total number of bytes that have been reserved.</span></span></summary>
        <value><span data-ttu-id="be935-909">이 레코드 시퀀스에서 만들어진 모든 예약의 총 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-909">The total size of all reservations made in this record sequence.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-910">시퀀스가 삭제된 후 속성에 액세스한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-910">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be935-911">로그 끝과 가장 가까운 재시작 영역의 시퀀스 번호를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="be935-911">Gets the sequence number of the restart area closest to the end of the log.</span></span></summary>
        <value><span data-ttu-id="be935-912">로그 끝과 가장 가까운 재시작 영역의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-912">The sequence number of the restart area closest to the end of the log.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-913">재시작 영역은 클라이언트의 마지막 검사점 작업을 포함하는 정보를 임시로 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-913">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="be935-914">CLFS(Common Log File System)에서는 적어도 하나의 유효한 영역을 항상 사용할 수 있도록 하기 위해 두 개의 재시작 영역을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-914">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="be935-915">복구가 필요한 경우 CLFS에서는 재시작 영역을 읽고 마지막 검사점 작업에서 데이터를 모두 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-915">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="be935-916">이 데이터는 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블을 복구 프로세스에서 사용할 수 있도록 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-916">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="be935-917"><xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A> 메서드를 사용하여 가장 최근에 쓴 재시작 영역을 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-917">Using the <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A> method, you can remove the most recently written restart area.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-918">시퀀스가 삭제된 후 속성에 액세스한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-918">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be935-919">로그가 꽉 차는 경우 추가 작업이 자동으로 다시 시도되는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-919">Gets or sets a value indicating whether or not appends are automatically retried if the log is full.</span></span></summary>
        <value><span data-ttu-id="be935-920">로그가 꽉 차는 경우 추가 작업이 자동으로 다시 시도되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-920"><see langword="true" /> if appends are automatically retried if the log is full; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="be935-921">기본값은 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-921">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-922">이 속성의 값이 `true`이고 시퀀스에 충분한 공간이 없기 때문에 <xref:System.IO.Log.LogRecordSequence.Append%2A> 호출이 실패하면 레코드 시퀀스에서 공간을 확보하려고 시도하고 추가 작업을 다시 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-922">If the value of this property is `true`, and an <xref:System.IO.Log.LogRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be935-923">다음 예제에서는 <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A> 속성을 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-923">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A> property.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-924">시퀀스가 삭제된 후 속성에 액세스한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-924">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="member this.SetLastRecord : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.SetLastRecord sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber"><span data-ttu-id="be935-925"><see cref="T:System.IO.Log.LogRecordSequence" />에 있는 마지막 신규 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-925">The new last sequence number in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span>  
  
<span data-ttu-id="be935-926">이 번호는 해당 시점에 로그에 있는 유효한 현재 레코드를 참조해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-926">This should refer to a current valid record   currently in the log.</span></span></param>
        <summary><span data-ttu-id="be935-927"><see cref="T:System.IO.Log.LogRecordSequence" />에서 마지막 레코드를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-927">Sets the last record in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-928">지정된 시퀀스 번호는 기준 시퀀스 번호보다 커야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-928">The specified sequence number must be larger than the base sequence number.</span></span>  
  
 <span data-ttu-id="be935-929">이 메서드가 완료되면 지정된 시퀀스 번호보다 큰 시퀀스 번호를 사용하여 이전에 추가한 모든 레코드에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-929">When this method completes, all records that had previously been appended with sequence numbers greater than the specified sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-930"><paramref name="sequenceNumber" />이 이 시퀀스에 유효하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-930"><paramref name="sequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-931">활성 로그의 기존 또는 새 아카이브 테일이나 베이스가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-931">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
<span data-ttu-id="be935-932">또는</span><span class="sxs-lookup"><span data-stu-id="be935-932">-or-</span></span> 
 <span data-ttu-id="be935-933"><paramref name="sequenceNumber" />이 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-933"><paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-934">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-934">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-935">또는</span><span class="sxs-lookup"><span data-stu-id="be935-935">-or-</span></span> 
<span data-ttu-id="be935-936">로그의 끝에 도달한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-936">The end of the log has been reached.</span></span>  
  
<span data-ttu-id="be935-937">또는</span><span class="sxs-lookup"><span data-stu-id="be935-937">-or-</span></span> 
<span data-ttu-id="be935-938">지정된 로그 파일 형식이나 버전이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-938">The specified log file format or version is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-939">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-939">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-940">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-940">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-941">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-941">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be935-942">시퀀스의 테일을 이동해야 함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="be935-942">Signals the need to move the tail of the sequence.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-943">레코드 시퀀스에 공간이 부족하면 이 이벤트를 발생시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-943">You can fire this event when the record sequence has run out of space.</span></span> <span data-ttu-id="be935-944">이 이벤트가 발생하면 공간을 확보하기 위해 시퀀스의 테일(즉, 기준 시퀀스 번호)이 앞으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-944">When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</span></span>  
  
 <span data-ttu-id="be935-945">이 이벤트는 레코드 시퀀스에서 어떤 이유로든 공간을 확보해야 한다고 결정하면 언제든지 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-945">The event can be fired at any time when the record sequence decides that it must free up space, for any reason.</span></span> <span data-ttu-id="be935-946">예를 들어, CLFS 정책 엔진은 동일한 로그 파일을 공유하는 두 로그 클라이언트의 테일이 너무 멀리 떨어져 있는 것이 확인되면 이벤트를 실행하도록 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-946">For example, the CLFS policy engine may decide to fire the event when it determines that the tails of two log clients sharing the same log file are too far apart.</span></span> <span data-ttu-id="be935-947">공간 확보는 재시작 영역을 쓰거나, 로그의 뒷부분을 잘라낸 후 <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> 메서드를 사용하여 공간을 지움으로써 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-947">Freeing space can be done by either writing restart areas, or truncating the log and using the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method to clear space.</span></span> <span data-ttu-id="be935-948">예제 부분의 코드 샘플에서는 두 번째 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-948">The code sample in the Example section demonstrates the second approach.</span></span>  
  
 <span data-ttu-id="be935-949"><xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> 이벤트 외부에서 <xref:System.IO.Log.LogRecordSequence.TailPinned> 메서드를 호출하여 공간을 확보할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-949">You can also call the <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> method outside of the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free space.</span></span> <span data-ttu-id="be935-950">재시작 영역은 다른 로그 처리 시스템의 검사점과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-950">A restart area is similar to a checkpoint in other log processing systems.</span></span> <span data-ttu-id="be935-951">이 메서드를 호출하면 응용 프로그램에서는 재시작 영역 전의 모든 이전 레코드가 완전히 완료되었으며 이후 레코드 추가에 사용할 수 있다고 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-951">Calling this method indicates that the application considers all prior records before the restart area as fully completed, and usable for future record appends.</span></span> <span data-ttu-id="be935-952">다른 레코드와 마찬가지로, 이 메서드가 기록한 레코드가 작동하려면 로그에 실제 빈 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-952">Similar to any other records, the record written by this method requires actual free space in the log to function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be935-953">다음 예제에서는 <xref:System.IO.Log.LogRecordSequence.TailPinned> 이벤트를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="be935-953">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.TailPinned> event.</span></span>  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be935-954"><see cref="T:System.IO.Log.LogRecordSequence" />에 재시작 영역을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="be935-954">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-955">재시작 영역은 클라이언트의 마지막 검사점 작업을 포함하는 정보를 임시로 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-955">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="be935-956">CLFS(Common Log File System)에서는 적어도 하나의 유효한 영역을 항상 사용할 수 있도록 하기 위해 두 개의 재시작 영역을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-956">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="be935-957">복구가 필요한 경우 CLFS에서는 재시작 영역을 읽고 마지막 검사점 작업에서 데이터를 모두 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-957">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="be935-958">이 데이터는 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블을 복구 프로세스에서 사용할 수 있도록 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-958">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="be935-959">재시작 영역은 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 메서드를 사용하여 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-959">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-960">연결하여 레코드로 추가할 배열 세그먼트입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-960">An array segment that will be concatenated and appended as the record.</span></span></param>
        <summary><span data-ttu-id="be935-961"><see cref="T:System.IO.Log.LogRecordSequence" />에 재시작 영역을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="be935-961">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span> <span data-ttu-id="be935-962">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-962">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-963">쓴 재시작 영역의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-963">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-964">재시작 영역은 클라이언트의 마지막 검사점 작업을 포함하는 정보를 임시로 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-964">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="be935-965">CLFS(Common Log File System)에서는 적어도 하나의 유효한 영역을 항상 사용할 수 있도록 하기 위해 두 개의 재시작 영역을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-965">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="be935-966">복구가 필요한 경우 CLFS에서는 재시작 영역을 읽고 마지막 검사점 작업에서 데이터를 모두 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-966">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="be935-967">이 데이터는 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블을 복구 프로세스에서 사용할 수 있도록 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-967">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="be935-968">재시작 영역은 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 메서드를 사용하여 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-968">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="be935-969">바이트 배열 세그먼트의 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-969">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-970">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-970">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-971">하나 이상의 인수가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-971">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-972">재시작 영역을 쓰는 동안 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-972">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-973">레코드 시퀀스에서 새 재시작 영역을 포함할 충분한 여유 공간을 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-973">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-974">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-974">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-975">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-975">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-976">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-976">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-977">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-977">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-978">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-978">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <summary><span data-ttu-id="be935-979"><see cref="T:System.IO.Log.LogRecordSequence" />에 재시작 영역을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="be935-979">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span> <span data-ttu-id="be935-980">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-980">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-981">쓴 재시작 영역의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-981">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-982">재시작 영역은 클라이언트의 마지막 검사점 작업을 포함하는 정보를 임시로 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-982">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="be935-983">CLFS(Common Log File System)에서는 적어도 하나의 유효한 영역을 항상 사용할 수 있도록 하기 위해 두 개의 재시작 영역을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-983">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="be935-984">복구가 필요한 경우 CLFS에서는 재시작 영역을 읽고 마지막 검사점 작업에서 데이터를 모두 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-984">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="be935-985">이 데이터는 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블을 복구 프로세스에서 사용할 수 있도록 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-985">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="be935-986">재시작 영역은 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 메서드를 사용하여 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-986">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="be935-987">바이트 배열 세그먼트의 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-987">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-988">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-988">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-989">하나 이상의 인수가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-989">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-990">재시작 영역을 쓰는 동안 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-990">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-991">레코드 시퀀스에서 새 재시작 영역을 포함할 충분한 여유 공간을 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-991">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-992">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-992">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-993">하나 이상의 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-993">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-994">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-994">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-995">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-995">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-996">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-996">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="be935-997">새 기준 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-997">The new base sequence number.</span></span> <span data-ttu-id="be935-998">지정된 시퀀스 번호는 현재 기준 시퀀스 번호보다 크거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-998">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <summary><span data-ttu-id="be935-999">재시작 영역을 <see cref="T:System.IO.Log.LogRecordSequence" />에 쓰고 기준 시퀀스 번호를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-999">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number.</span></span> <span data-ttu-id="be935-1000">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1000">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-1001">쓴 재시작 영역의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1001">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-1002">재시작 영역은 클라이언트의 마지막 검사점 작업을 포함하는 정보를 임시로 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1002">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="be935-1003">CLFS(Common Log File System)에서는 적어도 하나의 유효한 영역을 항상 사용할 수 있도록 하기 위해 두 개의 재시작 영역을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1003">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="be935-1004">복구가 필요한 경우 CLFS에서는 재시작 영역을 읽고 마지막 검사점 작업에서 데이터를 모두 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1004">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="be935-1005">이 데이터는 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블을 복구 프로세스에서 사용할 수 있도록 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1005">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="be935-1006">재시작 영역은 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 메서드를 사용하여 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1006">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="be935-1007">재시작 영역이 기록되면 바이트 배열 세그먼트의 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1007">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-1008">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1008">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="be935-1009">이 메서드가 성공적으로 완료되면 기준 세그먼트 번호가 업데이트된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1009">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="be935-1010">새 기준 시퀀스 번호보다 작은 시퀀스 번호를 가진 모든 로그 레코드에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1010">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="be935-1011">레코드 시퀀스가 삭제되었거나 잘못된 인수를 전달하는 경우 이 작업 내에서 즉시 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1011">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="be935-1012">비동기 추가 요청 중에 발생한 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 메서드를 호출할 때 예외로 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1012">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-1013">하나 이상의 인수가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1013">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-1014">재시작 영역을 쓰는 동안 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1014">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-1015">레코드 시퀀스에서 새 재시작 영역을 포함할 충분한 여유 공간을 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1015">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-1016">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1016">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-1017">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1017">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="be935-1018">새 기준 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1018">The new base sequence number.</span></span> <span data-ttu-id="be935-1019">지정된 시퀀스 번호는 현재 기준 시퀀스 번호보다 크거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1019">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <summary><span data-ttu-id="be935-1020">재시작 영역을 <see cref="T:System.IO.Log.LogRecordSequence" />에 쓰고 기준 시퀀스 번호를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1020">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number.</span></span> <span data-ttu-id="be935-1021">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1021">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-1022">쓴 재시작 영역의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1022">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-1023">재시작 영역은 클라이언트의 마지막 검사점 작업을 포함하는 정보를 임시로 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1023">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="be935-1024">CLFS(Common Log File System)에서는 적어도 하나의 유효한 영역을 항상 사용할 수 있도록 하기 위해 두 개의 재시작 영역을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1024">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="be935-1025">복구가 필요한 경우 CLFS에서는 재시작 영역을 읽고 마지막 검사점 작업에서 데이터를 모두 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1025">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="be935-1026">이 데이터는 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블을 복구 프로세스에서 사용할 수 있도록 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1026">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="be935-1027">재시작 영역은 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 메서드를 사용하여 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1027">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="be935-1028">재시작 영역이 기록되면 바이트 배열 세그먼트의 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1028">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-1029">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1029">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="be935-1030">이 메서드가 성공적으로 완료되면 기준 세그먼트 번호가 업데이트된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1030">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="be935-1031">새 기준 시퀀스 번호보다 작은 시퀀스 번호를 가진 모든 로그 레코드에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1031">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="be935-1032">레코드 시퀀스가 삭제되었거나 잘못된 인수를 전달하는 경우 이 작업 내에서 즉시 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1032">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="be935-1033">비동기 추가 요청 중에 발생한 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 메서드를 호출할 때 예외로 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1033">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-1034">하나 이상의 인수가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1034">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-1035">재시작 영역을 쓰는 동안 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1035">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-1036">레코드 시퀀스에서 새 재시작 영역을 포함할 충분한 여유 공간을 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1036">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-1037">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1037">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-1038">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1038">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="be935-1039">새 기준 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1039">The new base sequence number.</span></span> <span data-ttu-id="be935-1040">지정된 시퀀스 번호는 현재 기준 시퀀스 번호보다 크거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1040">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservations"><span data-ttu-id="be935-1041">이 재시작 영역에 사용해야 하는 예약이 포함된 <see cref="T:System.IO.Log.ReservationCollection" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1041">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <summary><span data-ttu-id="be935-1042">예약을 사용하여 재시작 영역을 <see cref="T:System.IO.Log.LogRecordSequence" />에 쓰고 기준 시퀀스 번호를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1042">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number.</span></span> <span data-ttu-id="be935-1043">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1043">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-1044">쓴 재시작 영역의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1044">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-1045">재시작 영역은 클라이언트의 마지막 검사점 작업을 포함하는 정보를 임시로 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1045">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="be935-1046">CLFS(Common Log File System)에서는 적어도 하나의 유효한 영역을 항상 사용할 수 있도록 하기 위해 두 개의 재시작 영역을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1046">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="be935-1047">복구가 필요한 경우 CLFS에서는 재시작 영역을 읽고 마지막 검사점 작업에서 데이터를 모두 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1047">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="be935-1048">이 데이터는 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블을 복구 프로세스에서 사용할 수 있도록 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1048">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="be935-1049">재시작 영역은 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 메서드를 사용하여 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1049">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="be935-1050">재시작 영역이 기록되면 바이트 배열 세그먼트의 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1050">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-1051">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1051">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="be935-1052">예약을 지정하는 경우 쓴 재시작 영역은 컬렉션에 포함된 예약을 사용하여 이전에 예약된 공간을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1052">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="be935-1053">메서드가 성공하면 데이터가 포함될 수 있는 가장 작은 예약을 사용하고 해당 예약이 컬렉션에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1053">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="be935-1054">이 메서드가 성공적으로 완료되면 기준 세그먼트 번호가 업데이트된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1054">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="be935-1055">새 기준 시퀀스 번호보다 작은 시퀀스 번호를 가진 모든 로그 레코드에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1055">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="be935-1056">레코드 시퀀스가 삭제되었거나 잘못된 인수를 전달하는 경우 이 작업 내에서 즉시 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1056">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="be935-1057">비동기 추가 요청 중에 발생한 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 메서드를 호출할 때 예외로 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1057">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-1058">하나 이상의 인수가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1058">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-1059">재시작 영역을 쓰는 동안 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1059">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-1060">레코드 시퀀스에서 새 재시작 영역을 포함할 충분한 여유 공간을 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1060">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-1061">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1061">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservationCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="be935-1062">연결하여 레코드로 추가할 바이트 배열 세그먼트의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1062">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="be935-1063">새 기준 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1063">The new base sequence number.</span></span> <span data-ttu-id="be935-1064">지정된 시퀀스 번호는 현재 기준 시퀀스 번호보다 크거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1064">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="be935-1065">이 재시작 영역에 사용해야 하는 예약이 포함된 <see cref="T:System.IO.Log.ReservationCollection" />입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1065">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <summary><span data-ttu-id="be935-1066">예약을 사용하여 재시작 영역을 <see cref="T:System.IO.Log.LogRecordSequence" />에 쓰고 기준 시퀀스 번호를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1066">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number.</span></span> <span data-ttu-id="be935-1067">이 메서드는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1067">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="be935-1068">쓴 재시작 영역의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1068">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be935-1069">재시작 영역은 클라이언트의 마지막 검사점 작업을 포함하는 정보를 임시로 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1069">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="be935-1070">CLFS(Common Log File System)에서는 적어도 하나의 유효한 영역을 항상 사용할 수 있도록 하기 위해 두 개의 재시작 영역을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1070">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="be935-1071">복구가 필요한 경우 CLFS에서는 재시작 영역을 읽고 마지막 검사점 작업에서 데이터를 모두 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1071">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="be935-1072">이 데이터는 트랜잭션 테이블, 더티 페이지 테이블 및 열린 파일 테이블을 복구 프로세스에서 사용할 수 있도록 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1072">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="be935-1073">재시작 영역은 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 메서드를 사용하여 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1073">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="be935-1074">재시작 영역이 기록되면 바이트 배열 세그먼트의 데이터는 레코드로 추가하기 위한 단일 바이트 배열로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1074">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="be935-1075">재시작 영역을 읽을 때 데이터를 배열 세그먼트로 다시 분할할 수 있는 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1075">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="be935-1076">예약을 지정하는 경우 쓴 재시작 영역은 컬렉션에 포함된 예약을 사용하여 이전에 예약된 공간을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1076">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="be935-1077">메서드가 성공하면 데이터가 포함될 수 있는 가장 작은 예약을 사용하고 해당 예약이 컬렉션에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1077">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="be935-1078">이 메서드가 성공적으로 완료되면 기준 세그먼트 번호가 업데이트된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1078">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="be935-1079">새 기준 시퀀스 번호보다 작은 시퀀스 번호를 가진 모든 로그 레코드에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1079">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="be935-1080">레코드 시퀀스가 삭제되었거나 잘못된 인수를 전달하는 경우 이 작업 내에서 즉시 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1080">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="be935-1081">비동기 추가 요청 중에 발생한 오류(예: I/O 요청 중의 디스크 오류)는 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 메서드를 호출할 때 예외로 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1081">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be935-1082"><paramref name="newBaseSeqNum" />이 이 시퀀스에 유효하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1082"><paramref name="newBaseSeqNum" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="be935-1083">또는</span><span class="sxs-lookup"><span data-stu-id="be935-1083">-or-</span></span> 
<span data-ttu-id="be935-1084">지정된 로그 열거형 시작 시퀀스 번호가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1084">The specified log enumeration start sequence number is invalid.</span></span>  
  
<span data-ttu-id="be935-1085">또는</span><span class="sxs-lookup"><span data-stu-id="be935-1085">-or-</span></span> 
 <span data-ttu-id="be935-1086"><paramref name="data" />가 최대 레코드 크기보다 커서 추가할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1086"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="be935-1087">또는</span><span class="sxs-lookup"><span data-stu-id="be935-1087">-or-</span></span> 
 <span data-ttu-id="be935-1088">이 레코드 시퀀스를 통해 <paramref name="reservationCollection" />를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1088"><paramref name="reservationCollection" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be935-1089">매개 변수 중 하나 이상이 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1089">One or more of the parameters is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be935-1090">활성 로그의 기존 또는 새 아카이브 테일이나 베이스가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="be935-1090">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
<span data-ttu-id="be935-1091">또는</span><span class="sxs-lookup"><span data-stu-id="be935-1091">-or-</span></span> 
 <span data-ttu-id="be935-1092"><paramref name="newBaseSeqNum" />이 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1092"><paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="be935-1093">예기치 못한 I/O 예외 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1093">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="be935-1094">또는</span><span class="sxs-lookup"><span data-stu-id="be935-1094">-or-</span></span> 
<span data-ttu-id="be935-1095">I/O 장치 오류 때문에 요청을 수행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1095">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="be935-1096">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1096">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="be935-1097">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1097">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="be935-1098">지정된 로그 시퀀스에 대한 액세스가 운영 체제에서 거부되는 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1098">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="be935-1099">레코드 시퀀스가 꽉 찬 경우</span><span class="sxs-lookup"><span data-stu-id="be935-1099">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>