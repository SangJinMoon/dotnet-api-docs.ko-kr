<Type Name="CipherMode" FullName="System.Security.Cryptography.CipherMode">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7c70ff3bf1a311578eeb87faf3ca052f53d7933f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30495927" />
  </Metadata>
  <TypeSignature Language="C#" Value="public enum CipherMode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed CipherMode extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.CipherMode" />
  <TypeSignature Language="VB.NET" Value="Public Enum CipherMode" />
  <TypeSignature Language="C++ CLI" Value="public enum class CipherMode" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="5620c-101">암호화에 사용할 블록 암호화 모드를 지정합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="5620c-101">Specifies the block cipher mode to use for encryption.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5620c-102">블록 암호화 알고리즘에는 한 번에 단일 바이트 보다는 데이터를 블록 단위로 암호화합니다.</span><span class="sxs-lookup"><span data-stu-id="5620c-102">Block cipher algorithms encrypt data in block units, rather than a single byte at a time.</span></span> <span data-ttu-id="5620c-103">가장 일반적인 블록 크기는 8 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="5620c-103">The most common block size is 8 bytes.</span></span> <span data-ttu-id="5620c-104">각 블록 게 처리 하기 때문에 블록 암호화 스트림 암호화 보다 더 높은 수준의 보안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="5620c-104">Because each block is heavily processed, block ciphers provide a higher level of security than stream ciphers.</span></span> <span data-ttu-id="5620c-105">그러나 블록 암호화 알고리즘은 스트림 암호화 보다 느리게 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5620c-105">However, block cipher algorithms tend to execute more slowly than stream ciphers.</span></span>  
  
 <span data-ttu-id="5620c-106">각 블록에 대 한 동일한 암호화 알고리즘을 사용 하는 블록 암호화 합니다.</span><span class="sxs-lookup"><span data-stu-id="5620c-106">Block ciphers use the same encryption algorithm for each block.</span></span> <span data-ttu-id="5620c-107">이 때문에 일반 텍스트 블록을 항상 동일한 암호화 텍스트는 동일한 키 및 알고리즘을 사용 하 여 암호화를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="5620c-107">Because of this, a block of plain text will always return the same cipher text when encrypted with the same key and algorithm.</span></span> <span data-ttu-id="5620c-108">이 문제는 암호 해독에 사용할 수 있으므로 이전 블록 암호화에서에서 피드백에 따라 암호화 프로세스를 수정 하는 암호화 모드가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5620c-108">Because this behavior can be used to crack a cipher, cipher modes are introduced that modify the encryption process based on feedback from earlier block encryptions.</span></span> <span data-ttu-id="5620c-109">암호화 결과 단순 블록 암호화 보다 더 높은 수준의 보안을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5620c-109">The resulting encryption provides a higher level of security than a simple block encryption.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CBC">
      <MemberSignature Language="C#" Value="CBC" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode CBC = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.CBC" />
      <MemberSignature Language="VB.NET" Value="CBC" />
      <MemberSignature Language="C++ CLI" Value="CBC" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="5620c-110">
            <see langword="CBC" />(Cipher Block Chaining) 모드를 통해 피드백이 형성됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-110">The Cipher Block Chaining (<see langword="CBC" />) mode introduces feedback.</span>
          </span>
          <span data-ttu-id="5620c-111">일반 텍스트 블록이 암호화되기 전에 비트 배타적 OR 연산에 의해 이전 블록의 암호화 텍스트와 결합됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-111">Before each plain text block is encrypted, it is combined with the cipher text of the previous block by a bitwise exclusive OR operation.</span>
          </span>
          <span data-ttu-id="5620c-112">따라서 일반 텍스트에 여러 개의 동일한 블록이 들어 있어도 각각 다른 암호화 텍스트 블록으로 암호화됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-112">This ensures that even if the plain text contains many identical blocks, they will each encrypt to a different cipher text block.</span>
          </span>
          <span data-ttu-id="5620c-113">블록이 암호화되기 전에 비트 배타적 OR 연산에 의해 초기화 벡터에 첫 번째 일반 텍스트 블록이 결합됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-113">The initialization vector is combined with the first plain text block by a bitwise exclusive OR operation before the block is encrypted.</span>
          </span>
          <span data-ttu-id="5620c-114">암호화 텍스트 블록의 한 비트라도 손상되면 대응하는 일반 텍스트 블록도 손상됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-114">If a single bit of the cipher text block is mangled, the corresponding plain text block will also be mangled.</span>
          </span>
          <span data-ttu-id="5620c-115">또한 손상된 원본 비트와 같은 위치에 있는 다음 블록의 비트도 손상됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-115">In addition, a bit in the subsequent block, in the same position as the original mangled bit, will be mangled.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CFB">
      <MemberSignature Language="C#" Value="CFB" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode CFB = int32(4)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.CFB" />
      <MemberSignature Language="VB.NET" Value="CFB" />
      <MemberSignature Language="C++ CLI" Value="CFB" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="5620c-116">
            <see langword="CFB" />(Cipher Feedback) 모드는 한 번에 전체 블록을 처리하지 않고 일반 텍스트를 조금씩 암호화 텍스트로 처리합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-116">The Cipher Feedback (<see langword="CFB" />) mode processes small increments of plain text into cipher text, instead of processing an entire block at a time.</span>
          </span>
          <span data-ttu-id="5620c-117">이 모드는 한 블록 길이를 가지며 섹션으로 구분되는 이동 레지스터를 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-117">This mode uses a shift register that is one block in length and is divided into sections.</span>
          </span>
          <span data-ttu-id="5620c-118">예를 들어 블록 크기가 한 번에 1바이트씩 처리되는 8바이트이면 이동 레지스터는 여덟 개의 섹션으로 구분됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-118">For example, if the block size is 8 bytes, with one byte processed at a time, the shift register is divided into eight sections.</span>
          </span>
          <span data-ttu-id="5620c-119">암호화 텍스트에서 하나의 비트가 손상되면, 하나의 일반 텍스트 비트가 손상되고 이동 레지스터도 손상됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-119">If a bit in the cipher text is mangled, one plain text bit is mangled and the shift register is corrupted.</span>
          </span>
          <span data-ttu-id="5620c-120">이로 인해 잘못된 비트가 이동 레지스터 밖으로 이동될 때까지 이어지는 일반 텍스트 비트는 손상됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-120">This results in the next several plain text increments being mangled until the bad bit is shifted out of the shift register.</span>
          </span>
          <span data-ttu-id="5620c-121">기본 피드백 크기는 알고리즘에 따라 달라질 수 있지만 일반적으로 8비트이거나 블록 크기의 비트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-121">The default feedback size can vary by algorithm, but is typically either 8 bits or the number of bits of the block size.</span>
          </span>
          <span data-ttu-id="5620c-122">
            <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" /> 속성을 사용하여 피드백 비트 수를 변경할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-122">You can alter the number of feedback bits by using the <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" /> property.</span>
          </span>
          <span data-ttu-id="5620c-123">CFB를 지원하는 알고리즘은 이 속성을 사용하여 피드백을 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-123">Algorithms that support CFB use this property to set the feedback.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CTS">
      <MemberSignature Language="C#" Value="CTS" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode CTS = int32(5)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.CTS" />
      <MemberSignature Language="VB.NET" Value="CTS" />
      <MemberSignature Language="C++ CLI" Value="CTS" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>5</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="5620c-124">
            <see langword="CTS" />(Cipher Text Stealing) 모드는 길이 제한 없이 일반 텍스트를 처리하고 일반 텍스트와 동일한 길이를 갖는 암호화 텍스트를 생성합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-124">The Cipher Text Stealing (<see langword="CTS" />) mode handles any length of plain text and produces cipher text whose length matches the plain text length.</span>
          </span>
          <span data-ttu-id="5620c-125">이 모드는 일반 텍스트의 마지막 두 블록을 제외한 모든 블록에 대해 <see langword="CBC" /> 모드와 동일하게 작동됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-125">This mode behaves like the <see langword="CBC" /> mode for all but the last two blocks of the plain text.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ECB">
      <MemberSignature Language="C#" Value="ECB" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode ECB = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.ECB" />
      <MemberSignature Language="VB.NET" Value="ECB" />
      <MemberSignature Language="C++ CLI" Value="ECB" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="5620c-126">
            <see langword="ECB" />(Electronic Codebook) 모드는 각 블록을 개별적으로 암호화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-126">The Electronic Codebook (<see langword="ECB" />) mode encrypts each block individually.</span>
          </span>
          <span data-ttu-id="5620c-127">동일하면서 같은 메시지에 포함되어 있는 일반 텍스트의 블록이나 같은 키로 암호화된 다른 메시지에 있는 일반 텍스트의 블록이 모두 동일한 암호화 텍스트 블록으로 변환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-127">Any blocks of plain text that are identical and in the same message, or that are in a different message encrypted with the same key, will be transformed into identical cipher text blocks.</span>
          </span>
          <span data-ttu-id="5620c-128">**중요**: 이 모드를 사용하면 여러 보안 위험에 노출될 수 있으므로 사용하지 않는 것이 좋습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-128">**Important**:  This mode is not recommended because it opens the door for multiple security exploits.</span>
          </span>
          <span data-ttu-id="5620c-129">암호화할 일반 텍스트에 반복 부분이 포함되어 있으면 암호화 텍스트를 한 번에 하나의 블록으로 쉽게 구분할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-129">If the plain text to be encrypted contains substantial repetition, it is feasible for the cipher text to be broken one block at a time.</span>
          </span>
          <span data-ttu-id="5620c-130">블록 분석을 사용하여 암호화 키를 확인할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-130">It is also possible to use block analysis to determine the encryption key.</span>
          </span>
          <span data-ttu-id="5620c-131">또한 다른 사용자가 몰래 개별 블록을 대체하거나 교환할 수 있으므로 다른 시점에 몰래 블록을 스트림에 저장 및 삽입할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-131">Also, an active adversary can substitute and exchange individual blocks without detection, which allows blocks to be saved and inserted into the stream at other points without detection.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="OFB">
      <MemberSignature Language="C#" Value="OFB" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode OFB = int32(3)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.OFB" />
      <MemberSignature Language="VB.NET" Value="OFB" />
      <MemberSignature Language="C++ CLI" Value="OFB" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>3</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="5620c-132">
            <see langword="OFB" />(Output Feedback) 모드는 한 번에 전체 블록을 처리하지 않고 일반 텍스트를 조금씩 암호화 텍스트로 처리합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-132">The Output Feedback (<see langword="OFB" />) mode processes small increments of plain text into cipher text instead of processing an entire block at a time.</span>
          </span>
          <span data-ttu-id="5620c-133">이 모드는 <see langword="CFB" />와 비슷하며 이동 레지스터를 채우는 방식에서만 차이가 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-133">This mode is similar to <see langword="CFB" />; the only difference between the two modes is the way that the shift register is filled.</span>
          </span>
          <span data-ttu-id="5620c-134">암호화 텍스트의 한 비트가 손상되면 일반 텍스트의 해당 비트도 손상됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-134">If a bit in the cipher text is mangled, the corresponding bit of plain text will be mangled.</span>
          </span>
          <span data-ttu-id="5620c-135">그러나 암호화 텍스트에 추가 비트나 누락된 비트가 있으면 그 지점부터 일반 텍스트가 손상됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5620c-135">However, if there are extra or missing bits from the cipher text, the plain text will be mangled from that point on.</span>
          </span>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>