<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CipherMode.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac57c70ff3bf1a311578eeb87faf3ca052f53d7933f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7c70ff3bf1a311578eeb87faf3ca052f53d7933f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.CipherMode">
          <source>Specifies the block cipher mode to use for encryption.</source>
          <target state="translated">암호화에 사용할 블록 암호화 모드를 지정합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>Block cipher algorithms encrypt data in block units, rather than a single byte at a time.</source>
          <target state="translated">블록 암호화 알고리즘에는 한 번에 단일 바이트 보다는 데이터를 블록 단위로 암호화합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>The most common block size is 8 bytes.</source>
          <target state="translated">가장 일반적인 블록 크기는 8 바이트입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>Because each block is heavily processed, block ciphers provide a higher level of security than stream ciphers.</source>
          <target state="translated">각 블록 게 처리 하기 때문에 블록 암호화 스트림 암호화 보다 더 높은 수준의 보안을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>However, block cipher algorithms tend to execute more slowly than stream ciphers.</source>
          <target state="translated">그러나 블록 암호화 알고리즘은 스트림 암호화 보다 느리게 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>Block ciphers use the same encryption algorithm for each block.</source>
          <target state="translated">각 블록에 대 한 동일한 암호화 알고리즘을 사용 하는 블록 암호화 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>Because of this, a block of plain text will always return the same cipher text when encrypted with the same key and algorithm.</source>
          <target state="translated">이 때문에 일반 텍스트 블록을 항상 동일한 암호화 텍스트는 동일한 키 및 알고리즘을 사용 하 여 암호화를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>Because this behavior can be used to crack a cipher, cipher modes are introduced that modify the encryption process based on feedback from earlier block encryptions.</source>
          <target state="translated">이 문제는 암호 해독에 사용할 수 있으므로 이전 블록 암호화에서에서 피드백에 따라 암호화 프로세스를 수정 하는 암호화 모드가 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>The resulting encryption provides a higher level of security than a simple block encryption.</source>
          <target state="translated">암호화 결과 단순 블록 암호화 보다 더 높은 수준의 보안을 제공합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>The Cipher Block Chaining (<ph id="ph1">&lt;see langword="CBC" /&gt;</ph>) mode introduces feedback.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="CBC" /&gt;</ph>(Cipher Block Chaining) 모드를 통해 피드백이 형성됩니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>Before each plain text block is encrypted, it is combined with the cipher text of the previous block by a bitwise exclusive OR operation.</source>
          <target state="translated">일반 텍스트 블록이 암호화되기 전에 비트 배타적 OR 연산에 의해 이전 블록의 암호화 텍스트와 결합됩니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>This ensures that even if the plain text contains many identical blocks, they will each encrypt to a different cipher text block.</source>
          <target state="translated">따라서 일반 텍스트에 여러 개의 동일한 블록이 들어 있어도 각각 다른 암호화 텍스트 블록으로 암호화됩니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>The initialization vector is combined with the first plain text block by a bitwise exclusive OR operation before the block is encrypted.</source>
          <target state="translated">블록이 암호화되기 전에 비트 배타적 OR 연산에 의해 초기화 벡터에 첫 번째 일반 텍스트 블록이 결합됩니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>If a single bit of the cipher text block is mangled, the corresponding plain text block will also be mangled.</source>
          <target state="translated">암호화 텍스트 블록의 한 비트라도 손상되면 대응하는 일반 텍스트 블록도 손상됩니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>In addition, a bit in the subsequent block, in the same position as the original mangled bit, will be mangled.</source>
          <target state="translated">또한 손상된 원본 비트와 같은 위치에 있는 다음 블록의 비트도 손상됩니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>The Cipher Feedback (<ph id="ph1">&lt;see langword="CFB" /&gt;</ph>) mode processes small increments of plain text into cipher text, instead of processing an entire block at a time.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="CFB" /&gt;</ph>(Cipher Feedback) 모드는 한 번에 전체 블록을 처리하지 않고 일반 텍스트를 조금씩 암호화 텍스트로 처리합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>This mode uses a shift register that is one block in length and is divided into sections.</source>
          <target state="translated">이 모드는 한 블록 길이를 가지며 섹션으로 구분되는 이동 레지스터를 사용합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>For example, if the block size is 8 bytes, with one byte processed at a time, the shift register is divided into eight sections.</source>
          <target state="translated">예를 들어 블록 크기가 한 번에 1바이트씩 처리되는 8바이트이면 이동 레지스터는 여덟 개의 섹션으로 구분됩니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>If a bit in the cipher text is mangled, one plain text bit is mangled and the shift register is corrupted.</source>
          <target state="translated">암호화 텍스트에서 하나의 비트가 손상되면, 하나의 일반 텍스트 비트가 손상되고 이동 레지스터도 손상됩니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>This results in the next several plain text increments being mangled until the bad bit is shifted out of the shift register.</source>
          <target state="translated">이로 인해 잘못된 비트가 이동 레지스터 밖으로 이동될 때까지 이어지는 일반 텍스트 비트는 손상됩니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>The default feedback size can vary by algorithm, but is typically either 8 bits or the number of bits of the block size.</source>
          <target state="translated">기본 피드백 크기는 알고리즘에 따라 달라질 수 있지만 일반적으로 8비트이거나 블록 크기의 비트 수입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>You can alter the number of feedback bits by using the <ph id="ph1">&lt;see cref="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" /&gt;</ph> 속성을 사용하여 피드백 비트 수를 변경할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>Algorithms that support CFB use this property to set the feedback.</source>
          <target state="translated">CFB를 지원하는 알고리즘은 이 속성을 사용하여 피드백을 설정합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CTS">
          <source>The Cipher Text Stealing (<ph id="ph1">&lt;see langword="CTS" /&gt;</ph>) mode handles any length of plain text and produces cipher text whose length matches the plain text length.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="CTS" /&gt;</ph>(Cipher Text Stealing) 모드는 길이 제한 없이 일반 텍스트를 처리하고 일반 텍스트와 동일한 길이를 갖는 암호화 텍스트를 생성합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CTS">
          <source>This mode behaves like the <ph id="ph1">&lt;see langword="CBC" /&gt;</ph> mode for all but the last two blocks of the plain text.</source>
          <target state="translated">이 모드는 일반 텍스트의 마지막 두 블록을 제외한 모든 블록에 대해 <ph id="ph1">&lt;see langword="CBC" /&gt;</ph> 모드와 동일하게 작동됩니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source>The Electronic Codebook (<ph id="ph1">&lt;see langword="ECB" /&gt;</ph>) mode encrypts each block individually.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="ECB" /&gt;</ph>(Electronic Codebook) 모드는 각 블록을 개별적으로 암호화합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source>Any blocks of plain text that are identical and in the same message, or that are in a different message encrypted with the same key, will be transformed into identical cipher text blocks.</source>
          <target state="translated">동일하면서 같은 메시지에 포함되어 있는 일반 텍스트의 블록이나 같은 키로 암호화된 다른 메시지에 있는 일반 텍스트의 블록이 모두 동일한 암호화 텍스트 블록으로 변환됩니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>:  This mode is not recommended because it opens the door for multiple security exploits.</source>
          <target state="translated"><bpt id="p1">**</bpt>중요<ept id="p1">**</ept>: 이 모드를 사용하면 여러 보안 위험에 노출될 수 있으므로 사용하지 않는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source>If the plain text to be encrypted contains substantial repetition, it is feasible for the cipher text to be broken one block at a time.</source>
          <target state="translated">암호화할 일반 텍스트에 반복 부분이 포함되어 있으면 암호화 텍스트를 한 번에 하나의 블록으로 쉽게 구분할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source>It is also possible to use block analysis to determine the encryption key.</source>
          <target state="translated">블록 분석을 사용하여 암호화 키를 확인할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source>Also, an active adversary can substitute and exchange individual blocks without detection, which allows blocks to be saved and inserted into the stream at other points without detection.</source>
          <target state="translated">또한 다른 사용자가 몰래 개별 블록을 대체하거나 교환할 수 있으므로 다른 시점에 몰래 블록을 스트림에 저장 및 삽입할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.OFB">
          <source>The Output Feedback (<ph id="ph1">&lt;see langword="OFB" /&gt;</ph>) mode processes small increments of plain text into cipher text instead of processing an entire block at a time.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="OFB" /&gt;</ph>(Output Feedback) 모드는 한 번에 전체 블록을 처리하지 않고 일반 텍스트를 조금씩 암호화 텍스트로 처리합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.OFB">
          <source>This mode is similar to <ph id="ph1">&lt;see langword="CFB" /&gt;</ph>; the only difference between the two modes is the way that the shift register is filled.</source>
          <target state="translated">이 모드는 <ph id="ph1">&lt;see langword="CFB" /&gt;</ph>와 비슷하며 이동 레지스터를 채우는 방식에서만 차이가 있습니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.OFB">
          <source>If a bit in the cipher text is mangled, the corresponding bit of plain text will be mangled.</source>
          <target state="translated">암호화 텍스트의 한 비트가 손상되면 일반 텍스트의 해당 비트도 손상됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.OFB">
          <source>However, if there are extra or missing bits from the cipher text, the plain text will be mangled from that point on.</source>
          <target state="translated">그러나 암호화 텍스트에 추가 비트나 누락된 비트가 있으면 그 지점부터 일반 텍스트가 손상됩니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>