<Type Name="ECDiffieHellman" FullName="System.Security.Cryptography.ECDiffieHellman">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="240947e743f897b08d004de6a9deb8c851fcc7e3" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ECDiffieHellman : System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ECDiffieHellman extends System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ECDiffieHellman&#xA;Inherits AsymmetricAlgorithm" />
  <TypeSignature Language="C++ CLI" Value="public ref class ECDiffieHellman abstract : System::Security::Cryptography::AsymmetricAlgorithm" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.AsymmetricAlgorithm</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="3a2e1-101">ECDH(Elliptic Curve Diffie-Hellman) 알고리즘 구현이 파생될 수 있는 추상 기본 클래스를 제공합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3a2e1-101">Provides an abstract base class that Elliptic Curve Diffie-Hellman (ECDH) algorithm implementations can derive from.</span>
      </span>
      <span data-ttu-id="3a2e1-102">이 클래스는 모든 ECDH 구현에서 지원해야 하는 기본 작업 집합을 제공합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3a2e1-102">This class provides the basic set of operations that all ECDH implementations must support.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-103">이 클래스는 ECDH 구현에 대 한 추상 기본 클래스로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-103">This class serves as the abstract base class for ECDH implementations.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ECDiffieHellman ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ECDiffieHellman();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3a2e1-104">
            <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-104">Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-105">이 생성자에서 파생 되는 클래스에서 호출 됩니다는 <xref:System.Security.Cryptography.ECDiffieHellman> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-105">This constructor is called by classes that derive from the <xref:System.Security.Cryptography.ECDiffieHellman> class.</span></span> <span data-ttu-id="3a2e1-106"><xref:System.Security.Cryptography.ECDiffieHellmanCng> 클래스는 현재에 포함 되어 있는 유일한 구현은 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-106">The <xref:System.Security.Cryptography.ECDiffieHellmanCng> class is the only implementation that is currently included in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span> <span data-ttu-id="3a2e1-107">Diffie Hellman ECDH (타원 곡선) 알고리즘의 새 구현을 만드는 방법에 대 한 자세한 내용은 참조는 <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-107">For information about how to create a new implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm, see the <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3a2e1-108">ECDH(Elliptic Curve Diffie-Hellman) 알고리즘 구현의 새 인스턴스를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-108">Creates a new instance of an implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3a2e1-109">기본 ECDH(Elliptic Curve Diffie-Hellman) 알고리즘 구현의 새 인스턴스를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-109">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-110">이 클래스의 기본 구현의 새 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-110">A new instance of the default implementation of this class.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (curve As ECCurve) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECCurve curve);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" />
      </Parameters>
      <Docs>
        <param name="curve">
          <span data-ttu-id="3a2e1-111">새 공개/개인 키 쌍을 생성하는 데 사용할 곡선입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-111">The curve to use to generate a new public/private key-pair.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-112">지정한 곡선에서 생성된 새 공개/개인 키 쌍을 사용하여 ECDH(타원 곡선 Diffie-Hellman) 알고리즘 기본 구현의 새 인스턴스를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-112">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with a new public/private key-pair generated over the specified curve.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-113">ECDH(타원 곡선 Diffie-Hellman) 알고리즘 기본 구현의 새 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-113">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-114">곡선의 유효성을 검사 해야 합니다 (즉, true를 반환 해야에 전달 될 때는 <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-114">curve must validate (that is, it must return true when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3a2e1-115">특징-2 곡선 Windows에서 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-115">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <span data-ttu-id="3a2e1-116">
            <paramref name="curve" />의 유효성을 검사할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-116">
              <paramref name="curve" /> does not validate.</span>
          </span>
        </exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (parameters As ECParameters) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECParameters parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">
          <span data-ttu-id="3a2e1-117">ECC(타원 곡선 암호화) 알고리즘에 대한 매개 변수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-117">The parameters  for the elliptic curve cryptography (ECC) algorithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-118">지정한 <see cref="T:System.Security.Cryptography.ECParameters" /> 개체로 기술되는 키를 사용하여 ECDH(타원 곡선 Diffie-Hellman) 알고리즘 기본 구현의 새 인스턴스를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-118">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with the key described by the specified  <see cref="T:System.Security.Cryptography.ECParameters" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-119">ECDH(타원 곡선 Diffie-Hellman) 알고리즘 기본 구현의 새 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-119">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-120">`parameters` 유효성을 검사 해야 (즉, 반환 해야 `true`)에 전달 될 때는 <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-120">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3a2e1-121">암시적 곡선을 통해 매개 변수는 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-121">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="3a2e1-122">특징-2 곡선 Windows에서 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-122">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <span data-ttu-id="3a2e1-123">
            <paramref name="parameters" />의 유효성을 검사할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-123">
              <paramref name="parameters" /> does not validate.</span>
          </span>
        </exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (string algorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(string algorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algorithm As String) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::String ^ algorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algorithm" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="algorithm">
          <span data-ttu-id="3a2e1-124">ECDH 알고리즘의 구현 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-124">The name of an implementation of the ECDH algorithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-125">ECDH(타원 곡선 Diffie-Hellman) 알고리즘의 지정된 구현에 대해 새 인스턴스를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-125">Creates a new instance of the specified implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-126">이 클래스의 지정된 구현에 대한 새 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-126">A new instance of the specified implementation of this class.</span>
          </span>
          <span data-ttu-id="3a2e1-127">지정된 알고리즘 이름이 ECDH 구현에 매핑되지 않는 경우 이 메서드는 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-127">If the specified algorithm name does not map to an ECDH implementation, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-128">사용자 지정 구현을 개발 하는 경우는 <xref:System.Security.Cryptography.ECDiffieHellman> 개체를 사용할 수 있습니다는 <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> 메서드 오버 로드는 사용자 지정 만들려면 `algorithm` 구현을 지정 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-128">If you develop your own implementation of an <xref:System.Security.Cryptography.ECDiffieHellman> object, you can use the <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> method overload to create a custom `algorithm` string that specifies your implementation.</span></span>  
  
 <span data-ttu-id="3a2e1-129">`algorithm` 매개 변수는 ECDH 알고리즘의 구현의 이름을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-129">The `algorithm` parameter specifies the name of an implementation of the ECDH algorithm.</span></span> <span data-ttu-id="3a2e1-130">다음 문자열은 모두 같은 구현을 참조합니다. [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]에서는 현재 이 구현만 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-130">The following strings all refer to the same implementation, which is the only implementation currently supported in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]:</span></span>  
  
-   <span data-ttu-id="3a2e1-131">"ECDH"</span><span class="sxs-lookup"><span data-stu-id="3a2e1-131">"ECDH"</span></span>  
  
-   <span data-ttu-id="3a2e1-132">"ECDiffieHellman"</span><span class="sxs-lookup"><span data-stu-id="3a2e1-132">"ECDiffieHellman"</span></span>  
  
-   <span data-ttu-id="3a2e1-133">"ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="3a2e1-133">"ECDiffieHellmanCng"</span></span>  
  
-   <span data-ttu-id="3a2e1-134">"System.Security.Cryptography.ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="3a2e1-134">"System.Security.Cryptography.ECDiffieHellmanCng"</span></span>  
  
 <span data-ttu-id="3a2e1-135">사용자 지정 ECDH 구현에 대 한 이름을 제공할 수도 있습니다는 `algorithm` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-135">You can also provide the name of a custom ECDH implementation for the `algorithm` parameter.</span></span> <span data-ttu-id="3a2e1-136">이렇게 하면는 <xref:System.Security.Cryptography.CryptoConfig> 개체 ECDH 개체를 만들 수 있는지 여부를 확인 하려면 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-136">If you do that, the <xref:System.Security.Cryptography.CryptoConfig> object will use it to determine whether an ECDH object can be created.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3a2e1-137">
            <paramref name="algorithm" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-137">The <paramref name="algorithm" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHash">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3a2e1-138">해시 함수를 사용하여 키로 사용할 수 있는 바이트를 파생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-138">Derives bytes that can be used as a key using a hash function .</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="3a2e1-139">상대방의 공개 키입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-139">The other party's public key.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="3a2e1-140">키 자료를 파생시키는 데 사용할 해시 알고리즘입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-140">The hash algorithm  to use to derive the key material.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-141">해시 함수, 지정된 다른 당사자의 공개 키 및 해시 알고리즘의 이름을 사용하여 키로 사용할 수 있는 바이트를 파생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-141">Derives bytes that can be used as a key using a hash function, given another party's public key and hash algorithm's name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-142">상대방의 공개 키와의 키 교환와 관련된 키 자료입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-142">The key material from the key exchange with the other party’s public key.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-143">이 오버 로드는 <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> 전달 메서드 `null` 는 prepend로 값을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-143">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" />
        <Parameter Name="secretAppend" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="3a2e1-144">상대방의 공개 키입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-144">The other party's public key.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="3a2e1-145">키 자료를 파생시키는 데 사용할 해시 알고리즘입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-145">The hash algorithm  to use to derive the key material.</span>
          </span>
        </param>
        <param name="secretPrepend">
          <span data-ttu-id="3a2e1-146">해시 전에 파생된 암호 앞에 추가할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-146">A value to prepend to the derived secret before hashing.</span>
          </span>
        </param>
        <param name="secretAppend">
          <span data-ttu-id="3a2e1-147">해시 전에 파생된 암호 뒤에 추가할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-147">A value to append to the derived secret before hashing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-148">파생된 클래스에서 구현되는 경우 해시 함수, 지정된 다른 당사자의 공개 키, 해시 알고리즘의 이름, 선행 값 및 후행 값을 사용하여 키로 사용할 수 있는 바이트를 파생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-148">When implemented in a derived class, derives bytes that can be used as a key using a hash function, given another party's public key, hash algorithm's name, a prepend value and an append value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-149">상대방의 공개 키와의 키 교환와 관련된 키 자료입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-149">The key material from the key exchange with the other party’s public key.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3a2e1-150">파생 클래스가 이 메서드를 재정의해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-150">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHmac">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3a2e1-151">HMAC(해시 기반 메시지 인증 코드)를 사용하여 키로 사용할 수 있는 바이트를 파생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-151">Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="hmacKey" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="3a2e1-152">상대방의 공개 키입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-152">The other party's public key.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="3a2e1-153">키 자료를 파생시키는 데 사용할 해시 알고리즘입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-153">The hash algorithm to use to derive the key material.</span>
          </span>
        </param>
        <param name="hmacKey">
          <span data-ttu-id="3a2e1-154">HMAC의 키입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-154">The key for the HMAC.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-155">HMAC(해시 기반 메시지 인증 코드)를 사용하여 키로 사용할 수 있는 바이트를 파생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-155">Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-156">상대방의 공개 키와의 키 교환와 관련된 키 자료입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-156">The key material from the key exchange with the other party’s public key.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-157">이 오버 로드는 <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> 전달 메서드 `null` 는 prepend로 값을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-157">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte(), secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="hmacKey" Type="System.Byte[]" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" />
        <Parameter Name="secretAppend" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="3a2e1-158">상대방의 공개 키입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-158">The other party's public key.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="3a2e1-159">키 자료를 파생시키는 데 사용할 해시 알고리즘입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-159">The hash algorithm to use to derive the key material.</span>
          </span>
        </param>
        <param name="hmacKey">
          <span data-ttu-id="3a2e1-160">HMAC의 키입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-160">The key for the HMAC.</span>
          </span>
        </param>
        <param name="secretPrepend">
          <span data-ttu-id="3a2e1-161">해시 전에 파생된 암호 앞에 추가할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-161">A value to prepend to the derived secret before hashing.</span>
          </span>
        </param>
        <param name="secretAppend">
          <span data-ttu-id="3a2e1-162">해시 전에 파생된 암호 뒤에 추가할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-162">A value to append to the derived secret before hashing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-163">파생 클래스에서 구현되는 경우 HMAC(해시 기반 메시지 인증 코드)를 사용하여 키로 사용할 수 있는 바이트를 파생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-163">When implemented in a derived class, derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-164">상대방의 공개 키와의 키 교환와 관련된 키 자료입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-164">The key material from the key exchange with the other party’s public key.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3a2e1-165">파생 클래스가 이 메서드를 재정의해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-165">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="3a2e1-166">상대방의 공개 키입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-166">The other party's public key.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-167">다른 당사자의 공개 키를 사용하여 키로 사용할 수 있는 바이트를 파생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-167">Derives bytes that can be used as a key, given another party's public key.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-168">상대방의 공개 키와의 키 교환와 관련된 키 자료입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-168">The key material from the key exchange with the other party’s public key.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-169">공개 키에 대 한 자세한 내용은 참조는 <xref:System.Security.Cryptography.ECDiffieHellmanPublicKey> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-169">For more information about public keys, see the <xref:System.Security.Cryptography.ECDiffieHellmanPublicKey> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyTls">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyTls (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyTls(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, unsigned int8[] prfLabel, unsigned int8[] prfSeed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyTls (otherPartyPublicKey As ECDiffieHellmanPublicKey, prfLabel As Byte(), prfSeed As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyTls(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, cli::array &lt;System::Byte&gt; ^ prfLabel, cli::array &lt;System::Byte&gt; ^ prfSeed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="prfLabel" Type="System.Byte[]" />
        <Parameter Name="prfSeed" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="3a2e1-170">상대방의 공개 키입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-170">The other party's public key.</span>
          </span>
        </param>
        <param name="prfLabel">
          <span data-ttu-id="3a2e1-171">ASCII로 인코딩된 PRF 레이블입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-171">The ASCII-encoded PRF label.</span>
          </span>
        </param>
        <param name="prfSeed">
          <span data-ttu-id="3a2e1-172">64바이트 PRF 시드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-172">The 64-byte PRF seed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-173">파생된 클래스에서 구현되는 경우 TLS(전송 계층 보안) PRF(의사 난수 함수) 파생 알고리즘을 사용하여 키로 사용할 수 있는 바이트를 파생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-173">When implemented in a derived class, derives bytes that can be used as a key using a Transport Layer Security (TLS) Pseudo-Random Function (PRF) derivation algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-174">상대방의 공개 키와의 키 교환와 관련된 키 자료입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-174">The key material from the key exchange with the other party’s public key.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3a2e1-175">파생 클래스가 이 메서드를 재정의해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-175">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExportExplicitParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportExplicitParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportExplicitParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportExplicitParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportExplicitParameters(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <span data-ttu-id="3a2e1-176">private 매개 변수를 포함하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-176">
              <see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-177">파생 클래스에서 재정의하는 경우 <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> 메서드로 전달할 수 있도록 명시적 곡선 형식을 사용하여 작동하는 <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> 키에서 <see cref="T:System.Security.Cryptography.ECParameters" /> 구조체로 공개 키 정보 또는 공개 및 개인 키 정보를 내보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-177">When overridden in a derived class, exports either the public or the public and private key information using the explicit curve form from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-178">이 키에 대한 곡선의 점을 나타내는 개체입니다(명시적 곡선 형식 사용).</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-178">An object that represents the point on the curve for this key, using the explicit curve format.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3a2e1-179">파생 클래스가 이 메서드를 재정의해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-179">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportParameters(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <span data-ttu-id="3a2e1-180">개인 매개 변수를 포함하려는 경우 <see langword="true" />로 설정하고, 공개 매개 변수만 포함하려면 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-180">
              <see langword="true" /> to include private parameters; otehrwise,  <see langword="false" /> to include public parameters only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-181">파생 클래스에서 재정의하는 경우 <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> 메서드로 전달할 수 있도록 작동하는 <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> 키에서 <see cref="T:System.Security.Cryptography.ECParameters" /> 구조체로 공개 키 정보 또는 공개 및 개인 키 정보를 내보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-181">When overridden in a derived class, exports either the public or the public and private key information from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a2e1-182">이 키에 대한 곡선의 점을 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-182">An object that represents the point on the curve for this key.</span>
          </span>
          <span data-ttu-id="3a2e1-183">
            <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> 메서드에 전달할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-183">It can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-184">곡선에는 이름이 있는 경우는 <xref:System.Security.Cryptography.ECParameters.Curve> 속성 커브 명명 된 매개 변수가 포함 됩니다; 그렇지 않으면 명시적 매개 변수를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-184">If the curve has a name, the <xref:System.Security.Cryptography.ECParameters.Curve> property contains named curve parameters; otherwise, it will contain explicit parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3a2e1-185">파생 클래스가 이 메서드를 재정의해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-185">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public virtual void GenerateKey (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateKey(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateKey (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateKey(System::Security::Cryptography::ECCurve curve);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" />
      </Parameters>
      <Docs>
        <param name="curve">
          <span data-ttu-id="3a2e1-186">사용 후 삭제 공개/개인 키 쌍을 생성하는 데 사용되는 곡선입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-186">The curve used to generate an ephemeral public/private key pair.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-187">파생 클래스에서 재정의하는 경우 지정된 곡선에 대해 사용 후 삭제 공개/개인 키 쌍을 새로 생성합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-187">When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-188">`curve` 유효성을 검사 해야 (즉, 반환 해야 `true`)에 전달 될 때는 <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> 메서드) 암시적이 아니어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-188">`curve` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method) and must not be implicit.</span></span>  
  
 <span data-ttu-id="3a2e1-189">특징-2 곡선 Windows에서 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-189">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <span data-ttu-id="3a2e1-190">
            <paramref name="curve" />의 유효성을 검사할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-190">
              <paramref name="curve" /> does not validate.</span>
          </span>
        </exception>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3a2e1-191">파생 클래스가 이 메서드를 재정의해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-191">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public virtual void ImportParameters (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportParameters(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportParameters (parameters As ECParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportParameters(System::Security::Cryptography::ECParameters parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">
          <span data-ttu-id="3a2e1-192">가져올 곡선의 매개 변수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-192">The curve's parameters to import.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a2e1-193">파생 클래스에서 재정의하는 경우 <see cref="T:System.Security.Cryptography.ECCurve" />에 대해 지정된 매개 변수를 현재 <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> 개체에 사용 후 삭제 키로 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-193">When overridden in a derived class, imports the specified parameters for an <see cref="T:System.Security.Cryptography.ECCurve" /> as an ephemeral key into the current <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-194">`parameters` 유효성을 검사 해야 (즉, 반환 해야 `true`)에 전달 될 때는 <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-194">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3a2e1-195">암시적 곡선을 통해 매개 변수는 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-195">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="3a2e1-196">특징-2 곡선 Windows에서 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-196">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <span data-ttu-id="3a2e1-197">
            <paramref name="parameters" />의 유효성을 검사할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-197">
              <paramref name="parameters" /> does not validate.</span>
          </span>
        </exception>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3a2e1-198">파생 클래스가 이 메서드를 재정의해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-198">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public override string KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property KeyExchangeAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ KeyExchangeAlgorithm { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a2e1-199">키 교환 알고리즘의 이름을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-199">Gets the name of the key exchange algorithm.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3a2e1-200">키 교환 알고리즘의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-200">The name of the key exchange algorithm.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-201">이 속성의 기본값 (비 재정의할) 구현 "ECDiffieHellman" 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-201">The default (non-overridden) implementation of this property returns the string "ECDiffieHellman".</span></span>  
  
 <span data-ttu-id="3a2e1-202">이 속성에서 상속 되는 <xref:System.Security.Cryptography.AsymmetricAlgorithm> 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-202">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PublicKey As ECDiffieHellmanPublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Security::Cryptography::ECDiffieHellmanPublicKey ^ PublicKey { System::Security::Cryptography::ECDiffieHellmanPublicKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanPublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a2e1-203">현재 ECDH(Elliptic Curve Diffie-Hellman) 인스턴스에 사용되는 공개 키를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-203">Gets the public key that is being used by the current Elliptic Curve Diffie-Hellman (ECDH) instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3a2e1-204">이 <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> 인스턴스에 사용되는 ECDH 키 쌍의 공개 부분입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-204">The public part of the ECDH key pair that is being used by this <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> instance.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public override string SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SignatureAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SignatureAlgorithm { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a2e1-205">서명 알고리즘의 이름을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-205">Gets the name of the signature algorithm.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3a2e1-206">항상 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a2e1-206">Always <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a2e1-207">이 속성에서 상속 되는 <xref:System.Security.Cryptography.AsymmetricAlgorithm> 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-207">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 <span data-ttu-id="3a2e1-208">키 파생에 Diffie Hellman ECDH (타원 곡선) 알고리즘을 사용 하지 디지털 서명 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-208">The Elliptic Curve Diffie-Hellman (ECDH) algorithm is used for key derivation, not digital signature generation.</span></span> <span data-ttu-id="3a2e1-209">따라서이 속성은 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a2e1-209">Therefore, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>