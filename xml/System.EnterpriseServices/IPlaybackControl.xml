<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IPlaybackControl.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac554fcf7590327e9d2356fc883bfae633d190f6a78.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">54fcf7590327e9d2356fc883bfae633d190f6a78</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>Functions in Queued Components in the abnormal handling of server-side playback errors and client-side failures of the Message Queuing delivery mechanism.</source>
          <target state="translated">메시지 큐 배달 매커니즘의 서버측 재생 오류 및 클라이언트측 실패를 예외적으로 처리하는 데 사용되는 큐 사용 구성 요소의 함수입니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The exception class defined for the component in the COM+ catalog implements both <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph> and the interface for the original class.</source>
          <target state="translated">COM + 카탈로그에 구성 요소 둘 다 구현에 대해 정의 된 예외 클래스 <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph> 및 원본 클래스에 대 한 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The method implementations of the original class interface are used to perform the exception handling for the failed methods in the class itself.</source>
          <target state="translated">원본 클래스 인터페이스의 메서드 구현은 예외 클래스 자체의 실패 한 메서드에 대 한 처리를 수행 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>They will be called after <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph> to process exceptions for the method originally called.</source>
          <target state="translated">후 호출 됩니다 <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph> 원래 호출 된 메서드가 대 한 예외를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The Queued Components Player calls the methods of <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph> to inform the exception-handler object that a message is about to be placed on the final resting or dead letter queue.</source>
          <target state="translated">큐 구성 요소 플레이어의 메서드를 호출 <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph> 메시지가 최종 채로 두거나 배달 못 한 편지 큐에 배치 하는 예외 처리기 개체를 알릴 수 있습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The Queued Components Player then calls the same method in the exception-handler object that had failed in the original method call.</source>
          <target state="translated">다음 구성 요소 큐 플레이어는 원래 메서드 호출에서 실패 한 예외 처리기 개체의 동일한 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The exception-handler object can implement an alternative, for example, by gathering problem diagnosis information or generating an object or message that informs the client of the problem.</source>
          <target state="translated">예외 처리기 개체 문제 진단 정보를 수집 하거나 개체 또는 클라이언트의 문제를 알리는 메시지를 생성 하 여는 대신을 예를 들어 구현할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>If the application does not implement <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph>, the poison message is placed on the final resting or dead letter queue when the Queued Components Player exhausts all retries.</source>
          <target state="translated">응용 프로그램을 구현 하지 않는 경우 <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph>, 포이즌 메시지가 큐에 대기 구성 요소 플레이어 소모 모든 다시 시도 하는 경우 마지막 채로 두거나 배달 못 한 편지 큐에 배치 됩니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>A poison message is a message that cannot be processed for some reason, perhaps because of a problem with the server or queuing system.</source>
          <target state="translated">포이즌 메시지는 처리할 수 없는 몇 가지 이유로 아마도 서버 또는 큐 시스템에 문제가 있어서 메시지입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The transaction is rolled back, and the poison message goes to the top of the queue.</source>
          <target state="translated">트랜잭션이 롤백되고 포이즌 메시지 큐의 맨 위로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>When the message is dequeued again, the same condition occurs.</source>
          <target state="translated">메시지 큐에서 제거 다시, 동일한 조건을 발생 합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>This message can continue looping indefinitely until something is done to correct the problem.</source>
          <target state="translated">이 메시지는 문제를 해결 하려면 이루어진다는 것 때까지 무한정 계속할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The Queued Components service handles the poison message by using a series of retries.</source>
          <target state="translated">대기 중인 구성 요소 서비스는 일련의 재시도 사용 하 여 포이즌 메시지를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>After several unsuccessful retries, the message is moved to a final resting queue.</source>
          <target state="translated">실패 한 여러 차례 다시 시도한 후 메시지가 최종 도착 큐로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>Poison messages remain in the resting queue until manually moved by using the Queued Components Message Mover tool.</source>
          <target state="translated">포이즌 메시지 큐에 대기 구성 요소 메시지 Mover 도구를 사용 하 여 수동으로 이동 될 때까지 평평 큐에 남아 있습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The poison message situation can also be resolved programmatically, using the <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph> method, which informs the server-side component author that all attempts to play back the deferred activation have failed.</source>
          <target state="translated">포이즌 메시지 상황 해결할 수도 있습니다를 프로그래밍 방식으로 사용 하 여는 <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph> 메서드는 지연된 된 활성화를 다시 재생 하려는 모든 시도가 실패 한 서버 쪽 구성 요소 작성자에 게 알립니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>If you discover a poison message, you might be able to solve the underlying cause of the problem quickly.</source>
          <target state="translated">포이즌 메시지를 발견 한 경우에 문제의 근본 원인을 신속 하 게 해결할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>For example, if the server was offline for some reason, you can bring the server back online.</source>
          <target state="translated">예를 들어 서버에서 몇 가지 이유로 오프 라인 상태를 다시 온라인으로 서버를 가져올 수 있습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>If you cannot solve the problem quickly, you can automatically generate another transaction that notifies the requestor that the transaction did not occur.</source>
          <target state="translated">이 문제를 신속 하 게 해결할 수 없는 경우 트랜잭션이 발생 하지 않았던 요청자에 게 알리는 다른 트랜잭션을 자동으로 생성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The requestor can then make a compensating transaction that reverses the effect of a transaction that has already committed.</source>
          <target state="translated">요청자는 이미 커밋된 트랜잭션 효과 취소 하는 보정 트랜잭션을 확인 수 있습니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>Informs the client-side exception-handling component that all Message Queuing attempts to deliver the message to the server were rejected, and the message ended up on the client-side Xact Dead Letter queue.</source>
          <target state="translated">메시지를 서버에 배달하기 위한 모든 메시지 큐의 시도가 거부되었음을 클라이언트측 예외 처리 구성 요소에 알리고 클라이언트측 Xact 배달 못 한 큐로 메시지를 이동합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>As messages arrive in the Xact Dead Letter queue, COM+ attempts to invoke a client-side exception handler related to the server class to deliver this notification.</source>
          <target state="translated">트랜잭션 배달 못 한 편지 큐에 메시지가 도착, COM + 하려고이 알림을 배달 서버 클래스와 관련 클라이언트 쪽 예외 처리기를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>It does so by first calling <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt;</ph>, then calling the exception-handling version of the failed method in the exception-handler object.</source>
          <target state="translated">첫 번째 호출 하 여 작업을 수행 <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt;</ph>, 예외 처리기 개체의 예외 처리 버전의 실패 한 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</source>
          <target state="translated">그러면이 예외 메서드 실패를 기록 하 여 메일 메시지 관리자를 보내거나 (이전 트랜잭션의 결과 반대로) 클라이언트 쪽 보정 작업을 수행 하는 같은 예외 동작을를 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>If the exception method is not successful, the message is left on the Xact Dead Letter queue.</source>
          <target state="translated">Exception 메서드 실패할 경우 메시지는 트랜잭션 배달 못 한 편지 큐에 그대로 사용 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>The Xact Dead Letter queue can be viewed in the Microsoft Message Queue (MSMQ) Explorer.</source>
          <target state="translated">트랜잭션 배달 못 한 편지 큐는 Microsoft Message Queue (MSMQ) 탐색기에서 볼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>Informs the server-side exception class implementation that all attempts to play back the deferred activation to the server have failed, and the message is about to be moved to its final resting queue.</source>
          <target state="translated">서버에 대한 지연된 활성화를 재생하려는 모든 시도가 실패하여 메시지가 마지막 휴면 큐로 이동하려고 한다는 것을 서버측 예외 클래스 구현에 알립니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>As messages arrive on the Xact Dead Letter queue, COM+ attempts to invoke a server-side exception handler related to the server class to deliver this notification.</source>
          <target state="translated">트랜잭션 배달 못 한 편지 큐에 메시지가 도착, COM + 하려고 클래스와 관련 된 서버가이 알림을 배달 하는 서버 쪽 예외 처리기를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>It does so by first calling <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph>, then calling the exception handling version of the failed method in the exception handler object.</source>
          <target state="translated">첫 번째 호출 하 여 작업을 수행 <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph>, 예외 처리 버전의 예외 처리기 개체에서 실패 한 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</source>
          <target state="translated">그러면이 예외 메서드 실패를 기록 하 여 메일 메시지 관리자를 보내거나 (이전 트랜잭션의 결과 반대로) 클라이언트 쪽 보정 작업을 수행 하는 같은 예외 동작을를 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>The server object should make every effort to complete this transaction successfully.</source>
          <target state="translated">서버 개체는이 거래를 성공적으로 완료 하기 위한 모든 작업을 확인 해야 합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>Otherwise, manual intervention is required to reprocess the message.</source>
          <target state="translated">그렇지 않으면 메시지를 다시 처리 하려면 수동 개입이 필요 합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>If the exception method is not successful, the message is moved to the final resting queue.</source>
          <target state="translated">Exception 메서드 실패할 경우 메시지가 최종 도착 큐로 이동 합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>