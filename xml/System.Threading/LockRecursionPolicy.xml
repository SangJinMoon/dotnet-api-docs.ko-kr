<Type Name="LockRecursionPolicy" FullName="System.Threading.LockRecursionPolicy">
  <TypeSignature Language="C#" Value="public enum LockRecursionPolicy" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed LockRecursionPolicy extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Threading.LockRecursionPolicy" />
  <TypeSignature Language="VB.NET" Value="Public Enum LockRecursionPolicy" />
  <TypeSignature Language="C++ CLI" Value="public enum class LockRecursionPolicy" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary><span data-ttu-id="ab06e-101">동일한 스레드에서 잠금을 여러 번 시작할 수 있는지 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-101">Specifies whether a lock can be entered multiple times by the same thread.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ab06e-102">기본 재귀 정책을 잠금 유형에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-102">The default recursion policy depends on the type of lock.</span></span> <span data-ttu-id="ab06e-103">기본 정책 및 잠금에 대 한 재귀 특정된 잠금 형식의 정확한 동작 유형에 대 한 설명서를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-103">For the default policy and the precise behavior of lock recursion for any given lock type, see the documentation for the type.</span></span> <span data-ttu-id="ab06e-104">예를 들어는 <xref:System.Threading.ReaderWriterLockSlim> 클래스 이미 입력 한 잠금을 잠금 정책 설정에 관계 없이 읽기 모드로 교착 상태의 가능성을 줄이기 위해 하는 경우 쓰기 모드로 잠금을 시작 하는 스레드를 허용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-104">For example, the <xref:System.Threading.ReaderWriterLockSlim> class does not allow a thread to enter the lock in write mode if it already entered the lock in read mode, regardless of the lock policy setting, in order to reduce the chance of deadlocks.</span></span>  
  
 <span data-ttu-id="ab06e-105">이 열거형을 사용 하는 한 잠금을에 현재:</span><span class="sxs-lookup"><span data-stu-id="ab06e-105">Currently only one lock uses this enumeration:</span></span>  
  
-   <span data-ttu-id="ab06e-106"><xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="ab06e-106"><xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="ab06e-107">자세한 내용은 <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> 속성을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab06e-107">For more information, see the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ab06e-108">다음 예제에서는 두 가지 예외 시나리오 하나에 따라 달라 지는 <xref:System.Threading.LockRecursionPolicy> 설정 하 고 다른 하나는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-108">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="ab06e-109">첫 번째 시나리오에서는 여 읽기 모드로 잠금을 시작한 스레드와 다음 재귀적으로 읽기 모드를 시작 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-109">In the first scenario, the thread enters the lock in read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="ab06e-110">경우는 <xref:System.Threading.ReaderWriterLockSlim> 만들어집니다 재귀 정책을 NoRecursion를로 설정 하는 기본 생성자를 사용 하 여 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-110">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the default constructor, which sets recursion policy to NoRecursion, an exception is thrown.</span></span> <span data-ttu-id="ab06e-111">SupportsRecursion 만드는 데 사용 되는 경우는 <xref:System.Threading.ReaderWriterLockSlim>, 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-111">If SupportsRecursion is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="ab06e-112">두 번째 시나리오에서는 여 읽기 모드로 잠금을 시작한 스레드와 쓰기 모드로 잠금을 시작 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-112">In the second scenario, the thread enters the lock in read mode and then tries to enter the lock in write mode.</span></span> <span data-ttu-id="ab06e-113"><xref:System.Threading.LockRecursionException> 잠금 재귀 정책을 관계 없이 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-113"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
 [!code-csharp[System.Threading.LockRecursionPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/example1.cs#1)]
 [!code-vb[System.Threading.LockRecursionPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="NoRecursion">
      <MemberSignature Language="C#" Value="NoRecursion" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.LockRecursionPolicy NoRecursion = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.LockRecursionPolicy.NoRecursion" />
      <MemberSignature Language="VB.NET" Value="NoRecursion" />
      <MemberSignature Language="C++ CLI" Value="NoRecursion" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary><span data-ttu-id="ab06e-114">스레드에서 잠금을 재귀적으로 시작하려고 하면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-114">If a thread tries to enter a lock recursively, an exception is thrown.</span></span> <span data-ttu-id="ab06e-115">이 설정을 적용하는 경우 일부 클래스에서 특정 재귀가 허용될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-115">Some classes may allow certain recursions when this setting is in effect.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="SupportsRecursion">
      <MemberSignature Language="C#" Value="SupportsRecursion" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.LockRecursionPolicy SupportsRecursion = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.LockRecursionPolicy.SupportsRecursion" />
      <MemberSignature Language="VB.NET" Value="SupportsRecursion" />
      <MemberSignature Language="C++ CLI" Value="SupportsRecursion" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary><span data-ttu-id="ab06e-116">스레드에서 잠금을 재귀적으로 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-116">A thread can enter a lock recursively.</span></span> <span data-ttu-id="ab06e-117">일부 클래스에서는 이 기능이 제한될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab06e-117">Some classes may restrict this capability.</span></span></summary>
      </Docs>
    </Member>
  </Members>
</Type>