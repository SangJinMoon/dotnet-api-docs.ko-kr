<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="EventWaitHandle.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac504ca1c444cfd772670659b4609b267628b38c728.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04ca1c444cfd772670659b4609b267628b38c728</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Represents a thread synchronization event.</source>
          <target state="translated">스레드 동기화 이벤트를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class allows threads to communicate with each other by signaling.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 클래스를 사용 하면 스레드가 신호를 보내 서로 통신할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Typically, one or more threads block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> until an unblocked thread calls the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method, releasing one or more of the blocked threads.</source>
          <target state="translated">에 하나 이상의 스레드가 차단 되는 일반적으로 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 차단 되지 않은 스레드가 호출 될 때까지 <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> 차단 된 스레드 중 하나 이상을 해제 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>A thread can signal an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> and then block on it, by calling the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">스레드를 표시할 수는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 후에 호출 하 여 차단할는 <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> Visual basic에서) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class provides access to named system synchronization events.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 클래스는 명명 된 시스템 동기화 이벤트에 대 한 액세스를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The behavior of an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> that has been signaled depends on its reset mode.</source>
          <target state="translated">동작은 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 신호를 받은 다시 설정 모드에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>An <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag resets automatically when signaled, after releasing a single waiting thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 사용 하 여 만든는 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> 신호를 대기 중인 단일 스레드를 해제 한 후 플래그도 자동으로 다시 설정 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>An <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag remains signaled until its <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 사용 하 여 만든는 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> 플래그는 그대로 남아 신호를 받은 될 때까지 해당 <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Automatic reset events provide exclusive access to a resource.</source>
          <target state="translated">자동 재설정 이벤트를 리소스에 대 한 단독 액세스를 제공합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</source>
          <target state="translated">대기 중인 스레드가 없을 때 신호를 받은 자동 재설정 이벤트는 스레드가 이 이벤트에서 대기를 시도할 때까지 신호를 받은 것으로 유지됩니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The event releases the thread and immediately resets, blocking subsequent threads.</source>
          <target state="translated">이벤트는 스레드를 해제하고 즉시 다시 설정되어 후속 스레드를 차단합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Manual reset events are like gates.</source>
          <target state="translated">이벤트는 게이트 처럼 수동 다시 설정 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>When the event is not signaled, threads that wait on it will block.</source>
          <target state="translated">이벤트 신호를 받지 대기 중인 스레드가 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">이벤트가 신호를 대기 중인 모든 스레드가 해제 되 고, 이벤트 신호를 받은 상태를 유지 하는 경우 (즉, 이후의 대기 작업을 차단 하지 않는지) 될 때까지 해당 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Manual reset events are useful when one thread must complete an activity before other threads can proceed.</source>
          <target state="translated">수동 다시 설정 이벤트는 하나의 스레드가 다른 스레드에서 진행 되기 전에 작업을 완료 해야 하는 경우에 유용 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects can be used with the <ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 개체에 사용할 수는 <ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> Visual basic에서) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>For more information about thread synchronization mechanisms, see <bpt id="p1">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id="p1">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.</source>
          <target state="translated">스레드 동기화 메커니즘에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id="p1">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> 메서드 오버 로드를 주 스레드에서 차단 된 스레드 신호를 보내고는 스레드가 작업을 완료할 때까지 대기할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses the ENTER key.</source>
          <target state="translated">이 예제에서는 5 개의 스레드를 시작 하 고 있는 경우 차단 될 수 있도록는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 사용 하 여 만든는 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> 플래그를 다음 릴리스에서 사용자가 ENTER 키를 누를 때마다 스레드를 하나씩 있습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">다음 예제에서는 다른 5 개의 스레드를 큐 대기를 사용 하 여 모든 해제는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 사용 하 여 만든는 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>This type is thread safe.</source>
          <target state="translated">이 형식은 스레드로부터 안전합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated">초기 상태를 신호 받음으로 설정하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>를 사용하고 초기 상태를 신호 없음으로 설정하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>를 사용합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">이벤트가 자동으로 다시 설정되는지 또는 수동으로 다시 설정되는지를 결정하는 <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</source>
          <target state="translated">대기 핸들의 초기 상태를 신호 받음으로 설정할지 여부와 대기 핸들을 자동으로 다시 설정할지 수동으로 다시 설정할지 여부를 지정하여 <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">이벤트의 초기 상태를 신호 없음으로 이벤트를 대기 하는 스레드가 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">초기 상태를 신호를 받으면 및 <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> 플래그가 지정 되어 <ph id="ph2">`mode`</ph>, 이벤트를 대기 하는 스레드를 차단 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">초기 상태를 신호를 받으면 및 <ph id="ph1">`mode`</ph> 은 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, 이벤트를 대기 하는 경우 첫 번째 스레드가 즉시 되는 이벤트가 다시 설정, 릴리스되며 후속 스레드가 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> 메서드 오버 로드를 주 스레드에서 차단 된 스레드 신호를 보내고는 스레드가 작업을 완료할 때까지 대기할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses ENTER key.</source>
          <target state="translated">이 예제에서는 5 개의 스레드를 시작 하 고 있는 경우 차단 될 수 있도록는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 사용 하 여 만든는 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> 플래그를 다음 릴리스에서 사용자가 ENTER 키를 누를 때마다 스레드를 하나씩 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">다음 예제에서는 다른 5 개의 스레드를 큐 대기를 사용 하 여 모든 해제는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 사용 하 여 만든는 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated">명명된 이벤트가 이 호출의 결과로 만들어지는 경우 초기 상태를 signaled로 설정하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, nonsignaled로 설정하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">이벤트가 자동으로 다시 설정되는지 또는 수동으로 다시 설정되는지를 결정하는 <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">시스템 차원 동기화 이벤트의 이름입니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</source>
          <target state="translated">이 호출의 결과로 만들어진 대기 핸들의 초기 상태를 신호 받음으로 설정할지 여부, 대기 핸들을 자동으로 다시 설정할지 수동으로 다시 설정할지 여부 및 시스템 동기화 이벤트의 이름을 지정하여 <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If <ph id="ph1">`name`</ph> is <ph id="ph2">`null`</ph> or an empty string, a local <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is created.</source>
          <target state="translated">경우 <ph id="ph1">`name`</ph> 은 <ph id="ph2">`null`</ph> 또는 빈 문자열인 경우 로컬 <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 만들어집니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">경우에 대 한 지정 된 이름과 함께 시스템 이벤트는 <ph id="ph1">`name`</ph> 매개 변수가 이미 있습니다는 <ph id="ph2">`initialState`</ph> 매개 변수가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>When using this constructor for named system events, specify <ph id="ph1">`false`</ph> for <ph id="ph2">`initialState`</ph>.</source>
          <target state="translated">이 생성자를 사용 하 여 명명 된 시스템 이벤트에 대 한을 지정 <ph id="ph1">`false`</ph> 에 대 한 <ph id="ph2">`initialState`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</source>
          <target state="translated">이 생성자는 명명 된 이벤트의 상태에 대 한 가정을 만들 수 없습니다 명명된 된 시스템 이벤트 만들어졌는지 여부를 결정할 수 없으므로 제공 합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>To determine whether a named event was created, use the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor or the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29&gt;</ph> constructor.</source>
          <target state="translated">명명된 된 이벤트 만들어졌는지 여부를 확인 하려면는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> 생성자 또는 <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">이벤트의 초기 상태를 신호 없음으로 이벤트를 대기 하는 스레드가 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">초기 상태를 신호를 받으면 및 <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> 플래그가 지정 되어 <ph id="ph2">`mode`</ph>, 이벤트를 대기 하는 스레드를 차단 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">초기 상태를 신호를 받으면 및 <ph id="ph1">`mode`</ph> 은 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, 이벤트를 대기 하는 경우 첫 번째 스레드가 즉시 되는 이벤트가 다시 설정, 릴리스되며 후속 스레드가 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">명명된 이벤트가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>이 없는 경우</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 이벤트를 만들 수 없는 경우</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated">명명된 이벤트가 이 호출의 결과로 만들어지는 경우 초기 상태를 signaled로 설정하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, nonsignaled로 설정하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">이벤트가 자동으로 다시 설정되는지 또는 수동으로 다시 설정되는지를 결정하는 <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">시스템 차원 동기화 이벤트의 이름입니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local event was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system event was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system event already existed.</source>
          <target state="translated">이 메서드가 반환될 때 로컬 이벤트가 만들어진 경우(즉, <bpt id="p1">&lt;c&gt;</bpt>이름<ept id="p1">&lt;/c&gt;</ept>이 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이거나 빈 문자열인 경우) 또는 지정한 명명된 시스템 이벤트가 만들어진 경우에는 <ph id="ph1">&lt;see langword="true" /&gt;</ph>가 포함되고, 지정한 명명된 시스템 이벤트가 이미 있는 경우에는 <ph id="ph3">&lt;see langword="false" /&gt;</ph>가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</source>
          <target state="translated">이 호출의 결과로 대기 핸들이 초기에 신호를 받는지 여부, 자동으로 재설정되는지 또는 수동으로 재설정되는지, 시스템 동기화 이벤트의 이름, 호출 후에 해당 값이 명명된 시스템 이벤트가 생성되었는지 여부를 나타내는 부울 변수를 지정하여 <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">경우에 대 한 지정 된 이름과 함께 시스템 이벤트는 <ph id="ph1">`name`</ph> 매개 변수가 이미 있습니다는 <ph id="ph2">`initialState`</ph> 매개 변수가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>After calling this constructor, use the value in the variable specified for the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> parameter in Visual Basic)<ph id="ph3">`createdNew`</ph> to determine whether the named system event already existed or was created.</source>
          <target state="translated">이 생성자를 호출한 후에 대 한 지정 된 변수에 값을 사용 하는 <ph id="ph1">`ref`</ph> 매개 변수 (<ph id="ph2">`ByRef`</ph> Visual Basic의)<ph id="ph3">`createdNew`</ph> 여부는 명명 된 시스템 이벤트 이미 존재 했는지 또는 만들어졌는지를 확인 하려면.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">이벤트의 초기 상태를 신호 없음으로 이벤트를 대기 하는 스레드가 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">초기 상태를 신호를 받으면 및 <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> 플래그가 지정 되어 <ph id="ph2">`mode`</ph>, 이벤트를 대기 하는 스레드를 차단 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">초기 상태를 신호를 받으면 및 <ph id="ph1">`mode`</ph> 은 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, 이벤트를 대기 하는 경우 첫 번째 스레드가 즉시 되는 이벤트가 다시 설정, 릴리스되며 후속 스레드가 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">명명된 이벤트가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>이 없는 경우</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 이벤트를 만들 수 없는 경우</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated">명명된 이벤트가 이 호출의 결과로 만들어지는 경우 초기 상태를 signaled로 설정하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, nonsignaled로 설정하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">이벤트가 자동으로 다시 설정되는지 또는 수동으로 다시 설정되는지를 결정하는 <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">시스템 차원 동기화 이벤트의 이름입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local event was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system event was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system event already existed.</source>
          <target state="translated">이 메서드가 반환될 때 로컬 이벤트가 만들어진 경우(즉, <bpt id="p1">&lt;c&gt;</bpt>이름<ept id="p1">&lt;/c&gt;</ept>이 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이거나 빈 문자열인 경우) 또는 지정한 명명된 시스템 이벤트가 만들어진 경우에는 <ph id="ph1">&lt;see langword="true" /&gt;</ph>가 포함되고, 지정한 명명된 시스템 이벤트가 이미 있는 경우에는 <ph id="ph3">&lt;see langword="false" /&gt;</ph>가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system event.</source>
          <target state="translated">명명된 시스템 이벤트에 적용할 액세스 제어 보안을 나타내는 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</source>
          <target state="translated">이 호출의 결과로 대기 핸들이 초기에 신호를 받는지 여부, 자동으로 재설정되는지 또는 수동으로 재설정되는지, 시스템 동기화 이벤트의 이름, 호출 후에 해당 값이 명명된 시스템 이벤트가 생성되었는지 여부를 나타내는 부울 변수, 생성되는 경우 명명된 이벤트에 적용될 액세스 제어 보안을 지정하여 <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</source>
          <target state="translated">이 생성자를 사용 하 여 인해 다른 코드에서 이벤트의 제어권을 만들 때 명명 된 시스템 이벤트에 대 한 액세스 제어 보안을 적용 합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This constructor initializes an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object that represents a system event.</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 시스템 이벤트를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects that represent the same system event.</source>
          <target state="translated">여러 개 만들 수 있습니다 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 같은 시스템 이벤트를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the system event does not exist, it is created with the specified access control security.</source>
          <target state="translated">시스템 이벤트가 없는 경우 지정 된 액세스 제어 보안을 사용 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event exists, the specified access control security is ignored.</source>
          <target state="translated">이벤트가 있는 경우 지정 된 액세스 제어 보안 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object even if <ph id="ph2">`eventSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">새로 만든에 대 한 모든 권한을 호출자에 게 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 경우에도 개체 <ph id="ph2">`eventSecurity`</ph> 거부 없거나 현재 사용자에 게 일부 액세스 권한을 부여에 실패 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object to represent the same named event, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">그러나 현재 사용자가 다른 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 개체를 나타내는 동일한 명명 된 이벤트를 사용 하 여 생성자 또는 <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> 메서드를 Windows 액세스 제어 보안 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">경우에 대 한 지정 된 이름과 함께 시스템 이벤트는 <ph id="ph1">`name`</ph> 매개 변수가 이미 있습니다는 <ph id="ph2">`initialState`</ph> 매개 변수가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After calling this constructor, use the value in the variable specified for the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> parameter in Visual Basic) <ph id="ph3">`createdNew`</ph> to determine whether the named system event already existed or was created.</source>
          <target state="translated">이 생성자를 호출한 후에 대 한 지정 된 변수에 값을 사용 하는 <ph id="ph1">`ref`</ph> 매개 변수 (<ph id="ph2">`ByRef`</ph> Visual Basic의) <ph id="ph3">`createdNew`</ph> 여부는 명명 된 시스템 이벤트 이미 존재 했는지 또는 만들어졌는지를 확인 하려면.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">이벤트의 초기 상태를 신호 없음으로 이벤트를 대기 하는 스레드가 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">초기 상태를 신호를 받으면 및 <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> 플래그가 지정 되어 <ph id="ph2">`mode`</ph>, 이벤트를 대기 하는 스레드를 차단 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">초기 상태를 신호를 받으면 및 <ph id="ph1">`mode`</ph> 은 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, 이벤트를 대기 하는 경우 첫 번째 스레드가 즉시 되는 이벤트가 다시 설정, 릴리스되며 후속 스레드가 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 된 명명 된 시스템 이벤트의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 이벤트의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">이벤트가 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 이벤트를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 변경 이벤트에 대 한 권한을 부여 하는 액세스 제어 보안 만들어집니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한으로는 이벤트를 대기 합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">권한이 변경 된 후 이벤트 신호를 대기 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우이 예제에서는 새 권한을 사용 하 여 실행 합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">명명된 이벤트가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>이 없는 경우</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 이벤트를 만들 수 없는 경우</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security for the named system event represented by the current <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> 개체로 표시되는 명명된 시스템 이벤트에 대한 액세스 제어 보안을 나타내는 <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security for the named system event.</source>
          <target state="translated">명명된 시스템 이벤트에 대한 액세스 제어 보안을 나타내는 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> 메서드 플래그 (비트 OR 연산을 사용 하 여 결합)는 다음과 같은 조합을 사용 하 여 사용 권한을 검색할: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, 및 <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the event must have been opened with the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">사용자에 게 있어야 <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> 이 메서드를 호출 하는 이벤트에 대 한 권한을 사용 하 여 열려 있어야는 <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 된 명명 된 시스템 이벤트의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 이벤트의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">이벤트가 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 이벤트를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 변경 이벤트에 대 한 권한을 부여 하는 액세스 제어 보안 만들어집니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한으로는 이벤트를 대기 합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>After the permissions have been read, using the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> method, and changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">사용 하 여 사용 권한을 읽은 후의 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> 메서드를 변경 하 고, 이벤트 신호를 대기 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우이 예제에서는 새 권한을 사용 하 여 실행 합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object represents a named system event, and the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> 개체가 명명된 시스템 이벤트를 나타내지만 사용자에게 <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>가 없는 경우</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object represents a named system event, and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> 개체가 명명된 시스템 이벤트를 나타내지만 <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>로 열리지 않는 경우</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Windows 98 또는 Windows Millennium Edition에서 지원되지 않는 경우</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> 메서드가 이 <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>에 대해 이전에 호출된 경우</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Opens a specified named synchronization event, if it already exists.</source>
          <target state="translated">이미 있는 경우 지정한 명명된 동기화 이벤트를 엽니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">열려는 시스템 동기화 이벤트의 이름입니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Opens the specified named synchronization event, if it already exists.</source>
          <target state="translated">이미 있는 경우 지정한 명명된 동기화 이벤트를 엽니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>An  object that represents the named system event.</source>
          <target state="translated">명명된 시스템 이벤트를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open the specified named system event.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> 메서드는 지정 된 명명 된 시스템 이벤트를 열려고 시도 합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If the system event does not exist, this method throws an exception instead of creating the system event.</source>
          <target state="translated">시스템 이벤트가 없는 경우이 메서드는 시스템 이벤트를 만들지 않고 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않으면 시스템 이벤트를 만들려면 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 <ph id="ph1">`name`</ph> 동일한 반드시 반환 하지 않는 <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 반환 되는 개체는 같은 명명 된 시스템 이벤트를 나타낼 경우에 개체입니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">이 메서드 오버 로드 하는 것은 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> 메서드 오버 로드를 지정 하 고 <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">지정 하는 <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> 플래그 명명 된 시스템 이벤트를 대기 하는 스레드를 사용 하 고 지정 하는 <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> 플래그를 호출 하는 스레드를 사용할 수 있습니다는 <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> 및 <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 된 명명 된 시스템 이벤트의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 이벤트의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">이벤트가 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 이벤트를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 변경 이벤트에 대 한 권한을 부여 하는 액세스 제어 보안 만들어집니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한으로는 이벤트를 대기 합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">권한이 변경 된 후 이벤트 신호를 대기 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우이 예제에서는 새 권한을 사용 하 여 실행 합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The named system event does not exist.</source>
          <target state="translated">명명된 시스템 이벤트가 없는 경우</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The named event exists, but the user does not have the security access required to use it.</source>
          <target state="translated">명명된 이벤트가 있지만 사용자에게 이 이벤트를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">열려는 시스템 동기화 이벤트의 이름입니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Opens the specified named synchronization event, if it already exists, with the desired security access.</source>
          <target state="translated">이미 있는 경우 지정한 명명된 동기화 이벤트를 원하는 보안 액세스로 엽니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>An object that represents the named system event.</source>
          <target state="translated">명명된 시스템 이벤트를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the event, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> 매개 변수를 포함 해야 합니다는 <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> 이벤트를 대기 하는 스레드를 허용 하도록 플래그 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> 호출 하는 스레드를 허용 하도록 플래그는 <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open an existing named system event.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> 메서드 기존 명명 된 시스템 이벤트를 열려고 시도 합니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If the system event does not exist, this method throws an exception instead of creating the system event.</source>
          <target state="translated">시스템 이벤트가 없는 경우이 메서드는 시스템 이벤트를 만들지 않고 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않으면 시스템 이벤트를 만들려면 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 <ph id="ph1">`name`</ph> 동일한 반드시 반환 하지 않는 <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 반환 되는 개체는 같은 명명 된 시스템 이벤트를 나타낼 경우에 개체입니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 된 명명 된 시스템 이벤트의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 이벤트의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">이벤트가 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 이벤트를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 변경 이벤트에 대 한 권한을 부여 하는 액세스 제어 보안 만들어집니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한으로는 이벤트를 대기 합니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">권한이 변경 된 후 이벤트 신호를 대기 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우이 예제에서는 새 권한을 사용 하 여 실행 합니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The named system event does not exist.</source>
          <target state="translated">명명된 시스템 이벤트가 없는 경우</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">명명된 이벤트가 존재하지만 사용자에게 필요한 보안 액세스 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source>Sets the state of the event to nonsignaled, causing threads to block.</source>
          <target state="translated">이벤트 상태를 신호 없음으로 설정하여 스레드가 차단되도록 합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업이 성공적으로 수행되면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> 메서드가 이 <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>에 대해 이전에 호출된 경우</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source>Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</source>
          <target state="translated">하나 이상의 대기 중인 스레드를 진행할 수 있도록 이벤트 상태를 신호 받음으로 설정합니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업이 성공적으로 수행되면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>For an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> (including <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>), the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method releases a single thread.</source>
          <target state="translated">에 대 한 프로그램 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> (포함 하 여 <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>), <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> 메서드는 단일 스레드를 해제 합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">대기 스레드가 없는 경우, 또는 될 때까지 대기 하는 스레드를 시도할 때까지 대기 핸들 신호를 받은 되지 해당 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>There is no guarantee that every call to the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method will release a thread from an <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> whose reset mode is <ph id="ph3">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">보장 되지 않습니다는를 호출할 때마다는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> 메서드에서 스레드를 해제 합니다는 <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 인 재설정 모드는 <ph id="ph3">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</source>
          <target state="translated">두 개를 호출 하는 스레드가 해제 되기 전에 두 번째 호출이 발생 너무 가까이 함께 인 하나의 스레드가 해제 됩니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>It is as if the second call did not happen.</source>
          <target state="translated">두 번째 호출에서는 발생 하지 않았으며 처럼 이며</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>Also, if <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> is called when there are no threads waiting and the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is already signaled, the call has no effect.</source>
          <target state="translated">또한 경우 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> 대기 하는 스레드가 없을 때 호출 되 고 <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 이미 신호는 호출에 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>For an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> (including <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>), calling the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method leaves the wait handle in a signaled state until its <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">에 대 한는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> (포함 하 여 <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>) 호출는 <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> 메서드 유지 될 때까지 신호를 받은 상태로 대기 핸들의 <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> 메서드 오버 로드를 주 스레드에서 차단 된 스레드 신호를 보내고는 스레드가 작업을 완료할 때까지 대기할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses the ENTER key.</source>
          <target state="translated">이 예제에서는 5 개의 스레드를 시작 하 고 있는 경우 차단 될 수 있도록는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 사용 하 여 만든는 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> 플래그를 다음 릴리스에서 사용자가 ENTER 키를 누를 때마다 스레드를 하나씩 있습니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">다음 예제에서는 다른 5 개의 스레드를 큐 대기를 사용 하 여 모든 해제는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 사용 하 여 만든는 <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> 메서드가 이 <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>에 대해 이전에 호출된 경우</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system event.</source>
          <target state="translated">명명된 시스템 이벤트에 적용할 액세스 제어 보안을 나타내는 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Sets the access control security for a named system event.</source>
          <target state="translated">명명된 시스템 이벤트에 대해 액세스 제어 보안을 설정합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the event must have been opened with the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">사용자에 게 있어야 <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> 이 메서드를 호출 하는 이벤트에 대 한 권한을 사용 하 여 열려 있어야는 <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 된 명명 된 시스템 이벤트의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 이벤트의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">이벤트가 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 이벤트를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 변경 이벤트에 대 한 권한을 부여 하는 액세스 제어 보안 만들어집니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한으로는 이벤트를 대기 합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After the permissions are changed, using the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.SetAccessControl%2A&gt;</ph> method, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">사용 권한을 사용 하 여 변경 된 후의 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.SetAccessControl%2A&gt;</ph> 메서드를 이벤트 대기 및 신호를 보내는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우이 예제에서는 새 권한을 사용 하 여 실행 합니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;paramref name="eventSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="eventSecurity" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>가 없는 경우</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The event was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">이벤트가 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>로 열리지 않은 경우</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object does not represent a named system event.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> 개체가 명명된 시스템 이벤트를 나타내지 않는 경우</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> 메서드가 이 <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>에 대해 이전에 호출된 경우</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">지정된 명명된 synchronization 이벤트(이미 존재하는 경우)를 열고 작업이 성공적으로 수행되었는지를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">열려는 시스템 동기화 이벤트의 이름입니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">이 메서드가 반환될 때 호출에 성공한 경우에는 명명된 동기화 이벤트를 나타내는 <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> 개체를 포함하고 호출에 실패한 경우에는 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을 포함합니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">지정한 명명된 동기화 이벤트(이미 존재하는 경우)를 열고 작업이 성공했는지를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named synchronization event was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">명명된 동기화 이벤트를 열었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 열지 않았으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>If the named synchronization event does not exist, this method does not create it.</source>
          <target state="translated">명명 된 동기화 이벤트가 없는 경우이 메서드가 만드는 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않으면 시스템 이벤트를 만들려면 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.</source>
          <target state="translated">대신이 메서드 오버 로드를 사용 하 여 명명 된 동기화 이벤트 있는지 잘 모르는 경우는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> 동기화 이벤트 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">이 메서드 오버 로드 하는 것은 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29&gt;</ph> 메서드 오버 로드를 지정 하 고 <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">지정 하는 <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> 플래그 명명 된 시스템 이벤트를 대기 하는 스레드를 사용 하 고 지정 하는 <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> 플래그를 호출 하는 스레드를 사용할 수 있습니다는 <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> 및 <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 <ph id="ph1">`name`</ph> 동일한 반드시 반환 하지 않는 <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 반환 되는 개체는 같은 명명 된 시스템 이벤트를 나타낼 경우에 개체입니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">명명된 이벤트가 존재하지만 사용자에게 필요한 보안 액세스 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">열려는 시스템 동기화 이벤트의 이름입니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">이 메서드가 반환될 때 호출에 성공한 경우에는 명명된 동기화 이벤트를 나타내는 <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> 개체를 포함하고 호출에 실패한 경우에는 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을 포함합니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">지정한 명명된 동기화 이벤트(이미 존재하는 경우)를 원하는 보안 액세스로 열고 작업이 성공적으로 수행되었는지 여부를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named synchronization event was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">명명된 동기화 이벤트를 열었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 열지 않았으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>If the named synchronization event does not exist, this method does not create it.</source>
          <target state="translated">명명 된 동기화 이벤트가 없는 경우이 메서드가 만드는 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않으면 시스템 이벤트를 만들려면 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.</source>
          <target state="translated">대신이 메서드 오버 로드를 사용 하 여 명명 된 동기화 이벤트 있는지 잘 모르는 경우는 <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> 동기화 이벤트 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the event, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> 매개 변수를 포함 해야 합니다는 <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> 이벤트를 대기 하는 스레드를 허용 하도록 플래그 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> 호출 하는 스레드를 허용 하도록 플래그는 <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 <ph id="ph1">`name`</ph> 동일한 반드시 반환 하지 않는 <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> 반환 되는 개체는 같은 명명 된 시스템 이벤트를 나타낼 경우에 개체입니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">명명된 이벤트가 존재하지만 사용자에게 필요한 보안 액세스 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>