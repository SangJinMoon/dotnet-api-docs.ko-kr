<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="70286-101">여러 스레드에서 읽을 수 있도록 허용하거나 쓰기를 위한 단독 액세스를 허용하여 리소스에 대한 액세스를 관리하는 데 사용되는 잠금을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="70286-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-102">사용 하 여 <xref:System.Threading.ReaderWriterLockSlim> 여러 스레드에서 읽을 이며 한 번에 한 스레드에서 기록 하는 리소스를 보호 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="70286-103"><xref:System.Threading.ReaderWriterLockSlim> 여러 스레드에서 읽기 모드에 있을 수 있습니다, 그리고 하나의 스레드 잠금을 단독 소유권을 갖는 쓰기 모드에 있을 수 있습니다 및 것을 포기 하지 않고 쓰기 모드를 업그레이드할 수 있는 스레드가 업그레이드 가능한 읽기 모드에 대 한 읽기 권한이 있는 하나의 스레드를 허용 합니다. 리소스에 대 한 s 읽기 권한입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-104"><xref:System.Threading.ReaderWriterLockSlim>은 <xref:System.Threading.ReaderWriterLock>과 비슷하지만 재귀 및 잠금 상태 업그레이드/다운그레이드에 대한 간소화된 규칙을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="70286-105"><xref:System.Threading.ReaderWriterLockSlim>은 교착 상태가 발생할 수 있는 많은 경우를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="70286-106">또한 <xref:System.Threading.ReaderWriterLockSlim>의 성능이 <xref:System.Threading.ReaderWriterLock>보다 훨씬 더 놓습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="70286-107"><xref:System.Threading.ReaderWriterLockSlim>은 모든 새 개발에 권장됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="70286-108">기본적으로 새 인스턴스의 <xref:System.Threading.ReaderWriterLockSlim> 사용 하 여 만든는 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> 플래그를 재귀를 허용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="70286-109">이 기본 정책은 재귀 불필요 한 복잡성을 소개 하 고 하면 코드를 교착 상태를 발생 시키기 때문에 새로운 개발에 권장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="70286-110">기존 계획에서 마이그레이션을 간소화 하기 위해 사용 하는 프로젝트 <xref:System.Threading.Monitor> 또는 <xref:System.Threading.ReaderWriterLock>를 사용할 수 있습니다는 <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> 플래그의 인스턴스를 만들 <xref:System.Threading.ReaderWriterLockSlim> 재귀를 허용 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="70286-111">스레드 잠금을 세 가지 모드에서 시작할 수: 모드, 쓰기 모드 및 업그레이드 가능한 읽기 모드 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="70286-112">(이 항목의 나머지 부분에서는 "업그레이드 가능한 읽기 모드" 라고 "업그레이드 가능 모드"로 "입력 `x` 모드" 긴 구문을 대신 사용 "에서 잠금을 입력 `x` 모드"입니다.)</span><span class="sxs-lookup"><span data-stu-id="70286-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="70286-113">재귀 정책에 관계 없이 하나의 스레드만 언제 든 지 쓰기 모드에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="70286-114">스레드 쓰기 모드일 때 다른 스레드에서 모든 모드로 잠금을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="70286-115">하나의 스레드만 언제 든 지 업그레이드 가능 모드에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="70286-116">스레드 개수에 관계 없이 읽기 모드로 수 있으며 있을 수 있습니다 스레드를 하나씩 업그레이드 가능 모드에서 다른 스레드에서 읽기 모드에 있는 동안 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="70286-117">이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="70286-118">형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="70286-119">직접 형식의 dispose를 호출 해당 <xref:System.IDisposable.Dispose%2A> 에서 메서드는 `try` / `catch` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="70286-120">작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="70286-121">자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <xref:System.IDisposable> 인터페이스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="70286-122"><xref:System.Threading.ReaderWriterLockSlim> 에서는 관리 스레드 선호도 있습니다. 즉, 각 <xref:System.Threading.Thread> 개체를 입력 하 고 스레드는 자체 메서드 호출을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="70286-123">스레드가 다른 스레드의 모드를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="70286-124">경우는 <xref:System.Threading.ReaderWriterLockSlim> 재귀에서는 여러 가지 이유로 잠금을 시작 하려고 시도 차단할 수 있는 스레드를 허용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="70286-125">쓰기 모드 또는 쓰기 모드에서 단일 스레드가 없는 경우 시작 하려고 대기 하는 스레드가 블록 읽기 모드를 시작 하려고 하는 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="70286-126">새 판독기를 차단 하 여 대기 중인 경우 기록기를 우선 하는 잠금 공정성 정책을입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="70286-127">현재의 관리 정책 공정성 판독기 및 작성기, 가장 일반적인 시나리오에서 처리량을 높일 수를 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="70286-128">이후 버전에서 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 새로운 관리 정책이 도입 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="70286-129">쓰기 모드에서 단일 스레드가 없는 경우 또는 이미 있는 경우 스레드에서 업그레이드 가능 모드에서 쓰기 모드를 시작 하려고 대기 하는 스레드가 업그레이드 가능 모드가 시작 블록을 시작 하려고 하는 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="70286-130">세 가지 모드 중 하나에 스레드가 없는 경우 쓰기 모드 블록을 시작 하려고 하는 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="70286-131">업그레이드 및 다운 그레이드 잠금</span><span class="sxs-lookup"><span data-stu-id="70286-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="70286-132">업그레이드 가능 모드는 스레드가 일반적으로 보호 된 리소스에서 읽는 경우를 위한 일부 조건이 충족 될 때 쓰기를 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="70286-133">가 입력 하는 스레드는 <xref:System.Threading.ReaderWriterLockSlim> 업그레이드 가능 모드에서 보호 된 리소스에 대 한 읽기 액세스를 포함 하 고 호출 하 여 쓰기 모드를 업그레이드할 수는 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> 또는 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="70286-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="70286-134">수 있기 때문에 한 스레드만 업그레이드 가능 모드에서 한 번에, 쓰기 모드로 업그레이드 교착 상태가 발생 하지 하는 기본 정책이 재귀가 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="70286-135">재귀 정책에 관계 없이 처음 시작한 스레드는 해당 패턴에 교착 상태가 발생할 가능성이 매우 만들기 때문에 업그레이드 가능 모드 또는 쓰기 모드를로 업그레이드 하 모드가 허용 되지 않습니다 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="70286-136">예를 들어 입력 하려고 시도 하 여 읽기 모드로 스레드가 각각 두 모드를 작성 하는 경우은 교착 상태가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="70286-137">업그레이드 가능 모드는 이러한 교착 상태를 방지 하기 위해 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="70286-138">있는 경우 다른 스레드에서 블록을 업그레이드 하는 스레드에서 읽기 모드로 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="70286-139">스레드가 차단 되는 동안 읽기 모드를 시작 하려고 하는 다른 스레드는 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="70286-140">모든 스레드가, 읽기 모드를 종료 하는 경우 업그레이드는 차단 된 스레드가 쓰기 모드가 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="70286-141">있는 경우 시작 하려고 대기 하는 다른 스레드에서 쓰기 모드를 업그레이드 가능 모드에 있는 단일 스레드는 리소스에 배타적으로 액세스 하지 못하도록 방지 계속 차단 되며, 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="70286-142">업그레이드 가능 모드에 있는 스레드에서 쓰기 모드 종료 되 면 읽기 모드를 시작 하려고 대기 중인 다른 스레드가 수 중장 년 쓰기 모드를 시작 하려고 대기 하는 스레드는 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="70286-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="70286-143">업그레이드 가능 모드에 있는 스레드를 업그레이드 한 것이 보호 된 리소스에 작성 하는 유일한 스레드도 무기한으로 다운 그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="70286-144">입력에 여러 스레드를 허용 하는 경우 쓰기 모드 또는 업그레이드 가능 모드 업그레이드 가능 모드를 독점 하는 하나의 스레드를 허용 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="70286-145">그렇지 않은 경우 시작 하려고 하는 스레드 작성 모드 직접 차단 됩니다 무기한으로 차단 하는 동안 다른 스레드가 없게 됩니다 읽기 모드를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="70286-146">업그레이드 가능 모드에서 스레드를 먼저 호출 하 여 읽기 모드로 다운 그레이드할 수는 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 메서드와 다음 호출에서 <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="70286-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="70286-147">이 다운 그레이드 패턴에 대 한 모든 잠금 재귀 정책을 허용 <xref:System.Threading.LockRecursionPolicy.NoRecursion>합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="70286-148">읽기 모드로 다운 그레이드 한 후 스레드를 다시 시작 업그레이드 가능 모드가 읽기 모드를 종료 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="70286-149">재귀적 잠금</span><span class="sxs-lookup"><span data-stu-id="70286-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="70286-150">만들 수 있습니다는 <xref:System.Threading.ReaderWriterLockSlim> 를 사용 하 여 재귀 잠금 입력을 지원 하 고 <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> 잠금 정책을 지정 하 고 지정 하는 생성자 <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-151">재귀를 사용 하 여 불필요 한 복잡성을 소개 하 고 하면 코드를 교착 상태를 발생 시키기 때문에 새로운 개발에 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="70286-152">에 대 한는 <xref:System.Threading.ReaderWriterLockSlim> 재귀를 허용 하는 스레드를 입력할 수 모드에 대 한 다음 한다고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="70286-153">읽기 모드에 있는 스레드에서 읽기 모드를 재귀적으로 시작할 수 있지만 쓰기 모드 또는 업그레이드 가능 모드를 입력할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="70286-154">이 작업을 수행 하려는 경우는 <xref:System.Threading.LockRecursionException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="70286-155">입력 읽기 모드 및 다음 입력 쓰기 모드 또는 업그레이드 가능 모드는 교착 상태 가능성이 매우 패턴 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="70286-156">앞에서 설명한 대로 업그레이드 가능 모드 잠금을 업그레이드 하는 데 필요한 한 경우에 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="70286-157">업그레이드 가능 모드로 스레드에서 쓰기 모드 및/또는 읽기 모드를 입력할 수 있고, 하나는 세 가지 모드 재귀적으로 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="70286-158">그러나 시작 하려는 경우 다른 스레드에서 읽기 모드에 있는 경우 쓰기 모드 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="70286-159">쓰기 모드로 스레드에서 읽기 모드 및/또는 업그레이드 가능 모드를 입력할 수 있고, 하나는 세 가지 모드 재귀적으로 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="70286-160">잠금을 시작 하는 스레드는 모든 모드를 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="70286-161">이 시도이 대해서는 비재귀적 잠금을 잠그려고 시도와 같은 이유로 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="70286-162">스레드 수 모드가 해당 횟수 만큼 정확 하 게 각 모드으로 어떤 순서로 든 않았으면 모드를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="70286-163">스레드가 너무 여러 번 종료 또는 시작 하지 않았으면 모드를 종료 하는 <xref:System.Threading.SynchronizationLockException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="70286-164">잠금 상태</span><span class="sxs-lookup"><span data-stu-id="70286-164">Lock States</span></span>  
 <span data-ttu-id="70286-165">상태 측면에서 잠금을 생각 하는 것이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="70286-166">A <xref:System.Threading.ReaderWriterLockSlim> 네 가지 상태 중 하나가 될 수 있습니다: 업그레이드를 입력 하지, 읽기 및 쓰기입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="70286-167">입력 하지:이 상태에서는 스레드가 잠금을 시작한 (또는 모든 스레드가 잠금을 종료).</span><span class="sxs-lookup"><span data-stu-id="70286-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="70286-168">읽기:이 상태에 있는 하나 이상의 스레드가 잠금을 시작한 읽기 액세스를 위해 보호 된 리소스에 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="70286-169">스레드를 사용 하 여 읽기 모드로 잠금을 입력할 수는 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 또는 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 메서드, 또는 업그레이드 가능 모드에서 다운 그레이드 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="70286-170">업그레이드:이 상태에서는 하나의 스레드에서 잠금을 쓰기 액세스로 업그레이드 하는 옵션으로 읽기 액세스를 위해 (즉, 업그레이드 가능 모드), 0 개 이상의 스레드가 읽기 액세스를 위해 잠금의 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="70286-171">한 번에 둘 이상의 스레드가; 업그레이드 하는 옵션을 사용 하 여 잠금을 입력할 수 있습니다. 업그레이드 가능 모드를 시작 하려고 하는 추가 스레드가 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="70286-172">쓰기:이 상태에서는 하나의 스레드 잠금을 시작한 쓰기 액세스를 위해 보호 된 리소스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="70286-173">스레드에 단독으로 잠금 소유 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="70286-174">어떤 이유로 든 잠금을 시작 하려고 하는 다른 스레드가 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="70286-175">다음 표에 재귀 때 스레드를 허용 하지 않는 잠금에 대 한 잠금 상태 전환을 `t` 맨 왼쪽 열에 설명 된 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="70286-176">작업, 당시 걸리는 `t` 모드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="70286-177">(특별 한 경우 여기서 `t` 에 업그레이드 가능 모드가 시작 표의 각주에 설명 되어 있습니다.) 맨 위 행 잠금의 시작 상태를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="70286-178">셀의 스레드로 수행 되는 작업에 대해 설명 하 고 잠금 상태에 대 한 변경 괄호 안에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="70286-179">입력 없습니다 (N)</span><span class="sxs-lookup"><span data-stu-id="70286-179">Not entered (N)</span></span>|<span data-ttu-id="70286-180">Read (R)</span><span class="sxs-lookup"><span data-stu-id="70286-180">Read (R)</span></span>|<span data-ttu-id="70286-181">업그레이드 (U)</span><span class="sxs-lookup"><span data-stu-id="70286-181">Upgrade (U)</span></span>|<span data-ttu-id="70286-182">쓰기 (W)</span><span class="sxs-lookup"><span data-stu-id="70286-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="70286-183">`t` 읽기 모드를 시작</span><span class="sxs-lookup"><span data-stu-id="70286-183">`t` enters read mode</span></span>|<span data-ttu-id="70286-184">`t` (R)를 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-184">`t` enters (R).</span></span>|<span data-ttu-id="70286-185">`t` 블록 스레드에서 쓰기 모드에 대 한 대기 중인 경우 그렇지 않으면 `t` 를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="70286-186">`t` 블록 스레드에서 쓰기 모드에 대 한 대기 중인 경우 그렇지 않으면 `t` 입력.<sup> 1</sup></span><span class="sxs-lookup"><span data-stu-id="70286-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="70286-187">`t` 블록 수입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-187">`t` blocks.</span></span>|  
|<span data-ttu-id="70286-188">`t` 업그레이드 가능 모드가 시작</span><span class="sxs-lookup"><span data-stu-id="70286-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="70286-189">`t` (U)을 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-189">`t` enters (U).</span></span>|<span data-ttu-id="70286-190">`t` 스레드가 대기 하는 경우 블록 쓰기 모드 또는 업그레이드 모드 그렇지 않으면 `t` (U)을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="70286-191">`t` 블록 수입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-191">`t` blocks.</span></span>|<span data-ttu-id="70286-192">`t` 블록 수입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-192">`t` blocks.</span></span>|  
|<span data-ttu-id="70286-193">`t` 쓰기 모드로 전환</span><span class="sxs-lookup"><span data-stu-id="70286-193">`t` enters write mode</span></span>|<span data-ttu-id="70286-194">`t` 입력 (W).</span><span class="sxs-lookup"><span data-stu-id="70286-194">`t` enters (W).</span></span>|<span data-ttu-id="70286-195">`t` 블록 수입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-195">`t` blocks.</span></span>|<span data-ttu-id="70286-196">`t` 블록 수입니다. <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="70286-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="70286-197">`t` 블록 수입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="70286-198"><sup>1</sup> 경우 `t` 시작으로 업그레이드 가능 모드로 읽기 모드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="70286-199">이 작업을 하지 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-199">This action never blocks.</span></span> <span data-ttu-id="70286-200">잠금 상태는 변경 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-200">The lock state does not change.</span></span> <span data-ttu-id="70286-201">(스레드에서 업그레이드 가능 모드를 종료 하 여 읽기 모드로 다운 그레이드를 완료할 수 있습니다.)</span><span class="sxs-lookup"><span data-stu-id="70286-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="70286-202"><sup>2</sup> 경우 `t` 읽기 모드에서 스레드가 있으면 차단할 업그레이드 가능 모드에서 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="70286-203">그렇지 않은 경우 쓰기 모드를 업그레이드 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="70286-204">잠금 상태 변경에 쓰기 (W).</span><span class="sxs-lookup"><span data-stu-id="70286-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="70286-205">경우 `t` 읽기 모드로 중인 스레드가 있으므로 차단 마지막 스레드에서 읽기 모드를 종료 하는 즉시 쓰기 모드가 시작, 경우에 대기 중인 스레드가 쓰기 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="70286-206">상태 변경이 발생 한 스레드에서 잠금을 종료 때문에 설정을 선택 해제 하는 다음 스레드에서 다음과 같이 선택 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="70286-207">첫째, 대기 하는 스레드는 쓰기 모드 고 이미 업그레이드 가능 모드 (있을 수 있습니다 최대 이러한 스레드를 하나씩)입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="70286-208">쓰기 모드에 대 한 대기 중인 스레드가 활성화 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="70286-209">업그레이드 가능 모드에 대 한 대기 중인 스레드가 활성화 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="70286-210">읽기 모드에 대 한 대기 중인 모든 스레드는 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="70286-211">후속 잠금 상태가 항상 쓰기 (W) 첫 번째에서 두 가지 경우 업그레이드 (U) 잠금 종료 하는 스레드가 상태 변경이 트리거되면 상태에 관계 없이, 세 번째 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="70286-212">마지막 경우에서 잠금 상태가 업그레이드 (U) 있는 경우 스레드에서 업그레이드 가능 모드로 후 상태 변경 및 Read (R) 그렇지 않은 경우 이전 상태에 관계 없이입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-213">다음 예제에서는 정수 키가 있는 문자열을 포함 하는 간단한 동기화 된 캐시를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="70286-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="70286-214">인스턴스 <xref:System.Threading.ReaderWriterLockSlim> 에 대 한 액세스를 동기화 하는 데 사용 되는 <xref:System.Collections.Generic.Dictionary%602> 역할을 내부 캐시 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="70286-215">이 예제에서는, 캐시에 추가 하 고, 캐시에서 삭제 하 고, 캐시에서 읽어 하는 간단한 방법을 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="70286-216">제한 시간을 보여 주기 위해는 예제는 지정된 된 제한 시간 내에서 그렇게 할 수 있는 경우에 캐시에 추가 하는 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="70286-217">업그레이드 가능 모드를 시연 하기 예제에서는 키와 연결 된 값을 검색 하는 메서드를 포함 하 고 새 값으로 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="70286-218">값이 변경 되지 않았으면, 메서드가 변경 되지 않았음을 나타내는 상태를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="70286-219">키에 대 한 값이 없는 찾으면, 키/값 쌍이 삽입 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-219">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="70286-220">값이 변경 하는 경우 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="70286-221">업그레이드 가능 모드에는 교착 상태가 발생할 위험 없이 필요에 따라 쓰기 액세스에 대 한 읽기에서에서 업그레이드 하는 스레드 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="70286-222">이 예제에서는 업그레이드 가능 모드를 보여 주는 메서드에 대 한 반환 값을 지정 하는 중첩된 된 열거형에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="70286-223">이 예제에서는 기본 생성자를 사용 하 여 만드는 잠금, 재귀 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-223">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="70286-224">프로그래밍의 <xref:System.Threading.ReaderWriterLockSlim> 잠금을 재귀를 허용 하지 않을 경우 더 간단 하 고 오류가 발생할 가능성이 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="70286-225">다음 코드에서는 다음의 `SynchronizedCache` 채소 이름 사전을 저장할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="70286-226">세 가지 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="70286-226">It creates three tasks.</span></span> <span data-ttu-id="70286-227">첫 번째 야채를 배열에 저장 된 이름을 씁니다는 `SynchronizedCache` 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="70286-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="70286-228">두 번째 및 세 번째 작업에는 오름차순으로 정렬 순서 (낮은 인덱스 로부터 높은 인덱스로) 내림차순 두 번째 첫 번째 야채의 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="70286-229">마지막 작업 "cucumber" 문자열을 검색 하 고, 발견 한 경우 호출 하는 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> 메서드를 "녹색 bean" 문자열을 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="70286-230">이 형식은 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-230">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="70286-231"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70286-232">기본 속성 값으로 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-233">A <xref:System.Threading.ReaderWriterLockSlim> 이 사용 하 여 초기화 생성자 재귀를 허용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="70286-234">즉, <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> 속성이 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="70286-235">재귀 정책 및 이러한 액세스가 영향에 대 한 자세한 내용은 참조는 <xref:System.Threading.LockRecursionPolicy> 열거형 및 <xref:System.Threading.ReaderWriterLockSlim> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-236">다음 예제에서는 정수 키가 있는 문자열을 포함 하는 간단한 동기화 된 캐시를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="70286-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="70286-237">인스턴스 <xref:System.Threading.ReaderWriterLockSlim> 에 대 한 액세스를 동기화 하는 데 사용 되는 <xref:System.Collections.Generic.Dictionary%602> 역할을 내부 캐시 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="70286-238">매개 변수가 없는 생성자를 만들려면 잠금을 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="70286-239">이 예제에서는, 캐시에 추가 하 고, 캐시에서 삭제 하 고, 캐시에서 읽어 하는 간단한 방법을 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="70286-240">제한 시간을 보여 주기 위해는 예제는 지정된 된 제한 시간 내에서 그렇게 할 수 있는 경우에 캐시에 추가 하는 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="70286-241">업그레이드 가능 모드를 시연 하기 예제에서는 키와 연결 된 값을 검색 하는 메서드를 포함 하 고 새 값으로 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="70286-242">값이 변경 되지 않았으면, 메서드가 변경 되지 않았음을 나타내는 상태를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="70286-243">키에 대 한 값이 없는 찾으면, 키/값 쌍이 삽입 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-243">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="70286-244">값이 변경 하는 경우 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="70286-245">업그레이드 가능 모드에는 교착 상태가 발생할 위험 없이 필요에 따라 쓰기 액세스에 대 한 읽기에서에서 업그레이드 하는 스레드 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="70286-246">이 예제에서는 업그레이드 가능 모드를 보여 주는 메서드에 대 한 반환 값을 지정 하는 중첩된 된 열거형에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="70286-247">이 예제에서는 기본 생성자를 사용 하 여 만드는 잠금, 재귀 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-247">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="70286-248">프로그래밍의 <xref:System.Threading.ReaderWriterLockSlim> 잠금을 재귀를 허용 하지 않을 경우 더 간단 하 고 오류가 발생할 가능성이 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="70286-249">다음 코드에서는 다음의 `SynchronizedCache` 채소 이름 사전을 저장할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="70286-250">세 가지 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="70286-250">It creates three tasks.</span></span> <span data-ttu-id="70286-251">첫 번째 야채를 배열에 저장 된 이름을 씁니다는 `SynchronizedCache` 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="70286-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="70286-252">두 번째 및 세 번째 작업에는 오름차순으로 정렬 순서 (낮은 인덱스 로부터 높은 인덱스로) 내림차순 두 번째 첫 번째 야채의 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="70286-253">마지막 작업 "cucumber" 문자열을 검색 하 고, 발견 한 경우 호출 하는 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> 메서드를 "녹색 bean" 문자열을 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy"><span data-ttu-id="70286-254">잠금 재귀 정책을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-254">One of the enumeration values that specifies the lock recursion policy.</span></span></param>
        <summary><span data-ttu-id="70286-255">잠금 재귀 정책을 지정하여 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-256">재귀 정책은 스레드에서 잠금을 여러 번 입력 하는 제한 사항을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="70286-257">예를 들어, 잠금을 사용 하 여 만든 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> 는 스레드에서 읽기 모드로 잠금을 시작 및 <xref:System.Threading.LockRecursionException> 스레드가 다시 읽기 모드로 잠금을 시작 하려고 하면 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="70286-258">마찬가지로, 스레드에서 쓰기 모드로 잠금을 시작한 경우 <xref:System.Threading.LockRecursionException> 스레드가 다시 모드로 잠금을 시작 하려고 하면 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-259">업그레이드 가능 모드에 있는 스레드에서 쓰기 모드로 업그레이드 하거나 읽기 잠금 재귀 정책 설정에 관계 없이 모드로 다운 그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="70286-260">재귀 정책에 관계 없이 처음 시작한 스레드는 해당 패턴에 교착 상태가 발생할 가능성이 매우 만들기 때문에 업그레이드 가능 모드 또는 쓰기 모드를로 업그레이드 하 모드가 허용 되지 않습니다 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="70286-261">재귀 정책 및 이러한 액세스가 영향에 대 한 자세한 내용은 참조는 <xref:System.Threading.LockRecursionPolicy> 열거형 및 <xref:System.Threading.ReaderWriterLockSlim> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-262">다음 예제에서는 두 가지 예외 시나리오 하나에 따라 달라 지는 <xref:System.Threading.LockRecursionPolicy> 설정 하 고 다른 하나는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="70286-263">첫 번째 시나리오에서는 스레드 읽기 모드를 시작 하 고 재귀적으로 읽기 모드를 시작 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="70286-264">경우는 <xref:System.Threading.ReaderWriterLockSlim> 을 재귀 정책을 설정 하는 기본 생성자를 사용 하 여 만든 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the default constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="70286-265">경우 <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> 만드는 데 사용 되는 <xref:System.Threading.ReaderWriterLockSlim>, 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="70286-266">두 번째 시나리오에서는 스레드에서 읽기 모드를 시작 하 고 쓰기 모드를 시작 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="70286-267"><xref:System.Threading.LockRecursionException> 잠금 재귀 정책을 관계 없이 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="70286-268">다음 코드에서는 다음의 `SynchronizedCache` 채소 이름 사전을 저장할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="70286-269">세 가지 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="70286-269">It creates three tasks.</span></span> <span data-ttu-id="70286-270">첫 번째 야채를 배열에 저장 된 이름을 씁니다는 `SynchronizedCache` 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="70286-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="70286-271">두 번째 및 세 번째 작업에는 오름차순으로 정렬 순서 (낮은 인덱스 로부터 높은 인덱스로) 내림차순 두 번째 첫 번째 야채의 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="70286-272">마지막 작업 "cucumber" 문자열을 검색 하 고, 발견 한 경우 호출 하는 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> 메서드를 "녹색 bean" 문자열을 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70286-273">읽기 모드로 잠금을 시작한 고유 스레드의 총 개수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="70286-273">Gets the total number of unique threads that have entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="70286-274">읽기 모드로 잠금을 시작한 고유 스레드의 총 개수입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-274">The number of unique threads that have entered the lock in read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-275">스레드를 한 번만 계산, 재귀 및 스레드 잠금을 허용 하는 경우에 읽기 모드가 시작 여러 번입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="70286-276">이 속성을 사용 하 여 디버깅, 프로 파일링 및 로깅 목적으로 대해서만 하 고 하지 않는 알고리즘의 동작을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="70286-277">결과 계산 되는 즉시 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="70286-278">따라서이 속성에 따라 결정을 내릴 수 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-279">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> 속성을 읽기 모드의 스레드 수가 임계값을 초과 하는 경우 이벤트 로그 항목을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70286-280"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-281"><xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 사용을 마치면 <xref:System.Threading.ReaderWriterLockSlim>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="70286-282"><xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 메서드를 사용하면 <xref:System.Threading.ReaderWriterLockSlim>를 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="70286-283">호출한 후 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>에 대 한 모든 참조를 해제 해야는 <xref:System.Threading.ReaderWriterLockSlim> 가비지 수집기는 메모리를 회수할 수 있도록 하는 <xref:System.Threading.ReaderWriterLockSlim> 차지한 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="70286-284">자세한 내용은 참조 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md) 및 [Dispose 메서드를 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-284">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-285">항상 호출 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 에 대 한 마지막 참조를 해제 하기 전에 <xref:System.Threading.ReaderWriterLockSlim> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="70286-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />가 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="70286-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span></span>  
  
 <span data-ttu-id="70286-287">또는</span><span class="sxs-lookup"><span data-stu-id="70286-287">-or-</span></span>  
  
 <span data-ttu-id="70286-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />가 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="70286-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span></span>  
  
 <span data-ttu-id="70286-289">또는</span><span class="sxs-lookup"><span data-stu-id="70286-289">-or-</span></span>  
  
 <span data-ttu-id="70286-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />가 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="70286-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70286-291">읽기 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-291">Tries to enter the lock in read mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-292">이 메서드 차단 때까지 호출 스레드가 잠금이 시작 하 고 따라서 되지 않을 수도 있습니다를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-292">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="70286-293">사용 하 여는 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 해당 간격 동안 읽기 모드 메서드를 지정된 된 간격에 대 한 차단 한 다음 호출 스레드가 시작 되지 않은 경우를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-293">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="70286-294">여러 스레드에서 동시에 읽기 모드를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-294">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="70286-295">쓰기 모드를 시작 하려고 대기 중인 하나 이상의 스레드가 경우 호출 하는 스레드가 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 이러한 스레드에서 될 때까지 쓰기 모드가 시작 되거나 시작 된 다음 종료 시간이 초과 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-295">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-296">재귀 잠금을 허용 하는 경우 읽기 모드로 잠금을 시작 하는 스레드는 다른 스레드에서 쓰기 모드를 시작 하려고 대기 중인 경우에 읽기 모드를 재귀적으로 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-296">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="70286-297">스레드 하나 다른 스레드에서 읽기 모드에 있는 동안 업그레이드 가능 모드에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-297">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="70286-298">업그레이드 가능 모드 추가 스레드가 대기 중인 쓰기 모드를 시작 하려고 대기 하는 스레드가 없는 경우 호출 하는 스레드는 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 메서드 읽기 모드를 즉시 시작 하 고 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-298">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-299">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 메서드 읽기 모드로 잠금을 시작 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-299">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="70286-300">이 예제에 표시 된 메서드는 키와 연결 된 값을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-300">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="70286-301">키가 없는 경우, 내부에서 throw 된 예외 <xref:System.Collections.Generic.Dictionary%602> 메서드가 종료를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-301">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="70286-302">A `finally` 블록은 실행 하는 데 사용 되는 <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> 메서드를 호출자가 읽기 모드를 종료할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-302">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="70286-303">이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Threading.ReaderWriterLockSlim> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-303">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="70286-304">현재 스레드에서 읽기 잠금을 보유하는 경우 쓰기 잠금을 가져올 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-304">The current thread cannot acquire the write lock when it holds the read lock.</span></span>  
  
 <span data-ttu-id="70286-305">또는</span><span class="sxs-lookup"><span data-stu-id="70286-305">-or-</span></span>  
  
 <span data-ttu-id="70286-306"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 읽기 잠금을 보유하고 있는 상황에서 읽기 잠금을 가져오려고 시도한 경우</span><span class="sxs-lookup"><span data-stu-id="70286-306">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span></span>  
  
 <span data-ttu-id="70286-307">또는</span><span class="sxs-lookup"><span data-stu-id="70286-307">-or-</span></span>  
  
 <span data-ttu-id="70286-308"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 읽기 잠금을 보유하고 있는 상황에서 읽기 잠금을 가져오려고 시도한 경우</span><span class="sxs-lookup"><span data-stu-id="70286-308">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span></span>  
  
 <span data-ttu-id="70286-309">또는</span><span class="sxs-lookup"><span data-stu-id="70286-309">-or-</span></span>  
  
 <span data-ttu-id="70286-310">재귀 횟수가 카운터의 용량을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-310">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="70286-311">이 제한은 응용 프로그램에서 이 예외가 발생하지 않을 정도로 매우 큽니다.</span><span class="sxs-lookup"><span data-stu-id="70286-311">This limit is so large that applications should never encounter this exception.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="70286-312"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-312">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70286-313">업그레이드 가능 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-313">Tries to enter the lock in upgradeable mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-314">이 메서드 차단 때까지 호출 스레드가 잠금이 시작 하 고 따라서 되지 않을 수도 있습니다를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-314">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="70286-315">사용 하 여는 <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> 메서드를 지정된 된 간격에 대 한 차단 한 다음 호출 스레드가 해당 간격 동안 업그레이드 가능 모드가 시작 되지 않은 경우를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-315">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="70286-316">스레드는 일반적으로로 보호 되는 리소스에 액세스 하는 경우 사용 하 여 업그레이드 가능 모드는 <xref:System.Threading.ReaderWriterLockSlim> 에 읽기 모드, 이지만 특정 조건이 충족 되 면 쓰기 모드를 시작 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-316">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="70286-317">업그레이드 가능 모드에 있는 스레드에서 읽기 모드로 다운 그레이드할 수 하거나 쓰기 모드로 업그레이드 하십시오.</span><span class="sxs-lookup"><span data-stu-id="70286-317">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="70286-318">하나의 스레드는 언제 든 지 업그레이드 가능 모드를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-318">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="70286-319">스레드에서 업그레이드 가능 모드 이므로 쓰기 모드를 시작 하려고 대기 하는 스레드가 없는 경우 개수에 관계 없이 다른 스레드에서 업그레이드 가능 모드 대기 중인 스레드가 있는 경우에 읽기 모드를 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-319">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="70286-320">쓰기 모드를 시작 하려고 대기 중인 하나 이상의 스레드가 경우 호출 하는 스레드가 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> 이러한 스레드에서 될 때까지 쓰기 모드가 시작 되거나 시작 된 다음 종료 시간이 초과 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-320">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-321">재귀 잠금을 허용 하는 경우 업그레이드 가능 모드로 잠금을 시작 하는 스레드는 다른 스레드에서 쓰기 모드를 시작 하려고 대기 중인 경우에 재귀적으로 업그레이드 가능 모드를 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-321">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-322">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> 메서드 업그레이드 가능 모드로 잠금을 시작 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-322">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="70286-323">A `finally` 블록은 실행 하는 데 사용 되는 <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> 메서드를 호출자가 업그레이드 가능 모드.</span><span class="sxs-lookup"><span data-stu-id="70286-323">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="70286-324">이 예제에 표시 된 메서드는 키와 연결 된 값을 검색 하며 새 값을와 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-324">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="70286-325">값이 변경 되지 않았으면, 메서드가 변경 되지 않았음을 나타내는 상태를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-325">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="70286-326">키에 대 한 값이 없는 찾으면, 키/값 쌍이 삽입 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-326">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="70286-327">값이 변경 하는 경우 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-327">If the value has changed, it is updated.</span></span> <span data-ttu-id="70286-328">업그레이드 가능 모드 스레드를 교착 상태가 발생할 위험 없이 필요에 따라 읽기 잠금을 업그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-328">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="70286-329">이 예제에서는 기본 생성자를 사용 하 여 만드는 잠금, 재귀 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-329">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="70286-330">프로그래밍의 <xref:System.Threading.ReaderWriterLockSlim> 잠금을 재귀를 허용 하지 않을 경우 더 간단 하 고 오류가 발생할 가능성이 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-330">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="70286-331">이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Threading.ReaderWriterLockSlim> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-331">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="70286-332"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 모드에 관계없이 잠금을 시작한 경우</span><span class="sxs-lookup"><span data-stu-id="70286-332">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
 <span data-ttu-id="70286-333">또는</span><span class="sxs-lookup"><span data-stu-id="70286-333">-or-</span></span>  
  
 <span data-ttu-id="70286-334">현재 스레드에서 읽기 모드를 시작했으므로 업그레이드 가능 모드를 시작하려고 하면 교착 상태가 발생할 수 있는 경우</span><span class="sxs-lookup"><span data-stu-id="70286-334">The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
 <span data-ttu-id="70286-335">또는</span><span class="sxs-lookup"><span data-stu-id="70286-335">-or-</span></span>  
  
 <span data-ttu-id="70286-336">재귀 횟수가 카운터의 용량을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-336">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="70286-337">이 제한은 매우 크므로 일반적으로 응용 프로그램에서 초과되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-337">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="70286-338"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-338">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70286-339">쓰기 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-339">Tries to enter the lock in write mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-340">이 메서드 차단 때까지 호출 스레드가 잠금이 시작 하 고 따라서 되지 않을 수도 있습니다를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-340">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="70286-341">사용 하 여는 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 메서드를 지정된 된 간격에 대 한 차단 한 다음 호출 스레드가 해당 간격 동안 쓰기 모드가 시작 되지 않은 경우를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-341">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="70286-342">다른 스레드에서 읽기 모드로 잠금을 시작한 경우 호출 하는 스레드가 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> 이러한 스레드가 종료 될 때까지 읽기 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-342">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="70286-343">쓰기 모드를 시작 하려고 대기 하는 스레드가 쓰기 모드를 시작 하려고 대기 하는 모든 스레드에서 업그레이드 가능 모드가 시작 블록 또는 읽기 모드를 시작 하려고 하는 추가 스레드 시간이 초과 되었습니다 쓰기 모드가 시작 되거나 시작 된 다음 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-343">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-344">재귀 잠금을 허용 하는 경우 쓰기 모드로 잠금을 시작 하는 스레드는 다른 스레드에서 쓰기 모드를 시작 하려고 대기 중인 경우에 재귀적으로 쓰기 모드를 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-344">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-345">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> 메서드 쓰기 모드로 잠금을 시작 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-345">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="70286-346">이 예제에 표시 된 메서드는 동기화 된 캐시에 새 키/값 쌍을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-346">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="70286-347">내부에서 throw 된 예외 캐시에 키가 이미 있으면 <xref:System.Collections.Generic.Dictionary%602> 메서드가 종료를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-347">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="70286-348">A `finally` 블록은 실행 하는 데 사용 되는 <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> 메서드를 호출자가 쓰기 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-348">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="70286-349">이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Threading.ReaderWriterLockSlim> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-349">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="70286-350"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 모드에 관계없이 잠금을 시작한 경우</span><span class="sxs-lookup"><span data-stu-id="70286-350">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
 <span data-ttu-id="70286-351">또는</span><span class="sxs-lookup"><span data-stu-id="70286-351">-or-</span></span>  
  
 <span data-ttu-id="70286-352">현재 스레드에서 읽기 모드를 시작했으므로 쓰기 모드로 잠금을 시작하려고 하면 교착 상태가 발생할 수 있는 경우</span><span class="sxs-lookup"><span data-stu-id="70286-352">The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.</span></span>  
  
 <span data-ttu-id="70286-353">또는</span><span class="sxs-lookup"><span data-stu-id="70286-353">-or-</span></span>  
  
 <span data-ttu-id="70286-354">재귀 횟수가 카운터의 용량을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-354">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="70286-355">이 제한은 매우 크므로 일반적으로 응용 프로그램에서 초과되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-355">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="70286-356"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-356">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70286-357">읽기 모드의 재귀 횟수를 줄이고, 결과 횟수가 0이 되면 읽기 모드를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-357">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-358">이 메서드는 재귀 순서는 중요 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-358">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="70286-359">예를 들어 스레드가 업그레이드 가능 모드로 잠금을 시작한 다음 읽기 모드로 잠금을 시작한 경우 스레드는 두 가지 모드를 종료 순서 중요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-359">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="70286-360">잠금 재귀 허용 하는 경우 스레드 수 쓰기 모드로 잠금을 시작를 다음 재귀적으로에 입력 읽기 모드입니다. 스레드가 종료 순서 읽기 모드 및 쓰기 모드는 중요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-360">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="70286-361">잠금을 종료 하면 대기 중인 다른 스레드가 신호를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-361">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-362">사용 하는 방법을 보여 주는 다음 예제는 `finally` 블록을 실행 된 <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> 메서드를 호출자가 읽기 모드를 종료할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-362">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="70286-363">이 예제에 표시 된 메서드는 키와 연결 된 값을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-363">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="70286-364">키가 없는 경우, 내부에서 throw 된 예외 <xref:System.Collections.Generic.Dictionary%602> 메서드가 종료를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-364">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="70286-365"><xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 메서드 읽기 모드를 시작 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-365">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="70286-366">이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Threading.ReaderWriterLockSlim> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-366">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="70286-367">현재 스레드에서 읽기 모드로 잠금을 시작하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="70286-367">The current thread has not entered the lock in read mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70286-368">업그레이드 가능 모드의 재귀 횟수를 줄이고, 결과 횟수가 0이 되면 업그레이드 가능 모드를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-368">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-369">이 메서드는 재귀 순서는 중요 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-369">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="70286-370">예를 들어 스레드가 업그레이드 가능 모드로 잠금을 시작한 다음 쓰기 모드로 잠금을 시작한 경우 스레드는 두 가지 모드를 종료 순서 중요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-370">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="70286-371">잠금 재귀 허용 하는 경우 스레드 수 쓰기 모드로 잠금을 시작를 다음 재귀적으로에 입력 업그레이드 가능 모드. 스레드에서 업그레이드 가능 모드 및 쓰기 모드를 종료 하는 순서는 중요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-371">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="70286-372">잠금을 종료 하면 대기 중인 다른 스레드가 신호를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-372">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-373">사용 하는 방법을 보여 주는 다음 예제는 `finally` 블록이 실행은 <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> 메서드를 호출자가 업그레이드 가능 모드.</span><span class="sxs-lookup"><span data-stu-id="70286-373">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="70286-374">이 예제에 표시 된 메서드는 키와 연결 된 값을 검색 하며 새 값을와 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-374">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="70286-375">값이 변경 되지 않았으면, 메서드가 변경 되지 않았음을 나타내는 상태를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-375">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="70286-376">키에 대 한 값이 없는 찾으면, 키/값 쌍이 삽입 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-376">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="70286-377">값이 변경 하는 경우 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-377">If the value has changed, it is updated.</span></span> <span data-ttu-id="70286-378">업그레이드 가능 모드 스레드를 교착 상태가 발생할 위험 없이 필요에 따라 읽기 잠금을 업그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-378">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="70286-379">이 예제에서는 기본 생성자를 사용 하 여 만드는 잠금, 재귀 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-379">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="70286-380">프로그래밍의 <xref:System.Threading.ReaderWriterLockSlim> 잠금을 재귀를 허용 하지 않을 경우 더 간단 하 고 오류가 발생할 가능성이 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-380">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="70286-381">이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Threading.ReaderWriterLockSlim> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-381">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="70286-382">현재 스레드에서 업그레이드 가능 모드로 잠금을 시작하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="70286-382">The current thread has not entered the lock in upgradeable mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70286-383">쓰기 모드의 재귀 횟수를 줄이고, 결과 횟수가 0이 되면 쓰기 모드를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-383">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-384">이 메서드는 재귀 순서는 중요 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-384">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="70286-385">예를 들어 스레드가 업그레이드 가능 모드로 잠금을 시작한 다음 쓰기 모드로 잠금을 시작한 경우 스레드는 두 가지 모드를 종료 순서 중요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-385">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="70286-386">잠금 재귀 허용 하는 경우 스레드 수 쓰기 모드로 잠금을 시작를 다음 재귀적으로에 입력 읽기 모드입니다. 스레드가 종료 순서 읽기 모드 및 쓰기 모드는 중요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-386">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="70286-387">잠금을 종료 하면 대기 중인 다른 스레드가 신호를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-387">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-388">사용 하는 방법을 보여 주는 다음 예제는 `finally` 블록을 실행 된 <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> 메서드를 호출자가 쓰기 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-388">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="70286-389">이 예제에 표시 된 메서드는 동기화 된 캐시에 새 키/값 쌍을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-389">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="70286-390">내부에서 throw 된 예외 캐시에 키가 이미 있으면 <xref:System.Collections.Generic.Dictionary%602> 메서드가 종료를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-390">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="70286-391"><xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> 메서드 쓰기 모드로 잠금을 시작 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-391">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="70286-392">이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Threading.ReaderWriterLockSlim> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-392">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="70286-393">현재 스레드에서 쓰기 모드로 잠금을 시작하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="70286-393">The current thread has not entered the lock in write mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70286-394">현재 스레드에서 읽기 모드로 잠금을 시작했는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="70286-394">Gets a value that indicates whether the current thread has entered the lock in read mode.</span></span></summary>
        <value>
          <span data-ttu-id="70286-395">현재 스레드에서 읽기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-395"><see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-396">이 속성은 어설션을에서 사용 하 여 하거나 기타 디버깅 용도로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-396">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="70286-397">프로그램 실행의 흐름 제어를 사용 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="70286-397">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-398">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> 예기치 않게 하기 위해 현재 스레드에서 시작한 경우 어설션을 생성 하는 속성 읽기 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-398">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70286-399">현재 스레드에서 업그레이드 가능 모드로 잠금을 시작했는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="70286-399">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span></span></summary>
        <value>
          <span data-ttu-id="70286-400">현재 스레드에서 업그레이드 가능 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-400"><see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-401">이 속성은 어설션을에서 사용 하 여 하거나 기타 디버깅 용도로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-401">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="70286-402">프로그램 실행의 흐름 제어를 사용 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="70286-402">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-403">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> 현재 스레드에서 예기치 않게 업그레이드 가능 모드를 시작 하는 경우 어설션을 생성 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-403">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70286-404">현재 스레드에서 쓰기 모드로 잠금을 시작했는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="70286-404">Gets a value that indicates whether the current thread has entered the lock in write mode.</span></span></summary>
        <value>
          <span data-ttu-id="70286-405">현재 스레드에서 쓰기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-405"><see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-406">이 속성은 어설션을에서 사용 하 여 하거나 기타 디버깅 용도로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-406">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="70286-407">프로그램 실행의 흐름 제어를 사용 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="70286-407">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-408">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> 현재 스레드에서 예기치 않게 쓰기 모드를 시작 하는 경우 어설션을 생성 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-408">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70286-409">현재 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체에 대한 재귀 정책을 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="70286-409">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span></span></summary>
        <value><span data-ttu-id="70286-410">잠금 재귀 정책을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-410">One of the enumeration values that specifies the lock recursion policy.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-411">재귀 정책은 스레드에서 잠금을 여러 번 입력 하는 제한 사항을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-411">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="70286-412">예를 들어, 잠금을 사용 하 여 만든 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> 는 스레드에서 읽기 모드로 잠금을 시작 및 <xref:System.Threading.LockRecursionException> 스레드가 다시 읽기 모드로 잠금을 시작 하려고 하면 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70286-412">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-413">업그레이드 가능 모드에 있는 스레드에서 쓰기 모드로 업그레이드 하거나 읽기 잠금 재귀 정책 설정에 관계 없이 모드로 다운 그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-413">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="70286-414">재귀 정책에 관계 없이 처음 시작한 스레드는 해당 패턴에 교착 상태가 발생할 가능성이 매우 만들기 때문에 업그레이드 가능 모드 또는 쓰기 모드를로 업그레이드 하 모드가 허용 되지 않습니다 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-414">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="70286-415">재귀 정책 및 이러한 액세스가 영향에 대 한 자세한 내용은 참조는 <xref:System.Threading.LockRecursionPolicy> 열거형 및 <xref:System.Threading.ReaderWriterLockSlim> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-415">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70286-416">재귀를 확인하기 위해 현재 스레드에서 읽기 모드로 잠금을 시작한 횟수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="70286-416">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="70286-417">읽기 모드를 현재 스레드를 시작 하지 않았으면 0 (영), 스레드에서 읽기 모드 했지만 하지 않았으면 1 재귀적으로 또는 *n* 스레드에서 재귀적으로 잠금을 *n* -1 회입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-417">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-418">이 속성을 사용 하 여 디버깅, 프로 파일링 및 로깅 목적으로 대해서만 하 고 하지 않는 알고리즘의 동작을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-418">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="70286-419">결과 계산 되는 즉시 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-419">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="70286-420">따라서이 속성에 따라 결정을 내릴 수 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-420">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70286-421">재귀를 확인하기 위해 현재 스레드에서 업그레이드 가능 모드로 잠금을 시작한 횟수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="70286-421">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="70286-422">현재 스레드에서 업그레이드 가능 모드, 1, 스레드에서 업그레이드 가능 모드가 시작 했지만 하지 재귀적으로 시작 하지 않았으면 0 또는 *n* 스레드에서 재귀적으로 업그레이드 가능 모드가 시작 되었으면 *n* -1 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-422">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-423">이 속성을 사용 하 여 디버깅, 프로 파일링 및 로깅 목적으로 대해서만 하 고 하지 않는 알고리즘의 동작을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-423">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="70286-424">결과 계산 되는 즉시 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-424">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="70286-425">따라서이 속성에 따라 결정을 내릴 수 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-425">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70286-426">재귀를 확인하기 위해 현재 스레드에서 쓰기 모드로 잠금을 시작한 횟수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="70286-426">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="70286-427">현재 스레드를 시작 하지 않았으면 0 쓰기 모드를 1 스레드가 쓰기 모드가 시작 되지 않은 경우 재귀적으로 또는 *n* 스레드에서 재귀적으로 쓰기 모드 *n* -1 회입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-427">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-428">이 속성을 사용 하 여 디버깅, 프로 파일링 및 로깅 목적으로 대해서만 하 고 하지 않는 알고리즘의 동작을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-428">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="70286-429">결과 계산 되는 즉시 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-429">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="70286-430">따라서이 속성에 따라 결정을 내릴 수 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-430">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="70286-431">제한 시간을 선택적으로 적용하여 읽기 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-431">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="70286-432">대기할 시간(밀리초)이거나, 무기한 대기할 경우 -1(<see cref="F:System.Threading.Timeout.Infinite" />)입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-432">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="70286-433">제한 시간(정수)을 선택적으로 적용하여 읽기 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-433">Tries to enter the lock in read mode, with an optional integer time-out.</span></span></summary>
        <returns>
          <span data-ttu-id="70286-434">호출하는 스레드에서 읽기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-434"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-435">경우 `millisecondsTimeout` 0 (영) 이면이 메서드는 잠금 상태를 확인 하 고 반환 `false` 즉시 원하는 상태로 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="70286-435">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="70286-436">여러 스레드에서 동시에 읽기 모드를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-436">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="70286-437">쓰기 모드를 시작 하려고 대기 중인 하나 이상의 스레드가 경우 호출 하는 스레드가 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 메서드는 먼저 해당 스레드에 해야 하거나 시간 초과 또는 쓰기 모드가 시작 여기에서 시작 된 다음 종료 또는 호출 스레드 자체의 시간 제한 간격이 만료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-437">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-438">재귀 잠금을 허용 하는 경우 읽기 모드로 잠금을 시작 하는 스레드는 다른 스레드에서 쓰기 모드를 시작 하려고 대기 중인 경우에 읽기 모드를 재귀적으로 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-438">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="70286-439">한 스레드가 다른 스레드에서 읽기 모드에 있는 동안 업그레이드 가능 모드로 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-439">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="70286-440">업그레이드 가능 모드 추가 스레드가 대기 중인 쓰기 모드를 시작 하려고 대기 하는 스레드가 없는 경우 호출 하는 스레드는 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 메서드 읽기 모드를 즉시 시작 하 고 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-440">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="70286-441"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우</span><span class="sxs-lookup"><span data-stu-id="70286-441">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
 <span data-ttu-id="70286-442">또는</span><span class="sxs-lookup"><span data-stu-id="70286-442">-or-</span></span>  
  
 <span data-ttu-id="70286-443">재귀 횟수가 카운터의 용량을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-443">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="70286-444">이 제한은 매우 크므로 일반적으로 응용 프로그램에서 초과되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-444">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="70286-445"><paramref name="millisecondsTimeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 <see cref="F:System.Threading.Timeout.Infinite" />(-1)이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="70286-445">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="70286-446"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-446">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="70286-447">대기할 간격이거나, 무기한 대기하려는 경우 -1밀리초입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-447">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="70286-448">제한 시간을 선택적으로 적용하여 읽기 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-448">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
        <returns>
          <span data-ttu-id="70286-449">호출하는 스레드에서 읽기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-449"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-450">경우 `timeout` 0 (영) 이면이 메서드는 잠금 상태를 확인 하 고 반환 `false` 즉시 원하는 상태로 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="70286-450">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="70286-451">여러 스레드에서 동시에 읽기 모드로 잠금을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-451">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="70286-452">쓰기 모드를 시작 하려면 하나 이상의 스레드가 큐에 대기 하는 경우 호출 하는 스레드가 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 메서드는 먼저 해당 스레드에 해야 하거나 시간 초과 또는 쓰기 모드가 시작 여기에서 시작 된 다음 종료 또는 호출 스레드 자체의 시간 제한 간격이 만료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-452">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-453">재귀 잠금을 허용 하는 경우 읽기 모드로 잠금을 시작 하는 스레드는 다른 스레드에서 쓰기 모드를 시작 하려고 대기 중인 경우에 읽기 모드를 재귀적으로 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-453">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="70286-454">한 스레드가 다른 스레드에서 읽기 모드에 있는 동안 업그레이드 가능 모드로 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-454">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="70286-455">업그레이드 가능 모드 추가 스레드가 대기 중인 쓰기 모드를 시작 하려고 대기 하는 스레드가 없는 경우 호출 하는 스레드는 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 메서드 읽기 모드를 즉시 시작 하 고 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-455">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="70286-456"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우</span><span class="sxs-lookup"><span data-stu-id="70286-456">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
 <span data-ttu-id="70286-457">또는</span><span class="sxs-lookup"><span data-stu-id="70286-457">-or-</span></span>  
  
 <span data-ttu-id="70286-458">재귀 횟수가 카운터의 용량을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-458">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="70286-459">이 제한은 매우 크므로 일반적으로 응용 프로그램에서 초과되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-459">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="70286-460"><paramref name="timeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 -1밀리초가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="70286-460">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
 <span data-ttu-id="70286-461">또는</span><span class="sxs-lookup"><span data-stu-id="70286-461">-or-</span></span>  
  
 <span data-ttu-id="70286-462"><paramref name="timeout" />의 값이 <see cref="F:System.Int32.MaxValue" />밀리초보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="70286-462">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="70286-463"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-463">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="70286-464">제한 시간을 선택적으로 적용하여 업그레이드 가능 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-464">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="70286-465">대기할 시간(밀리초)이거나, 무기한 대기할 경우 -1(<see cref="F:System.Threading.Timeout.Infinite" />)입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-465">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="70286-466">제한 시간을 선택적으로 적용하여 업그레이드 가능 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-466">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns>
          <span data-ttu-id="70286-467">호출하는 스레드에서 업그레이드 가능 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-467"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-468">경우 `millisecondsTimeout` 0 (영) 이면이 메서드는 잠금 상태를 확인 하 고 반환 `false` 즉시 원하는 상태로 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="70286-468">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="70286-469">스레드는 일반적으로로 보호 되는 리소스에 액세스 하는 경우 사용 하 여 업그레이드 가능 모드는 <xref:System.Threading.ReaderWriterLockSlim> 에 읽기 모드, 이지만 특정 조건이 충족 되 면 쓰기 모드를 시작 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-469">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="70286-470">업그레이드 가능 모드에 있는 스레드에서 쓰기 모드로 업그레이드 하거나 읽기 모드로 다운 그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-470">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="70286-471">하나의 스레드는 언제 든 지 업그레이드 가능 모드로 잠금을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-471">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="70286-472">스레드에서 업그레이드 가능 모드 이므로 쓰기 모드를 시작 하려고 대기 하는 스레드가 없는 경우 개수에 관계 없이 다른 스레드에서 업그레이드 가능 모드 대기 중인 스레드가 있는 경우에 읽기 모드를 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-472">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="70286-473">쓰기 모드를 시작 하려고 대기 중인 하나 이상의 스레드가 경우 호출 하는 스레드가 <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> 메서드는 먼저 해당 스레드에 해야 하거나 시간 초과 또는 쓰기 모드가 시작 여기에서 시작 된 다음 종료 또는 호출 스레드 자체의 시간 제한 간격이 만료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-473">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-474">재귀 잠금을 허용 하는 경우 업그레이드 가능 모드로 잠금을 시작 하는 스레드는 다른 스레드에서 쓰기 모드를 시작 하려고 대기 중인 경우에 재귀적으로 업그레이드 가능 모드를 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-474">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="70286-475"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우</span><span class="sxs-lookup"><span data-stu-id="70286-475">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
 <span data-ttu-id="70286-476">또는</span><span class="sxs-lookup"><span data-stu-id="70286-476">-or-</span></span>  
  
 <span data-ttu-id="70286-477">현재 스레드에서 초기에 읽기 모드로 잠금을 시작했으므로 업그레이드 가능 모드를 시작하려고 하면 교착 상태가 발생할 수 있는 경우</span><span class="sxs-lookup"><span data-stu-id="70286-477">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
 <span data-ttu-id="70286-478">또는</span><span class="sxs-lookup"><span data-stu-id="70286-478">-or-</span></span>  
  
 <span data-ttu-id="70286-479">재귀 횟수가 카운터의 용량을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-479">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="70286-480">이 제한은 매우 크므로 일반적으로 응용 프로그램에서 초과되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-480">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="70286-481"><paramref name="millisecondsTimeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 <see cref="F:System.Threading.Timeout.Infinite" />(-1)이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="70286-481">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="70286-482"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-482">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="70286-483">대기할 간격이거나, 무기한 대기하려는 경우 -1밀리초입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-483">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="70286-484">제한 시간을 선택적으로 적용하여 업그레이드 가능 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-484">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns>
          <span data-ttu-id="70286-485">호출하는 스레드에서 업그레이드 가능 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-485"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-486">경우 `timeout` 0 (영) 이면이 메서드는 잠금 상태를 확인 하 고 반환 `false` 즉시 원하는 상태로 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="70286-486">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="70286-487">스레드에 의해 보호 된 리소스에 일반적으로 액세스 하는 경우 사용 하 여 업그레이드 가능 모드는 <xref:System.Threading.ReaderWriterLockSlim> 에 읽기 모드, 이지만 특정 조건이 충족 되 면 쓰기 모드를 시작 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-487">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="70286-488">업그레이드 가능 모드에 있는 스레드에서 쓰기 모드로 업그레이드 하거나 읽기 모드로 다운 그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-488">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="70286-489">하나의 스레드는 언제 든 지 업그레이드 가능 모드로 잠금을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-489">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="70286-490">스레드에서 업그레이드 가능 모드 이므로 쓰기 모드를 시작 하려고 대기 하는 스레드가 없는 경우 개수에 관계 없이 다른 스레드에서 업그레이드 가능 모드 대기 중인 스레드가 있는 경우에 읽기 모드를 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-490">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="70286-491">쓰기 모드를 시작 하려고 대기 중인 하나 이상의 스레드가 경우 호출 하는 스레드가 <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> 메서드는 먼저 해당 스레드에 해야 하거나 시간 초과 또는 쓰기 모드가 시작 여기에서 시작 된 다음 종료 또는 호출 스레드 자체의 시간 제한 간격이 만료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-491">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-492">재귀 잠금을 허용 하는 경우 업그레이드 가능 모드로 잠금을 시작 하는 스레드는 다른 스레드에서 쓰기 모드를 시작 하려고 대기 중인 경우에 재귀적으로 업그레이드 가능 모드를 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-492">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="70286-493"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우</span><span class="sxs-lookup"><span data-stu-id="70286-493">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
 <span data-ttu-id="70286-494">또는</span><span class="sxs-lookup"><span data-stu-id="70286-494">-or-</span></span>  
  
 <span data-ttu-id="70286-495">현재 스레드에서 초기에 읽기 모드로 잠금을 시작했으므로 업그레이드 가능 모드를 시작하려고 하면 교착 상태가 발생할 수 있는 경우</span><span class="sxs-lookup"><span data-stu-id="70286-495">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
 <span data-ttu-id="70286-496">또는</span><span class="sxs-lookup"><span data-stu-id="70286-496">-or-</span></span>  
  
 <span data-ttu-id="70286-497">재귀 횟수가 카운터의 용량을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-497">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="70286-498">이 제한은 매우 크므로 일반적으로 응용 프로그램에서 초과되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-498">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="70286-499"><paramref name="timeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 -1밀리초가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="70286-499">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
 <span data-ttu-id="70286-500">또는</span><span class="sxs-lookup"><span data-stu-id="70286-500">-or-</span></span>  
  
 <span data-ttu-id="70286-501"><paramref name="timeout" />의 값이 <see cref="F:System.Int32.MaxValue" />밀리초보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="70286-501">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="70286-502"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-502">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="70286-503">제한 시간을 선택적으로 적용하여 쓰기 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-503">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="70286-504">대기할 시간(밀리초)이거나, 무기한 대기할 경우 -1(<see cref="F:System.Threading.Timeout.Infinite" />)입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-504">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="70286-505">제한 시간을 선택적으로 적용하여 쓰기 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-505">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns>
          <span data-ttu-id="70286-506">호출하는 스레드에서 쓰기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-506"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-507">경우 `millisecondsTimeout` 0 (영) 이면이 메서드는 잠금 상태를 확인 하 고 반환 `false` 즉시 원하는 상태로 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="70286-507">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="70286-508">다른 스레드에서 읽기 모드로 잠금을 시작한 경우 호출 하는 스레드가 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 메서드가 이러한 스레드에서 읽기 모드를 종료 될 때까지 또는 시간 제한 간격이 경과할 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-508">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="70286-509">쓰기 모드를 시작 하려고 대기 중인 스레드가 차단 됩니다, 읽기 모드 또는 업그레이드 가능 모드를 시작 하려고 하는 추가 스레드 대기 중인 모든 스레드가 쓰기 모드는 하거나 시간 초과 또는 쓰기 모드가 시작 하 고 시작 된 다음 종료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-509">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-510">재귀 잠금을 허용 하는 경우 쓰기 모드로 잠금을 시작 하는 스레드는 다른 스레드에서 쓰기 모드를 시작 하려고 대기 중인 경우에 재귀적으로 쓰기 모드를 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-510">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-511">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 메서드가 시간 제한으로 쓰기 모드로 잠금을 시작 하려고 합니다. 이 예제에 표시 된 메서드는 동기화 된 캐시에 새 키/값 쌍을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-511">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="70286-512">메서드가 반환 하는 경우는 지정 된 시간 제한 간격이 지나면 스레드가 잠금을 들어가기 전에 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-512">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="70286-513">메서드가 반환 `true` 키/값 쌍이 추가 되는 경우.</span><span class="sxs-lookup"><span data-stu-id="70286-513">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="70286-514">내부에서 throw 된 예외 캐시에 키가 이미 있으면 <xref:System.Collections.Generic.Dictionary%602> 메서드가 종료를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-514">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="70286-515">A `finally` 블록은 실행 하는 데 사용 되는 <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> 메서드를 호출자가 잠금을 종료할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-515">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="70286-516">이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Threading.ReaderWriterLockSlim> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-516">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="70286-517"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우</span><span class="sxs-lookup"><span data-stu-id="70286-517">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
 <span data-ttu-id="70286-518">또는</span><span class="sxs-lookup"><span data-stu-id="70286-518">-or-</span></span>  
  
 <span data-ttu-id="70286-519">현재 스레드에서 초기에 읽기 모드로 잠금을 시작했으므로 쓰기 모드를 시작하려고 하면 교착 상태가 발생할 수 있는 경우</span><span class="sxs-lookup"><span data-stu-id="70286-519">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
 <span data-ttu-id="70286-520">또는</span><span class="sxs-lookup"><span data-stu-id="70286-520">-or-</span></span>  
  
 <span data-ttu-id="70286-521">재귀 횟수가 카운터의 용량을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-521">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="70286-522">이 제한은 매우 크므로 일반적으로 응용 프로그램에서 초과되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-522">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="70286-523"><paramref name="millisecondsTimeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 <see cref="F:System.Threading.Timeout.Infinite" />(-1)이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="70286-523">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="70286-524"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-524">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="70286-525">대기할 간격이거나, 무기한 대기하려는 경우 -1밀리초입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-525">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="70286-526">제한 시간을 선택적으로 적용하여 쓰기 모드로 잠금을 시작하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-526">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns>
          <span data-ttu-id="70286-527">호출하는 스레드에서 쓰기 모드가 시작되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-527"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-528">경우 `timeout` 0 (영) 이면이 메서드는 잠금 상태를 확인 하 고 반환 `false` 즉시 원하는 상태로 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="70286-528">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="70286-529">다른 스레드에서 읽기 모드로 잠금을 시작한 경우 호출 하는 스레드가 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 메서드가 이러한 스레드에서 읽기 모드를 종료 될 때까지 또는 시간 제한 간격이 경과할 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-529">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="70286-530">쓰기 모드를 시작 하려고 대기 중인 스레드가 차단 됩니다, 읽기 모드 또는 업그레이드 가능 모드를 시작 하려고 하는 추가 스레드 대기 중인 모든 스레드가 쓰기 모드는 하거나 시간 초과 또는 쓰기 모드가 시작 하 고 시작 된 다음 종료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-530">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70286-531">재귀 잠금을 허용 하는 경우 쓰기 모드로 잠금을 시작 하는 스레드는 다른 스레드에서 쓰기 모드를 시작 하려고 대기 중인 경우에 재귀적으로 쓰기 모드를 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-531">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="70286-532"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 속성이 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />이고 현재 스레드에서 이미 잠금을 시작한 경우</span><span class="sxs-lookup"><span data-stu-id="70286-532">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
 <span data-ttu-id="70286-533">또는</span><span class="sxs-lookup"><span data-stu-id="70286-533">-or-</span></span>  
  
 <span data-ttu-id="70286-534">현재 스레드에서 초기에 읽기 모드로 잠금을 시작했으므로 쓰기 모드를 시작하려고 하면 교착 상태가 발생할 수 있는 경우</span><span class="sxs-lookup"><span data-stu-id="70286-534">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
 <span data-ttu-id="70286-535">또는</span><span class="sxs-lookup"><span data-stu-id="70286-535">-or-</span></span>  
  
 <span data-ttu-id="70286-536">재귀 횟수가 카운터의 용량을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-536">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="70286-537">이 제한은 매우 크므로 일반적으로 응용 프로그램에서 초과되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-537">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="70286-538"><paramref name="timeout" />의 값이 음수이지만 유일하게 허용되는 음수 값인 -1밀리초가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="70286-538">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
 <span data-ttu-id="70286-539">또는</span><span class="sxs-lookup"><span data-stu-id="70286-539">-or-</span></span>  
  
 <span data-ttu-id="70286-540"><paramref name="timeout" />의 값이 <see cref="F:System.Int32.MaxValue" />밀리초보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="70286-540">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="70286-541"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-541">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70286-542">읽기 모드로 잠금을 시작하려고 대기 중인 스레드의 총 개수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="70286-542">Gets the total number of threads that are waiting to enter the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="70286-543">읽기 모드를 시작하려고 대기 중인 스레드의 총 개수입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-543">The total number of threads that are waiting to enter read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-544">이 속성을 사용 하 여 디버깅, 프로 파일링 및 로깅 목적으로 대해서만 하 고 하지 않는 알고리즘의 동작을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-544">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="70286-545">결과 계산 되는 즉시 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-545">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="70286-546">따라서이 속성에 따라 결정을 내릴 수 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-546">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-547">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> 속성을 읽기 모드 차단 되는 스레드 수가 임계값을 초과 하는 경우 이벤트 로그 항목을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-547">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70286-548">업그레이드 가능 모드로 잠금을 시작하려고 대기 중인 스레드의 총 개수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="70286-548">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="70286-549">업그레이드 가능 모드를 시작하려고 대기 중인 스레드의 총 개수입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-549">The total number of threads that are waiting to enter upgradeable mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-550">이 속성을 사용 하 여 디버깅, 프로 파일링 및 로깅 목적으로 대해서만 하 고 하지 않는 알고리즘의 동작을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-550">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="70286-551">결과 계산 되는 즉시 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-551">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="70286-552">따라서이 속성에 따라 결정을 내릴 수 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-552">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-553">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> 업그레이드 가능 모드 차단 되는 스레드 수가 임계값을 초과 하는 경우 이벤트 로그 항목을 생성 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-553">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70286-554">쓰기 모드로 잠금을 시작하려고 대기 중인 스레드의 총 개수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="70286-554">Gets the total number of threads that are waiting to enter the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="70286-555">쓰기 모드를 시작하려고 대기 중인 스레드의 총 개수입니다.</span><span class="sxs-lookup"><span data-stu-id="70286-555">The total number of threads that are waiting to enter write mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70286-556">이 속성을 사용 하 여 디버깅, 프로 파일링 및 로깅 목적으로 대해서만 하 고 하지 않는 알고리즘의 동작을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-556">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="70286-557">결과 계산 되는 즉시 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-557">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="70286-558">따라서이 속성에 따라 결정을 내릴 수 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70286-558">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70286-559">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> 속성을 쓰기 모드 차단 되는 스레드 수가 임계값을 초과 하는 경우 이벤트 로그 항목을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="70286-559">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>