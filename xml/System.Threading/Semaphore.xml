<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Semaphore.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Limits the number of threads that can access a resource or pool of resources concurrently.</source>
          <target state="translated">리소스 또는 리소스 풀에 동시에 액세스할 수 있는 스레드 수를 제한합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class to control access to a pool of resources.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 리소스 풀에 대 한 액세스를 제어 하는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Threads enter the semaphore by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method, which is inherited from the <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> class, and release the semaphore by calling the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">호출 하 여 세마포를 입력 하는 스레드는 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 에서 상속 된 메서드는 <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> 클래스를 호출 하 여 세마포를 해제는 <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</source>
          <target state="translated">최대값에 도달한 세마포에 스레드가 세마포를 입력 하 고 스레드가 세마포를 해제 하는 경우에 증가 될 때마다 감소 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>When the count is zero, subsequent requests block until other threads release the semaphore.</source>
          <target state="translated">수가 0 경우 후속 요청이 다른 스레드가 세마포를 해제할 때까지 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</source>
          <target state="translated">모든 스레드가 세마포를 해제 수는 최대 값 지정 된 세마포를 만들 때.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</source>
          <target state="translated">예: FIFO 또는 차단 된 스레드가 세마포를 입력할 수 있는 LIFO 보장 된 순서 없이 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>A thread can enter the semaphore multiple times, by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method repeatedly.</source>
          <target state="translated">스레드가 세마포에 들어갈 수를 여러 번 호출 하 여는 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 메서드 반복적으로 합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>To release some or all of these entries, the thread can call the parameterless <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload multiple times, or it can call the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload that specifies the number of entries to be released.</source>
          <target state="translated">이러한 항목의 일부나 전부를 해제 하려면 스레드가 매개 변수가 없는 호출 수 <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> 메서드 오버 로드를 여러 번 이거나 호출할 수는 <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> 해제할 항목 수를 지정 하는 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity on calls to <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 클래스에 대 한 호출에 스레드 id를 적용 하지 않습니다 <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 또는 <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</source>
          <target state="translated">프로그래머의는 스레드를 놓지 마십시오 세마포 너무 여러 번 확인 해야 합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</source>
          <target state="translated">예를 들어 세마포의 최대 개수가 2개인데 스레드 A와 스레드 B가 모두 세마포를 입력한다고 가정해 보겠습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>If a programming error in thread B causes it to call <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> twice, both calls succeed.</source>
          <target state="translated">스레드 B에서에서 프로그래밍 오류가 있으면 호출로 인해 <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> 을 두 번 두 호출은 모두 성공 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The count on the semaphore is full, and when thread A eventually calls <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>, a <ph id="ph2">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown.</source>
          <target state="translated">그러면 세마포 개수가 다 차서 스레드 A가 <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>를 호출하면 <ph id="ph2">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph>이 throw됩니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Semaphores are of two types: local semaphores and named system semaphores.</source>
          <target state="translated">세마포는 다음 두 가지 유형: 로컬 세마포 및 명명 된 시스템 세마포 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>If you create a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</source>
          <target state="translated">만드는 경우는 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 개체 이름을 허용 하는 생성자를 사용 하 여 해당 이름의 운영 체제 세마포와 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</source>
          <target state="translated">명명 된 시스템 세마포 운영 체제 전체에 표시 되며 프로세스 작업을 동기화 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore, and you can use the <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method to open an existing named system semaphore.</source>
          <target state="translated">여러 개 만들 수 있습니다 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 명명 된 시스템 세마포를 동일한 나타내는 개체를 사용할 수 있습니다 및는 <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> 기존 여 메서드를 명명 된 시스템 세마포 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>A local semaphore exists only within your process.</source>
          <target state="translated">로컬 세마포가 프로세스 내에 존재합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>It can be used by any thread in your process that has a reference to the local <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">로컬 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 개체에 대한 참조가 있는 프로세스의 모든 스레드에서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object is a separate local semaphore.</source>
          <target state="translated">각 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 개체는 별도 로컬 세마포입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">다음 코드 예제에서는 세 개의 최대 개수 및 0에 대 한 초기 카운트 세마포를 만듭니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">이 예제에서는 세마포를 기다리는 동안 차단 5 개의 스레드를 시작 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">주 스레드에서 <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> 메서드 오버 로드 세마포 개수 세마포를 입력 하려면 3 개의 스레드를 허용 된 최대값을 늘릴 수 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">사용 하 여 각 스레드에 <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> 1 초 동안 작업을 시뮬레이션 한 다음 호출을 대기 하는 메서드는 <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> 메서드 오버 로드 세마포를 해제 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">세마포가 해제 될 때마다 이전 세마포 수가 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Console messages track semaphore use.</source>
          <target state="translated">콘솔 메시지 세마포 사용을 추적 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">출력을 보다 쉽게 읽을 수 있도록 각 스레드에 대 한 시뮬레이션 된 작업 간격이 약간 향상 됩니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>This type is thread safe.</source>
          <target state="translated">이 형식은 스레드로부터 안전합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The initial number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">세마포에 동시에 부여할 수 있는 초기 요청 수입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The maximum number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">세마포에 동시에 부여할 수 있는 최대 요청 수입니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries.</source>
          <target state="translated">초기 항목 수 및 최대 동시 항목 수를 지정하여 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>This constructor initializes an unnamed semaphore.</source>
          <target state="translated">이 생성자는 명명 되지 않은 세마포를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>All threads that use an instance of such a semaphore must have references to the instance.</source>
          <target state="translated">이러한 세마포의 인스턴스를 사용 하는 모든 스레드는 인스턴스에 대 한 참조가 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, the effect is the same as if the current thread had called <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) times.</source>
          <target state="translated">경우 <ph id="ph1">`initialCount`</ph> 는 보다 작은 <ph id="ph2">`maximumCount`</ph>, 마치 현재 스레드를 호출 하는 경우의 결과 같습니다 <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> 뺀 <ph id="ph5">`initialCount`</ph>) 시간입니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for <ph id="ph1">`maximumCount`</ph> and <ph id="ph2">`initialCount`</ph>.</source>
          <target state="translated">세마포를 만드는 스레드는 엔트리를 예약 하지 않을 경우 같은 숫자를 사용 하 여 <ph id="ph1">`maximumCount`</ph> 및 <ph id="ph2">`initialCount`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The following example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">다음 예제에서는 세마포의 최대 개수가 3 및 0에 대 한 초기 카운트</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">이 예제에서는 세마포를 기다리는 동안 차단 5 개의 스레드를 시작 합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">주 스레드에서 <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> 메서드 오버 로드 세마포 개수 세마포를 입력 하려면 3 개의 스레드를 허용 된 최대값을 늘릴 수 있습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">사용 하 여 각 스레드에 <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> 1 초 동안 작업을 시뮬레이션 한 다음 호출을 대기 하는 메서드는 <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> 메서드 오버 로드 세마포를 해제 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">세마포가 해제 될 때마다 이전 세마포 수가 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Console messages track semaphore use.</source>
          <target state="translated">콘솔 메시지 세마포 사용을 추적 합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">출력을 보다 쉽게 읽을 수 있도록 각 스레드에 대 한 시뮬레이션 된 작업 간격이 약간 향상 됩니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>보다 큰 경우</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph>가 1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph>가 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The initial number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">세마포에 동시에 부여할 수 있는 초기 요청 수입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The maximum number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">세마포에 동시에 부여할 수 있는 최대 요청 수입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">명명된 시스템 세마포 개체의 이름입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</source>
          <target state="translated">초기 항목 수 및 최대 동시 항목 수를 지정하고 선택적으로 시스템 세마포 개체의 이름을 지정하여 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 명명된 된 시스템 세마포를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">여러 개 만들 수 있습니다 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 명명 된 시스템 세마포를 나타내는 동일한 개체입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">초기 카운트 및로 지정 된 최대 수로 생성 된 명명 된 시스템 세마포에 없는 경우 <ph id="ph1">`initialCount`</ph> 및 <ph id="ph2">`maximumCount`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">명명 된 시스템 세마포가 이미 있는 경우 <ph id="ph1">`initialCount`</ph> 및 <ph id="ph2">`maximumCount`</ph> 잘못 된 값에는 예외가 발생 하더라도 있지만 사용 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you need to determine whether or not a named system semaphore was created, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor overload instead.</source>
          <target state="translated">확인 해야 하는 경우 명명된 된 시스템 세마포를 만들지 여부, 사용 된 <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> 생성자 오버 로드를 대신 합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>When you use this constructor overload, the recommended practice is to specify the same number for <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">권장 되는 방법에 대 한 동일한 수를 지정 하는 것이 생성자 오버 로드를 사용 하면 <ph id="ph1">`initialCount`</ph> 및 <ph id="ph2">`maximumCount`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and a named system semaphore is created, the effect is the same as if the current thread had called <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) times.</source>
          <target state="translated">경우 <ph id="ph1">`initialCount`</ph> 는 보다 작은 <ph id="ph2">`maximumCount`</ph>, 및 명명된 된 시스템 세마포 만들어지고, 현재 스레드 마치 호출 하는 경우의 결과 같습니다 <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> 뺀 <ph id="ph5">`initialCount`</ph>) 시간입니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>However, with this constructor overload there is no way to determine whether a named system semaphore was created.</source>
          <target state="translated">그러나,이 생성자 오버 로드를 가진 없기 명명 된 시스템 세마포가 만들어졌는지 여부를 확인할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">지정 하는 경우 <ph id="ph1">`null`</ph> 또는 빈 문자열을 <ph id="ph2">`name`</ph>를 호출한 것 처럼 로컬 세마포가 만들어집니다는 <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> 생성자 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">명명 된 세마포에서 운영 체제 전체에 표시 되므로 프로세스 경계를 넘어 리소스 사용을 조정 데 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you want to find out whether a named system semaphore exists, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">명명 된 시스템 세마포가 있는지 여부를 알아보려면, 사용 하려는 경우는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> 메서드는 기존 명명 된 세마포를 열려고 시도 하 고 시스템 세마포가 존재 하지 않는 경우 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore.</source>
          <target state="translated">다음 코드 예제에서는 명명된 된 세마포의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The example creates a named semaphore with a maximum count of five and an initial count of five.</source>
          <target state="translated">이 예제에서는 명명된 된 세마포 최대 개수가 5와 5에 대 한 초기 카운트</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The program makes three calls to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">프로그램을 세 번 호출 된 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">따라서 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 두 번째 복사본은 차단에 대 한 세 번째 호출에서 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Release one or more entries in the first copy of the program to unblock the second.</source>
          <target state="translated">두 번째 차단을 해제 하려면 프로그램의 첫 번째 복사본에 있는 하나 이상의 항목을 해제 합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>보다 큰 경우</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph>가 1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph>가 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">명명된 세마포가 존재하고 이 세마포에 액세스 제어 보안이 있고 사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>이 없는 경우</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 세마포를 만들 수 없는 경우</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">명명 된 시스템 세마포를 만들지 비관리 코드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">보안 동작: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The initial number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">동시에 충족될 수 있는 세마포의 초기 요청 수입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The maximum number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">동시에 충족될 수 있는 세마포의 최대 요청 수입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">명명된 시스템 세마포 개체의 이름입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local semaphore was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system semaphore was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system semaphore already existed.</source>
          <target state="translated">이 메서드가 반환될 때 로컬 세마포가 만들어진 경우(즉, <bpt id="p1">&lt;c&gt;</bpt>이름<ept id="p1">&lt;/c&gt;</ept>이 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이거나 빈 문자열인 경우) 또는 지정한 명명된 시스템 세마포가 만들어진 경우에는 <ph id="ph1">&lt;see langword="true" /&gt;</ph>가 포함되고, 지정한 명명된 시스템 세마포가 이미 있는 경우에는 <ph id="ph3">&lt;see langword="false" /&gt;</ph>가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</source>
          <target state="translated">초기 항목 수 및 최대 동시 항목 수를 지정하고, 선택적으로 시스템 세마포 개체의 이름을 지정하고, 새 시스템 세마포가 만들어졌는지 여부를 나타내는 값을 받을 변수를 지정하여 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 명명된 된 시스템 세마포를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">여러 개 만들 수 있습니다 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 명명 된 시스템 세마포를 나타내는 동일한 개체입니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">초기 카운트 및로 지정 된 최대 수로 생성 된 명명 된 시스템 세마포에 없는 경우 <ph id="ph1">`initialCount`</ph> 및 <ph id="ph2">`maximumCount`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">명명 된 시스템 세마포가 이미 있는 경우 <ph id="ph1">`initialCount`</ph> 및 <ph id="ph2">`maximumCount`</ph> 잘못 된 값에는 예외가 발생 하더라도 있지만 사용 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Use <ph id="ph1">`createdNew`</ph> to determine whether the system semaphore was created.</source>
          <target state="translated">사용 하 여 <ph id="ph1">`createdNew`</ph> 시스템 세마포가 만들어졌는지 여부를 확인 하려면.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and <ph id="ph3">`createdNew`</ph> is <ph id="ph4">`true`</ph>, the effect is the same as if the current thread had called <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) times.</source>
          <target state="translated">경우 <ph id="ph1">`initialCount`</ph> 는 보다 작은 <ph id="ph2">`maximumCount`</ph>, 및 <ph id="ph3">`createdNew`</ph> 은 <ph id="ph4">`true`</ph>, 마치 현재 스레드를 호출 하는 경우의 결과 같습니다 <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> 뺀 <ph id="ph7">`initialCount`</ph>) 시간입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">지정 하는 경우 <ph id="ph1">`null`</ph> 또는 빈 문자열을 <ph id="ph2">`name`</ph>를 호출한 것 처럼 로컬 세마포가 만들어집니다는 <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> 생성자 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">이 경우 <ph id="ph1">`createdNew`</ph> 항상 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">명명 된 세마포에서 운영 체제 전체에 표시 되므로 프로세스 경계를 넘어 리소스 사용을 조정 데 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore.</source>
          <target state="translated">다음 코드 예제에서는 명명된 된 세마포의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The example creates a named semaphore with a maximum count of five and an initial count of two.</source>
          <target state="translated">이 예제에서는 5 개의 최대 개수 및 초기 카운트 2와 명명된 된 세마포를 만듭니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>That is, it reserves three entries for the thread that calls the constructor.</source>
          <target state="translated">즉, 세 항목에 대 한 생성자를 호출 하는 스레드를 예약 합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`createNew`</ph> is <ph id="ph2">`false`</ph>, the program makes three calls to the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">경우 <ph id="ph1">`createNew`</ph> 은 <ph id="ph2">`false`</ph>, 프로그램을 세 번 호출 된 <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">따라서 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 두 번째 복사본은 차단에 대 한 세 번째 호출에서 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Release one or more entries in the first copy of the program to unblock the second.</source>
          <target state="translated">두 번째 차단을 해제 하려면 프로그램의 첫 번째 복사본에 있는 하나 이상의 항목을 해제 합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>보다 큰 경우</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph>가 1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph>가 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">명명된 세마포가 존재하고 이 세마포에 액세스 제어 보안이 있고 사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>이 없는 경우</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 세마포를 만들 수 없는 경우</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">명명 된 시스템 세마포를 만들지 비관리 코드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">보안 동작: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The initial number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">동시에 충족될 수 있는 세마포의 초기 요청 수입니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The maximum number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">동시에 충족될 수 있는 세마포의 최대 요청 수입니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">명명된 시스템 세마포 개체의 이름입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local semaphore was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system semaphore was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system semaphore already existed.</source>
          <target state="translated">이 메서드가 반환될 때 로컬 세마포가 만들어진 경우(즉, <bpt id="p1">&lt;c&gt;</bpt>이름<ept id="p1">&lt;/c&gt;</ept>이 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이거나 빈 문자열인 경우) 또는 지정한 명명된 시스템 세마포가 만들어진 경우에는 <ph id="ph1">&lt;see langword="true" /&gt;</ph>가 포함되고, 지정한 명명된 시스템 세마포가 이미 있는 경우에는 <ph id="ph3">&lt;see langword="false" /&gt;</ph>가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system semaphore.</source>
          <target state="translated">명명된 시스템 세마포에 적용할 액세스 제어 보안을 나타내는 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</source>
          <target state="translated">초기 항목 수 및 최대 동시 항목 수를 지정하고, 선택적으로 시스템 세마포 개체의 이름을 지정하고, 새 시스템 세마포가 만들어졌는지 여부를 나타내는 값을 받을 변수를 지정하고, 시스템 세마포에 대한 액세스 제어 보안을 지정하여 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</source>
          <target state="translated">이 생성자를 사용 하 여 다른 코드에서 세마포의 제어권 갖지 못하게를 만들 때 명명 된 시스템 세마포에 액세스 제어 보안을 적용 합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 명명된 된 시스템 세마포를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">여러 개 만들 수 있습니다 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 명명 된 시스템 세마포를 나타내는 동일한 개체입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore does not exist, it is created with the specified access control security.</source>
          <target state="translated">명명된 된 시스템 세마포에 없는 경우 지정 된 액세스 제어 보안을 사용 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named semaphore exists, the specified access control security is ignored.</source>
          <target state="translated">명명 된 세마포 있으면 지정 된 액세스 제어 보안은 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object even if <ph id="ph2">`semaphoreSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">새로 만든에 대 한 모든 권한을 호출자에 게 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 경우에도 개체 <ph id="ph2">`semaphoreSecurity`</ph> 거부 없거나 현재 사용자에 게 일부 액세스 권한을 부여에 실패 합니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object to represent the same named semaphore, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">그러나 현재 사용자가 다른 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 개체를 나타내는 동일한 명명 된 세마포를 사용 하 여 생성자 또는 <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> 메서드를 Windows 액세스 제어 보안 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">초기 카운트 및로 지정 된 최대 수로 생성 된 명명 된 시스템 세마포에 없는 경우 <ph id="ph1">`initialCount`</ph> 및 <ph id="ph2">`maximumCount`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">명명 된 시스템 세마포가 이미 있는 경우 <ph id="ph1">`initialCount`</ph> 및 <ph id="ph2">`maximumCount`</ph> 잘못 된 값에는 예외가 발생 하더라도 있지만 사용 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Use the <ph id="ph1">`createdNew`</ph> parameter to determine whether the system semaphore was created by this constructor.</source>
          <target state="translated">사용 하 여 <ph id="ph1">`createdNew`</ph> 매개 변수를이 생성자에 의해 시스템 세마포가 만들어졌는지 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and <ph id="ph3">`createdNew`</ph> is <ph id="ph4">`true`</ph>, the effect is the same as if the current thread had called <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) times.</source>
          <target state="translated">경우 <ph id="ph1">`initialCount`</ph> 는 보다 작은 <ph id="ph2">`maximumCount`</ph>, 및 <ph id="ph3">`createdNew`</ph> 은 <ph id="ph4">`true`</ph>, 마치 현재 스레드를 호출 하는 경우의 결과 같습니다 <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> 뺀 <ph id="ph7">`initialCount`</ph>) 시간입니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">지정 하는 경우 <ph id="ph1">`null`</ph> 또는 빈 문자열을 <ph id="ph2">`name`</ph>를 호출한 것 처럼 로컬 세마포가 만들어집니다는 <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> 생성자 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">이 경우 <ph id="ph1">`createdNew`</ph> 항상 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">명명 된 세마포에서 운영 체제 전체에 표시 되므로 프로세스 경계를 넘어 리소스 사용을 조정 데 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 세마포의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 세마포의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">세마포가 없는 경우 세마포를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 세마포에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안을 사용 하 고 2의 최대 수와 함께 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 세마포를 엽니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">권한이 변경 된 후 세마포를 입력 하 고 해제 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>보다 큰 경우</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph>가 1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph>가 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">명명된 세마포가 존재하고 이 세마포에 액세스 제어 보안이 있고 사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>이 없는 경우</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 세마포를 만들 수 없는 경우</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">명명 된 시스템 세마포를 만들지 비관리 코드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">보안 동작: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>Gets the access control security for a named system semaphore.</source>
          <target state="translated">명명된 시스템 세마포에 대한 액세스 제어 보안을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security for the named system semaphore.</source>
          <target state="translated">명명된 시스템 세마포에 대한 액세스 제어 보안을 나타내는 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> 메서드 플래그 (비트 OR 연산을 사용 하 여 결합)는 다음과 같은 조합을 사용 하 여 사용 권한을 검색할: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, 및 <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">사용자에 게 있어야 <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> 이 메서드와 세마포를 호출 하는 권한으로 연 해야 <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> 권한.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>On a local semaphore, access control security is irrelevant.</source>
          <target state="translated">로컬 세마포가에서 액세스 제어 보안은 관련이 없습니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object does not represent a named system semaphore, this method returns a <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object that grants all rights to any user.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 이 메서드는 반환 개체가 명명된 된 시스템 세마포를 나타내지 않는는 <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> 모든 사용자에 게 모든 권한을 부여 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 세마포의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 세마포의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">세마포가 없는 경우 세마포를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 세마포에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안을 사용 하 고 2의 최대 수와 함께 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 세마포를 엽니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The access control security for the system semaphore is obtained using the <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> method.</source>
          <target state="translated">사용 하 여 시스템 세마포에 대 한 액세스 제어 보안 가져온는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">권한이 변경 된 후 세마포를 입력 하 고 해제 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object represents a named system semaphore, and the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> rights.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 개체가 명명된 시스템 세마포를 나타내며 사용자에게 <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object represents a named system semaphore and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> rights.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 개체가 명명된 시스템 세마포를 나타내며 <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> 권한으로 열리지 않은 경우</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Windows 98 또는 Windows Millennium Edition에서 지원되지 않는 경우</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Opens a specified named semaphore, if it already exists.</source>
          <target state="translated">이미 있는 경우 지정한 명명된 세마포를 엽니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">열려는 시스템 세마포의 이름입니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Opens the specified named semaphore, if it already exists.</source>
          <target state="translated">이미 있는 경우 지정한 명명된 세마포를 엽니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>An object that represents the named system semaphore.</source>
          <target state="translated">명명된 시스템 세마포를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open the specified named semaphore.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> 메서드는 지정 된 명명 된 세마포를 열려고 합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</source>
          <target state="translated">시스템 세마포가 없는 경우이 메서드는 시스템 세마포를 만들지 않고 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않을 때 시스템 세마포가 만들려는 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 <ph id="ph1">`name`</ph> 동일한 반드시 반환 하지 않는 <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> 있지만 대표 반환 되는 개체가 동일한 명명 된 시스템 세마포 개체입니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">이 메서드 오버 로드 하는 것은 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> 메서드 오버 로드를 지정 하 고 <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to enter the semaphore, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">지정 하는 <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> 플래그 세마포를 입력 하는 스레드를 사용 하 고 지정 하는 <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> 플래그를 호출 하는 스레드를 사용할 수 있습니다는 <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 세마포의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 세마포의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">세마포가 없는 경우 세마포를 사용할 수 있는 권한이 현재 사용자 거부는 하지만 읽기 및 세마포에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안을 사용 하 고 2의 최대 수와 함께 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 세마포를 엽니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</source>
          <target state="translated">권한이 변경 된 후 세마포를 입력 하 고 해제 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The named semaphore does not exist.</source>
          <target state="translated">명명된 세마포가 없는 경우</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">명명된 세마포가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>for calling unmanaged code to open a named system semaphore.</source>
          <target state="translated">명명된 된 시스템 세마포를 열려고 비관리 코드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">보안 동작: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">열려는 시스템 세마포의 이름입니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Opens the specified named semaphore, if it already exists, with the desired security access.</source>
          <target state="translated">이미 있는 경우 지정한 명명된 세마포를 원하는 보안 액세스로 엽니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>An object that represents the named system semaphore.</source>
          <target state="translated">명명된 시스템 세마포를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> 매개 변수를 포함 해야 합니다는 <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> 세마포를 입력 하는 스레드를 허용 하도록 플래그 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> 호출 하는 스레드를 허용 하도록 플래그는 <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open an existing named semaphore.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> 메서드는 기존의 명명 된 세마포를 열려고 합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</source>
          <target state="translated">시스템 세마포가 없는 경우이 메서드는 시스템 세마포를 만들지 않고 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않을 때 시스템 세마포가 만들려는 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 <ph id="ph1">`name`</ph> 동일한 반드시 반환 하지 않는 <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> 있지만 대표 반환 되는 개체가 동일한 명명 된 시스템 세마포 개체입니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 세마포의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 세마포의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">세마포가 없는 경우 세마포를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 세마포에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안을 사용 하 고 2의 최대 수와 함께 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 세마포를 엽니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</source>
          <target state="translated">권한이 변경 된 후 세마포를 입력 하 고 해제 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The named semaphore does not exist.</source>
          <target state="translated">명명된 세마포가 없는 경우</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The named semaphore exists, but the user does not have the desired security access rights.</source>
          <target state="translated">명명된 세마포가 있지만 사용자에게 원하는 보안 액세스 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">명명 된 시스템 세마포를 만들지 비관리 코드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">보안 동작: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Exits the semaphore.</source>
          <target state="translated">세마포를 종료합니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>Exits the semaphore and returns the previous count.</source>
          <target state="translated">세마포를 종료하고 이전 카운트를 반환합니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The count on the semaphore before the <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> method was called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> 메서드가 호출되기 전의 세마포 카운트입니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Threads typically use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method to enter the semaphore, and they typically use this method overload to exit.</source>
          <target state="translated">스레드는 일반적으로 사용 된 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 종료 하려면이 메서드 오버 로드를 사용 하는 메서드를 일반적으로 고 세마포를 입력 합니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> 에 의해 throw 되는 <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> 메서드를 호출 하는 스레드에서 문제가 반드시 나타내지는지 않습니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</source>
          <target state="translated">다른 스레드의 프로그래밍 오류가 해당 스레드 횟수 보다 더 많이 입력 세마포를 종료 원인이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>If the current <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights and the semaphore must have been opened with <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">하는 경우 현재 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 개체가 명명된 된 시스템 세마포를 나타내는 사용자 있어야 <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> 권한 및 세마포 열려 있어야와 <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> 권한.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">다음 코드 예제에서는 세 개의 최대 개수 및 0에 대 한 초기 카운트 세마포를 만듭니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">이 예제에서는 세마포를 기다리는 동안 차단 5 개의 스레드를 시작 합니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">주 스레드에서 <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> 메서드 오버 로드 세마포 개수 세마포를 입력 하려면 3 개의 스레드를 허용 된 최대값을 늘릴 수 있습니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">사용 하 여 각 스레드에 <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> 1 초 동안 작업을 시뮬레이션 한 다음 호출을 대기 하는 메서드는 <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> 메서드 오버 로드 세마포를 해제 합니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">세마포가 해제 될 때마다 이전 세마포 수가 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Console messages track semaphore use.</source>
          <target state="translated">콘솔 메시지 세마포 사용을 추적 합니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">출력을 보다 쉽게 읽을 수 있도록 각 스레드에 대 한 시뮬레이션 된 작업 간격이 약간 향상 됩니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The semaphore count is already at the maximum value.</source>
          <target state="translated">세마포 카운트가 이미 최대값인 경우</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>A Win32 error occurred with a named semaphore.</source>
          <target state="translated">명명된 세마포에서 Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The current semaphore represents a named system semaphore, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</source>
          <target state="translated">현재 세마포가 명명된 시스템 세마포를 나타내지만 사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>가 없는 경우</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The current semaphore represents a named system semaphore, but it was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</source>
          <target state="translated">현재 세마포가 명명된 시스템 세마포를 나타내지만 세마포가 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>를 사용하여 열리지 않은 경우</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The number of times to exit the semaphore.</source>
          <target state="translated">세마포를 종료할 횟수입니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Exits the semaphore a specified number of times and returns the previous count.</source>
          <target state="translated">지정된 횟수만큼 세마포를 종료하고 이전 카운트를 반환합니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The count on the semaphore before the <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> method was called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> 메서드가 호출되기 전의 세마포 카운트입니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</source>
          <target state="translated">스레드가를 입력 한 세마포 여러 번 하는 경우이 메서드 오버 로드에는 전체 세마포 카운트를를 호출 하 여 복원할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> 에 의해 throw 되는 <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> 메서드를 호출 하는 스레드에서 문제가 반드시 나타내지는지 않습니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</source>
          <target state="translated">다른 스레드의 프로그래밍 오류가 해당 스레드 횟수 보다 더 많이 입력 세마포를 종료 원인이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If the current <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights and the semaphore must have been opened with <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">하는 경우 현재 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 개체가 명명된 된 시스템 세마포를 나타내는 사용자 있어야 <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> 권한 및 세마포 열려 있어야와 <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> 권한.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">다음 코드 예제에서는 세 개의 최대 개수 및 0에 대 한 초기 카운트 세마포를 만듭니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">이 예제에서는 세마포를 기다리는 동안 차단 5 개의 스레드를 시작 합니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">주 스레드에서 <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> 메서드 오버 로드 세마포 개수 세마포를 입력 하려면 3 개의 스레드를 허용 된 최대값을 늘릴 수 있습니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">사용 하 여 각 스레드에 <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> 1 초 동안 작업을 시뮬레이션 한 다음 호출을 대기 하는 메서드는 <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> 메서드 오버 로드 세마포를 해제 합니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">세마포가 해제 될 때마다 이전 세마포 수가 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Console messages track semaphore use.</source>
          <target state="translated">콘솔 메시지 세마포 사용을 추적 합니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">출력을 보다 쉽게 읽을 수 있도록 각 스레드에 대 한 시뮬레이션 된 작업 간격이 약간 향상 됩니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="releaseCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="releaseCount" /&gt;</ph>가 1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The semaphore count is already at the maximum value.</source>
          <target state="translated">세마포 카운트가 이미 최대값인 경우</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>A Win32 error occurred with a named semaphore.</source>
          <target state="translated">명명된 세마포에서 Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The current semaphore represents a named system semaphore, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> rights.</source>
          <target state="translated">현재 세마포가 명명된 시스템 세마포를 나타내지만 사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The current semaphore represents a named system semaphore, but it was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> rights.</source>
          <target state="translated">현재 세마포가 명명된 시스템 세마포를 나타내지만 세마포가 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> 권한을 사용하여 열리지 않은 경우</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system semaphore.</source>
          <target state="translated">명명된 시스템 세마포에 적용할 액세스 제어 보안을 나타내는 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>Sets the access control security for a named system semaphore.</source>
          <target state="translated">명명된 시스템 세마포에 대한 액세스 제어 보안을 설정합니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>You can set access control security only on <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent named system semaphores.</source>
          <target state="translated">에 대해서만 액세스 제어 보안을 설정할 수 있습니다 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 명명 된 시스템 세마포를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">사용자에 게 있어야 <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> 이 메서드와 세마포를 호출 하는 권한으로 연 해야 <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> 권한.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 세마포의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 세마포의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">세마포가 없는 경우 세마포를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 세마포에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안을 사용 하 고 2의 최대 수와 함께 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 세마포를 엽니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>After the permissions are changed, using the <ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A&gt;</ph> method, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">사용 권한을 사용 하 여 변경 된 후의 <ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A&gt;</ph> 메서드를 세마포를 입력 하 고 해제 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="semaphoreSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="semaphoreSecurity" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> rights.</source>
          <target state="translated">사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The semaphore was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> rights.</source>
          <target state="translated">세마포가 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> 권한을 사용하여 열리지 않은 경우</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object does not represent a named system semaphore.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 개체가 명명된 시스템 세마포를 나타내지 않는 경우</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">지정한 명명된 세마포(이미 존재하는 경우)를 열고 작업이 성공적으로 수행되었는지 여부를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">열려는 시스템 세마포의 이름입니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">이 메서드가 반환될 때 호출에 성공한 경우에는 명명된 세마포를 나타내는 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 개체를 포함하고 호출에 실패한 경우에는 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을 포함합니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">지정한 명명된 세마포(이미 존재하는 경우)를 열고 작업이 성공했는지를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named semaphore was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">명명된 세마포를 열었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그 열지 않았으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>If the named semaphore does not exist, this method does not create it.</source>
          <target state="translated">명명 된 세마포가 없는 경우이 메서드가 만드는 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않을 때 시스템 세마포가 만들려는 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.</source>
          <target state="translated">대신이 메서드 오버 로드를 사용 하 여 명명 된 세마포 있는지 잘 모르는 경우는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> 세마포 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Semaphore.TryOpenExisting%2A&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">이 메서드 오버 로드 하는 것은 <ph id="ph1">&lt;xref:System.Threading.Semaphore.TryOpenExisting%2A&gt;</ph> 메서드 오버 로드를 지정 하 고 <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to enter the semaphore, and specifying the   <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">지정 하는 <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> 플래그 세마포를 입력 하는 스레드를 사용 하 고 지정 하는 <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> 플래그를 호출 하는 스레드를 사용할 수 있습니다는 <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">명명된 세마포가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">열려는 시스템 세마포의 이름입니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">이 메서드가 반환될 때 호출에 성공한 경우에는 명명된 세마포를 나타내는 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 개체를 포함하고 호출에 실패한 경우에는 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을 포함합니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">지정한 명명된 세마포(이미 존재하는 경우)를 원하는 보안 액세스로 열고 작업이 성공적으로 수행되었는지 여부를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named semaphore was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">명명된 세마포를 열었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그 열지 않았으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>If the named semaphore does not exist, this method does not create it.</source>
          <target state="translated">명명 된 세마포가 없는 경우이 메서드가 만드는 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않을 때 시스템 세마포가 만들려는 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.</source>
          <target state="translated">대신이 메서드 오버 로드를 사용 하 여 명명 된 세마포 있는지 잘 모르는 경우는 <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> 세마포 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> 매개 변수를 포함 해야 합니다는 <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> 세마포를 입력 하는 스레드를 허용 하도록 플래그 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> 호출 하는 스레드를 허용 하도록 플래그는 <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 <ph id="ph1">`name`</ph> 동일한 반드시 반환 하지 않는 <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> 있지만 대표 반환 되는 개체가 동일한 명명 된 시스템 세마포 개체입니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">명명된 세마포가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>