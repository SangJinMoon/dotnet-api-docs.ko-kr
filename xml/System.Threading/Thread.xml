<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="195329e46927ec7485d68643b0c65bff7b6dec83" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51928536" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="0137b-101">스레드를 만들고 제어하며, 해당 속성을 설정하고, 상태를 가져옵니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0137b-101">Creates and controls a thread, sets its priority, and gets its status.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-102">프로세스가 시작 되 면 공용 언어 런타임 응용 프로그램 코드를 실행 하는 단일 포그라운드 스레드를 자동으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="0137b-103">이 기본 포그라운드 스레드 함께 프로세스는 프로세스에 연결 된 프로그램 코드의 일부를 실행 하려면 하나 이상의 스레드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="0137b-104">이러한 스레드는 포그라운드 또는 백그라운드에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="0137b-105">또한 사용할 수 있습니다는 <xref:System.Threading.ThreadPool> 공용 언어 런타임에 의해 관리 되는 작업자 스레드에서 코드를 실행 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="0137b-106">단원 내용</span><span class="sxs-lookup"><span data-stu-id="0137b-106">In this section</span></span>  
  
 <span data-ttu-id="0137b-107">[스레드 시작](#Starting) </span><span class="sxs-lookup"><span data-stu-id="0137b-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="0137b-108">[스레드 개체를 검색합니다.](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="0137b-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="0137b-109">[포그라운드 및 백그라운드 스레드](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="0137b-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="0137b-110">[문화권 및 스레드](#Culture) </span><span class="sxs-lookup"><span data-stu-id="0137b-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="0137b-111">에 대 한 정보를 가져오고 스레드 제어</span><span class="sxs-lookup"><span data-stu-id="0137b-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="0137b-112">스레드 시작</span><span class="sxs-lookup"><span data-stu-id="0137b-112">Starting a thread</span></span>  
 <span data-ttu-id="0137b-113">스레드가 해당 클래스 생성자에서 실행 되는 메서드를 나타내는 대리자를 제공 하 여 스레드를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="0137b-114">다음 호출을 <xref:System.Threading.Thread.Start%2A> 실행을 시작 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="0137b-115"><xref:System.Threading.Thread> 생성자 실행할 메서드를 인수를 전달할 수는 여부에 따라 두 대리자 형식 중 하나를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="0137b-116">전달 메서드에 인수가 없는 경우는 <xref:System.Threading.ThreadStart> 생성자에 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="0137b-117">서명이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="0137b-118">다음 예제를 만들고 실행 하는 스레드를 시작 합니다 `ExecuteInForeground` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="0137b-119">메서드를 일부 스레드 속성에 대 한 정보를 표시 한 다음는 0.5 초 동안 일시 중지 하 고 경과 된 초 수를 표시 하는 루프를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="0137b-120">스레드는 5 초 이상 실행 하는 경우 루프 종료 되 고 스레드가 실행을 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="0137b-121">메서드 인수에 전달 하면를 <xref:System.Threading.ParameterizedThreadStart> 생성자에 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="0137b-122">서명이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="0137b-123">대리자가 실행 한 다음 캐스팅 (C#) 하거나 적절 한 형식 매개 변수를 (Visual Basic)에서는 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="0137b-124">다음 예제는 호출 한다는 점을 제외 하면 이전 쿼리와 동일 합니다 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="0137b-125">이 버전의는 `ExecuteInForeground` 메서드는 루프를 실행 하는 시간 (밀리초)의 대략적인 수를 나타내는 단일 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="0137b-126">에 대 한 참조를 유지할 필요가 없기를 <xref:System.Threading.Thread> 스레드가 시작 된 후 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="0137b-127">스레드가 계속 스레드 프로시저가 완료 될 때까지 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="0137b-128">스레드 개체를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="0137b-129">정적을 사용할 수 있습니다 (`Shared` Visual basic에서) <xref:System.Threading.Thread.CurrentThread%2A> 스레드가 실행 되는 코드에서 현재 실행 중인 스레드에 대 한 참조를 검색할 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="0137b-130">다음 예제에서는 <xref:System.Threading.Thread.CurrentThread%2A> 속성을 기본 응용 프로그램 스레드, 다른 포그라운드 스레드, 백그라운드 스레드 및 스레드 풀 스레드에 대 한 정보를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="0137b-131">포그라운드 및 백그라운드 스레드</span><span class="sxs-lookup"><span data-stu-id="0137b-131">Foreground and background threads</span></span>  
 <span data-ttu-id="0137b-132">인스턴스는 <xref:System.Threading.Thread> 백그라운드 스레드 또는 포그라운드 스레드 클래스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="0137b-133">백그라운드 스레드는 한 가지 예외를 사용 하 여 포그라운드 스레드와 동일 합니다: 모든 포그라운드 스레드가 종료 된 경우 백그라운드 스레드에서 실행 되는 프로세스를 유지 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="0137b-134">모든 포그라운드 스레드가 중지 된 후 런타임이 모든 백그라운드 스레드를 중지 하 고 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="0137b-135">기본적으로 다음 스레드 포그라운드에서 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="0137b-136">기본 응용 프로그램 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="0137b-137">호출 하 여 만들어진 모든 스레드는 <xref:System.Threading.Thread> 클래스 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="0137b-138">다음 스레드는 기본적으로 백그라운드에서 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="0137b-139">런타임에 의해 유지 관리 하는 작업자 스레드 풀을 하는 풀 스레드를 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="0137b-140">사용 하 여 스레드 풀에서 스레드 풀 및 일정 작업을 구성할 수 있습니다는 <xref:System.Threading.ThreadPool> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="0137b-141">작업 기반 비동기 작업은 자동으로 스레드 풀 스레드에 대해 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="0137b-142">작업 기반 비동기 작업을 사용 합니다 <xref:System.Threading.Tasks.Task> 및 <xref:System.Threading.Tasks.Task%601> 클래스를 구현 하는 [작업 기반 비동기 패턴](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="0137b-143">비관리 코드에서 관리 되는 실행 환경에 들어가는 모든 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="0137b-144">스레드에 설정 하 여 백그라운드에서 실행 하도록 변경할 수 있습니다는 <xref:System.Threading.Thread.IsBackground%2A> 언제 든 지 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="0137b-145">백그라운드 스레드는 응용 프로그램이 실행 되 고 있지만 종료 파일 시스템 변경 사항 또는 들어오는 소켓 연결을 모니터링 하는 등의 응용 프로그램을 중지 되지는 않습니다 있다면 계속 해야 하는 모든 작업에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="0137b-146">다음 예제에서는 포그라운드 및 백그라운드 스레드 간의 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="0137b-147">첫 번째 예제와 같은 것은 [스레드 시작](#Starting) 섹션을 제외 하 고 스레드가 시작 하기 전에 백그라운드에서 실행 되도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="0137b-148">출력에서 볼 수 있듯이 5 초 동안 실행 하기 전에 루프 중단 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="0137b-149">문화권 및 스레드</span><span class="sxs-lookup"><span data-stu-id="0137b-149">Culture and threads</span></span>  
 <span data-ttu-id="0137b-150">각 스레드가 문화권을 나타내는 합니다 <xref:System.Threading.Thread.CurrentCulture%2A> 속성인 및 UI 문화권을 나타내는 <xref:System.Threading.Thread.CurrentUICulture%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="0137b-151">현재 문화권을 구문 분석 및 서식 지정, 문자열 비교 및 정렬 등의 문화권 구분 작업을 지원 하 고 또한 된 쓰기 시스템 및 스레드에 의해 사용 되는 달력을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="0137b-152">현재 UI 문화권 리소스 파일에서 리소스의 문화권 구분 검색을 위해 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="0137b-153">합니다 <xref:System.Threading.Thread.CurrentCulture> 고 <xref:System.Threading.Thread.CurrentUICulture> 속성은 현재 스레드를 제외한 모든 스레드를 사용 하 여 사용 하면 안정적으로 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-153">The <xref:System.Threading.Thread.CurrentCulture> and <xref:System.Threading.Thread.CurrentUICulture> properties don't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="0137b-154">.NET framework에서 이러한 속성을 읽는 신뢰할 수 있지만 현재 스레드를 제외한 스레드에 대 한 이러한 속성을 설정 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-154">In .NET Framework, reading these properties is reliable, although setting these properties for a thread other than the current thread is not.</span></span> <span data-ttu-id="0137b-155">.NET Core에는 <xref:System.InvalidOperationException> 스레드가 다른 스레드에서 이러한 속성에 쓰거나 읽을 하려고 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-155">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write these properties on a different thread.</span></span>
> <span data-ttu-id="0137b-156">사용 하는 것이 좋습니다 합니다 <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> 및 <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> 속성을 검색 하 고 현재 문화권을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-156">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> properties to retrieve and set the current culture.</span></span>

 <span data-ttu-id="0137b-157">새 스레드를 인스턴스화하면 해당 문화권 및 UI 문화권 현재 시스템 문화권 및 UI 문화권 및 문화권 및 UI 문화권 새 스레드가 생성 되는 스레드의 아니라 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-157">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="0137b-158">즉, 예를 들어, 현재 시스템 문화권이 영어 (미국) 및 기본 응용 프로그램 스레드의 현재 문화권이 프랑스어 (프랑스) 호출 하 여 만든 새 스레드의 문화권은 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 주 스레드에서 생성자 영어 (미국) 및 프랑스어 (프랑스) 되지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-158">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="0137b-159">자세한 내용은 "문화권 및 스레드" 섹션을 참조 합니다 <xref:System.Globalization.CultureInfo> 클래스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-159">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0137b-160">이 대상으로 하는 앱 용 비동기 작업을 실행 하는 스레드는 적용 되지 않습니다는 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] 비동기의 일부인 이상 버전에서는이 경우, 문화권 및 UI 문화권 및 작업 컨텍스트; 스레드에서 비동기 작업 실행 하 여 기본 문화권 및 비동기 작업이 시작 된 된 스레드의 UI 문화권을 상속 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-160">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="0137b-161">자세한 내용은 <xref:System.Globalization.CultureInfo> 클래스 항목의 “문화권 및 작업 기반 비동기 작업” 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0137b-161">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="0137b-162">하나를 수행 하면 동일한 문화권 및 UI 문화권 공유 응용 프로그램에서 실행 중의 모든 스레드가 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-162">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="0137b-163">전달할 수는 <xref:System.Globalization.CultureInfo> 해당 문화권을 나타내는 개체를 <xref:System.Threading.ParameterizedThreadStart> 대리자 또는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-163">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="0137b-164">실행 중인 앱에 대 한 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 이상 버전, 문화권 및 UI 문화권의 값을 설정 하 여 응용 프로그램 도메인에서 만들어진 모든 스레드를 할당할 수는 정의할 수 있습니다 합니다 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-164">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="0137b-165">이 응용 프로그램별 도메인 설정 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-165">Note that this is a per-application domain setting.</span></span>  

 <span data-ttu-id="0137b-166">자세한 내용 및 예제에 대 한의 "문화권 및 스레드" 섹션을 참조 합니다 <xref:System.Globalization.CultureInfo> 클래스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-166">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="0137b-167">에 대 한 정보를 가져오고 스레드 제어</span><span class="sxs-lookup"><span data-stu-id="0137b-167">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="0137b-168">스레드에 대 한 정보를 제공 하는 속성 값의 수를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-168">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="0137b-169">일부 경우에도 스레드의 작업을 제어 하려면 이러한 속성 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-169">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="0137b-170">이러한 스레드 속성은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-170">These thread properties include:</span></span>  
  
-   <span data-ttu-id="0137b-171">이름</span><span class="sxs-lookup"><span data-stu-id="0137b-171">A name.</span></span> <span data-ttu-id="0137b-172"><xref:System.Threading.Thread.Name%2A> 대 한 쓰기-스레드를 식별 하는 데 사용할 수 있는 속성에 한 번입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-172"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="0137b-173">기본값은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-173">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="0137b-174">호출 하 여 검색할 수 있는 해시 코드를 <xref:System.Threading.Thread.GetHashCode%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-174">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="0137b-175">스레드를 고유 하 게 식별 하려면 해시 코드를 사용할 수 있습니다. 스레드 수명 동안 해당 해시 코드 값을 가져온 응용 프로그램 도메인에 관계 없이 다른 스레드에서 값과 충돌 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-175">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="0137b-176">스레드 id입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-176">A thread ID.</span></span> <span data-ttu-id="0137b-177">읽기 전용 값 <xref:System.Threading.Thread.ManagedThreadId%2A> 속성 런타임에 의해 할당 되 고 해당 프로세스 내에서 스레드를 고유 하 게 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-177">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="0137b-178">관리되지 않는 호스트가 관리되는 스레드와 관리되지 않는 스레드 간의 관계를 제어할 수 있으므로 운영 체제 [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) 는 관리되는 스레드에 대한 고정 관계를 포함하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-178">An operating-system [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="0137b-179">특히, 정교한 호스트를 사용할 수는 [CLR 호스팅 API](https://msdn.microsoft.com/library/ms404385.aspx) 는 동일한 운영 체제 스레드에 대해 관리 되는 여러 스레드를 예약 또는 다른 운영 체제 스레드 간에 관리 되는 스레드를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-179">Specifically, a sophisticated host can use the [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="0137b-180">스레드의 현재 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-180">The thread's current state.</span></span> <span data-ttu-id="0137b-181">존재 기간에 대 한 스레드는 항상 하나 이상 정의한 상태는 <xref:System.Threading.ThreadState> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-181">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="0137b-182">에 정의 된 예약 우선 순위 수준에는 <xref:System.Threading.ThreadPriority> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-182">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="0137b-183">스레드의 우선 순위를 요청 하려면이 값을 설정할 수 있지만 운영 체제에 의해 적용 되는 것 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-183">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="0137b-184">읽기 전용 <xref:System.Threading.Thread.IsThreadPoolThread%2A> 스레드 스레드 풀 스레드에서 여부를 나타내는 속성도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-184">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="0137b-185"><xref:System.Threading.Thread.IsBackground%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="0137b-185">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="0137b-186">자세한 내용은 참조는 [포그라운드 및 백그라운드 스레드](#Foreground) 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-186">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="0137b-187">다음 예제에서는 간단한 스레딩 기능을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-187">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="0137b-188">이 코드는 다음과 유사한 출력을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-188">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="0137b-189">이 형식은 스레드로부터 안전합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0137b-189">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
      <span data-ttu-id="0137b-190">스레드 및 스레딩</span>
      <span class="sxs-lookup">
        <span data-stu-id="0137b-190">Threads and Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">
      <span data-ttu-id="0137b-191">스레드 및 스레딩 사용</span>
      <span class="sxs-lookup">
        <span data-stu-id="0137b-191">Using Threads and Threading</span>
      </span>
    </related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96">
      <span data-ttu-id="0137b-192">Thread 클래스에 대 한 참조 소스</span>
      <span class="sxs-lookup">
        <span data-stu-id="0137b-192">Reference Source for the Thread Class</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-193">
            <see cref="T:System.Threading.Thread" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-193">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="0137b-194">이 스레드의 실행이 시작될 때 호출될 메서드를 나타내는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-194">A delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-195">스레드가 시작될 때 개체가 스레드로 전달될 수 있도록 하는 대리자를 지정하여 <see cref="T:System.Threading.Thread" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-195">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-196">스레드가 만들어질 때 실행 되 고 시작 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-196">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="0137b-197">스레드 실행을 예약 하려면 호출을 <xref:System.Threading.Thread.Start%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-197">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="0137b-198">데이터 개체에 스레드를 전달 하려면 사용 된 <xref:System.Threading.Thread.Start%28System.Object%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-198">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-199">Visual Basic 사용자를 생략할 수는 <xref:System.Threading.ThreadStart> 스레드를 만드는 경우에 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-199">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="0137b-200">사용 된 `AddressOf` 예를 들어, 해당 메서드를 전달 하는 경우 연산자 `Dim t As New Thread(AddressOf ThreadProc)`합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-200">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="0137b-201">Visual Basic에서 자동으로 호출 된 <xref:System.Threading.ThreadStart> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-201">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-202">다음 예제에서는 만들기 및 사용에 대 한 구문을 보여 줍니다는 <xref:System.Threading.ParameterizedThreadStart> 정적 메서드와 인스턴스 메서드를 사용 하 여 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-202">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0137b-203">
            <paramref name="start" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-203">
              <paramref name="start" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">
          <span data-ttu-id="0137b-204">스레드 만들기</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-204">Creating Threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="0137b-205">이 스레드의 실행이 시작될 때 호출될 메서드를 나타내는 <see cref="T:System.Threading.ThreadStart" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-205">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-206">
            <see cref="T:System.Threading.Thread" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-206">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-207">스레드가 만들어질 때 실행 되 고 시작 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-207">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="0137b-208">스레드 실행을 예약 하려면 호출을 <xref:System.Threading.Thread.Start%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-208">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-209">Visual Basic 사용자를 생략할 수는 <xref:System.Threading.ThreadStart> 스레드를 만드는 경우에 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-209">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="0137b-210">사용 된 `AddressOf` 예를 들어 메서드를 전달 하는 경우 연산자 `Dim t As New Thread(AddressOf ThreadProc)`합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-210">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="0137b-211">Visual Basic에서 자동으로 호출 된 <xref:System.Threading.ThreadStart> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-211">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-212">다음 코드 예제에는 정적 메서드를 실행 하는 스레드를 만드는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-212">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="0137b-213">다음 코드 예제에는 인스턴스 메서드를 실행 하는 스레드를 만드는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-213">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0137b-214">
            <paramref name="start" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-214">The <paramref name="start" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">
          <span data-ttu-id="0137b-215">스레드 만들기</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-215">Creating Threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="0137b-216">이 스레드의 실행이 시작될 때 호출될 메서드를 나타내는 <see cref="T:System.Threading.ParameterizedThreadStart" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-216">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <param name="maxStackSize">
          <span data-ttu-id="0137b-217">스레드에서 사용할 최대 스택 크기(바이트)입니다. 실행 파일의 헤더에 지정된 기본 최대 스택 크기를 사용하려면 0을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-217">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span>
          </span>
          <span data-ttu-id="0137b-218">중요 부분적으로 신뢰할 수 있는 코드의 경우 <c>maxStackSize</c>가 기본 스택 크기보다 크면 무시됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-218">Important   For partially trusted code, <c>maxStackSize</c> is ignored if it is greater than the default stack size.</span>
          </span>
          <span data-ttu-id="0137b-219">예외가 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-219">No exception is thrown.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-220">스레드가 시작될 때 스레드로 개체가 전달될 수 있도록 하는 대리자를 지정하고 스레드의 최대 스택 크기를 지정하여 <see cref="T:System.Threading.Thread" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-220">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-221">이 생성자 오버 로드를 사용 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="0137b-221">Avoid using this constructor overload.</span></span> <span data-ttu-id="0137b-222">사용 하는 기본 스택 크기는 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 생성자 오버 로드는 스레드에 대 한 권장 되는 스택 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-222">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="0137b-223">스레드가 메모리 문제, 가장 일반적인 원인은 무한 재귀 등의 오류가 프로그래밍입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-223">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0137b-224">로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]코드 설정할 수 있습니다 완전히 신뢰할 수 있는, `maxStackSize` 기본 스택 크기 (메가바이트) 보다 큰 값으로.</span><span class="sxs-lookup"><span data-stu-id="0137b-224">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="0137b-225">더 큰 값을 지정 하는 경우 `maxStackSize` 코드는 부분 신뢰로 실행 중일 때 `maxStackSize` 무시 됩니다 기본 스택 크기는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-225">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="0137b-226">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-226">No exception is thrown.</span></span> <span data-ttu-id="0137b-227">코드 모든 신뢰 수준에서 설정할 수 있습니다 `maxStackSize` 기본 스택 크기 보다 작은 값으로.</span><span class="sxs-lookup"><span data-stu-id="0137b-227">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-228">부분적으로 신뢰할 수 있는 코드에서 사용할 완전히 신뢰할 수 있는 라이브러리를 개발 하는 스레드를 시작 해야 하는 경우 큰 스택을 필요로 하는 스레드를 만들기 전에 완전 신뢰를 어설션해야 또는 사용할 기본 스택 크기.</span><span class="sxs-lookup"><span data-stu-id="0137b-228">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="0137b-229">이렇게 하지 않으면 스레드에서 실행 되는 코드를 완벽 하 게 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-229">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="0137b-230">경우 `maxStackSize` 작습니다. 최소 스택 크기 보다 최소 스택 크기가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-230">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="0137b-231">경우 `maxStackSize` 배수가 아닌 페이지 크기의 큰 페이지 크기의 배수로 반올림 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-231">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="0137b-232">예를 들어, Windows Vista에는.NET Framework 버전 2.0 사용 중인 경우 256KB (262,144 바이트)는 최소 스택 크기 및 페이지 크기는 64KB (65,536 바이트).</span><span class="sxs-lookup"><span data-stu-id="0137b-232">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-233">Microsoft Windows Windows XP 및 Windows Server 2003 이전 버전에서 `maxStackSize` 무시 되는 실행 파일 헤더에 지정 된 스택 크기는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-233">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="0137b-234">매우 작은 스택 크기를 지정 하는 경우에 스택 오버플로 검색을 사용 하지 않도록 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-234">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="0137b-235">스택에 엄격 하 게 제한 하는 경우를 검색 발생할 수 있습니다 자체 스택 오버플로가 발생 했습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-235">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="0137b-236">스택 오버플로 검색을 사용 하지 않으려면 다음 응용 프로그램 구성 파일을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-236">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0137b-237">
            <paramref name="start" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-237">
              <paramref name="start" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0137b-238">
            <paramref name="maxStackSize" />가 0보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-238">
              <paramref name="maxStackSize" /> is less than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="0137b-239">이 스레드의 실행이 시작될 때 호출될 메서드를 나타내는 <see cref="T:System.Threading.ThreadStart" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-239">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <param name="maxStackSize">
          <span data-ttu-id="0137b-240">스레드에서 사용할 최대 스택 크기(바이트)입니다. 실행 파일의 헤더에 지정된 기본 최대 스택 크기를 사용하려면 0을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-240">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span>
          </span>
          <span data-ttu-id="0137b-241">중요 부분적으로 신뢰할 수 있는 코드의 경우 <c>maxStackSize</c>가 기본 스택 크기보다 크면 무시됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-241">Important   For partially trusted code, <c>maxStackSize</c> is ignored if it is greater than the default stack size.</span>
          </span>
          <span data-ttu-id="0137b-242">예외가 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-242">No exception is thrown.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-243">스레드의 최대 스택 크기를 지정하여 <see cref="T:System.Threading.Thread" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-243">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-244">이 생성자 오버 로드를 사용 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="0137b-244">Avoid using this constructor overload.</span></span> <span data-ttu-id="0137b-245">사용 하는 기본 스택 크기는 <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> 생성자 오버 로드는 스레드에 대 한 권장 되는 스택 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-245">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="0137b-246">스레드가 메모리 문제, 가장 일반적인 원인은 무한 재귀 등의 오류가 프로그래밍입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-246">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0137b-247">로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]코드 설정할 수 있습니다 완전히 신뢰할 수 있는, `maxStackSize` 기본 스택 크기 (메가바이트) 보다 큰 값으로.</span><span class="sxs-lookup"><span data-stu-id="0137b-247">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="0137b-248">더 큰 값을 지정 하는 경우 `maxStackSize` 코드는 부분 신뢰로 실행 중일 때 `maxStackSize` 무시 됩니다 기본 스택 크기는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-248">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="0137b-249">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-249">No exception is thrown.</span></span> <span data-ttu-id="0137b-250">코드 모든 신뢰 수준에서 설정할 수 있습니다 `maxStackSize` 기본 스택 크기 보다 작은 값으로.</span><span class="sxs-lookup"><span data-stu-id="0137b-250">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-251">부분적으로 신뢰할 수 있는 코드에서 사용할 완전히 신뢰할 수 있는 라이브러리를 개발 하는 스레드를 시작 해야 하는 경우 큰 스택을 필요로 하는 스레드를 만들기 전에 완전 신뢰를 어설션해야 또는 사용할 기본 스택 크기.</span><span class="sxs-lookup"><span data-stu-id="0137b-251">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="0137b-252">이렇게 하지 않으면 스레드에서 실행 되는 코드를 완벽 하 게 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-252">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="0137b-253">경우 `maxStackSize` 작습니다. 최소 스택 크기 보다 최소 스택 크기가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-253">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="0137b-254">경우 `maxStackSize` 배수가 아닌 페이지 크기의 큰 페이지 크기의 배수로 반올림 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-254">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="0137b-255">예를 들어, Windows Vista에는.NET Framework 버전 2.0 사용 중인 경우 256KB (262,144 바이트)는 최소 스택 크기 및 페이지 크기는 64KB (65,536 바이트).</span><span class="sxs-lookup"><span data-stu-id="0137b-255">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-256">Microsoft Windows Windows XP 및 Windows Server 2003 이전 버전에서 `maxStackSize` 무시 되는 실행 파일 헤더에 지정 된 스택 크기는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-256">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="0137b-257">매우 작은 스택 크기를 지정 하는 경우에 스택 오버플로 검색을 사용 하지 않도록 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-257">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="0137b-258">스택에 엄격 하 게 제한 하는 경우를 검색 발생할 수 있습니다 자체 스택 오버플로가 발생 했습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-258">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="0137b-259">스택 오버플로 검색을 사용 하지 않으려면 다음 응용 프로그램 구성 파일을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-259">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0137b-260">
            <paramref name="start" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-260">
              <paramref name="start" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0137b-261">
            <paramref name="maxStackSize" />가 0보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-261">
              <paramref name="maxStackSize" /> is less than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-262">이 메서드가 호출되는 스레드에서 <see cref="T:System.Threading.ThreadAbortException" />을 발생시켜 스레드 종료 프로세스를 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-262">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span>
          </span>
          <span data-ttu-id="0137b-263">이 메서드를 호출하면 대개 스레드가 종료됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-263">Calling this method usually terminates the thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-264">이 메서드가 호출되는 스레드에서 <see cref="T:System.Threading.ThreadAbortException" />을 발생시켜 스레드 종료 프로세스를 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-264">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span>
          </span>
          <span data-ttu-id="0137b-265">이 메서드를 호출하면 대개 스레드가 종료됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-265">Calling this method usually terminates the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-266">이 메서드는 스레드에서 호출 되 면 시스템 throw를 <xref:System.Threading.ThreadAbortException> 스레드에서 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-266">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="0137b-267">`ThreadAbortException` 응용 프로그램 코드에서 발견 될 수 있는 특별 한 예외는 이지만 끝날 때 다시 throw 합니다 `catch` 경우가 아니면 차단 <xref:System.Threading.Thread.ResetAbort%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-267">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="0137b-268">`ResetAbort` 취소 요청을 중단 하 고, 수 없고는 `ThreadAbortException` 스레드를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-268">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="0137b-269">실행 되지 않은 `finally` 블록 스레드가 중단 되기 전에 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-269">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-270">스레드 호출 하는 경우 `Abort` 효과 예외를 throw 비슷합니다를 자체적으로 <xref:System.Threading.ThreadAbortException> 즉시 발생 하는 결과 예측할 수.</span><span class="sxs-lookup"><span data-stu-id="0137b-270">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="0137b-271">그러나 한 스레드가 `Abort` 중단 다른 스레드에서 코드 실행을 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-271">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="0137b-272">정적 생성자를 중단 될 수 있는 기회 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-272">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="0137b-273">드문 경우에서 해당 응용 프로그램 도메인에서 생성 되 고 해당 클래스의 인스턴스 못할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-273">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="0137b-274">.NET Framework 버전 1.0 및 1.1에서는 가능성이 있습니다 스레드가 중단 수 하는 동안를 `finally` 블록이 실행 되는 경우에 `finally` 블록이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-274">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="0137b-275">스레드가 중단 즉시 또는 전혀 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-275">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="0137b-276">스레드 제한 없는 계산의 경우 이러한 상황이 발생할 수 있습니다는 `finally` 무한정 중단이 지연 되는 중단 절차의 일부로 호출 되는 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-276">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="0137b-277">스레드가 중단 될 때까지 기다려야 다음을 호출할 수 있습니다 합니다 <xref:System.Threading.Thread.Join%2A> 메서드를 호출한 후 스레드에서 <xref:System.Threading.Thread.Abort%2A> 메서드를 이지만 대기가 종료 됩니다 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-277">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-278">호출 하는 스레드 <xref:System.Threading.Thread.Abort%2A> 스레드가 중단 되는 코드의 보호 된 영역에서 같은 경우 차단할 수는 `catch` 블록 `finally` 블록 또는 제약이 있는 실행 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-278">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="0137b-279">호출 하는 스레드가 <xref:System.Threading.Thread.Abort%2A> 잠금이 필요한 중단 된 스레드를 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-279">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="0137b-280">하는 경우 `Abort` 라고 시작 되지 않은 스레드에서 스레드 될 때 중단 됩니다 <xref:System.Threading.Thread.Start%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-280">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="0137b-281">경우 `Abort` 라고 차단 또는 중지 하는 스레드에서 스레드 중단 이며 완전히 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-281">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="0137b-282">경우 `Abort` 중단 된 스레드에 대해를 <xref:System.Threading.ThreadStateException> 호출한 스레드에서 throw 됩니다 <xref:System.Threading.Thread.Abort%2A>, 및 <xref:System.Threading.ThreadState.AbortRequested> 에 추가 됩니다는 <xref:System.Threading.Thread.ThreadState%2A> 중단 스레드의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-282">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="0137b-283">A <xref:System.Threading.ThreadAbortException> 될 때까지 일시 중단 된 스레드에서 throw 되지 않습니다 <xref:System.Threading.Thread.Resume%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-283">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="0137b-284">하는 경우 `Abort` 비관리 코드를 실행 하는 동안 관리 되는 스레드에서 호출 되는 `ThreadAbortException` 스레드가 관리 코드로 반환 될 때까지 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-284">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="0137b-285">두 번 호출 하는 경우 `Abort` 제공 되는 동시에 상태 정보를 설정 하려면 한 번의 호출 및 실행 하는 다른 호출에 대 한 가능한 것을 `Abort`.</span><span class="sxs-lookup"><span data-stu-id="0137b-285">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="0137b-286">그러나 응용 프로그램이이 상황을 검색할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-286">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="0137b-287">이후에 `Abort` 가 호출 스레드의 상태는 스레드에서 다음을 포함 합니다. <xref:System.Threading.ThreadState.AbortRequested>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-287">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="0137b-288">스레드가 호출에 성공한 결과로 종료 한 후 `Abort`를 스레드 상태가 변경 되기 <xref:System.Threading.ThreadState.Stopped>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-288">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="0137b-289">충분 한 권한이 있는 스레드는의 대상인를 `Abort` 사용 하 여 중단을 취소할 수는 `ResetAbort` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-289">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="0137b-290">호출을 보여 주는 예는 `ResetAbort` 메서드를 참조 합니다 `ThreadAbortException` 클래스.</span><span class="sxs-lookup"><span data-stu-id="0137b-290">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="0137b-291">.NET Core만 해당: 이 멤버는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-291">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="0137b-292">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-292">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-293">중단 중인 스레드가 현재 일시 중단됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-293">The thread that is being aborted is currently suspended.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="0137b-294">스레드에서 고급 작업입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-294">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="0137b-295">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-295">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="0137b-296">스레드 및 스레딩</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-296">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">
          <span data-ttu-id="0137b-297">스레드 및 스레딩 사용</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-297">Using threads and threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">
          <span data-ttu-id="0137b-298">스레드 제거</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-298">Destroying threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">
          <span data-ttu-id="0137b-299">상태와 같이 중단 중인 스레드에서 사용할 수 있는 응용 프로그램 관련 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-299">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-300">이 메서드가 호출되는 스레드에서 <see cref="T:System.Threading.ThreadAbortException" />을 발생시켜 스레드 종료 프로세스를 시작하고, 스레드 종료에 대한 예외 정보를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-300">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span>
          </span>
          <span data-ttu-id="0137b-301">이 메서드를 호출하면 대개 스레드가 종료됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-301">Calling this method usually terminates the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-302">이 메서드는 스레드에서 호출 되 면 시스템 throw를 <xref:System.Threading.ThreadAbortException> 스레드에서 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-302">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="0137b-303">`ThreadAbortException` 응용 프로그램 코드에서 발견 될 수 있는 특별 한 예외는 이지만 끝날 때 다시 throw 합니다 `catch` 경우가 아니면 차단 <xref:System.Threading.Thread.ResetAbort%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-303">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="0137b-304">`ResetAbort` 취소 요청을 중단 하 고, 수 없고는 `ThreadAbortException` 스레드를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-304">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="0137b-305">실행 되지 않은 `finally` 블록 스레드가 중단 되기 전에 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-305">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-306">스레드 호출 하는 경우 `Abort` 효과 예외를 throw 비슷합니다를 자체적으로 <xref:System.Threading.ThreadAbortException> 즉시 발생 하는 결과 예측할 수.</span><span class="sxs-lookup"><span data-stu-id="0137b-306">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="0137b-307">그러나 한 스레드가 `Abort` 중단 다른 스레드에서 코드 실행을 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-307">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="0137b-308">정적 생성자를 중단할 수 없습니다 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-308">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="0137b-309">드문 경우에서 해당 응용 프로그램 도메인에서 생성 되 고 해당 클래스의 인스턴스 못할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-309">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="0137b-310">.NET Framework 버전 1.0 및 1.1에서는 가능성이 있습니다 스레드가 중단 수 하는 동안를 `finally` 블록이 실행 되는 경우에 `finally` 블록이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-310">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="0137b-311">스레드가 중단 즉시 또는 전혀 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-311">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="0137b-312">스레드 제한 없는 계산의 경우 이러한 상황이 발생할 수 있습니다는 `finally` 무한정 중단이 지연 되는 중단 절차의 일부로 호출 되는 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-312">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="0137b-313">스레드가 중단 될 때까지 기다려야 다음을 호출할 수 있습니다 합니다 <xref:System.Threading.Thread.Join%2A> 메서드를 호출한 후 스레드에서 <xref:System.Threading.Thread.Abort%2A> 메서드를 이지만 대기 끝나는 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-313">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-314">호출 하는 스레드 <xref:System.Threading.Thread.Abort%2A> 스레드가 중단 되는 코드의 보호 된 영역에서 같은 경우 차단할 수는 `catch` 블록 `finally` 블록 또는 제약이 있는 실행 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-314">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="0137b-315">호출 하는 스레드가 <xref:System.Threading.Thread.Abort%2A> 잠금이 필요한 중단 된 스레드를 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-315">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="0137b-316">하는 경우 `Abort` 라고 시작 되지 않은 스레드에서 스레드 될 때 중단 됩니다 <xref:System.Threading.Thread.Start%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-316">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="0137b-317">경우 `Abort` 라고 차단 또는 중지 하는 스레드에서 스레드 중단 이며 완전히 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-317">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="0137b-318">경우 `Abort` 중단 된 스레드에 대해를 <xref:System.Threading.ThreadStateException> 호출한 스레드에서 throw 됩니다 <xref:System.Threading.Thread.Abort%2A>, 및 <xref:System.Threading.ThreadState.AbortRequested> 에 추가 됩니다는 <xref:System.Threading.Thread.ThreadState%2A> 중단 스레드의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-318">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="0137b-319">A <xref:System.Threading.ThreadAbortException> 될 때까지 일시 중단 된 스레드에서 throw 되지 않습니다 <xref:System.Threading.Thread.Resume%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-319">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="0137b-320">하는 경우 `Abort` 비관리 코드를 실행 하는 동안 관리 되는 스레드에서 호출 되는 `ThreadAbortException` 스레드가 관리 코드로 반환 될 때까지 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-320">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="0137b-321">두 번 호출 하는 경우 `Abort` 제공 되는 동시에 상태 정보를 설정 하려면 한 번의 호출 및 실행 하는 다른 호출에 대 한 가능한 것을 `Abort`.</span><span class="sxs-lookup"><span data-stu-id="0137b-321">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="0137b-322">그러나 응용 프로그램이이 상황을 검색할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-322">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="0137b-323">이후에 `Abort` 가 호출 스레드의 상태는 스레드에서 다음을 포함 합니다. <xref:System.Threading.ThreadState.AbortRequested>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-323">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="0137b-324">스레드가 호출에 성공한 결과로 종료 한 후 `Abort`를 스레드 상태가 변경 되기 <xref:System.Threading.ThreadState.Stopped>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-324">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="0137b-325">충분 한 권한이 있는 스레드는의 대상인를 `Abort` 사용 하 여 중단을 취소할 수는 `ResetAbort` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-325">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="0137b-326">호출을 보여 주는 예는 `ResetAbort` 메서드를 참조 합니다 `ThreadAbortException` 클래스.</span><span class="sxs-lookup"><span data-stu-id="0137b-326">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-327">다음 코드 예제에서는 스레드 중단 되는 정보를 전달 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-327">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="0137b-328">.NET Core만 해당: 이 멤버는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-328">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="0137b-329">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-329">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-330">중단 중인 스레드가 현재 일시 중단됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-330">The thread that is being aborted is currently suspended.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="0137b-331">스레드에서 고급 작업입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-331">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="0137b-332">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-332">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="0137b-333">스레드 및 스레딩</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-333">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">
          <span data-ttu-id="0137b-334">스레드 및 스레딩 사용</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-334">Using threads and threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">
          <span data-ttu-id="0137b-335">스레드 제거</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-335">Destroying threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-336">모든 스레드에 명명되지 않은 데이터 슬롯을 할당합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-336">Allocates an unnamed data slot on all the threads.</span>
          </span>
          <span data-ttu-id="0137b-337">성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-337">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-338">모든 스레드에 할당된 명명된 데이터 슬롯입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-338">The allocated named data slot on all threads.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="0137b-339">스레드 로컬 저장소 (TLS)를 사용 하 여 두 가지 메커니즘을 제공 하는.NET Framework: 스레드 상대 정적 필드 (즉, 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-339">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="0137b-340">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-340">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="0137b-341">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-341">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="0137b-342">슬롯 모든 스레드가 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-342">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="0137b-343">스레드는 스레드 관련 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-343">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="0137b-344">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-344">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="0137b-345">스레드는 데이터 저장소에 데이터 슬롯을 할당할 수, 저장 및 검색 데이터 슬롯의 값 및 스레드가 만료 된 후 다시 사용에 대 한 슬롯을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-345">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="0137b-346">데이터 슬롯은 스레드 당 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-346">Data slots are unique per thread.</span></span> <span data-ttu-id="0137b-347">다른 스레드가 없습니다. (자식 스레드 하지도 함) 해당 데이터를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-347">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-348">이 섹션에는 두 코드 예제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-348">This section contains two code examples.</span></span> <span data-ttu-id="0137b-349">첫 번째 예제에 사용 하 여 표시 된 필드를 사용 하는 방법을 보여 줍니다는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 저장 하는 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-349">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="0137b-350">두 번째 예제에는 데이터 슬롯을 사용 하 여 동일한 작업을 수행 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-350">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="0137b-351">**첫 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-351">**First Example**</span></span>  
  
 <span data-ttu-id="0137b-352">다음 예제로 표시 된 필드를 사용 하는 방법을 보여 줍니다 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-352">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="0137b-353">이 방법은 두 번째 예제에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-353">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="0137b-354">**두 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-354">**Second Example**</span></span>  
  
 <span data-ttu-id="0137b-355">다음 코드 예제에서는 스레드 관련 정보를 저장 된 데이터 슬롯을 사용 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-355">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="0137b-356">스레드 및 스레딩</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-356">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="0137b-357">스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-357">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="0137b-358">할당할 데이터 슬롯의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-358">The name of the data slot to be allocated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-359">모든 스레드에 명명된 데이터 슬롯을 할당합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-359">Allocates a named data slot on all threads.</span>
          </span>
          <span data-ttu-id="0137b-360">성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-360">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-361">모든 스레드에 할당된 명명된 데이터 슬롯입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-361">The allocated named data slot on all threads.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="0137b-362">스레드 로컬 저장소 (TLS)를 사용 하 여 두 가지 메커니즘을 제공 하는.NET Framework: 스레드 상대 정적 필드 (즉, 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-362">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="0137b-363">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-363">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="0137b-364">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-364">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="0137b-365">스레드는 스레드 관련 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-365">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="0137b-366">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-366">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="0137b-367">스레드는 데이터 저장소에 데이터 슬롯을 할당할 수, 저장 및 검색 데이터 슬롯의 값 및 스레드가 만료 된 후 다시 사용에 대 한 슬롯을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-367">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="0137b-368">데이터 슬롯은 스레드 당 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-368">Data slots are unique per thread.</span></span> <span data-ttu-id="0137b-369">다른 스레드가 없습니다. (자식 스레드 하지도 함) 해당 데이터를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-369">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="0137b-370">사용할 필요는 없습니다 합니다 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 때문에 명명 된 데이터 슬롯을 할당 하는 방법의 <xref:System.Threading.Thread.GetNamedDataSlot%2A> 메서드가 아직 할당 되지 않은 경우 슬롯을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-370">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-371">경우는 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 메서드는, 지정 된 이름 사용 하 여 슬롯에 이미 할당 된 경우 예외를 throw 하기 때문에 프로그램을 시작할 때 주 스레드에서 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-371">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="0137b-372">슬롯을 이미 할당 되어 있는지 여부를 테스트할 방법이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-372">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="0137b-373">이 메서드를 사용 하 여 할당 슬롯을 사용 하 여 해제 해야 <xref:System.Threading.Thread.FreeNamedDataSlot%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-373">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-374">이 섹션에는 두 코드 예제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-374">This section contains two code examples.</span></span> <span data-ttu-id="0137b-375">첫 번째 예제에 사용 하 여 표시 된 필드를 사용 하는 방법을 보여 줍니다는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 저장 하는 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-375">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="0137b-376">두 번째 예제에는 데이터 슬롯을 사용 하 여 동일한 작업을 수행 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-376">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="0137b-377">**첫 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-377">**First Example**</span></span>  
  
 <span data-ttu-id="0137b-378">다음 예제로 표시 된 필드를 사용 하는 방법을 보여 줍니다 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-378">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="0137b-379">이 방법은 두 번째 예제에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-379">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="0137b-380">**두 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-380">**Second Example**</span></span>  
  
 <span data-ttu-id="0137b-381">다음 예제에서는 명명된 된 데이터 슬롯을 사용 하 여 스레드 관련 정보를 저장 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-381">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-382">예제 코드를 사용 하지 않는 합니다 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 메서드를 때문에 <xref:System.Threading.Thread.GetNamedDataSlot%2A> 메서드가 아직 할당 되지 않은 경우 슬롯을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-382">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="0137b-383">경우는 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 메서드는, 프로그램을 시작할 때 주 스레드에서 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-383">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0137b-384">지정한 이름의 명명된 데이터 슬롯이 이미 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-384">A named data slot with the specified name already exists.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="0137b-385">스레드 및 스레딩</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-385">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="0137b-386">스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-386">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-387">이 스레드의 아파트 상태를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-387">Gets or sets the apartment state of this thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-388">
            <see cref="T:System.Threading.ApartmentState" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-388">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span>
          </span>
          <span data-ttu-id="0137b-389">초기 값은 <see langword="Unknown" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-389">The initial value is <see langword="Unknown" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-390">**<xref:System.Threading.Thread.ApartmentState%2A> 속성이 사용 되지 않습니다.**</span><span class="sxs-lookup"><span data-stu-id="0137b-390">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="0137b-391">않는 대안이 합니다 <xref:System.Threading.Thread.GetApartmentState%2A> 아파트 상태를 검색 하는 방법 및 <xref:System.Threading.Thread.SetApartmentState%2A> 아파트 상태를 설정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-391">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="0137b-392">.NET Framework 버전 1.0 및 1.1의 `ApartmentState` 속성으로 단일 스레드 또는 다중 스레드 아파트에서 실행 되는지 나타내기 위해 스레드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-392">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="0137b-393">스레드 상태인 경우이 속성을 설정할 수는 `Unstarted` 또는 `Running` 스레드 상태; 그러나 설정할 수 있습니다 한 번만 스레드에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-393">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="0137b-394">반환 하는 경우 속성에 설정 되어 있지 `Unknown`합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-394">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="0137b-395">사용 하려는 시도가 <xref:System.Threading.Thread.ApartmentState%2A> 아파트 상태가 이미 설정 되어 스레드의 아파트 상태를 설정 하는 속성은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-395">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="0137b-396">그러나 합니다 <xref:System.Threading.Thread.SetApartmentState%2A> 메서드가 throw를 <xref:System.InvalidOperationException> 이 경우.</span><span class="sxs-lookup"><span data-stu-id="0137b-396">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0137b-397">.NET Framework 버전 2.0에서 새 스레드로 초기화 됩니다 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 시작 되기 전에 아파트 상태로 설정 되지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="0137b-397">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="0137b-398">기본 응용 프로그램 스레드가 초기화가 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 기본적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-398">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="0137b-399">기본 응용 프로그램 스레드를 더 이상 설정할 수 없습니다 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> 설정 하 여는 <xref:System.Threading.ApartmentState?displayProperty=nameWithType> 코드의 첫 번째 줄에는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-399">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="0137b-400">사용 된 <xref:System.STAThreadAttribute> 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-400">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="0137b-401">.NET framework 버전 2.0에서의 COM 스레딩 모델이 사용 하 여 c + + 응용 프로그램을 지정할 수 있습니다 합니다 [/CLRTHREADATTRIBUTE (CLR 스레드 특성 설정)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) 링커 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-401">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-402">다음 코드 예제에는 스레드의 아파트 상태를 설정 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-402">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0137b-403">이 속성을 올바르지 않은 아파트 상태[단일 스레드 아파트(<see langword="STA" />) 또는 다중 스레드 아파트(<see langword="MTA" />) 이외의 상태]로 설정하려고 했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-403">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-404">스레드 중단 또는 처리되지 않은 예외로 인해 응용 프로그램 도메인의 다른 작업이 손상될 수 있는 코드 영역이 실행될 수 있다는 사실을 호스트에 알립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-404">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-405">Microsoft SQL Server 2005와 같은 공용 언어 런타임 (CLR)의 호스트에는 오류 코드의 중요 한 및 중요 하지 않은 영역에 대해 다른 정책을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-405">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="0137b-406">중요 영역은는 스레드 중단 또는 처리 되지 않은 예외가 미치는 국한 되지 않는 현재 작업에 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-406">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="0137b-407">반면, 중단 이나 오류 코드는 중요 하지 않은 영역에서 오류가 발생 하는 작업을만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-407">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="0137b-408">예를 들어, 잠금을 보유 하는 동안 메모리 할당을 시도 하는 작업을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-408">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="0137b-409">메모리 할당이 실패 하면 현재 작업이 중단 되지의 안정성을 보장 하는 데 충분 합니다 <xref:System.AppDomain>이므로 도메인에 동일한 잠금을 대기 하는 다른 작업이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-409">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="0137b-410">현재 작업이 종료 되는 경우 다른 작업은 교착 상태 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-410">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="0137b-411">중요 한 영역에서 오류가 발생 하는 경우 호스트 수도 전체 언로드 <xref:System.AppDomain> 잠재적으로 불안정 한 상태의 실행을 계속의 위험을 감수 하지 않고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-411">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="0137b-412">호출 코드는 중요 한 영역을 입력 하는 호스트를 알리는, <xref:System.Threading.Thread.BeginCriticalRegion%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-412">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="0137b-413">호출 <xref:System.Threading.Thread.EndCriticalRegion%2A> 실행 코드의 중요 하지 않은 영역을 반환 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="0137b-413">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="0137b-414">이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행 되도록 코드가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-414">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-415">다음 예제에서는 사용 된 <xref:System.Threading.Thread.BeginCriticalRegion%2A> 및 <xref:System.Threading.Thread.EndCriticalRegion%2A> 코드 블록을 중요 하 고 중요 하지 않은 영역으로 나누는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-415">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-416">관리되는 코드가 현재 실제 운영 체제 스레드의 ID에 종속되는 명령을 실행하려고 한다는 사실을 호스트에 알립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-416">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-417">Microsoft SQL Server 2005와 같은 공용 언어 런타임의 일부 호스트는 고유한 스레드 관리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-417">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="0137b-418">고유한 스레드 관리를 제공 하는 호스트 간에 이동할 수는 실행 중인 작업 한 실제 운영 체제 스레드에서 언제 든 지 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-418">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="0137b-419">이 전환 하 여 대부분의 작업을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-419">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="0137b-420">그러나 일부 작업에는 스레드 선호도-즉, 실제 운영 체제 스레드의 id에 의존 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-420">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="0137b-421">이러한 작업 전환 해야 하는 코드를 실행 하는 해당 호스트에 게 알려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-421">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="0137b-422">예를 들어 운영 체제를 획득 하는 사용자 응용 프로그램 호출 시스템 API를 잠그는 경우에 Win32 CRITICAL_SECTION 같은 스레드 선호도 있는 호출 해야 합니다 <xref:System.Threading.Thread.BeginThreadAffinity%2A> 잠금을 획득 하기 전에 및 <xref:System.Threading.Thread.EndThreadAffinity%2A> 후 잠금을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-422">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="0137b-423">이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행 되도록 코드가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-423">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-424">다음 예제에서는 사용 된 <xref:System.Threading.Thread.BeginThreadAffinity%2A> 및 <xref:System.Threading.Thread.EndThreadAffinity%2A> 코드 블록을 실제 운영 체제 스레드의 id에 의존 하는 호스트에 알리기 위해 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-424">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="0137b-425">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-425">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0137b-426">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-426">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0137b-427">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-427">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-428">스레드가 실행 중인 현재 컨텍스트를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-428">Gets the current context in which the thread is executing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-429">현재 스레드 컨텍스트를 나타내는 <see cref="T:System.Runtime.Remoting.Contexts.Context" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-429">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="0137b-430">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-430">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0137b-431">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-431">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0137b-432">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-432">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-433">현재 스레드에 대한 문화권을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-433">Gets or sets the culture for the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-434">현재 스레드에 대한 문화권을 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-434">An object that represents the culture for the current thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-435"><xref:System.Globalization.CultureInfo> 날짜에 대 한 기본 형식, 시간, 숫자, 통화 값, 텍스트의 순서를 정렬, 규칙, 대/소문자를 확인 하 고 문자열을 비교 하는 연결된 된 개체와 함께이 속성에 의해 반환 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-435">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="0137b-436">참조 된 <xref:System.Globalization.CultureInfo> 문화권 이름 및 식별자, 고정, 중립 및 특정 문화권 간의 차이점에 대해 자세히 알아보려면 클래스 및 응용 프로그램 도메인과 스레드 방식으로 문화권 정보에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-436">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="0137b-437">참조 된 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 스레드의 기본 문화권을 결정 하는 방법을 알아보고 사용자가 자신의 컴퓨터에 대 한 문화권 정보를 설정 하는 방법에 대 한 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-437">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="0137b-438"><xref:System.Threading.Thread.CurrentCulture> 속성은 현재 스레드를 제외한 모든 스레드를 사용 하 여 사용 하면 안정적으로 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-438">The <xref:System.Threading.Thread.CurrentCulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="0137b-439">.NET framework에서 속성을 읽는 신뢰할 수 있지만 현재 스레드 이외의 스레드가 설정 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-439">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="0137b-440">.NET Core에는 <xref:System.InvalidOperationException> 스레드 읽기 또는 쓰기를 시도할 경우 throw 되는 <xref:System.Threading.Thread.CurrentCulture> 다른 스레드에서 속성.</span><span class="sxs-lookup"><span data-stu-id="0137b-440">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentCulture> property on a different thread.</span></span>
> <span data-ttu-id="0137b-441">사용 하는 것이 좋습니다는 <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> 속성을 검색 하 고 현재 문화권을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-441">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="0137b-442">부터 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]를 설정할 수 있습니다는 <xref:System.Threading.Thread.CurrentCulture%2A> 중립 문화권에 대 한 속성.</span><span class="sxs-lookup"><span data-stu-id="0137b-442">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="0137b-443">왜냐하면의 동작을 <xref:System.Globalization.CultureInfo> 클래스가 변경 된: 중립 문화권에 해당 속성 값을 나타내는 것 (특히를 <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, 및 <xref:System.Globalization.CultureInfo.TextInfo%2A> 속성) 이제 중립 문화권을 사용 하 여 연결 된 특정 문화권을 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-443">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="0137b-444">이전 버전의.NET Framework를 <xref:System.Threading.Thread.CurrentCulture%2A> 속성에서를 <xref:System.NotSupportedException> 중립 문화권 할당 하는 동안 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-444">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
## Examples  
 <span data-ttu-id="0137b-445">다음 예제에서는 제어판에 설정 된 문화권에서 표시 하는 Windows Forms 응용 프로그램의 사용자 인터페이스를 허용 하는 스레딩 문을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-445">The following example shows the threading statement that allows the user interface of a Windows Forms application to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="0137b-446">추가 코드가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-446">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0137b-447">속성이 <see langword="null" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-447">The property is set to <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0137b-448">.NET Core만 해당: 다른 스레드의 스레드 문화권을 읽거나 쓰는 기능은 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-448">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="0137b-449">속성을 설정 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-449">for setting the property.</span>
          </span>
          <span data-ttu-id="0137b-450">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-450">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-451">스레드의 현재 보안 주체(역할 기반 보안용)를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-451">Gets or sets the thread's current principal (for role-based security).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-452">보안 컨텍스트를 나타내는 <see cref="T:System.Security.Principal.IPrincipal" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-452">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0137b-453">다음 코드 예제에는 설정 및 스레드 보안 주체를 검색 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-453">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="0137b-454">호출자에게 보안 주체를 설정하는 데 필요한 사용 권한이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-454">The caller does not have the permission required to set the principal.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="0137b-455">보안 주체 개체를 조작 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-455">to manipulate the principal object.</span>
          </span>
          <span data-ttu-id="0137b-456">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-456">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-457">현재 실행 중인 스레드를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-457">Gets the currently running thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-458">현재 실행 중인 스레드를 나타내는 <see cref="T:System.Threading.Thread" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-458">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0137b-459">다음 예제에서는 20 개의 자식 작업을 다시 만드는 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-459">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="0137b-460">각 잘 작업으로 응용 프로그램 자체에서 호출 합니다 `ShowThreadInformation` 메서드를 사용 하는 <xref:System.Threading.Thread.CurrentThread%2A> 가 실행 되는 스레드에 대 한 정보를 표시 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-460">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="0137b-461">각 자식 작업 1에서 1 백만 간의 1 백만 난수를 생성 하 고 평균값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-461">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="0137b-462">부모 작업을 호출 하 여는 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 각 작업에서 반환한 평균을 표시 하기 전에 자식 작업 완료를 확인 하는 방법 및 의미의 평균을 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-462">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="0137b-463">응용 프로그램이 포그라운드 스레드에서 실행 되는 동안 각 태스크가 실행 되도록 스레드 풀 스레드에서 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-463">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-464">리소스 관리자가 런타임에 문화권 관련 리소스를 찾기 위해 사용하는 현재 문화권을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-464">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-465">현재 문화를 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-465">An object that represents the current culture.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-466">UI 문화권은 응용 프로그램 사용자 입력 및 출력을 지원 하며 기본적으로 운영 체제 문화권과 동일 리소스를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-466">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="0137b-467">참조 된 <xref:System.Globalization.CultureInfo> 문화권 이름 및 식별자, 고정, 중립 및 특정 문화권 간의 차이점에 대해 자세히 알아보려면 클래스 및 응용 프로그램 도메인과 스레드 방식으로 문화권 정보에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-467">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="0137b-468">참조 된 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> 스레드의 기본 UI 문화권을 결정 하는 방법을 알아보려면 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-468">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="0137b-469"><xref:System.Threading.Thread.CurrentUICulture> 속성은 현재 스레드를 제외한 모든 스레드를 사용 하 여 사용 하면 안정적으로 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-469">The <xref:System.Threading.Thread.CurrentUICulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="0137b-470">.NET framework에서 속성을 읽는 신뢰할 수 있지만 현재 스레드 이외의 스레드가 설정 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-470">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="0137b-471">.NET Core에는 <xref:System.InvalidOperationException> 스레드 읽기 또는 쓰기를 시도할 경우 throw 되는 <xref:System.Threading.Thread.CurrentUICulture> 다른 스레드에서 속성.</span><span class="sxs-lookup"><span data-stu-id="0137b-471">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentUICulture> property on a different thread.</span></span>
> <span data-ttu-id="0137b-472">사용 하는 것이 좋습니다는 <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> 속성을 검색 하 고 현재 문화권을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-472">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="0137b-473"><xref:System.Globalization.CultureInfo> 이 속성이 반환 하는 중립 문화권 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-473">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="0137b-474">중립 문화권 해서는 안와 같은 서식 지정 메서드로 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, 및 <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-474">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0137b-475">사용 합니다 <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> 특정 문화권을 가져오거나 사용 하는 메서드는 <xref:System.Threading.Thread.CurrentCulture%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-475">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-476">합니다 <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> 메서드가 throw <xref:System.ArgumentException> 중립 문화권 "Zh-hant" ("ZH-CHT") 및 "Zh-hans" ("ZH-CHS").</span><span class="sxs-lookup"><span data-stu-id="0137b-476">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-477">다음 예에서는 현재 스레드의 UI 문화권의 언어가 프랑스어 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-477">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="0137b-478">없는 경우 현재 스레드의 UI 문화권을 영어 (미국)으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-478">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="0137b-479">다음 코드 예제에는 제어판에서 설정 된 문화권에서 표시 하는 Windows Forms의 사용자 인터페이스를 허용 하는 스레딩 문을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-479">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="0137b-480">추가 코드가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-480">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0137b-481">속성이 <see langword="null" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-481">The property is set to <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0137b-482">속성이 리소스 파일을 찾는 데 사용할 수 없는 문화권 이름으로 설정되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-482">The property is set to a culture name that cannot be used to locate a resource file.</span>
          </span>
          <span data-ttu-id="0137b-483">리소스 파일 이름에는 문자, 숫자, 하이픈 또는 밑줄만 포함해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-483">Resource filenames must include only letters, numbers, hyphens or underscores.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0137b-484">.NET Core만 해당: 다른 스레드의 스레드 문화권을 읽거나 쓰는 기능은 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-484">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-485">현재 스레드에 대해 RCW(런타임 호출 가능 래퍼)의 자동 정리를 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-485">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-486">기본적으로 CLR (공용 언어 런타임) 런타임 호출 가능 래퍼 자동으로 정리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-486">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="0137b-487">비정상적인 다음 조건을 충족 하는 몇 가지 응용 프로그램에서 재진입 문제가 발생할 수 있습니다 정리 하는 동안 CLR 펌프로 메시지:</span><span class="sxs-lookup"><span data-stu-id="0137b-487">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="0137b-488">응용 프로그램 자체 메시지 펌프를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-488">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="0137b-489">응용 프로그램 메시지 펌핑 발생 하는 경우에 정확 하 게 제어 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-489">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="0137b-490">이러한 응용 프로그램에서 사용할 수는 <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> 메서드 CLR 호출 가능 래퍼 런타임의 자동 확보를 수행 하지 못하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-490">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="0137b-491">스레드에서이 메서드를 호출 하는 경우 자동 정리 해당 스레드에 대 한 다시 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-491">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="0137b-492">응용 프로그램 런타임 호출 가능 래퍼를 정리 하도록 준비 되 면 사용 된 <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> 현재 컨텍스트에서 모든 런타임 호출 가능 래퍼를 정리 하도록 런타임에 지시 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-492">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="0137b-493">메시지 펌핑 메서드를 실행 하는 동안 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-493">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0137b-494">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-494">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0137b-495">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-495">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-496">스레드 중단 또는 처리되지 않은 예외가 현재 작업에만 영향을 주는 코드 영역이 실행될 것임을 호스트에 알립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-496">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-497">Microsoft SQL Server 2005와 같은 공용 언어 런타임 (CLR)의 호스트에는 오류 코드의 중요 한 및 중요 하지 않은 영역에 대해 다른 정책을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-497">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="0137b-498">중요 영역은는 스레드 중단 또는 처리 되지 않은 예외가 미치는 국한 되지 않는 현재 작업에 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-498">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="0137b-499">반면, 중단 이나 오류 코드는 중요 하지 않은 영역에서 오류가 발생 하는 작업을만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-499">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="0137b-500">예를 들어, 잠금을 보유 하는 동안 메모리 할당을 시도 하는 작업을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-500">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="0137b-501">메모리 할당이 실패 하면 현재 작업이 중단 되지의 안정성을 보장 하는 데 충분 합니다 <xref:System.AppDomain>이므로 도메인에 동일한 잠금을 대기 하는 다른 작업이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-501">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="0137b-502">현재 작업이 종료 되는 경우 다른 작업은 교착 상태 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-502">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="0137b-503">중요 한 영역에서 오류가 발생 하는 경우 호스트 수도 전체 언로드 <xref:System.AppDomain> 잠재적으로 불안정 한 상태의 실행을 계속의 위험을 감수 하지 않고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-503">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="0137b-504">호출 코드는 중요 한 영역을 입력 하는 호스트를 알리는, <xref:System.Threading.Thread.BeginCriticalRegion%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-504">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="0137b-505">호출 <xref:System.Threading.Thread.EndCriticalRegion%2A> 실행 코드의 중요 하지 않은 영역을 반환 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="0137b-505">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="0137b-506">이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행 되도록 코드가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-506">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-507">다음 예제에서는 사용 된 <xref:System.Threading.Thread.BeginCriticalRegion%2A> 및 <xref:System.Threading.Thread.EndCriticalRegion%2A> 코드 블록을 중요 하 고 중요 하지 않은 영역으로 나누는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-507">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-508">관리되는 코드가 현재 실제 운영 체제 스레드의 ID에 종속되는 명령의 실행을 완료했음을 호스트에 알립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-508">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-509">Microsoft SQL Server 2005와 같은 공용 언어 런타임의 일부 호스트는 고유한 스레드 관리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-509">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="0137b-510">고유한 스레드 관리를 제공 하는 호스트 간에 이동할 수는 실행 중인 작업 한 실제 운영 체제 스레드에서 언제 든 지 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-510">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="0137b-511">이 전환 하 여 대부분의 작업을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-511">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="0137b-512">그러나 일부 작업에는 스레드 선호도-즉, 실제 운영 체제 스레드의 id에 의존 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-512">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="0137b-513">이러한 작업 전환 해야 하는 코드를 실행 하는 해당 호스트에 게 알려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-513">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="0137b-514">예를 들어 운영 체제를 획득 하는 사용자 응용 프로그램 호출 시스템 API를 잠그는 경우에 Win32 CRITICAL_SECTION 같은 스레드 선호도 있는 호출 해야 합니다 <xref:System.Threading.Thread.BeginThreadAffinity%2A> 잠금을 획득 하기 전에 및 <xref:System.Threading.Thread.EndThreadAffinity%2A> 후 잠금을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-514">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="0137b-515">이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행 되도록 코드가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-515">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-516">다음 예제에서는 사용 된 <xref:System.Threading.Thread.BeginThreadAffinity%2A> 및 <xref:System.Threading.Thread.EndThreadAffinity%2A> 코드 블록을 실제 운영 체제 스레드의 id에 의존 하는 호스트에 알리기 위해 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-516">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="0137b-517">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-517">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0137b-518">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-518">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0137b-519">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-519">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-520">현재 스레드의 다양한 컨텍스트 정보를 포함하는 <see cref="T:System.Threading.ExecutionContext" /> 개체를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-520">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-521">현재 스레드의 컨텍스트 정보를 통합하는 <see cref="T:System.Threading.ExecutionContext" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-521">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-522"><xref:System.Threading.ExecutionContext> 클래스는 실행의 논리적 스레드 관련 된 모든 정보에 대 한 단일 컨테이너를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-522">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="0137b-523">보안 컨텍스트, 호출 컨텍스트, 동기화 컨텍스트, 지역화 컨텍스트 및 트랜잭션 컨텍스트가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-523">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-524">가비지 컬렉션기에서 <see cref="T:System.Threading.Thread" /> 개체를 회수할 때 리소스가 해제되고 다른 정리 작업이 수행되도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-524">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-525">가비지 수집기를 호출 하 여 <xref:System.Threading.Thread.Finalize%2A> 종료 준비가 된 경우.</span><span class="sxs-lookup"><span data-stu-id="0137b-525">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="0137b-526">해제할 데이터 슬롯의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-526">The name of the data slot to be freed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-527">프로세스의 모든 스레드에 대해 이름과 슬롯 간의 연관을 없앱니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-527">Eliminates the association between a name and a slot, for all threads in the process.</span>
          </span>
          <span data-ttu-id="0137b-528">성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-528">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="0137b-529">스레드 로컬 저장소 (TLS)를 사용 하 여 두 가지 메커니즘을 제공 하는.NET Framework: 스레드 상대 정적 필드 (즉, 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-529">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="0137b-530">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-530">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="0137b-531">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-531">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="0137b-532">호출 스레드에서 `FreeNamedDataSlot`를 호출 하는 다른 스레드에 <xref:System.Threading.Thread.GetNamedDataSlot%2A> 동일한 이름의 이름과 연결 된 새 슬롯을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-532">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="0137b-533">에 대 한 후속 호출 `GetNamedDataSlot` 모든 스레드에서 새 슬롯을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-533">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="0137b-534">그러나 모든 스레드는 아직를 <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> 대 한 이전 호출에서 반환 된 `GetNamedDataSlot` 계속 이전 슬롯을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-534">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="0137b-535">슬롯 이름과 연관 되어 있는 경우에 해제 될 경우에만 모든 `LocalDataStoreSlot` 호출 하기 전에 가져온 `FreeNamedDataSlot` 출시 되었으며 가비지 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-535">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="0137b-536">스레드는 스레드 관련 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-536">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="0137b-537">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-537">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="0137b-538">스레드는 데이터 저장소에 데이터 슬롯을 할당할 수, 저장 및 검색 데이터 슬롯의 값 및 스레드가 만료 된 후 다시 사용에 대 한 슬롯을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-538">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="0137b-539">데이터 슬롯은 스레드 당 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-539">Data slots are unique per thread.</span></span> <span data-ttu-id="0137b-540">다른 스레드가 없습니다. (자식 스레드 하지도 함) 해당 데이터를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-540">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-541">이 섹션에는 두 코드 예제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-541">This section contains two code examples.</span></span> <span data-ttu-id="0137b-542">첫 번째 예제에 사용 하 여 표시 된 필드를 사용 하는 방법을 보여 줍니다는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 저장 하는 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-542">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="0137b-543">두 번째 예제에는 데이터 슬롯을 사용 하 여 동일한 작업을 수행 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-543">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="0137b-544">**첫 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-544">**First Example**</span></span>  
  
 <span data-ttu-id="0137b-545">다음 예제로 표시 된 필드를 사용 하는 방법을 보여 줍니다 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-545">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="0137b-546">이 방법은 두 번째 예제에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-546">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="0137b-547">**두 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-547">**Second Example**</span></span>  
  
 <span data-ttu-id="0137b-548">다음 예제에서는 명명된 된 데이터 슬롯을 사용 하 여 스레드 관련 정보를 저장 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-548">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="0137b-549">스레드 및 스레딩</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-549">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="0137b-550">스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-550">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-551">아파트 상태를 나타내는 <see cref="T:System.Threading.ApartmentState" /> 값을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-551">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-552">관리되는 스레드의 아파트 상태를 나타내는 <see cref="T:System.Threading.ApartmentState" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-552">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span>
          </span>
          <span data-ttu-id="0137b-553">기본값은 <see cref="F:System.Threading.ApartmentState.Unknown" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-553">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-554">이 메서드를 함께 합니다 <xref:System.Threading.Thread.SetApartmentState%2A> 메서드 및 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드를 대체 합니다 <xref:System.Threading.Thread.ApartmentState%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-554">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-555">다음 코드 예제는 <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, 및 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-555">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="0137b-556">코드 예제에서는 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-556">The code example creates a thread.</span></span> <span data-ttu-id="0137b-557">스레드를 시작 하기 전에 <xref:System.Threading.Thread.GetApartmentState%2A> 초기 표시 <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> 상태와 <xref:System.Threading.Thread.SetApartmentState%2A> 상태를 변경 합니다 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-557">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0137b-558">합니다 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드가 반환 됩니다 `false` 상태를 변경 하려고 할 때 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 아파트 상태가 이미 설정 되어 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-558">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="0137b-559">동일한 작업을 시도 하는 경우 <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> 이 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-559">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="0137b-560">스레드가 시작 된 후의 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드를 다시 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-560">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="0137b-561">이 시간 throw <xref:System.Threading.ThreadStateException> 스레드가 이미 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-561">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-562">현재 스레드 스택을 캡처하는 데 사용할 수 있는 <see cref="T:System.Threading.CompressedStack" /> 개체를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-562">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-563">없음</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-563">None.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-564">이 메서드는 더 이상 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-564">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0137b-565">모든 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-565">In all cases.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0137b-566">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-566">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0137b-567">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-567">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">
          <span data-ttu-id="0137b-568">값을 검색할 원본 <see cref="T:System.LocalDataStoreSlot" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-568">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-569">현재 스레드의 도메인 내에서 현재 스레드의 지정된 슬롯에서 값을 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-569">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span>
          </span>
          <span data-ttu-id="0137b-570">성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-570">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-571">검색된 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-571">The retrieved value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="0137b-572">스레드 로컬 저장소 (TLS)를 사용 하 여 두 가지 메커니즘을 제공 하는.NET Framework: 스레드 상대 정적 필드 (즉, 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-572">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="0137b-573">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-573">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="0137b-574">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-574">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="0137b-575">스레드는 스레드 관련 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-575">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="0137b-576">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-576">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="0137b-577">스레드는 데이터 저장소에 데이터 슬롯을 할당할 수, 저장 및 검색 데이터 슬롯의 값 및 스레드가 만료 된 후 다시 사용에 대 한 슬롯을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-577">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="0137b-578">데이터 슬롯은 스레드 당 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-578">Data slots are unique per thread.</span></span> <span data-ttu-id="0137b-579">다른 스레드가 없습니다. (자식 스레드 하지도 함) 해당 데이터를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-579">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-580"><xref:System.Threading.Thread.GetData%2A> 가 `Shared` 항상 적용 되는 현재 실행 중인 스레드와 다른 스레드를 가리키는 변수를 사용 하 여 호출 하는 경우에 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-580"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="0137b-581">혼동을 피하기 위해 사용 하 여 클래스 이름을 호출 하는 경우 `Shared` 메서드: `Dim test As Object = Thread.GetData(testSlot)`합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-581">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-582">이 섹션에는 두 코드 예제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-582">This section contains two code examples.</span></span> <span data-ttu-id="0137b-583">첫 번째 예제에 사용 하 여 표시 된 필드를 사용 하는 방법을 보여 줍니다는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 저장 하는 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-583">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="0137b-584">두 번째 예제에는 데이터 슬롯을 사용 하 여 동일한 작업을 수행 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-584">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="0137b-585">**첫 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-585">**First Example**</span></span>  
  
 <span data-ttu-id="0137b-586">다음 예제로 표시 된 필드를 사용 하는 방법을 보여 줍니다 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-586">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="0137b-587">이 방법은 두 번째 예제에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-587">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="0137b-588">**두 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-588">**Second Example**</span></span>  
  
 <span data-ttu-id="0137b-589">다음 예제에서는 스레드 관련 정보를 저장 된 데이터 슬롯을 사용 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-589">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="0137b-590">스레드 및 스레딩</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-590">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="0137b-591">스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-591">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-592">현재 스레드가 실행 중인 현재 도메인을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-592">Returns the current domain in which the current thread is running.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-593">실행 중인 스레드의 현재 응용 프로그램 도메인을 나타내는 <see cref="T:System.AppDomain" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-593">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0137b-594">다음 코드 예제는의 이름 및 ID를 검색 하는 방법을 보여 줍니다는 `AppDomain` 스레드가 실행 되는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-594">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-595">고유한 응용 프로그램 도메인 식별자를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-595">Returns a unique application domain identifier.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-596">응용 프로그램 도메인을 고유하게 식별하는 부호 있는 32비트 정수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-596">A 32-bit signed integer uniquely identifying the application domain.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0137b-597">다음 코드 예제는의 이름 및 ID를 검색 하는 방법을 보여 줍니다는 `AppDomain` 스레드가 실행 되는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-597">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-598">현재 스레드의 해시 코드를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-598">Returns a hash code for the current thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-599">정수 해시 코드 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-599">An integer hash code value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-600">해시 코드를 고유 하 게 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-600">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="0137b-601">사용 된 <xref:System.Threading.Thread.ManagedThreadId%2A> 속성 관리 되는 스레드에 대 한 고유 식별자를 사용 해야 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="0137b-601">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="0137b-602">로컬 데이터 슬롯의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-602">The name of the local data slot.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-603">명명된 데이터 슬롯을 찾습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-603">Looks up a named data slot.</span>
          </span>
          <span data-ttu-id="0137b-604">성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-604">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-605">이 스레드에 대해 할당된 <see cref="T:System.LocalDataStoreSlot" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-605">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="0137b-606">스레드 로컬 저장소 (TLS)를 사용 하 여 두 가지 메커니즘을 제공 하는.NET Framework: 스레드 상대 정적 필드 (즉, 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-606">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="0137b-607">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-607">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="0137b-608">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-608">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="0137b-609">스레드는 스레드 관련 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-609">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="0137b-610">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-610">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="0137b-611">스레드는 데이터 저장소에 데이터 슬롯을 할당할 수, 저장 및 검색 데이터 슬롯의 값 및 스레드가 만료 된 후 다시 사용에 대 한 슬롯을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-611">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="0137b-612">데이터 슬롯은 스레드 당 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-612">Data slots are unique per thread.</span></span> <span data-ttu-id="0137b-613">다른 스레드가 없습니다. (자식 스레드 하지도 함) 해당 데이터를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-613">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="0137b-614">명명 된 슬롯 존재 하지 않는 경우 새 슬롯 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-614">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="0137b-615">명명 된 데이터 슬롯은 공용 이며 모든 사용자가 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-615">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-616">이 섹션에는 두 코드 예제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-616">This section contains two code examples.</span></span> <span data-ttu-id="0137b-617">첫 번째 예제에 사용 하 여 표시 된 필드를 사용 하는 방법을 보여 줍니다는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 저장 하는 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-617">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="0137b-618">두 번째 예제에는 데이터 슬롯을 사용 하 여 동일한 작업을 수행 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-618">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="0137b-619">**첫 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-619">**First Example**</span></span>  
  
 <span data-ttu-id="0137b-620">다음 예제로 표시 된 필드를 사용 하는 방법을 보여 줍니다 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-620">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="0137b-621">이 방법은 두 번째 예제에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-621">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="0137b-622">**두 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-622">**Second Example**</span></span>  
  
 <span data-ttu-id="0137b-623">다음 예제에서는 명명된 된 데이터 슬롯을 사용 하 여 스레드 관련 정보를 저장 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-623">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="0137b-624">스레드 및 스레딩</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-624">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="0137b-625">스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-625">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-626">
            <see langword="WaitSleepJoin" /> 스레드 상태에 있는 스레드를 중단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-626">Interrupts a thread that is in the <see langword="WaitSleepJoin" /> thread state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-627">이 스레드가 대기, 대기 또는 조인 상태에 현재 차단 되지 않은 경우 다음에 차단 하기 시작할 때 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-627">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="0137b-628"><xref:System.Threading.ThreadInterruptedException> 해당 스레드는 차단 되지만 중단 스레드에서 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-628"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="0137b-629">스레드가 차단 되지 않으면 예외가 throw 되지 및 스레드를 중단 없이 완료할 수 있습니다 따라서 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-629">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-630">다음 코드 예제에서는 중단 되 고 이어서 차단 하는 경우 실행 중인 스레드의 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-630">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="0137b-631">호출자에게 해당 <see cref="T:System.Security.Permissions.SecurityPermission" />이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-631">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="0137b-632">스레드에서 고급 작업입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-632">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="0137b-633">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-633">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">
          <span data-ttu-id="0137b-634">스레드 일시 중지 및 중단</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-634">Pausing and interrupting threads</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="0137b-635">관리되는 스레드 상태</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-635">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-636">현재 스레드의 실행 상태를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-636">Gets a value indicating the execution status of the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-637">이 스레드가 시작되었으며 정상적으로 종료 또는 중단되지 않았으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-637">
              <see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-638">스레드가 배경 스레드인지를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-638">Gets or sets a value indicating whether or not a thread is a background thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-639">이 스레드가 백그라운드 스레드이거나 백그라운드 스레드가 될 예정이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-639">
              <see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-640">스레드는 백그라운드 스레드 또는 포그라운드 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-640">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="0137b-641">백그라운드 스레드는 백그라운드 스레드 프로세스를 종료 하는 것을 금지 하지 않는 점을 제외 하 고 포그라운드 스레드와 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-641">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="0137b-642">프로세스에 속하는 모든 포그라운드 스레드가 중단 되 면 공용 언어 런타임 프로세스를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-642">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="0137b-643">나머지 모든 백그라운드 스레드 중단 되 고 완료 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="0137b-643">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="0137b-644">기본적으로 다음 스레드 포그라운드에서 실행 (즉, 해당 <xref:System.Threading.Thread.IsBackground%2A> 속성이 반환 `false`):</span><span class="sxs-lookup"><span data-stu-id="0137b-644">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="0137b-645">기본 스레드 (또는 주 응용 프로그램 스레드가).</span><span class="sxs-lookup"><span data-stu-id="0137b-645">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="0137b-646">호출 하 여 만들어진 모든 스레드는 <xref:System.Threading.Thread> 클래스 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-646">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="0137b-647">기본적으로 백그라운드에서 실행 하는 다음 스레드 (즉, 해당 <xref:System.Threading.Thread.IsBackground%2A> 속성이 반환 `true`):</span><span class="sxs-lookup"><span data-stu-id="0137b-647">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="0137b-648">런타임에 의해 유지 관리 하는 작업자 스레드 풀을 하는 풀 스레드를 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-648">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="0137b-649">사용 하 여 스레드 풀에서 스레드 풀 및 일정 작업을 구성할 수 있습니다는 <xref:System.Threading.ThreadPool> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-649">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="0137b-650">작업 기반 비동기 작업은 자동으로 스레드 풀 스레드에 대해 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-650">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="0137b-651">비관리 코드에서 관리 되는 실행 환경에 들어가는 모든 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-651">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-652">다음 예제에서는 포그라운드 및 백그라운드 스레드 동작을 대조 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-652">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="0137b-653">포그라운드 스레드와 백그라운드 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-653">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="0137b-654">포그라운드 스레드 프로세스를 계속 실행 될 때까지 완료 해당 `for` 반복 하 고 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-654">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="0137b-655">그러나 출력의 예제에서 보듯이 포그라운드 스레드 실행이 완료 된 때문에 백그라운드 스레드에서 실행이 완료 되기 전에 프로세스가 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-655">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-656">스레드가 중지되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-656">The thread is dead.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md">
          <span data-ttu-id="0137b-657">포그라운드 및 백그라운드 스레드</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-657">Foreground and Background Threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-658">스레드가 관리되는 스레드 풀에 속하는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-658">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-659">이 스레드가 관리되는 스레드 풀에 속하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-659">
              <see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-660">자세한 내용은 참조 [관리 되는 스레드 풀](~/docs/standard/threading/the-managed-thread-pool.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-660">For more information see [The managed thread pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-661">다음 코드 예제에서는 스레드 풀에서 스레드 인지 여부를 확인 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-661">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="0137b-662">관리되는 스레드 풀</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-662">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-663">이 인스턴스가 나타내는 스레드가 종료될 때까지 호출 스레드를 차단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-663">Blocks the calling thread until the thread represented by this instance terminates.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-664">표준 COM 및 <see langword="SendMessage" /> 펌프를 계속 수행하면서 이 인스턴스가 나타내는 스레드가 종료될 때까지 호출 스레드를 차단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-664">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-665"><xref:System.Threading.Thread.Join%2A> 스레드가 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 메서드는 해당 <xref:System.Threading.Thread.Join%2A> 메서드는 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-665"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="0137b-666">스레드 종료 되었다는 확인 하려면이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-666">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="0137b-667">스레드가 종료 되지 않는 경우 호출자는 무기한으로 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-667">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="0137b-668">다음 예제에서는 `Thread1` 호출 스레드를 <xref:System.Threading.Thread.Join> 메서드의 `Thread2`, 있어 `Thread1` 까지 블록에 `Thread2` 완료.</span><span class="sxs-lookup"><span data-stu-id="0137b-668">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="0137b-669">스레드가 이미 종료 되는 경우 <xref:System.Threading.Thread.Join%2A> 가 호출 된 메서드가 즉시 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-669">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="0137b-670">호출 하지 말아야 합니다 <xref:System.Threading.Thread.Join%2A> 메서드는 <xref:System.Threading.Thread> 현재 스레드에서 현재 스레드를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-670">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="0137b-671">이렇게 하면 앱을 자동으로 현재 스레드의 무기한으로 대기 하기 때문에 중지</span><span class="sxs-lookup"><span data-stu-id="0137b-671">This causes your app to hang because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="0137b-672">이 메서드를 포함 하는 호출 스레드의 상태를 변경 <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-672">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0137b-673">호출할 수 없습니다 `Join` 에 있는 스레드에서 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-673">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-674">호출자가 <see cref="F:System.Threading.ThreadState.Unstarted" /> 상태의 스레드에 연결하려고 했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-674">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="0137b-675">스레드가 대기하는 동안 중단되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-675">The thread is interrupted while waiting.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="0137b-676">관리되는 스레드 상태</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-676">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="0137b-677">스레드가 종료되기를 기다릴 밀리초 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-677">The number of milliseconds to wait for the thread to terminate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-678">표준 COM 및 SendMessage 펌프를 계속 수행하면서 이 인스턴스가 나타내는 스레드가 종료되거나 지정된 시간이 경과할 때까지 호출 스레드를 차단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-678">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-679">스레드가 종료되면 <see langword="true" />이고, <see langword="false" /> 매개 변수에서 지정한 기간이 경과된 후에도 스레드가 종료되지 않으면 <paramref name="millisecondsTimeout" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-679">
              <see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-680"><xref:System.Threading.Thread.Join%28System.Int32%29> 두 스레드가 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 메서드는 해당 <xref:System.Threading.Thread.Join%2A> 메서드는 완료 제한 시간이 경과 하거나 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-680"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="0137b-681">다음 예에서 `Thread1` 호출 스레드를 <xref:System.Threading.Thread.Join> 메서드의 `Thread2`, 있어 `Thread1` 할 때 까지는 차단 `Thread2` 완료 또는 2 시간 (초)이 경과한 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-681">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="0137b-682">경우 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 에 대해 지정 된를 `millisecondsTimeout` 매개 변수를이 똑같이 동작 합니다 <xref:System.Threading.Thread.Join> 반환 값을 제외 하 고 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-682">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="0137b-683">스레드가 이미 종료 되는 경우 <xref:System.Threading.Thread.Join%2A> 가 호출 된 메서드가 즉시 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-683">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="0137b-684">이 메서드를 포함 하는 호출 스레드의 상태를 변경 <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-684">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0137b-685">호출할 수 없습니다 `Join` 에 있는 스레드에서 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-685">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0137b-686">
            <paramref name="millisecondsTimeout" /> 값이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(밀리초)와 같지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-686">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-687">스레드가 시작되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-687">The thread has not been started.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="0137b-688">관리되는 스레드 상태</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-688">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="0137b-689">스레드가 종료되기를 기다리는 시간으로 설정된 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-689">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-690">표준 COM 및 SendMessage 펌프를 계속 수행하면서 이 인스턴스가 나타내는 스레드가 종료되거나 지정된 시간이 경과할 때까지 호출 스레드를 차단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-690">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-691">스레드가 종료되면 <see langword="true" />이고, <see langword="false" /> 매개 변수에서 지정한 기간이 경과된 후에도 스레드가 종료되지 않으면 <paramref name="timeout" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-691">
              <see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-692"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> 두 스레드가 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 메서드는 해당 <xref:System.Threading.Thread.Join%2A> 메서드는 완료 제한 시간이 경과 하거나 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-692"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="0137b-693">다음 예에서 `Thread1` 호출 스레드를 <xref:System.Threading.Thread.Join> 메서드의 `Thread2`, 있어 `Thread1` 할 때 까지는 차단 `Thread2` 완료 또는 2 시간 (초)이 경과한 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-693">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="0137b-694">경우 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 에 대해 지정 된 `timeout`,이 메서드는 동일 하 게 동작 합니다 <xref:System.Threading.Thread.Join> 반환 값을 제외 하 고 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-694">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="0137b-695">스레드가 이미 종료 되는 경우 <xref:System.Threading.Thread.Join%2A> 가 호출 된 메서드가 즉시 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-695">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="0137b-696">이 메서드를 포함 하도록 현재 스레드의 상태 변경 <xref:System.Threading.ThreadState.WaitSleepJoin>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-696">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="0137b-697">호출할 수 없습니다 `Join` 에 있는 스레드에서 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-697">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-698">다음 코드 예제에 사용 하는 방법을 보여 줍니다.는 `TimeSpan` 값을 `Join` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-698">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0137b-699">
            <paramref name="timeout" /> 값이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(밀리초)와 같지 않거나 <see cref="F:System.Int32.MaxValue" />(밀리초)보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-699">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-700">호출자가 <see cref="F:System.Threading.ThreadState.Unstarted" /> 상태의 스레드에 연결하려고 했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-700">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="0137b-701">관리되는 스레드 상태</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-701">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-702">현재 관리되는 스레드의 고유 식별자를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-702">Gets a unique identifier for the current managed thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-703">이 관리되는 스레드의 고유 식별자를 나타내는 정수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-703">An integer that represents a unique identifier for this managed thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-704">스레드의 <xref:System.Threading.Thread.ManagedThreadId%2A> 해당 프로세스 내에서 스레드를 고유 하 게 식별 하는 데 사용 되는 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-704">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="0137b-705">값을 <xref:System.Threading.Thread.ManagedThreadId%2A> 속성 공용 언어 런타임을 호스트 하는 관리 되지 않는 코드를 파이버 스레드를 구현 하는 경우에 시간이 지나면서 달라 지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-705">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-706">다음과 같이 메모리 액세스를 동기화합니다. 현재 스레드를 실행 중인 프로세서는 <see cref="M:System.Threading.Thread.MemoryBarrier" />에 대한 호출 이전의 메모리 액세스가 <see cref="M:System.Threading.Thread.MemoryBarrier" />에 대한 호출 이후의 메모리 액세스 뒤에 실행되는 방식으로 명령을 다시 정렬할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-706">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-707"><xref:System.Threading.Thread.MemoryBarrier%2A> 메모리 순서가 (예: 여러 Intel Itanium 프로세서를 사용 하는 시스템)를 사용 하 여 다중 프로세서 시스템에만 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-707"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="0137b-708">대부분의 용도, C# `lock` 문, Visual Basic `SyncLock` 문 또는 <xref:System.Threading.Monitor> 편리 하 게 데이터를 동기화 할 클래스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-708">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-709">스레드의 이름을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-709">Gets or sets the name of the thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-710">스레드의 이름을 포함하는 문자열이며 설정된 이름이 없으면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-710">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-711">이 속성은 쓰기-면 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-711">This property is write-once.</span></span> <span data-ttu-id="0137b-712">때문에 기본값인 스레드의 <xref:System.Threading.Thread.Name%2A> 속성은 `null`, 이름에 이미 할당 되었는지 여부를 명시적으로 스레드를 사용 하 여 비교 하 여 확인할 수 있습니다 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-712">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="0137b-713">에 할당 된 문자열을 <xref:System.Threading.Thread.Name%2A> 속성 유니코드 문자를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-713">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-714">다음 예제에는 스레드의 이름을 지정 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-714">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0137b-715">집합 작업이 요청되었으나 <see langword="Name" /> 속성이 이미 설정되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-715">A set operation was requested, but the <see langword="Name" /> property has already been set.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-716">스레드의 예약 우선 순위를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-716">Gets or sets a value indicating the scheduling priority of a thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-717">
            <see cref="T:System.Threading.ThreadPriority" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-717">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span>
          </span>
          <span data-ttu-id="0137b-718">기본값은 <see cref="F:System.Threading.ThreadPriority.Normal" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-718">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-719">스레드 우선 순위를 다음 중 하나를 할당할 수 있습니다 <xref:System.Threading.ThreadPriority> 값:</span><span class="sxs-lookup"><span data-stu-id="0137b-719">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="0137b-720">운영 체제 스레드의 우선 순위 인식 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-720">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-721">다음 예제에서는 스레드 우선 순위를 변경의 결과 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-721">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="0137b-722">하나의 스레드의 우선 순위를로, 3 개의 스레드가 만들어집니다 <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, 두 번째의 우선 순위로 설정 됩니다 <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-722">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0137b-723">각 스레드에에서 변수를 증가 시킵니다.는 `while` 루프와 설정된 된 시간에 대 한 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-723">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-724">스레드가 <see cref="F:System.Threading.ThreadState.Aborted" /> 같은 최종 상태에 도달했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-724">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0137b-725">Set 작업에 대해 지정된 값이 올바른 <see cref="T:System.Threading.ThreadPriority" /> 값이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-725">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md">
          <span data-ttu-id="0137b-726">스레드 스케줄링</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-726">Scheduling threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-727">현재 스레드에 대해 요청된 <see cref="M:System.Threading.Thread.Abort(System.Object)" />를 취소합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-727">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-728">이 메서드가 적절 한 권한이 있는 코드로 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-728">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="0137b-729">호출할 때 `Abort` 는 시스템에서 스레드를 종료 하려면 다음을 throw 합니다.는 <xref:System.Threading.ThreadAbortException>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-729">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="0137b-730">`ThreadAbortException` 응용 프로그램 코드에서 발견 될 수 있지만 하지 않는 한 catch 블록의 끝에 다시 throw 되는 특별 한 예외는 `ResetAbort` 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-730">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="0137b-731">`ResetAbort` 취소 요청을 중단 하 고, 수 없고는 `ThreadAbortException` 스레드를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-731">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="0137b-732">참조 <xref:System.Threading.ThreadAbortException> 호출을 보여 주는 예는 `ResetAbort` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-732">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="0137b-733">.NET Core만 해당: 이 멤버는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-733">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-734">
            <see langword="Abort" />가 현재 스레드에서 호출되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-734">
              <see langword="Abort" /> was not invoked on the current thread.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="0137b-735">호출자에게 현재 스레드에 대한 필수 보안 권한이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-735">The caller does not have the required security permission for the current thread.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="0137b-736">스레드에서 고급 작업입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-736">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="0137b-737">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-737">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">
          <span data-ttu-id="0137b-738">스레드 제거</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-738">Destroying threads</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="0137b-739">관리되는 스레드 상태</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-739">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-740">일시 중단된 스레드를 다시 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-740">Resumes a thread that has been suspended.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="0137b-741">사용 하지 않는 합니다 <xref:System.Threading.Thread.Suspend%2A> 및 <xref:System.Threading.Thread.Resume%2A> 스레드의 활동을 동기화 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-741">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="0137b-742">일시 중단 하면 스레드는 어떤 코드가 실행 되는 알 수 없습니다 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-742">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="0137b-743">스레드 보안 권한 확인 하는 동안 잠금을 유지 하는 동안 스레드를 일시 중단, 기타는 <xref:System.AppDomain> 차단 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-743">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="0137b-744">클래스 생성자를 실행 하는 동안 스레드를 일시 중단, 기타의 스레드는 <xref:System.AppDomain> 클래스 차단 됩니다 사용 하려고 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-744">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="0137b-745">교착 상태를 매우 쉽게 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-745">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="0137b-746">.NET Core만 해당: 이 멤버는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-746">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-747">스레드가 시작되지 않았거나, 중지되었거나, 일시 중단된 상태가 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-747">The thread has not been started, is dead, or is not in the suspended state.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="0137b-748">호출자에게 해당 <see cref="T:System.Security.Permissions.SecurityPermission" />이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-748">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="0137b-749">스레드에서 고급 작업입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-749">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="0137b-750">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-750">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">
          <span data-ttu-id="0137b-751">스레드 일시 중지 및 중단</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-751">Pausing and interrupting threads</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="0137b-752">관리되는 스레드 상태</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-752">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="0137b-753">새 아파트 상태입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-753">The new apartment state.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-754">스레드를 시작하기 전에 스레드의 아파트 상태를 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-754">Sets the apartment state of a thread before it is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-755">새 스레드가 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 시작 되기 전에 아파트 상태로 설정 되지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="0137b-755">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="0137b-756">스레드가 시작 되기 전에 아파트 상태를 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-756">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-757">기본 응용 프로그램 스레드가 초기화가 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 기본적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-757">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="0137b-758">주 응용 프로그램 스레드의 아파트 상태를 설정 하는 유일한 방법은 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> 적용 하는 것은 <xref:System.STAThreadAttribute> 진입점 메서드 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-758">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="0137b-759"><xref:System.Threading.Thread.SetApartmentState%2A> 메서드를 함께 합니다 <xref:System.Threading.Thread.GetApartmentState%2A> 메서드 및 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드를 대체 합니다 <xref:System.Threading.Thread.ApartmentState%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="0137b-759">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-760">다음 코드 예제는 <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, 및 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-760">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="0137b-761">코드 예제에서는 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-761">The code example creates a thread.</span></span> <span data-ttu-id="0137b-762">스레드를 시작 하기 전에 <xref:System.Threading.Thread.GetApartmentState%2A> 초기 표시 <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> 상태와 <xref:System.Threading.Thread.SetApartmentState%2A> 상태를 변경 합니다 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-762">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0137b-763">합니다 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드가 반환 됩니다 `false` 상태를 변경 하려고 할 때 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 아파트 상태가 이미 설정 되어 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-763">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="0137b-764">동일한 작업을 시도 하는 경우 <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> 이 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-764">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="0137b-765">스레드가 시작 된 후의 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드를 다시 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-765">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="0137b-766">이 시간 throw <xref:System.Threading.ThreadStateException> 스레드가 이미 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-766">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="0137b-767">.NET Core만 해당: 이 멤버는 macOS 및 Linux 플랫폼에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-767">.NET Core only: This member is not supported on the macOS and Linux platforms.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0137b-768">
            <paramref name="state" />가 잘못된 아파트 상태가 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-768">
              <paramref name="state" /> is not a valid apartment state.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-769">스레드가 이미 시작되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-769">The thread has already been started.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0137b-770">아파트 상태가 이미 초기화되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-770">The apartment state has already been initialized.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">
          <span data-ttu-id="0137b-771">현재 스레드에 적용할 <see cref="T:System.Threading.CompressedStack" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-771">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-772">캡처한 <see cref="T:System.Threading.CompressedStack" />을 현재 스레드에 적용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-772">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-773">이 메서드는 더 이상 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-773">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0137b-774">모든 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-774">In all cases.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0137b-775">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-775">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0137b-776">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-776">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">
          <span data-ttu-id="0137b-777">값을 설정할 <see cref="T:System.LocalDataStoreSlot" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-777">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="0137b-778">설정하려는 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-778">The value to be set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-779">해당 스레드의 현재 도메인에 대해 현재 실행 중인 스레드의 지정된 슬롯에서 데이터를 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-779">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span>
          </span>
          <span data-ttu-id="0137b-780">성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-780">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="0137b-781">스레드 로컬 저장소 (TLS)를 사용 하 여 두 가지 메커니즘을 제공 하는.NET Framework: 스레드 상대 정적 필드 (즉, 표시 된 필드를 사용 하 여는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-781">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="0137b-782">스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-782">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="0137b-783">TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-783">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="0137b-784">스레드는 스레드 관련 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-784">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="0137b-785">공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-785">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="0137b-786">스레드는 데이터 저장소에 데이터 슬롯을 할당할 수, 저장 및 검색 데이터 슬롯의 값 및 스레드 프로시저가 종료 된 후 다시 사용에 대 한 슬롯을 해제 및 <xref:System.Threading.Thread> 가비지 수집에서 회수 된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-786">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="0137b-787">데이터 슬롯은 스레드 당 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-787">Data slots are unique per thread.</span></span> <span data-ttu-id="0137b-788">다른 스레드가 없습니다. (자식 스레드 하지도 함) 해당 데이터를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-788">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-789"><xref:System.Threading.Thread.SetData%2A> 가 `Shared` 항상 적용 되는 현재 실행 중인 스레드와 다른 스레드를 가리키는 변수를 사용 하 여 호출 하는 경우에 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-789"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="0137b-790">혼동을 피하기 위해 사용 하 여 클래스 이름을 호출 하는 경우 `Shared` 메서드: `Thread.SetData(testSlot, "test data")`합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-790">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-791">이 섹션에는 두 코드 예제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-791">This section contains two code examples.</span></span> <span data-ttu-id="0137b-792">첫 번째 예제에 사용 하 여 표시 된 필드를 사용 하는 방법을 보여 줍니다는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 저장 하는 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-792">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="0137b-793">두 번째 예제에는 데이터 슬롯을 사용 하 여 동일한 작업을 수행 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-793">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="0137b-794">**첫 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-794">**First Example**</span></span>  
  
 <span data-ttu-id="0137b-795">다음 예제로 표시 된 필드를 사용 하는 방법을 보여 줍니다 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-795">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="0137b-796">이 방법은 두 번째 예제에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-796">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="0137b-797">**두 번째 예제**</span><span class="sxs-lookup"><span data-stu-id="0137b-797">**Second Example**</span></span>  
  
 <span data-ttu-id="0137b-798">다음 예제에서는 명명된 된 데이터 슬롯을 사용 하 여 스레드 관련 정보를 저장 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-798">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="0137b-799">스레드 및 스레딩</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-799">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="0137b-800">스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-800">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-801">지정된 시간 동안 현재 스레드를 일시 중단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-801">Suspends the current thread for the specified amount of time.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="0137b-802">스레드가 일시 중단되는 밀리초 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-802">The number of milliseconds for which the thread is suspended.</span>
          </span>
          <span data-ttu-id="0137b-803">
            <c>millisecondsTimeout</c> 인수의 값이 0이면 스레드는 실행할 준비가 된 우선 순위가 같은 스레드에 나머지 시간 간격을 내어 줍니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-803">If the value of the <c>millisecondsTimeout</c> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span>
          </span>
          <span data-ttu-id="0137b-804">실행할 준비가 된 우선 순위가 같은 스레드가 없으면 현재 스레드의 실행이 일시 중단되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-804">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-805">지정된 시간(밀리초) 동안 현재 스레드를 일시 중단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-805">Suspends the current thread for the specified number of milliseconds.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-806">지정 된 시간 동안 운영 체제에서 실행에 대 한 스레드를 예약할 수 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-806">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="0137b-807">이 메서드를 포함 하는 스레드의 상태를 변경 <xref:System.Threading.ThreadState.WaitSleepJoin>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-807">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="0137b-808">지정할 수 있습니다 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 에 대 한는 `millisecondsTimeout` 매개 변수를 스레드를 무기한으로 일시 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-808">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="0137b-809">하지만 다른을 사용 하는 권장 <xref:System.Threading?displayProperty=nameWithType> 와 같은 클래스 <xref:System.Threading.Mutex>를 <xref:System.Threading.Monitor>를 <xref:System.Threading.EventWaitHandle>, 또는 <xref:System.Threading.Semaphore> 대신 동기화 할 스레드에 또는 리소스를 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-809">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="0137b-810">특정 속도로 시스템 클록 틱의 클록 해상도 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-810">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="0137b-811">실제 제한 시간 정확 하 게 지정된 된 제한 시간을 지정된 된 제한 시간 클록 틱에 맞추어 조정 됩니다 때문에 없을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-811">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="0137b-812">시계 확인 및 대기 시간에 대 한 자세한 내용은 참조는 [함수를 절전 모드로 전환](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) 항목.</span><span class="sxs-lookup"><span data-stu-id="0137b-812">For more information on clock resolution and the waiting time, see the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) topic.</span></span> <span data-ttu-id="0137b-813">이 메서드를 호출 합니다 [함수를 절전 모드로 전환](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) Api Windows 시스템에서.</span><span class="sxs-lookup"><span data-stu-id="0137b-813">This method calls the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="0137b-814">이 메서드는 표준 COM 및 SendMessage 펌프를 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-814">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-815">있는 스레드를 대기 해야 하는 경우 <xref:System.STAThreadAttribute>를 오버 로드 중 하나를 사용 하는 것이 좋습니다, 표준 COM 및 SendMessage 펌프를 수행 하려는 <xref:System.Threading.Thread.Join%2A> 제한 시간 간격을 지정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-815">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-816">다음 예제에서는 <xref:System.Threading.Thread.Sleep%2A> 응용 프로그램의 주 스레드를 차단 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-816">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0137b-817">시간 제한 값이 음수이며 <see cref="F:System.Threading.Timeout.Infinite" />와 같지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-817">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="0137b-818">스레드가 일시 중단되는 시간입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-818">The amount of time for which the thread is suspended.</span>
          </span>
          <span data-ttu-id="0137b-819">
            <c>millisecondsTimeout</c> 인수의 값이 <see cref="F:System.TimeSpan.Zero" />이면 스레드는 실행할 준비가 된 우선 순위가 같은 스레드에 나머지 시간 간격을 내어 줍니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-819">If the value of the <c>millisecondsTimeout</c> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span>
          </span>
          <span data-ttu-id="0137b-820">실행할 준비가 된 우선 순위가 같은 스레드가 없으면 현재 스레드의 실행이 일시 중단되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-820">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-821">지정된 시간 동안 현재 스레드를 일시 중단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-821">Suspends the current thread for the specified amount of time.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-822">지정 된 시간 동안 운영 체제에서 실행에 대 한 스레드를 예약할 수 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-822">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="0137b-823">이 메서드를 포함 하는 스레드의 상태를 변경 <xref:System.Threading.ThreadState.WaitSleepJoin>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-823">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="0137b-824">지정할 수 있습니다 <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> 에 대 한는 `timeout` 매개 변수를 스레드를 무기한으로 일시 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-824">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="0137b-825">하지만 다른을 사용 하는 권장 <xref:System.Threading?displayProperty=nameWithType> 와 같은 클래스 <xref:System.Threading.Mutex>를 <xref:System.Threading.Monitor>를 <xref:System.Threading.EventWaitHandle>, 또는 <xref:System.Threading.Semaphore> 대신 동기화 할 스레드에 또는 리소스를 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-825">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="0137b-826">이 오버 로드 <xref:System.Threading.Thread.Sleep%2A> 에서 정수 밀리초의 총 수를 사용 하 여 `timeout`입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-826">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="0137b-827">소수 시간 (밀리초)이 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-827">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="0137b-828">이 메서드는 표준 COM 및 SendMessage 펌프를 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-828">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-829">있는 스레드를 대기 해야 하는 경우 <xref:System.STAThreadAttribute>를 오버 로드 중 하나를 사용 하는 것이 좋습니다, 표준 COM 및 SendMessage 펌프를 수행 하려는 <xref:System.Threading.Thread.Join%2A> 제한 시간 간격을 지정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-829">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-830">다음 예제에서는 <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> 메서드 오버 로드를 2 초 동안 때마다 다섯 번 응용 프로그램의 주 스레드를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-830">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0137b-831">
            <paramref name="timeout" /> 값이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(밀리초)와 같지 않거나 <see cref="F:System.Int32.MaxValue" />(밀리초)보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-831">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">
          <span data-ttu-id="0137b-832">스레드 대기 시간을 정의하는 부호 있는 32비트 정수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-832">A 32-bit signed integer that defines how long a thread is to wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-833">스레드가 <paramref name="iterations" /> 매개 변수에서 정의하는 시간 동안 대기하도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-833">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-834"><xref:System.Threading.Thread.SpinWait%2A> 메서드는 잠금을 구현 하는 데 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-834">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="0137b-835">와 같은.NET framework에서 클래스 <xref:System.Threading.Monitor> 및 <xref:System.Threading.ReaderWriterLock>,이 메서드를 내부적으로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-835">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="0137b-836"><xref:System.Threading.Thread.SpinWait%2A> 기본적으로 지정 된 반복 횟수를 사용 하 여 매우 긴밀 한 루프에 프로세서를 배치 합니다 `iterations` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-836"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="0137b-837">따라서 대기 기간 프로세서의 속도에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-837">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="0137b-838">이 <xref:System.Threading.Thread.Sleep%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-838">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="0137b-839">호출 하는 스레드 <xref:System.Threading.Thread.Sleep%2A> 지정한 간격이 0 인 경우에 해당 현재 프로세서 시간 조각의 나머지 부분을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-839">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="0137b-840">에 대해 0이 아닌 간격을 지정 <xref:System.Threading.Thread.Sleep%2A> 시간 간격이 경과할 때까지 스레드를 스레드 스케줄러에서 고려 대상에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-840">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="0137b-841"><xref:System.Threading.Thread.SpinWait%2A> 일반적인 응용 프로그램에 일반적으로 유용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-841"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="0137b-842">대부분의 경우에서 않으며.NET Framework에서 제공 되는 동기화 클래스 사용 해야 예를 들어, 호출 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 문이나를 래핑하는 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` C# 또는 `SyncLock` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="0137b-842">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0137b-843">상태 변경 임박을 알고 있는 경우와 같은 컨텍스트 스위치를 피하려면 하는 드문 경우를 호출 하 여 <xref:System.Threading.Thread.SpinWait%2A> 루프에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-843">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="0137b-844">코드 <xref:System.Threading.Thread.SpinWait%2A> 실행 되는 다중 프로세서 컴퓨터에서 발생할 수 있는 문제를 방지 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-844">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="0137b-845">예를 들어, 하이퍼 스레딩 기술에서는 사용 하는 여러 Intel 프로세서가 장착 된 컴퓨터에서 <xref:System.Threading.Thread.SpinWait%2A> 프로세서 부족 상황에서을 방지 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-845">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-846">스레드의 실행 일정을 예약합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-846">Causes a thread to be scheduled for execution.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-847">운영 체제에서 현재 인스턴스의 상태를 <see cref="F:System.Threading.ThreadState.Running" />으로 변경하도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-847">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-848">스레드 되 면는 <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> 상태, 운영 체제 실행을 예약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-848">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="0137b-849">스레드가 나타내는 메서드의 첫 번째 줄에서 실행이 시작 합니다 <xref:System.Threading.ThreadStart> 또는 <xref:System.Threading.ParameterizedThreadStart> 스레드 생성자에 제공 하는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-849">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="0137b-850">호출 <xref:System.Threading.Thread.Start%2A> 호출 스레드를 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-850">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-851">이 오버 로드를 사용 하 여 만든 스레드를 사용 하 여 사용 하는 경우는 <xref:System.Threading.ParameterizedThreadStart> 대리자 `null` 스레드에 의해 실행 메서드에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-851">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="0137b-852">스레드가 종료 되 면 다시 시작할 수 없습니다를 호출 하 여 `Start`입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-852">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-853">다음 예제에서는 만들고 스레드를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-853">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-854">스레드가 이미 시작되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-854">The thread has already been started.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="0137b-855">이 스레드를 시작하기 위한 메모리가 부족합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-855">There is not enough memory available to start this thread.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="0137b-856">스레드 및 스레딩</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-856">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">
          <span data-ttu-id="0137b-857">스레드 만들기 및 시작할 때 데이터 전달</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-857">Creating Threads and Passing Data at Start Time</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">
          <span data-ttu-id="0137b-858">스레드가 실행하는 메서드에 사용될 데이터가 포함된 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-858">An object that contains data to be used by the method the thread executes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-859">운영 체제에서 현재 인스턴스의 상태를 <see cref="F:System.Threading.ThreadState.Running" />으로 변경하도록 하며 경우에 따라 스레드가 실행하는 메서드에 사용될 데이터가 포함된 개체를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-859">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-860">스레드 되 면는 <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> 상태, 운영 체제 실행을 예약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-860">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="0137b-861">스레드가 나타내는 메서드의 첫 번째 줄에서 실행이 시작 합니다 <xref:System.Threading.ThreadStart> 또는 <xref:System.Threading.ParameterizedThreadStart> 스레드 생성자에 제공 하는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-861">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="0137b-862">호출 <xref:System.Threading.Thread.Start%2A> 호출 스레드를 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-862">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="0137b-863">스레드가 종료 되 면 다시 시작할 수 없습니다를 호출 하 여 `Start`입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-863">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="0137b-864">이 오버 로드 및 <xref:System.Threading.ParameterizedThreadStart> 대리자 쉽게 데이터를 스레드 프로시저에 전달할 있지만 기술을 형식이 안전 하지 않은 모든 개체는이 오버 로드에 전달 될 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-864">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="0137b-865">스레드 프로시저에 데이터를 전달 하는 보다 강력한 방법 작업자 개체로 스레드 프로시저 및 데이터 필드를 배치 하는 경우</span><span class="sxs-lookup"><span data-stu-id="0137b-865">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="0137b-866">자세한 내용은 [스레드 만들기 및 시작 시 데이터 전달](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-866">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-867">다음 예제에서는 <xref:System.Threading.ParameterizedThreadStart> 정적 메서드와 인스턴스 메서드를 사용 하 여 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-867">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-868">스레드가 이미 시작되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-868">The thread has already been started.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="0137b-869">이 스레드를 시작하기 위한 메모리가 부족합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-869">There is not enough memory available to start this thread.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0137b-870">이 스레드는 <see cref="T:System.Threading.ParameterizedThreadStart" /> 대리자 대신 <see cref="T:System.Threading.ThreadStart" /> 대리자를 사용하여 만들었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-870">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">
          <span data-ttu-id="0137b-871">스레드 만들기</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-871">Creating Threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-872">스레드를 일시 중단하며 스레드가 이미 일시 중단된 경우에는 아무런 효과도 나타나지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-872">Either suspends the thread, or if the thread is already suspended, has no effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-873">스레드가 이미 일시 중단 하는 경우이 메서드는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-873">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0137b-874">사용 하지 않는 합니다 <xref:System.Threading.Thread.Suspend%2A> 및 <xref:System.Threading.Thread.Resume%2A> 스레드의 활동을 동기화 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-874">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="0137b-875">일시 중단 하면 스레드는 어떤 코드가 실행 되는 알 수 없습니다 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-875">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="0137b-876">스레드 보안 권한 확인 하는 동안 잠금을 유지 하는 동안 스레드를 일시 중단, 기타는 <xref:System.AppDomain> 차단 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-876">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="0137b-877">클래스 생성자를 실행 하는 동안 스레드를 일시 중단, 기타의 스레드는 <xref:System.AppDomain> 클래스 차단 됩니다 사용 하려고 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-877">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="0137b-878">교착 상태를 매우 쉽게 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-878">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="0137b-879">.NET Core만 해당: 이 멤버는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-879">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-880">스레드가 시작 또는 중단되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-880">The thread has not been started or is dead.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="0137b-881">호출자에게 해당 <see cref="T:System.Security.Permissions.SecurityPermission" />이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-881">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="0137b-882">스레드에서 고급 작업입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-882">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="0137b-883">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-883">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">
          <span data-ttu-id="0137b-884">스레드 일시 중지 및 중단</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-884">Pausing and interrupting threads</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="0137b-885">관리되는 스레드 상태</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-885">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="0137b-886">나중에 사용하기 위해 예약되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-886">Reserved for future use.</span>
          </span>
          <span data-ttu-id="0137b-887">IID_NULL이어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-887">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="0137b-888">매핑할 전달된 이름의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-888">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="0137b-889">매핑할 이름의 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-889">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="0137b-890">이름을 해석할 로캘 컨텍스트입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-890">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="0137b-891">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-891">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-892">이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-892">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-893">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-893">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="0137b-894">에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-894">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="0137b-895">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-895">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="0137b-896">반환할 형식 정보입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-896">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="0137b-897">형식 정보의 로캘 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-897">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="0137b-898">요청된 형식 정보 개체에 대한 포인터를 받습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-898">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-899">인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-899">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-900">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-900">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="0137b-901">에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-901">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="0137b-902">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-902">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="0137b-903">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-903">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-904">개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-904">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-905">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-905">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="0137b-906">에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-906">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="0137b-907">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-907">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="0137b-908">멤버를 식별합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-908">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="0137b-909">나중에 사용하기 위해 예약되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-909">Reserved for future use.</span>
          </span>
          <span data-ttu-id="0137b-910">IID_NULL이어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-910">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="0137b-911">인수를 해석할 로캘 컨텍스트입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-911">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="0137b-912">호출의 컨텍스트를 설명하는 플래그입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-912">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="0137b-913">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-913">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="0137b-914">결과를 저장할 위치에 대한 포인터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-914">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="0137b-915">예외 정보가 포함된 구조체에 대한 포인터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-915">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="0137b-916">오류가 있는 첫 번째 인수의 인덱스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-916">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-917">개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-917">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-918">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-918">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="0137b-919">에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-919">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="0137b-920">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-920">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-921">현재 스레드의 상태를 포함하는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-921">Gets a value containing the states of the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0137b-922">현재 스레드의 상태를 나타내는 <see cref="T:System.Threading.ThreadState" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-922">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span>
          </span>
          <span data-ttu-id="0137b-923">초기 값은 <see langword="Unstarted" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-923">The initial value is <see langword="Unstarted" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-924">합니다 <xref:System.Threading.Thread.ThreadState%2A> 속성 보다 구체적인 정보를 제공 합니다 <xref:System.Threading.Thread.IsAlive%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-924">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0137b-925">스레드 상태는만 디버깅 시나리오에서 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-925">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="0137b-926">코드에서 스레드 상태를 사용하여 스레드 활동을 동기화하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-926">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-927">다음 코드 예제에 액세스 하는 방법을 보여 줍니다는 `ThreadState` 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-927">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="0137b-928">관리되는 스레드 상태</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-928">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="0137b-929">새 아파트 상태입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-929">The new apartment state.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-930">스레드를 시작하기 전에 스레드의 아파트 상태를 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-930">Sets the apartment state of a thread before it is started.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-931">아파트 상태가 설정되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-931">
              <see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-932">새 스레드가 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 시작 되기 전에 아파트 상태로 설정 되지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="0137b-932">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="0137b-933">스레드가 시작 되기 전에 아파트 상태를 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-933">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-934">기본 응용 프로그램 스레드가 초기화가 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 기본적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-934">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="0137b-935">주 응용 프로그램 스레드의 아파트 상태를 설정 하는 유일한 방법은 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> 적용 하는 것은 <xref:System.STAThreadAttribute> 진입점 메서드 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-935">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="0137b-936"><xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드를 함께 합니다 <xref:System.Threading.Thread.GetApartmentState%2A> 메서드 및 <xref:System.Threading.Thread.SetApartmentState%2A> 메서드를 대체 합니다 <xref:System.Threading.Thread.ApartmentState%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="0137b-936">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0137b-937">다음 코드 예제는 <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, 및 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0137b-937">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="0137b-938">코드 예제에서는 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-938">The code example creates a thread.</span></span> <span data-ttu-id="0137b-939">스레드를 시작 하기 전에 <xref:System.Threading.Thread.GetApartmentState%2A> 초기 표시 <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> 상태와 <xref:System.Threading.Thread.SetApartmentState%2A> 상태를 변경 합니다 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-939">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0137b-940">합니다 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드가 반환 됩니다 `false` 상태를 변경 하려고 할 때 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 아파트 상태가 이미 설정 되어 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-940">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="0137b-941">동일한 작업을 시도 하는 경우 <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> 이 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-941">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="0137b-942">스레드가 시작 된 후의 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드를 다시 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-942">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="0137b-943">이 시간 throw <xref:System.Threading.ThreadStateException> 스레드가 이미 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-943">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0137b-944">
            <paramref name="state" />가 잘못된 아파트 상태가 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-944">
              <paramref name="state" /> is not a valid apartment state.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="0137b-945">스레드가 이미 시작되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-945">The thread has already been started.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-946">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-946">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-947">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-947">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-948">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-948">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-949">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-949">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-950">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-950">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-951">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-951">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-952"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-952"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-953">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-953">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-954">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-954">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-955">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-955">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-956">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-956">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-957">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-957">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-958">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-958">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-959">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-959">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-960">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-960">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-961">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-961">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-962">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-962">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-963">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-963">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-964">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-964">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-965"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-965"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-966">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-966">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-967">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-967">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-968">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-968">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-969">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-969">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-970">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-970">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-971">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-971">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-972">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-972">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-973">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-973">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-974">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-974">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-975">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-975">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-976">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-976">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-977">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-977">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-978"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-978"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-979">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-979">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-980">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-980">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-981">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-981">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-982">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-982">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-983">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-983">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-984">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-984">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-985">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-985">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-986">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-986">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-987">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-987">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-988">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-988">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-989">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-989">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-990">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-990">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-991"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-991"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-992">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-992">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-993">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-993">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-994">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-994">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-995">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-995">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-996">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-996">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-997">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-997">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-998">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-998">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-999">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-999">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1000">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1000">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1001">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1001">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-1002">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1002">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-1003">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1003">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1004"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1004"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1005">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1005">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1006">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1006">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-1007">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1007">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1008">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1008">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1009">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1009">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1010">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1010">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1011">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1011">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1012">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1012">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1013">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1013">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1014">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1014">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-1015">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1015">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-1016">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1016">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1017"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1017"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1018">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1018">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1019">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1019">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-1020">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1020">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1021">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1021">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1022">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1022">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1023">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1023">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1024">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1024">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1025">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1025">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1026">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1026">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1027">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1027">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-1028">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1028">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-1029">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1029">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1030"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1030"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1031">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1031">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1032">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1032">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-1033">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1033">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1034">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1034">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1035">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1035">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1036">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1036">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1037">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1037">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1038">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1038">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1039">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1039">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1040">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1040">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-1041">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1041">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-1042">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1042">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1043"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1043"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1044">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1044">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1045">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1045">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-1046">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1046">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1047">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1047">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1048">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1048">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1049">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1049">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1050">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1050">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1051">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1051">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1052">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1052">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1053">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1053">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-1054">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1054">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-1055">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1055">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1056"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1056"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1057">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1057">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1058">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1058">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-1059">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1059">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1060">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1060">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1061">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1061">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1062">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1062">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1063">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1063">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1064">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1064">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1065">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1065">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1066">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1066">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-1067">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1067">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-1068">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1068">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1069"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1069"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1070">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1070">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1071">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1071">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-1072">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1072">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1073">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1073">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1074">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1074">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1075">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1075">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1076">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1076">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1077">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1077">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1078">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1078">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1079">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1079">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-1080">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1080">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-1081">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1081">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1082"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1082"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1083">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1083">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1084">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1084">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-1085">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1085">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1086">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1086">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1087">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1087">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1088">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1088">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1089">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1089">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1090">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1090">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1091">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1091">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1092">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1092">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-1093">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1093">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-1094">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1094">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1095"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1095"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1096">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1096">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1097">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1097">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-1098">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1098">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1099">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1099">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1100">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1100">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1101">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1101">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1102">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1102">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1103">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1103">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1104">읽을 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1104">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1105">필드의 값을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1105">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="0137b-1106">이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1106">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-1107">프로세서에서 해당 필드에 쓴 마지막 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1107">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1108"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1108"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1109">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1109">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1110">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 의 어떠한 프로세서 메모리 위치에 기록 합니다. 최신 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1110">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="0137b-1111">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1111">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1112">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1112">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1113">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1113">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1114">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1114">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1115">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1115">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1116">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1116">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0137b-1117">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1117">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1118">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1118">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1119">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1119">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1120">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1120">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1121"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1121"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1122">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1122">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1123">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1123">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1124">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1124">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1125">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1125">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1126">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1126">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1127">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1127">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1128">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1128">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1129">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1129">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1130">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1130">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1131">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1131">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1132">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1132">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1133"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1133"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1134">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1134">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1135">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1135">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1136">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1136">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1137">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1137">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1138">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1138">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1139">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1139">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1140">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1140">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1141">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1141">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1142">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1142">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1143">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1143">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1144">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1144">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1145"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1145"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1146">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1146">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1147">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1147">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1148">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1148">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1149">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1149">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1150">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1150">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1151">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1151">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1152">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1152">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1153">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1153">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1154">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1154">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1155">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1155">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1156">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1156">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1157"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1157"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1158">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1158">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1159">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1159">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1160">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1160">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1161">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1161">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1162">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1162">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1163">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1163">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1164">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1164">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1165">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1165">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1166">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1166">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1167">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1167">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1168">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1168">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1169"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1169"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1170">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1170">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1171">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1171">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1172">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1172">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1173">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1173">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1174">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1174">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1175">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1175">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1176">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1176">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1177">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1177">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1178">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1178">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1179">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1179">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1180">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1180">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1181"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1181"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1182">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1182">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1183">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1183">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1184">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1184">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1185">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1185">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1186">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1186">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1187">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1187">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1188">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1188">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1189">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1189">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1190">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1190">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1191">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1191">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1192">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1192">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1193"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1193"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1194">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1194">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1195">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1195">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1196">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1196">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1197">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1197">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1198">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1198">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1199">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1199">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1200">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1200">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1201">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1201">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1202">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1202">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1203">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1203">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1204">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1204">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1205"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1205"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1206">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1206">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1207">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1207">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1208">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1208">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1209">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1209">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1210">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1210">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1211">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1211">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1212">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1212">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1213">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1213">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1214">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1214">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1215">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1215">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1216">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1216">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1217"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1217"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1218">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1218">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1219">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1219">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1220">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1220">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1221">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1221">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1222">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1222">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1223">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1223">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1224">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1224">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1225">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1225">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1226">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1226">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1227">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1227">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1228">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1228">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1229"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1229"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1230">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1230">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1231">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1231">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1232">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1232">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1233">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1233">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1234">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1234">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1235">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1235">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1236">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1236">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1237">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1237">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1238">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1238">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1239">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1239">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1240">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1240">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1241"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1241"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1242">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1242">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1243">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1243">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1244">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1244">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1245">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1245">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1246">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1246">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1247">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1247">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1248">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1248">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1249">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1249">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1250">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1250">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1251">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1251">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1252">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1252">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1253"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1253"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1254">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1254">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1255">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1255">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1256">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1256">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1257">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1257">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1258">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1258">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1259">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1259">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1260">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1260">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1261">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1261">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0137b-1262">값이 쓰여질 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1262">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0137b-1263">쓸 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1263">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0137b-1264">이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1264">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1265"><xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 특별 한 경우 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1265"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="0137b-1266">정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문 및 <xref:System.Threading.Monitor> 클래스 쉽게 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1266">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="0137b-1267">다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1267">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="0137b-1268">프로세서 캐시 플러시 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1268">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="0137b-1269">단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 고 <xref:System.Threading.Thread.VolatileWrite%2A> 값 읽기 또는 메모리에 기록 하 고 (예: 프로세서 레지스터)에 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1269">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="0137b-1270">따라서 하드웨어 또는 다른 스레드에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화 하 고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1270">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="0137b-1271">이 메서드를 호출 하는 단일 메모리 액세스를만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1271">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="0137b-1272">필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 합니다 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1272">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0137b-1273">C#에서 사용 하는 `volatile` 한정자 필드를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1273">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0137b-1274">호출 스레드가 현재 프로세서에서 실행할 준비가 되어 있는 다른 스레드에 실행 명령을 내리도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1274">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span>
          </span>
          <span data-ttu-id="0137b-1275">운영 체제에서 실행 명령을 내릴 스레드를 선택합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1275">The operating system selects the thread to yield to.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0137b-1276">응용 프로그램에서 다른 스레드로 실행을 전환하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0137b-1276">
              <see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0137b-1277">이 메서드가 성공 하면 스레드의 현재 시간 조각의 나머지가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1277">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="0137b-1278">운영 체제의 우선 순위 및 실행에 사용할 수 있는 다른 스레드의 상태에 따라 다른 시간 조각에 대 한 호출 스레드를 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1278">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="0137b-1279">생성 호출 스레드를 실행 하는 프로세서로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1279">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="0137b-1280">운영 체제는 프로세서 유휴 또는 낮은 우선 순위의 스레드를 실행 중인 경우에 실행 다른 프로세서도 전환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1280">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="0137b-1281">현재 프로세서에서 실행할 준비가 되어 있는 다른 스레드가 없는 경우 운영 체제 실행을 생성 하지 않습니다 및이 메서드가 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1281">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="0137b-1282">이 메서드는 플랫폼을 사용 하 여 네이티브 Win32 호출을 호출 `SwitchToThread` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1282">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="0137b-1283">호출 해야 합니다 <xref:System.Threading.Thread.Yield%2A> 플랫폼 모든 사용자 지정 스레딩 동작 호스트 요청한 바이패스를 호출 하기 때문에 플랫폼을 사용 하는 대신 메서드 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="0137b-1283">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>