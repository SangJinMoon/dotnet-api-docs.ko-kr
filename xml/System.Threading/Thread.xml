<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7aae04c039e4c598f2f78c1131b5525f9c9e9654" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407697" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>스레드를 만들고 제어하며, 해당 속성을 설정하고, 상태를 가져옵니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스가 시작 되 면 공용 언어 런타임 응용 프로그램 코드를 실행 하는 단일 포그라운드 스레드를 자동으로 만듭니다. 이 기본 전경 스레드 함께 프로세스는 프로세스와 관련 된 프로그램 코드의 일부를 실행 하려면 하나 이상의 스레드를 만들 수 있습니다. 이러한 스레드는 포그라운드에서 또는 백그라운드에서 실행할 수 있습니다. 또한 사용할 수 있습니다는 <xref:System.Threading.ThreadPool> 공용 언어 런타임에 의해 관리 되는 작업자 스레드에 대 한 코드를 실행 하는 클래스입니다.  
  
 단원 내용  
  
 [스레드 시작](#Starting)   
 [스레드 개체를 검색합니다.](#Retrieving)   
 [포그라운드 및 백그라운드 스레드](#Foreground)   
 [문화권 및 스레드](#Culture)   
 [에 대 한 정보를 가져오고 스레드 제어](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>스레드 시작  
 해당 클래스 생성자에서를 실행 하는 메서드를 나타내는 대리자를 제공 하 여 스레드를 시작 합니다. 그런 다음 호출에서 <xref:System.Threading.Thread.Start%2A> 메서드 실행을 시작 합니다.  
  
 <xref:System.Threading.Thread> 생성자 실행할 메서드를 인수를 전달할 수 있는지 여부에 따라 두 대리자 유형 중 하나를 사용할 수 있습니다.  
  
-   전달 하면 메서드는 인수가 없는 경우는 <xref:System.Threading.ThreadStart> 생성자에 위임 합니다. 시그니처가:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     다음 예제를 만들고 실행 하는 스레드를 시작는 `ExecuteInForeground` 메서드. 메서드가 일부 스레드 속성에 대 한 정보를 표시 한 다음는 0.5 초 일시 중지 하 고 경과 된 초 수를 표시 하는 루프를 실행 합니다. 스레드가 5 초 이상 동안 실행 된 경우 루프 종료 되 고 스레드는 실행을 종료 합니다.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   메서드가 인수를 전달 하면 한 <xref:System.Threading.ParameterizedThreadStart> 생성자에 위임 합니다. 시그니처가:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     메서드가 대리자가 실행 한 다음 캐스팅 (C#) 하거나 (Visual Basic)에서는 매개 변수를 적절 한 형식 변환할 수 있습니다.  
  
     다음 예제는 이전 쿼리와 동일 호출 한다는 점을 제외 하 고는 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 생성자입니다. 이 버전의는 `ExecuteInForeground` 메서드는 루프를 실행 하는 시간 (밀리초). 대략적인 수를 나타내는 단일 매개 변수입니다.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 에 대 한 참조를 유지할 필요가 없는 한 <xref:System.Threading.Thread> 스레드를 시작 되 면 개체입니다. 스레드 실행 스레드 프로시저가 완료 될 때까지 계속 합니다.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>스레드 개체를 검색합니다.  
 정적을 사용할 수 있습니다 (`Shared` Visual basic에서) <xref:System.Threading.Thread.CurrentThread%2A> 스레드가 실행 하는 코드에서 현재 실행 중인 스레드에 대 한 참조를 검색 하는 속성입니다. 다음 예제에서는 <xref:System.Threading.Thread.CurrentThread%2A> 속성을 기본 응용 프로그램 스레드, 다른 포그라운드 스레드, 백그라운드 스레드 및 스레드 풀 스레드에서 대 한 정보를 표시 합니다.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>포그라운드 및 백그라운드 스레드  
 인스턴스는 <xref:System.Threading.Thread> 전경 스레드 또는 백그라운드 스레드 클래스를 나타냅니다. 백그라운드 스레드는 한 가지 예외로 포그라운드 스레드 동일: 모든 포그라운드 스레드가 했습니다. 종료 하는 경우 백그라운드 스레드에서 실행 되는 프로세스를 보관 하지 않습니다. 모든 포그라운드 스레드가 중지 되 면 런타임은 모든 백그라운드 스레드를 중지 하 고 종료 합니다.  
  
 기본적으로는 다음 스레드 포그라운드에서 실행합니다.  
  
-   기본 응용 프로그램 스레드입니다.  
  
-   호출 하 여 만든 모든 스레드는 <xref:System.Threading.Thread> 클래스 생성자입니다.  
  
 기본적으로는 다음 스레드 백그라운드에서 실행합니다.  
  
-   런타임에 의해 유지 관리 하는 작업자 스레드 풀은 풀 스레드를 스레드입니다.  사용 하 여 스레드 풀에서 스레드 풀 및 일정 작업을 구성할 수 있습니다는 <xref:System.Threading.ThreadPool> 클래스입니다.  
  
    > [!NOTE]
    >  작업 기반 비동기 작업은 스레드 풀 스레드에서 자동으로 실행합니다. 사용 하 여 작업 기반 비동기 작업의 <xref:System.Threading.Tasks.Task> 및 <xref:System.Threading.Tasks.Task%601> 클래스를 구현 하는 [작업 기반 비동기 패턴](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)합니다.  
  
-   비관리 코드에서 관리 되는 실행 환경에 들어가는 모든 스레드가 있습니다.  
  
 설정 하 여 백그라운드에서 실행 하는 스레드를 변경할 수는 <xref:System.Threading.Thread.IsBackground%2A> 언제 든 지 속성입니다.  백그라운드 스레드는 응용 프로그램이 실행 되 고 있지만 응용 프로그램의 파일 시스템 변경 사항 또는 들어오는 소켓 연결을 모니터링 하는 등 종료를 방지 해야 한다면 계속 해야 하는 모든 작업에 유용 합니다.  
  
 다음 예제에서는 포그라운드 및 백그라운드 스레드 간의 차이점을 보여 줍니다. 첫 번째 예제 비슷합니다는 [스레드 시작](#Starting) 섹션을 제외 하 고 스레드를 시작 하기 전에 백그라운드에서 실행할 설정 합니다. 출력에서 볼 수 있듯이 5 초 동안 실행 하기 전에 루프 중단 됩니다.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>문화권 및 스레드  
 각 스레드는로 표시 되는 문화권의 <xref:System.Threading.Thread.CurrentCulture%2A> 속성 및 UI 문화권에서 표시는 <xref:System.Threading.Thread.CurrentUICulture%2A> 속성입니다.  현재 문화권 등의 문화권 구분 작업 구문 분석 및 형식 지정, 문자열 비교 및 정렬을 지원 하 고 또한 쓰기 시스템 및 사용 하 여 스레드에서 일정을 제어 합니다. 현재 UI 문화권 리소스 파일에서 리소스의 문화권 구분 검색을 위해 제공합니다.  
  
 새 스레드를 인스턴스화할 때 해당 culture 및 UL culture 문화권 및 UI 스레드의 문화권에 새 스레드가 만들어집니다가 아니라 및 현재 시스템 문화권 및 UI 문화권에 의해 정의 됩니다. 즉, 예를 들어 있는 경우 현재 시스템 문화권이 영어 (미국) 및 기본 응용 프로그램 스레드의 현재 문화권이 프랑스어 (프랑스) 문화권 호출 하 여 만든 새 스레드는 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 주 스레드에서 생성자 영어 (미국) 및 프랑스어 (프랑스) 되지 됩니다. 자세한 내용은의 "문화권 및 스레드" 섹션을 참조 하십시오.는 <xref:System.Globalization.CultureInfo> 클래스 항목입니다.  
  
> [!IMPORTANT]
>  대상으로 하는 앱에 대 한 비동기 작업을 실행 하는 스레드는 적용 되지 않습니다는 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] 이상 버전에서는이 경우, 문화권 및 UI 문화권에는 비동기의 일부인 작업 컨텍스트; 된 스레드는 비동기 작업 실행 하 여 기본 문화권 및 비동기 작업을 시작 하는 스레드의 UI 문화권을 상속 합니다. 자세한 내용은 <xref:System.Globalization.CultureInfo> 클래스 항목의 “문화권 및 작업 기반 비동기 작업” 섹션을 참조하세요.  
  
 하나를 수행 하면 같은 culture 및 UL culture 공유 응용 프로그램에서 실행 되도록 하는 모든 스레드는 다음 중:  
  
-   전달할 수는 <xref:System.Globalization.CultureInfo> 해당 문화권을 나타내는 개체는 <xref:System.Threading.ParameterizedThreadStart> 위임 또는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> 메서드.  
  
-   실행 되는 앱에 대 한는 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 이상 버전, 문화권 및 UI 문화권의 값을 설정 하 여 응용 프로그램 도메인에서 만든 모든 스레드에 할당 하는 정의할 수 있습니다는 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> 속성입니다. 이것은 응용 프로그램별 도메인 설정 note 합니다.  
  
 자세한 내용 및 예제에 대 한의 "문화권 및 스레드" 섹션을 참조는 <xref:System.Globalization.CultureInfo> 클래스 항목입니다.  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>에 대 한 정보를 가져오고 스레드 제어  
 다양 한 스레드에 대 한 정보를 제공 하는 속성 값을 검색할 수 있습니다. 경우에 따라 스레드 작업을 제어 하려면 이러한 속성 값을 설정할 수도 있습니다. 이러한 스레드 속성은 다음과 같습니다.  
  
-   이름 <xref:System.Threading.Thread.Name%2A> 대 한 쓰기-스레드를 식별 하는 데 사용할 수 있는 속성에 한 번입니다.  기본값은 `null`합니다.  
  
-   해시 코드를 호출 하 여 검색할 수 있습니다는 <xref:System.Threading.Thread.GetHashCode%2A> 메서드. 해시 코드를 사용 하 여 고유 하 게 식별 스레드 수 있습니다. 스레드 수명 동안에 대 한 해시 코드 값을 가져온 응용 프로그램 도메인과 관계 없이 다른 스레드의 값과 충돌 하지 않습니다.  
  
-   스레드 id입니다. 읽기 전용 값 <xref:System.Threading.Thread.ManagedThreadId%2A> 속성이 런타임에 의해 할당 되 고 해당 프로세스 내에서 스레드를 고유 하 게 식별 합니다.  
  
    > [!NOTE]
    >  관리되지 않는 호스트가 관리되는 스레드와 관리되지 않는 스레드 간의 관계를 제어할 수 있으므로 운영 체제 [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)는 관리되는 스레드에 대한 고정 관계를 포함하지 않습니다. 특히, 정교한 호스트를 사용할 수는 [CLR 호스팅 API](https://msdn.microsoft.com/library/ms404385.aspx) 를 동일한 운영 체제 스레드에 대해 관리 되는 여러 스레드를 예약 하거나 다양 한 운영 체제 스레드 간에 관리 되는 스레드를 이동할 수 있습니다.  
  
-   스레드의 현재 상태입니다. 존재 기간에 대 한 스레드는 항상 하나 이상으로 정의 된 상태에는 <xref:System.Threading.ThreadState> 속성입니다.  
  
-   일정 예약 우선 순위 수준 문자로 정의 되는 <xref:System.Threading.ThreadPriority> 속성입니다. 스레드의 우선 순위를 요청 하려면이 값을 설정할 수 있지만 운영 체제에 의해 적용 되는 것 보장할 수는 없습니다.  
  
-   읽기 전용 <xref:System.Threading.Thread.IsThreadPoolThread%2A> 스레드는 스레드 풀 스레드 인지 여부를 나타내는 속성입니다.  
  
-   <xref:System.Threading.Thread.IsBackground%2A> 속성 자세한 내용은 참조는 [포그라운드 및 백그라운드 스레드](#Foreground) 섹션.  
  
## Examples  
 다음 예제에서는 간단한 스레딩 기능을 보여 줍니다.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 이 코드는 다음과 유사한 출력을 생성합니다.  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Thread" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">이 스레드의 실행이 시작될 때 호출될 메서드를 나타내는 대리자입니다.</param>
        <summary>스레드가 시작될 때 개체가 스레드로 전달될 수 있도록 하는 대리자를 지정하여 <see cref="T:System.Threading.Thread" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드 생성 될 때 실행을 시작 하지 않습니다. 스레드 실행을 예약 하려면 호출 된 <xref:System.Threading.Thread.Start%2A> 메서드. 스레드에 데이터 개체를 전달 하려면는 <xref:System.Threading.Thread.Start%28System.Object%29> 메서드 오버 로드 합니다.  
  
> [!NOTE]
>  Visual Basic 사용자를 생략할 수는 <xref:System.Threading.ThreadStart> 스레드를 만드는 경우에 생성자입니다. 사용 하 여는 `AddressOf` 예를 들어 메서드를 전달할 때 연산자 `Dim t As New Thread(AddressOf ThreadProc)`합니다. Visual Basic에서 자동으로 호출 된 <xref:System.Threading.ThreadStart> 생성자입니다.  
  
   
  
## Examples  
 만들기 및 사용에 대 한 구문을 보여 주는 다음 예제는 <xref:System.Threading.ParameterizedThreadStart> 정적 메서드와 인스턴스 메서드를 사용 하 여 대리자입니다.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">이 스레드의 실행이 시작될 때 호출될 메서드를 나타내는 <see cref="T:System.Threading.ThreadStart" /> 대리자입니다.</param>
        <summary>
          <see cref="T:System.Threading.Thread" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드 생성 될 때 실행을 시작 하지 않습니다. 스레드 실행을 예약 하려면 호출 된 <xref:System.Threading.Thread.Start%2A> 메서드.  
  
> [!NOTE]
>  Visual Basic 사용자를 생략할 수는 <xref:System.Threading.ThreadStart> 스레드를 만드는 경우에 생성자입니다. 사용 하 여는 `AddressOf` 예를 들어 메서드를 전달할 때 연산자 `Dim t As New Thread(AddressOf ThreadProc)`합니다. Visual Basic에서 자동으로 호출 된 <xref:System.Threading.ThreadStart> 생성자입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 정적 메서드를 실행 하는 스레드를 만드는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 다음 코드 예제에는 인스턴스 메서드를 실행 하는 스레드를 만드는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">이 스레드의 실행이 시작될 때 호출될 메서드를 나타내는 <see cref="T:System.Threading.ParameterizedThreadStart" /> 대리자입니다.</param>
        <param name="maxStackSize">스레드에서 사용할 최대 스택 크기(바이트)입니다. 실행 파일의 헤더에 지정된 기본 최대 스택 크기를 사용하려면 0을 지정합니다.  중요 부분적으로 신뢰할 수 있는 코드의 경우 <c>maxStackSize</c>가 기본 스택 크기보다 크면 무시됩니다. 예외가 throw되지 않습니다.</param>
        <summary>스레드가 시작될 때 스레드로 개체가 전달될 수 있도록 하는 대리자를 지정하고 스레드의 최대 스택 크기를 지정하여 <see cref="T:System.Threading.Thread" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자 오버 로드를 사용 하지 마십시오. 사용 하는 기본 스택 크기는 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 생성자 오버 로드는 스레드에 대 한 권장된 스택 크기입니다. 스레드가 메모리 문제가 발생 하는 경우는 가장 일반적인 원인은 프로그래밍 무한 재귀 같은 오류입니다.  
  
> [!IMPORTANT]
>  부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]코드 설정할 수 있습니다 완전히 신뢰할 수 있는, `maxStackSize` (1mb)의 기본 스택 크기 보다 큰 값으로. 더 큰 값을 지정 하는 경우 `maxStackSize` 코드가 부분 신뢰로 실행 되 고 때 `maxStackSize` 는 무시 됩니다 기본 스택 크기는 데 사용 됩니다. 예외가 throw되지 않습니다. 코드 모든 신뢰 수준에서 설정할 수 있습니다 `maxStackSize` 기본 스택 크기 보다 작은 값으로.  
  
> [!NOTE]
>  스레드를 시작 해야 하는 완전히 신뢰할 수 있는 라이브러리 부분적으로 신뢰할 수 있는 코드에서 사용할를 개발 하는 경우 큰 스택을 필요로 하는 스레드를 만들기 전에 완전 신뢰를 어설션해야 또는 기본 스택 크기를 사용 됩니다. 스레드에서 실행 되는 코드를 완벽 하 게 제어 하지 않는 한에 이렇게 하지 마십시오.  
  
 경우 `maxStackSize` 작으면 최소 스택 크기 보다 최소 스택 크기가 사용 됩니다. 경우 `maxStackSize` 배수가 아닙니다. 페이지 크기의 큰 페이지 크기의 배수로 반올림 됩니다. 예를 들어.NET Framework 버전 2.0은 Windows vista를 사용 하는 256KB (262, 144 바이트)는 최소 스택 크기 및 페이지 크기는 64KB (65536 바이트)입니다.  
  
> [!NOTE]
>  Windows XP 및 Windows Server 2003 이전 버전에서 `maxStackSize` 무시 되 고 실행 하는 헤더에 지정 된 스택 크기가 사용 됩니다.  
  
 매우 작은 스택 크기를 지정 하면 스택 오버플로 검색을 사용 하지 않도록 설정 해야 합니다. 스택에 엄격 하 게 제한 하는 경우 찾기 자체 지정 하면 스택 오버플로가 발생 했습니다. 스택 오버플로 검색을 사용 하지 않으려면 다음 응용 프로그램 구성 파일을 추가 합니다.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" />가 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">이 스레드의 실행이 시작될 때 호출될 메서드를 나타내는 <see cref="T:System.Threading.ThreadStart" /> 대리자입니다.</param>
        <param name="maxStackSize">스레드에서 사용할 최대 스택 크기(바이트)입니다. 실행 파일의 헤더에 지정된 기본 최대 스택 크기를 사용하려면 0을 지정합니다.  중요 부분적으로 신뢰할 수 있는 코드의 경우 <c>maxStackSize</c>가 기본 스택 크기보다 크면 무시됩니다. 예외가 throw되지 않습니다.</param>
        <summary>스레드의 최대 스택 크기를 지정하여 <see cref="T:System.Threading.Thread" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자 오버 로드를 사용 하지 마십시오. 사용 하는 기본 스택 크기는 <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> 생성자 오버 로드는 스레드에 대 한 권장된 스택 크기입니다. 스레드가 메모리 문제가 발생 하는 경우는 가장 일반적인 원인은 프로그래밍 무한 재귀 같은 오류입니다.  
  
> [!IMPORTANT]
>  부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]코드 설정할 수 있습니다 완전히 신뢰할 수 있는, `maxStackSize` (1mb)의 기본 스택 크기 보다 큰 값으로. 더 큰 값을 지정 하는 경우 `maxStackSize` 코드가 부분 신뢰로 실행 되 고 때 `maxStackSize` 는 무시 됩니다 기본 스택 크기는 데 사용 됩니다. 예외가 throw되지 않습니다. 코드 모든 신뢰 수준에서 설정할 수 있습니다 `maxStackSize` 기본 스택 크기 보다 작은 값으로.  
  
> [!NOTE]
>  스레드를 시작 해야 하는 완전히 신뢰할 수 있는 라이브러리 부분적으로 신뢰할 수 있는 코드에서 사용할를 개발 하는 경우 큰 스택을 필요로 하는 스레드를 만들기 전에 완전 신뢰를 어설션해야 또는 기본 스택 크기를 사용 됩니다. 스레드에서 실행 되는 코드를 완벽 하 게 제어 하지 않는 한에 이렇게 하지 마십시오.  
  
 경우 `maxStackSize` 작으면 최소 스택 크기 보다 최소 스택 크기가 사용 됩니다. 경우 `maxStackSize` 배수가 아닙니다. 페이지 크기의 큰 페이지 크기의 배수로 반올림 됩니다. 예를 들어.NET Framework 버전 2.0은 Windows vista를 사용 하는 256KB (262, 144 바이트)는 최소 스택 크기 및 페이지 크기는 64KB (65536 바이트)입니다.  
  
> [!NOTE]
>  Windows XP 및 Windows Server 2003 이전 버전에서 `maxStackSize` 무시 되 고 실행 하는 헤더에 지정 된 스택 크기가 사용 됩니다.  
  
 매우 작은 스택 크기를 지정 하면 스택 오버플로 검색을 사용 하지 않도록 설정 해야 합니다. 스택에 엄격 하 게 제한 하는 경우 찾기 자체 지정 하면 스택 오버플로가 발생 했습니다. 스택 오버플로 검색을 사용 하지 않으려면 다음 응용 프로그램 구성 파일을 추가 합니다.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" />가 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 메서드가 호출되는 스레드에서 <see cref="T:System.Threading.ThreadAbortException" />을 발생시켜 스레드 종료 프로세스를 시작합니다. 이 메서드를 호출하면 대개 스레드가 종료됩니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드가 호출되는 스레드에서 <see cref="T:System.Threading.ThreadAbortException" />을 발생시켜 스레드 종료 프로세스를 시작합니다. 이 메서드를 호출하면 대개 스레드가 종료됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 스레드에서 호출 되 면 시스템에서 throw 한 <xref:System.Threading.ThreadAbortException> 에서 스레드를 중단 하는 것입니다. `ThreadAbortException` 응용 프로그램 코드에서 사용할 수 있는 특별 한 예외가 있지만 끝날 때 다시 throw 된 `catch` 차단 하지 않는 한 <xref:System.Threading.Thread.ResetAbort%2A> 라고 합니다. `ResetAbort` 중단을 요청을 취소 하 고 방지는 `ThreadAbortException` 의 스레드를 종료 합니다. 실행 되지 않은 `finally` 블록 스레드가 중단 되기 전에 실행 됩니다.  
  
> [!NOTE]
>  호출 하면 스레드 `Abort` 효과 자기 비슷합니다 자체에 <xref:System.Threading.ThreadAbortException> 즉시 발생 하는 결과 예측 가능한 합니다. 그러나 한 스레드가 `Abort` 다른 스레드에서 abort 인터럽트 모든 코드가 실행 되 고 있습니다. 정적 생성자를 중단 될 수 있는 기회 이기도 합니다. 드문 경우에서 해당 클래스의 인스턴스로 해당 응용 프로그램 도메인에서 생성 되지 못할 수도 있습니다. .NET Framework 버전 1.0 및 1.1은 스레드가 중단 수 있는 기회 동안는 `finally` 블록이 실행 되는 경우, 고 `finally` 블록이 중단 됩니다.  
  
 스레드가 즉시 또는 전혀 중단 보장 되지 않습니다. 스레드 제한 없는에 계산의 경우 이러한 상황이 발생할 수 있습니다는 `finally` 무한정 중단이 지연 되는 중단 절차의 일부분으로 호출 된 합니다. 스레드가 중단 될 때까지 기다려야 호출할 수 있습니다는 <xref:System.Threading.Thread.Join%2A> 메서드를 호출한 후 스레드에서 <xref:System.Threading.Thread.Abort%2A> 메서드를 있지만 될 보장 되지 않습니다.  
  
> [!NOTE]
>  호출 하는 스레드에서 <xref:System.Threading.Thread.Abort%2A> 중단 중인 스레드가 코드의 보호 된 영역에 같은 경우를 차단할 수는 `catch` 블록 `finally` 블록 또는 제약이 있는 실행 영역입니다. 호출 하는 스레드가 <xref:System.Threading.Thread.Abort%2A> 잠금이 중단 된 스레드 필요한 교착 상태가 발생할 수 있습니다.  
  
 경우 `Abort` 라고 시작 되지 않은 스레드에서 스레드가 될 때 중단 됩니다 <xref:System.Threading.Thread.Start%2A> 라고 합니다. 경우 `Abort` 라고 차단 되었거나 대기 중인 스레드에 스레드가 중단 되며 완전히 중단 됩니다.  
  
 경우 `Abort` 중단 된 스레드에서 호출는 <xref:System.Threading.ThreadStateException> 호출 스레드에서 throw 되 <xref:System.Threading.Thread.Abort%2A>, 및 <xref:System.Threading.ThreadState.AbortRequested> 에 추가 되는 <xref:System.Threading.Thread.ThreadState%2A> 중단 중인 스레드에서의 속성입니다. A <xref:System.Threading.ThreadAbortException> 될 때까지 일시 중단 된 스레드에서 throw 되지 <xref:System.Threading.Thread.Resume%2A> 호출 됩니다.  
  
 경우 `Abort` 비관리 코드를 실행 하는 동안 관리 되는 스레드에서 호출 됩니다는 `ThreadAbortException` 스레드가 관리 코드에 반환 될 때까지 throw 되지 않습니다.  
  
 두 번 호출 하는 경우 `Abort` 제공 같은 시간에 대해 불가능 한 상태 정보를 설정 하는 한 번 호출 하 고 실행 하 고 다른 호출에서 `Abort`합니다. 그러나 응용 프로그램이이 상황을 검색할 수 없습니다.  
  
 후 `Abort` 호출 스레드의 상태를 포함 한 스레드에서 <xref:System.Threading.ThreadState.AbortRequested>합니다. 성공적으로 호출의 결과로 스레드가 종료 후 `Abort`, 스레드 상태는 됨으로 변경 <xref:System.Threading.ThreadState.Stopped>합니다. 충분 한 권한이 있는 스레드는의 대상이 되는 `Abort` 사용 하 여 중단을 취소할 수는 `ResetAbort` 메서드. 에 대 한 호출을 보여 주는 예제는 `ResetAbort` 메서드를 참조는 `ThreadAbortException` 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core만 해당: 이 멤버는 지원되지 않습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.Threading.ThreadStateException">중단 중인 스레드가 현재 일시 중단됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 고급 작업 스레드입니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">상태와 같이 중단 중인 스레드에서 사용할 수 있는 응용 프로그램 관련 정보를 포함하는 개체입니다.</param>
        <summary>이 메서드가 호출되는 스레드에서 <see cref="T:System.Threading.ThreadAbortException" />을 발생시켜 스레드 종료 프로세스를 시작하고, 스레드 종료에 대한 예외 정보를 제공합니다. 이 메서드를 호출하면 대개 스레드가 종료됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 스레드에서 호출 되 면 시스템에서 throw 한 <xref:System.Threading.ThreadAbortException> 에서 스레드를 중단 하는 것입니다. `ThreadAbortException` 응용 프로그램 코드에서 사용할 수 있는 특별 한 예외가 있지만 끝날 때 다시 throw 된 `catch` 차단 하지 않는 한 <xref:System.Threading.Thread.ResetAbort%2A> 라고 합니다. `ResetAbort` 중단을 요청을 취소 하 고 방지는 `ThreadAbortException` 의 스레드를 종료 합니다. 실행 되지 않은 `finally` 블록 스레드가 중단 되기 전에 실행 됩니다.  
  
> [!NOTE]
>  호출 하면 스레드 `Abort` 효과 자기 비슷합니다 자체에 <xref:System.Threading.ThreadAbortException> 즉시 발생 하는 결과 예측 가능한 합니다. 그러나 한 스레드가 `Abort` 다른 스레드에서 abort 인터럽트 모든 코드가 실행 되 고 있습니다. 수 있으므로 정적 생성자를 중단할 수 없습니다. 드문 경우에서 해당 클래스의 인스턴스로 해당 응용 프로그램 도메인에서 생성 되지 못할 수도 있습니다. .NET Framework 버전 1.0 및 1.1은 스레드가 중단 수 있는 기회 동안는 `finally` 블록이 실행 되는 경우, 고 `finally` 블록이 중단 됩니다.  
  
 스레드가 즉시 또는 전혀 중단 보장 되지 않습니다. 스레드 제한 없는에 계산의 경우 이러한 상황이 발생할 수 있습니다는 `finally` 무한정 중단이 지연 되는 중단 절차의 일부분으로 호출 된 합니다. 스레드가 중단 될 때까지 기다려야 호출할 수 있습니다는 <xref:System.Threading.Thread.Join%2A> 메서드를 호출한 후 스레드에서 <xref:System.Threading.Thread.Abort%2A> 메서드를 있지만 될 보장 되지 않습니다.  
  
> [!NOTE]
>  호출 하는 스레드에서 <xref:System.Threading.Thread.Abort%2A> 중단 중인 스레드가 코드의 보호 된 영역에 같은 경우를 차단할 수는 `catch` 블록 `finally` 블록 또는 제약이 있는 실행 영역입니다. 호출 하는 스레드가 <xref:System.Threading.Thread.Abort%2A> 잠금이 중단 된 스레드 필요한 교착 상태가 발생할 수 있습니다.  
  
 경우 `Abort` 라고 시작 되지 않은 스레드에서 스레드가 될 때 중단 됩니다 <xref:System.Threading.Thread.Start%2A> 라고 합니다. 경우 `Abort` 라고 차단 되었거나 대기 중인 스레드에 스레드가 중단 되며 완전히 중단 됩니다.  
  
 경우 `Abort` 중단 된 스레드에서 호출는 <xref:System.Threading.ThreadStateException> 호출 스레드에서 throw 되 <xref:System.Threading.Thread.Abort%2A>, 및 <xref:System.Threading.ThreadState.AbortRequested> 에 추가 되는 <xref:System.Threading.Thread.ThreadState%2A> 중단 중인 스레드에서의 속성입니다. A <xref:System.Threading.ThreadAbortException> 될 때까지 일시 중단 된 스레드에서 throw 되지 <xref:System.Threading.Thread.Resume%2A> 호출 됩니다.  
  
 경우 `Abort` 비관리 코드를 실행 하는 동안 관리 되는 스레드에서 호출 됩니다는 `ThreadAbortException` 스레드가 관리 코드에 반환 될 때까지 throw 되지 않습니다.  
  
 두 번 호출 하는 경우 `Abort` 제공 같은 시간에 대해 불가능 한 상태 정보를 설정 하는 한 번 호출 하 고 실행 하 고 다른 호출에서 `Abort`합니다. 그러나 응용 프로그램이이 상황을 검색할 수 없습니다.  
  
 후 `Abort` 호출 스레드의 상태를 포함 한 스레드에서 <xref:System.Threading.ThreadState.AbortRequested>합니다. 성공적으로 호출의 결과로 스레드가 종료 후 `Abort`, 스레드 상태는 됨으로 변경 <xref:System.Threading.ThreadState.Stopped>합니다. 충분 한 권한이 있는 스레드는의 대상이 되는 `Abort` 사용 하 여 중단을 취소할 수는 `ResetAbort` 메서드. 에 대 한 호출을 보여 주는 예제는 `ResetAbort` 메서드를 참조는 `ThreadAbortException` 클래스입니다.  
  
   
  
## Examples  
 다음 코드 예제 정보 중단 중인 스레드를 전달 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core만 해당: 이 멤버는 지원되지 않습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.Threading.ThreadStateException">중단 중인 스레드가 현재 일시 중단됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 고급 작업 스레드입니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 스레드에 명명되지 않은 데이터 슬롯을 할당합니다. 성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</summary>
        <returns>모든 스레드에 할당된 명명된 데이터 슬롯입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘을 제공: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다. 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.  
  
 슬롯 모든 스레드가 할당 됩니다.  
  
 스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다. 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.  
  
   
  
## Examples  
 이 섹션에는 두 가지 코드 예제가 포함 되어 있습니다. 로 표시 된 필드를 사용 하는 방법을 보여 주는 첫 번째 예제는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 하는 특성입니다. 두 번째 예에서는 동일한 작업을 수행 하려면 데이터 슬롯을 사용 하는 방법을 보여 줍니다.  
  
 **첫 번째 예제**  
  
 로 표시 된 필드를 사용 하는 방법을 보여 주는 다음 예제 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다. 이 방법은 두 번째 예에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **두 번째 예제**  
  
 다음 코드 예제에서는 스레드 관련 정보를 저장 된 데이터 슬롯을 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">할당할 데이터 슬롯의 이름입니다.</param>
        <summary>모든 스레드에 명명된 데이터 슬롯을 할당합니다. 성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</summary>
        <returns>모든 스레드에 할당된 명명된 데이터 슬롯입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘을 제공: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다. 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.  
  
 스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다. 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.  
  
 사용할 필요는 없습니다는 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 때문에 명명 된 데이터 슬롯을 할당 하는 메서드는 <xref:System.Threading.Thread.GetNamedDataSlot%2A> 메서드가 아직 할당 되지 않은 경우 슬롯을 할당 합니다.  
  
> [!NOTE]
>  경우는 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 메서드는, 지정 된 이름의 슬롯이 이미 할당 되어 있으면 예외를 throw 하기 때문에 프로그램을 시작할 때 주 스레드에서 호출 해야 합니다. 슬롯이 이미 할당 되어 있는지 여부를 테스트 방식은 없습니다.  
  
 로이 메서드를 사용 하 여 할당 슬롯을 해제 해야 <xref:System.Threading.Thread.FreeNamedDataSlot%2A>합니다.  
  
   
  
## Examples  
 이 섹션에는 두 가지 코드 예제가 포함 되어 있습니다. 로 표시 된 필드를 사용 하는 방법을 보여 주는 첫 번째 예제는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 하는 특성입니다. 두 번째 예에서는 동일한 작업을 수행 하려면 데이터 슬롯을 사용 하는 방법을 보여 줍니다.  
  
 **첫 번째 예제**  
  
 로 표시 된 필드를 사용 하는 방법을 보여 주는 다음 예제 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다. 이 방법은 두 번째 예에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **두 번째 예제**  
  
 다음 예제에서는 명명된 된 데이터 슬롯을 사용 하 여 스레드 관련 정보를 저장 하는 방법을 보여 줍니다.  
  
> [!NOTE]
>  예제 코드를 사용 하지 않습니다는 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 메서드를 때문에 <xref:System.Threading.Thread.GetNamedDataSlot%2A> 메서드가 아직 할당 되지 않은 경우 슬롯을 할당 합니다. 경우는 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 메서드 사용, 프로그램을 시작할 때 주 스레드에서 호출 해야 합니다.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">지정한 이름의 명명된 데이터 슬롯이 이미 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 스레드의 아파트 상태를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Threading.ApartmentState" /> 값 중 하나입니다. 초기 값은 <see langword="Unknown" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **<xref:System.Threading.Thread.ApartmentState%2A> 속성은 사용 되지 않습니다.**  대체 방법은 사용 되는 <xref:System.Threading.Thread.GetApartmentState%2A> 아파트 상태를 검색 하는 메서드 및 <xref:System.Threading.Thread.SetApartmentState%2A> 아파트 상태를 설정 하는 메서드.  
  
 .NET Framework 버전 1.0 및 1.1에서는 `ApartmentState` 속성은 스레드가 단일 스레드 또는 다중 스레드 아파트에서 실행 될를 표시 합니다. 이 속성은 스레드가 때 설정할 수 있습니다는 `Unstarted` 또는 `Running` 스레드 상태; 그러나 설정할 수 있습니다 한 번만 스레드에 대 한 합니다. 반환 하는 경우 속성에 설정 되어 있지 `Unknown`합니다.  
  
 사용 하려는 시도가 <xref:System.Threading.Thread.ApartmentState%2A> 아파트 상태가 이미 설정 되어 스레드의 아파트 상태를 설정 하는 속성은 무시 됩니다. 그러나는 <xref:System.Threading.Thread.SetApartmentState%2A> 메서드가 throw 한 <xref:System.InvalidOperationException> 이 경우.  
  
> [!IMPORTANT]
>  .NET Framework 버전 2.0에서 새 스레드로 초기화 됩니다 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 시작 되기 전에 해당 아파트 상태가 설정 되지 않은 경우. 기본 응용 프로그램 스레드도 초기화 됩니다 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 기본적으로 합니다. 기본 응용 프로그램 스레드를 더 이상 설정할 수 없습니다 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> 설정 하 여는 <xref:System.Threading.ApartmentState?displayProperty=nameWithType> 코드의 첫 번째 줄에는 속성입니다. 사용 하 여 <xref:System.STAThreadAttribute> 대신 합니다.  
  
 .NET Framework 버전 2.0에서에서의 COM 스레딩 모델이 사용 하 여 c + + 응용 프로그램에 대 한를 지정할 수 있습니다는 [/CLRTHREADATTRIBUTE (CLR 스레드 특성 설정)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) 링커 옵션입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 스레드의 아파트 상태를 설정 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">이 속성을 올바르지 않은 아파트 상태[단일 스레드 아파트(<see langword="STA" />) 또는 다중 스레드 아파트(<see langword="MTA" />) 이외의 상태]로 설정하려고 했습니다.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>스레드 중단 또는 처리되지 않은 예외로 인해 응용 프로그램 도메인의 다른 작업이 손상될 수 있는 코드 영역이 실행될 수 있다는 사실을 호스트에 알립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005와 같은 공용 언어 런타임 (CLR)의 호스트에는 코드의 중요 하 고 중요 하지 않은 영역에서 발생 한 실패에 대해 다른 정책을 설정할 수 있습니다. 중요 한 영역을는 하는 스레드 중단 또는 처리 되지 않은 예외가 국한 되지 않는 현재 작업에 하나입니다. 반면, 한 중단 이나 오류 코드는 중요 하지 않은 영역에서 오류가 발생 하는 작업을만 영향을 줍니다.  
  
 예를 들어 잠금을 보유 하는 동안 메모리를 할당 하려고 시도 하는 작업을 살펴보겠습니다. 메모리 할당이 실패 하면 현재 작업이 중단 만으로는의 안정성을 보장 하는 <xref:System.AppDomain>도메인에 동일한 잠금을 대기 하는 다른 작업이 있을 수 있으므로, 합니다. 현재 작업이 종료 되는 경우 다른 작업 교착 상태가 될 수 없습니다.  
  
 중요 한 영역에서 오류가 발생 하는 경우 호스트는 전체 언로드 결정할 수 <xref:System.AppDomain> 하지 않고는 잠재적으로 불안정 한 상태에서 실행을 계속 위험 합니다. 호출 코드의 중요 영역 시작 하는 호스트에 제공, <xref:System.Threading.Thread.BeginCriticalRegion%2A>합니다. 호출 <xref:System.Threading.Thread.EndCriticalRegion%2A> 실행 중요 하지 않은 코드 영역을 반환 하는 경우.  
  
 이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Threading.Thread.BeginCriticalRegion%2A> 및 <xref:System.Threading.Thread.EndCriticalRegion%2A> 코드 블록을 중요 하 고 중요 하지 않은 영역으로 분할 하는 방법입니다.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>관리되는 코드가 현재 실제 운영 체제 스레드의 ID에 종속되는 명령을 실행하려고 한다는 사실을 호스트에 알립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005와 같은 공용 언어 런타임의 일부 호스트는 고유한 스레드 관리를 제공합니다. 고유한 스레드 관리를 제공 하는 호스트 간에 이동할 수는 실행 중인 작업 실제 운영 체제 스레드 간에 언제 든 지 합니다. 이 전환 하 여 대부분의 작업 영향을 받지 않습니다. 그러나 일부 작업에는 스레드 선호도-즉, 실제 운영 체제 스레드의 id에 종속 됩니다. 이러한 작업은 코드를 안을 실행 하는 동안 호스트에 게 알려야 합니다.  
  
 예를 들어, 스레드 선호도 Win32 CRITICAL_SECTION 갖는 응용 프로그램 호출 시스템 API를 운영 체제를 획득을 잠그는 경우에 호출 해야 <xref:System.Threading.Thread.BeginThreadAffinity%2A> 잠금을 획득 하기 전에 및 <xref:System.Threading.Thread.EndThreadAffinity%2A> 후 잠금을 해제 합니다.  
  
 이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Threading.Thread.BeginThreadAffinity%2A> 및 <xref:System.Threading.Thread.EndThreadAffinity%2A> 코드 블록을 실제 운영 체제 스레드의 id에 의존 하는 호스트에 알리기 위해 메서드.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드가 실행 중인 현재 컨텍스트를 가져옵니다.</summary>
        <value>현재 스레드 컨텍스트를 나타내는 <see cref="T:System.Runtime.Remoting.Contexts.Context" />입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 스레드에 대한 문화권을 가져오거나 설정합니다.</summary>
        <value>현재 스레드에 대한 문화권을 나타내는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo> 날짜에 대 한 기본 형식, 시간, 숫자, 통화 값, 텍스트의 순서 정렬, 대/소문자 규칙을 확인 하 고 문자열을 비교 하는 연결된 된 개체와 함께이 속성에서 반환 되는 개체입니다. 참조는 <xref:System.Globalization.CultureInfo> 문화권 이름 및 식별자, 고정, 중립 및 특정 문화권 간의 차이점에 대 한 자세한 내용은 클래스와 스레드 및 응용 프로그램 도메인 방식으로 문화권 정보에 영향을 줍니다. 참조는 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 스레드의 기본 문화권을 결정 하는 방법 및 사용자가 자신의 컴퓨터에 대 한 문화권 정보를 설정 하는 방법에 대해 알아보려면 속성입니다.  
  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]를 설정할 수 있습니다는 <xref:System.Threading.Thread.CurrentCulture%2A> 속성 중립 문화권을 합니다. 때문에 이것이의 동작은 <xref:System.Globalization.CultureInfo> 클래스가 변경 된: 때 중립 문화권에 해당 속성 값을 나타냅니다 (특히는 <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, 및 <xref:System.Globalization.CultureInfo.TextInfo%2A> 속성) 이제 중립 문화권 연관 된 특정 문화권을 반영 합니다. 이전 버전의.NET Framework는 <xref:System.Threading.Thread.CurrentCulture%2A> 속성에서는 <xref:System.NotSupportedException> 중립 문화권 할당 된 경우에 예외입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 제어판에 설정 된 문화권에서 표시 하는 Windows Forms의 사용자 인터페이스를 허용 하는 스레딩 문을 보여 줍니다. 추가 코드가 필요 합니다.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">속성이 <see langword="null" />로 설정됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">속성을 설정 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드의 현재 보안 주체(역할 기반 보안용)를 가져오거나 설정합니다.</summary>
        <value>보안 컨텍스트를 나타내는 <see cref="T:System.Security.Principal.IPrincipal" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 설정 하 고 스레드의 보안 주체를 검색 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 보안 주체를 설정하는 데 필요한 사용 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">보안 주체 개체를 조작 하 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 실행 중인 스레드를 가져옵니다.</summary>
        <value>현재 실행 중인 스레드를 나타내는 <see cref="T:System.Threading.Thread" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에는 20 개의 자식 작업을 다시 만드는 작업을 만듭니다. 각 잘 작업으로 응용 프로그램 자체에서 호출 된 `ShowThreadInformation` 메서드를 사용 하는 <xref:System.Threading.Thread.CurrentThread%2A> 속성을 실행 중인 스레드에 대 한 정보를 표시 합니다.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 1 백만 1에서 1 백만 사이의 난수를 생성 하 고 평균을 반환 하는 각 자식 작업입니다. 부모 작업 호출에서 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 메서드를 각 작업에서 반환 되는 평균을 표시 하기 전에 자식 작업이 완료 되도록 한 의미의 평균을 계산 합니다.  
  
 포그라운드 스레드에서 응용 프로그램이 실행 되는 동안 각 실행 태스크가 실행 하는 스레드 풀 스레드에서 note 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>리소스 관리자가 런타임에 문화권 관련 리소스를 찾기 위해 사용하는 현재 문화권을 가져오거나 설정합니다.</summary>
        <value>현재 문화를 나타내는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 UI 문화권이 응용 프로그램 사용자 입력 및 출력을 지원 해야 하 고 기본적으로 같은 운영 체제 culture와 리소스를 지정 합니다. 참조는 <xref:System.Globalization.CultureInfo> 문화권 이름 및 식별자, 고정, 중립 및 특정 문화권 간의 차이점에 대 한 자세한 내용은 클래스와 스레드 및 응용 프로그램 도메인 방식으로 문화권 정보에 영향을 줍니다. 참조는 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> 스레드의 기본 UI 문화권을 결정 하는 방법을 알아보려면 속성입니다.  
  
 <xref:System.Globalization.CultureInfo> 이 속성에서 반환 되는 중립 문화권 일 수 있습니다. 중립 문화권와 같은 형식 지정 메서드를 사용할 수 없습니다 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, 및 <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>합니다. 사용 하 여는 <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> 특정 문화권을 가져오거나 사용 하는 메서드는 <xref:System.Threading.Thread.CurrentCulture%2A> 속성입니다.  
  
> [!NOTE]
>  <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> 메서드가 throw <xref:System.ArgumentException> 중립 문화권 "Zh-hant" ("ZH-CHT") 및 "Zh-hans" ("ZH-CHS")에 대 한 합니다.  
  
   
  
## Examples  
 다음 예제에서는 현재 스레드의 UI 문화권의 언어 프랑스어 인지 확인 합니다. 없는 경우 영어 (미국)에 현재 스레드의 UI 문화권을 설정 합니다.  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 다음 코드 예제에서는 제어판에 설정 된 문화권에서 표시 하는 Windows Forms의 사용자 인터페이스를 허용 하는 스레딩 문을 보여 줍니다. 추가 코드가 필요 합니다.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">속성이 <see langword="null" />로 설정됩니다.</exception>
        <exception cref="T:System.ArgumentException">속성이 리소스 파일을 찾는 데 사용할 수 없는 문화권 이름으로 설정되어 있습니다. 리소스 파일 이름에는 문자, 숫자, 하이픈 또는 밑줄만 포함해야 합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 스레드에 대해 RCW(런타임 호출 가능 래퍼)의 자동 정리를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 공용 언어 런타임 (CLR) 런타임 호출 가능 래퍼 자동으로 정리 합니다. 비정상적인는 다음 조건을 충족 하는 몇 가지 응용 프로그램에서 재진입 문제를 일으킬 수 있는 정리 하는 동안 CLR 펌프 메시지:  
  
-   응용 프로그램 자체 메시지 펌프를 수행 합니다.  
  
-   응용 프로그램 메시지 펌핑이 발생 하는 경우에 정확 하 게 제어 해야 합니다.  
  
 이러한 응용 프로그램에서 사용할 수는 <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> CLR 것 자동 회수 런타임 호출 가능 래퍼는 것을 방지 하려면 메서드.  
  
 스레드에서이 메서드를 호출 하는 경우 자동 정리를 해당 스레드에 대 한 다시 활성화 수 없습니다. 사용 하 여 응용 프로그램 런타임 호출 가능 래퍼를 정리 하도록 준비 되 면는 <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> 메서드를 현재 컨텍스트의 모든 런타임 호출 가능 래퍼를 정리 하도록 런타임에 지시 합니다. 메시지 펌프 메서드가 실행 하는 동안 발생 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>스레드 중단 또는 처리되지 않은 예외가 현재 작업에만 영향을 주는 코드 영역이 실행될 것임을 호스트에 알립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005와 같은 공용 언어 런타임 (CLR)의 호스트에는 코드의 중요 하 고 중요 하지 않은 영역에서 발생 한 실패에 대해 다른 정책을 설정할 수 있습니다. 중요 한 영역을는 하는 스레드 중단 또는 처리 되지 않은 예외가 국한 되지 않는 현재 작업에 하나입니다. 반면, 한 중단 이나 오류 코드는 중요 하지 않은 영역에서 오류가 발생 하는 작업을만 영향을 줍니다.  
  
 예를 들어 잠금을 보유 하는 동안 메모리를 할당 하려고 시도 하는 작업을 살펴보겠습니다. 메모리 할당이 실패 하면 현재 작업이 중단 만으로는의 안정성을 보장 하는 <xref:System.AppDomain>도메인에 동일한 잠금을 대기 하는 다른 작업이 있을 수 있으므로, 합니다. 현재 작업이 종료 되는 경우 다른 작업 교착 상태가 될 수 없습니다.  
  
 중요 한 영역에서 오류가 발생 하는 경우 호스트는 전체 언로드 결정할 수 <xref:System.AppDomain> 하지 않고는 잠재적으로 불안정 한 상태에서 실행을 계속 위험 합니다. 호출 코드의 중요 영역 시작 하는 호스트에 제공, <xref:System.Threading.Thread.BeginCriticalRegion%2A>합니다. 호출 <xref:System.Threading.Thread.EndCriticalRegion%2A> 실행 중요 하지 않은 코드 영역을 반환 하는 경우.  
  
 이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Threading.Thread.BeginCriticalRegion%2A> 및 <xref:System.Threading.Thread.EndCriticalRegion%2A> 코드 블록을 중요 하 고 중요 하지 않은 영역으로 분할 하는 방법입니다.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>관리되는 코드가 현재 실제 운영 체제 스레드의 ID에 종속되는 명령의 실행을 완료했음을 호스트에 알립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005와 같은 공용 언어 런타임의 일부 호스트는 고유한 스레드 관리를 제공합니다. 고유한 스레드 관리를 제공 하는 호스트 간에 이동할 수는 실행 중인 작업 실제 운영 체제 스레드 간에 언제 든 지 합니다. 이 전환 하 여 대부분의 작업 영향을 받지 않습니다. 그러나 일부 작업에는 스레드 선호도-즉, 실제 운영 체제 스레드의 id에 종속 됩니다. 이러한 작업은 코드를 안을 실행 하는 동안 호스트에 게 알려야 합니다.  
  
 예를 들어, 스레드 선호도 Win32 CRITICAL_SECTION 갖는 응용 프로그램 호출 시스템 API를 운영 체제를 획득을 잠그는 경우에 호출 해야 <xref:System.Threading.Thread.BeginThreadAffinity%2A> 잠금을 획득 하기 전에 및 <xref:System.Threading.Thread.EndThreadAffinity%2A> 후 잠금을 해제 합니다.  
  
 이 메서드를 사용 하 여 SQL Server 2005에서 실행 되는 코드에서 가장 높은 호스트 보호 수준에서 실행할 코드를 필요 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Threading.Thread.BeginThreadAffinity%2A> 및 <xref:System.Threading.Thread.EndThreadAffinity%2A> 코드 블록을 실제 운영 체제 스레드의 id에 의존 하는 호스트에 알리기 위해 메서드.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 스레드의 다양한 컨텍스트 정보를 포함하는 <see cref="T:System.Threading.ExecutionContext" /> 개체를 가져옵니다.</summary>
        <value>현재 스레드의 컨텍스트 정보를 통합하는 <see cref="T:System.Threading.ExecutionContext" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext> 클래스는 실행의 논리적 스레드와 관련 된 모든 정보에 대 한 단일 컨테이너를 제공 합니다. 보안 컨텍스트, 호출 컨텍스트에, 동기화 컨텍스트, 지역화 컨텍스트 및 트랜잭션 컨텍스트가 포함 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>가비지 수집기에서 <see cref="T:System.Threading.Thread" /> 개체를 회수할 때 리소스가 해제되고 다른 정리 작업이 수행되도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가비지 컬렉션이 <xref:System.Threading.Thread.Finalize%2A> 현재 개체를 종료 될 경우.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">해제할 데이터 슬롯의 이름입니다.</param>
        <summary>프로세스의 모든 스레드에 대해 이름과 슬롯 간의 연관을 없앱니다. 성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘을 제공: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다. 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.  
  
 호출 스레드에서 `FreeNamedDataSlot`를 호출 하는 다른 스레드가 <xref:System.Threading.Thread.GetNamedDataSlot%2A> 이름이 같은 이름과 연결 된 새 슬롯을 할당 합니다. 에 대 한 후속 호출 `GetNamedDataSlot` 스레드에서 새 슬롯을 반환 합니다. 그러나 모든 스레드는 여전히에 <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> 한 이전 호출에서 반환 된 `GetNamedDataSlot` 계속는 이전 슬롯을 사용할 수 있습니다.  
  
 이름에 연결 되어 있는 슬롯 해제 될 경우에만 모든 `LocalDataStoreSlot` 호출 하기 전에 가져온 `FreeNamedDataSlot` 이 해제 되 고 가비지 수집 합니다.  
  
 스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다. 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.  
  
   
  
## Examples  
 이 섹션에는 두 가지 코드 예제가 포함 되어 있습니다. 로 표시 된 필드를 사용 하는 방법을 보여 주는 첫 번째 예제는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 하는 특성입니다. 두 번째 예에서는 동일한 작업을 수행 하려면 데이터 슬롯을 사용 하는 방법을 보여 줍니다.  
  
 **첫 번째 예제**  
  
 로 표시 된 필드를 사용 하는 방법을 보여 주는 다음 예제 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다. 이 방법은 두 번째 예에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **두 번째 예제**  
  
 다음 예제에서는 명명된 된 데이터 슬롯을 사용 하 여 스레드 관련 정보를 저장 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>아파트 상태를 나타내는 <see cref="T:System.Threading.ApartmentState" /> 값을 반환합니다.</summary>
        <returns>관리되는 스레드의 아파트 상태를 나타내는 <see cref="T:System.Threading.ApartmentState" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Threading.ApartmentState.Unknown" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를와 함께 <xref:System.Threading.Thread.SetApartmentState%2A> 메서드 및 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드를 대체는 <xref:System.Threading.Thread.ApartmentState%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, 및 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드. 코드 예제에서는 스레드를 만듭니다. 스레드가 시작 되기 전에 <xref:System.Threading.Thread.GetApartmentState%2A> 초기 표시 <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> 상태 및 <xref:System.Threading.Thread.SetApartmentState%2A> 변경 된 상태를 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>합니다. <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드 다음 반환 `false` 상태를 변경 하려고 할 때 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 아파트 상태가 이미 설정 되어 있으므로 합니다. 동일한 작업을 시도 하는 경우 <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> 이 throw 합니다.  
  
 스레드가 시작 된 후의 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드가 다시 사용 됩니다. 이 시간을 throw <xref:System.Threading.ThreadStateException> 스레드가 이미 시작 합니다.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 스레드 스택을 캡처하는 데 사용할 수 있는 <see cref="T:System.Threading.CompressedStack" /> 개체를 반환합니다.</summary>
        <returns>없음</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 더 이상 지원 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">모든 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">값을 검색할 원본 <see cref="T:System.LocalDataStoreSlot" />입니다.</param>
        <summary>현재 스레드의 도메인 내에서 현재 스레드의 지정된 슬롯에서 값을 검색합니다. 성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</summary>
        <returns>검색된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘을 제공: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다. 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.  
  
 스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다. 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> 이 `Shared` 항상 다른 스레드를 참조 하는 변수를 사용 하 여 호출 하는 경우에 현재 실행 중인 스레드에 적용 되는 메서드. 혼동을 피하기 위해 사용 하 여 클래스 이름을 호출할 때 `Shared` 메서드: `Dim test As Object = Thread.GetData(testSlot)`합니다.  
  
   
  
## Examples  
 이 섹션에는 두 가지 코드 예제가 포함 되어 있습니다. 로 표시 된 필드를 사용 하는 방법을 보여 주는 첫 번째 예제는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 하는 특성입니다. 두 번째 예에서는 동일한 작업을 수행 하려면 데이터 슬롯을 사용 하는 방법을 보여 줍니다.  
  
 **첫 번째 예제**  
  
 로 표시 된 필드를 사용 하는 방법을 보여 주는 다음 예제 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다. 이 방법은 두 번째 예에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **두 번째 예제**  
  
 다음 예제에서는 스레드 관련 정보를 저장 된 데이터 슬롯을 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 스레드가 실행 중인 현재 도메인을 반환합니다.</summary>
        <returns>실행 중인 스레드의 현재 응용 프로그램 도메인을 나타내는 <see cref="T:System.AppDomain" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 이름 및 ID를 검색 하는 방법을 보여 줍니다.는 `AppDomain` 스레드가 실행 되는 합니다.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>고유한 응용 프로그램 도메인 식별자를 반환합니다.</summary>
        <returns>응용 프로그램 도메인을 고유하게 식별하는 부호 있는 32비트 정수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 이름 및 ID를 검색 하는 방법을 보여 줍니다.는 `AppDomain` 스레드가 실행 되는 합니다.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 스레드의 해시 코드를 반환합니다.</summary>
        <returns>정수 해시 코드 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 해시 코드는 고유 하 게 보장 되지 않습니다. 사용 된 <xref:System.Threading.Thread.ManagedThreadId%2A> 관리 되는 스레드에 대 한 고유 식별자가 필요한 경우 속성을 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">로컬 데이터 슬롯의 이름입니다.</param>
        <summary>명명된 데이터 슬롯을 찾습니다. 성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</summary>
        <returns>이 스레드에 대해 할당된 <see cref="T:System.LocalDataStoreSlot" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘을 제공: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다. 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.  
  
 스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드가 만료 된 후 다시 사용 하기 위해 슬롯을 해제 합니다. 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.  
  
 명명 된 슬롯 존재 하지 않는 경우 새 슬롯 할당 됩니다. 명명 된 데이터 슬롯은 공용 이며 다른 사용자에 의해 조작 될 수 있습니다.  
  
   
  
## Examples  
 이 섹션에는 두 가지 코드 예제가 포함 되어 있습니다. 로 표시 된 필드를 사용 하는 방법을 보여 주는 첫 번째 예제는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 하는 특성입니다. 두 번째 예에서는 동일한 작업을 수행 하려면 데이터 슬롯을 사용 하는 방법을 보여 줍니다.  
  
 **첫 번째 예제**  
  
 로 표시 된 필드를 사용 하는 방법을 보여 주는 다음 예제 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다. 이 방법은 두 번째 예에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **두 번째 예제**  
  
 다음 예제에서는 명명된 된 데이터 슬롯을 사용 하 여 스레드 관련 정보를 저장 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see langword="WaitSleepJoin" /> 스레드 상태에 있는 스레드를 중단합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 스레드가 대기, 대기 또는 조인 상태에 현재 차단 되지 않은 경우 차단 하는 다음 시작 될 때 중단 됩니다.  
  
 <xref:System.Threading.ThreadInterruptedException> 중단된 된 스레드의에서 수행 되지만 해당 스레드는 차단 throw 됩니다. 스레드가 차단 되지 않으면 예외가 throw 되지 및 스레드가 중단 없이 완료할 수 있으므로 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 중단 되 고 이어서 차단 하는 경우 실행 중인 스레드 동작을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 해당 <see cref="T:System.Security.Permissions.SecurityPermission" />이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 고급 작업 스레드입니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 스레드의 실행 상태를 나타내는 값을 가져옵니다.</summary>
        <value>이 스레드가 시작되었으며 정상적으로 종료 또는 중단되지 않았으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드가 배경 스레드인지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>이 스레드가 백그라운드 스레드이거나 백그라운드 스레드가 될 예정이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드는 백그라운드 스레드 이거나 포그라운드 스레드는. 백그라운드 스레드는 백그라운드 스레드 프로세스를 종료 하는 것을 금지 하지 않는 점을 제외 하 고 포그라운드 스레드를 동일 합니다. 프로세스에 속한 모든 포그라운드 스레드가 중단 되 면 공용 언어 런타임에서 프로세스를 끝냅니다. 나머지 모든 백그라운드 스레드 중단 되 고 완료 하지 마세요.  
  
 기본적으로 다음 스레드 포그라운드에서 실행 (즉, 해당 <xref:System.Threading.Thread.IsBackground%2A> 속성에서 반환 `false`):  
  
-   기본 스레드 (또는 주 응용 프로그램 스레드).  
  
-   호출 하 여 만든 모든 스레드는 <xref:System.Threading.Thread> 클래스 생성자입니다.  
  
 기본적으로 백그라운드에서 실행 하는 다음 스레드 (즉, 해당 <xref:System.Threading.Thread.IsBackground%2A> 속성에서 반환 `true`):  
  
-   런타임에 의해 유지 관리 하는 작업자 스레드 풀은 풀 스레드를 스레드입니다. 사용 하 여 스레드 풀에서 스레드 풀 및 일정 작업을 구성할 수 있습니다는 <xref:System.Threading.ThreadPool> 클래스입니다.  
  
    > [!NOTE]
    >  작업 기반 비동기 작업은 스레드 풀 스레드에서 자동으로 실행합니다.  
  
-   비관리 코드에서 관리 되는 실행 환경에 들어가는 모든 스레드가 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 포그라운드 및 백그라운드 스레드 동작을 대조 합니다. 포그라운드 스레드 및 백그라운드 스레드를 만듭니다. 포그라운드 스레드 프로세스를 계속 실행 될 때까지 완료 된 해당 `for` 반복 하 고 종료 합니다. 그러나 예제의 출력에서 보듯이 포그라운드 스레드 실행이 완료 되었습니다 때문에 백그라운드 스레드 실행이 완료 되기 전에 프로세스가 종료 됩니다.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">스레드가 중지되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드가 관리되는 스레드 풀에 속하는지를 나타내는 값을 가져옵니다.</summary>
        <value>이 스레드가 관리되는 스레드 풀에 속하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 참조 [스레드 풀 관리](~/docs/standard/threading/the-managed-thread-pool.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 스레드 풀의 스레드가 인지 확인 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스가 나타내는 스레드가 종료될 때까지 호출 스레드를 차단합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>표준 COM 및 <see langword="SendMessage" /> 펌프를 계속 수행하면서 이 인스턴스가 나타내는 스레드가 종료될 때까지 호출 스레드를 차단합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> 스레드가 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 방법 인 <xref:System.Threading.Thread.Join%2A> 메서드는 완료 되었습니다. 이 메서드를 사용 하 여 스레드가 종료 되었는지 확인 합니다. 스레드가 종료 되지 않는 경우 호출자에 게는 무기한으로 차단 됩니다. 다음 예제에서는 `Thread1` 호출 스레드는 <xref:System.Threading.Thread.Join> 메서드 `Thread2`,으로 구독이 `Thread1` 될 때까지 차단 하려면 `Thread2` 완료 되었습니다.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 스레드가 이미 종료 되는 경우 <xref:System.Threading.Thread.Join%2A> 를 호출할 메서드가 즉시 반환 합니다.  
  
> [!WARNING]
>  호출 하지 말아야는 <xref:System.Threading.Thread.Join%2A> 의 메서드는 <xref:System.Threading.Thread> 현재 스레드에서 현재 스레드를 나타내는 개체입니다. 이렇게 하면 앱 제한이, 자신 없음을 현재 스레드를 중단 합니다.  
  
 이 메서드를 포함 하도록 호출 스레드의 상태를 변경 <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>합니다. 호출할 수 없습니다 `Join` 에 있는 스레드에서 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 상태입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">호출자가 <see cref="F:System.Threading.ThreadState.Unstarted" /> 상태의 스레드에 연결하려고 했습니다.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">스레드가 대기하는 동안 중단되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">스레드가 종료되기를 기다릴 밀리초 수입니다.</param>
        <summary>표준 COM 및 SendMessage 펌프를 계속 수행하면서 이 인스턴스가 나타내는 스레드가 종료되거나 지정된 시간이 경과할 때까지 호출 스레드를 차단합니다.</summary>
        <returns>스레드가 종료되면 <see langword="true" />이고, <see langword="false" /> 매개 변수에서 지정한 기간이 경과된 후에도 스레드가 종료되지 않으면 <paramref name="millisecondsTimeout" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> 스레드 중 하나가 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 방법 인 <xref:System.Threading.Thread.Join%2A> 메서드는 완료 된 시간 제한 간격이 경과 또는 합니다. 다음 예제에서는 `Thread1` 호출 스레드는 <xref:System.Threading.Thread.Join> 메서드 `Thread2`,으로 구독이 `Thread1` 할 때 까지는 차단 하도록 `Thread2` 완료 2 분이 지난 또는 합니다.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 경우 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 에 대해 지정 된는 `millisecondsTimeout` 매개 변수를이 똑같이 동작는 <xref:System.Threading.Thread.Join> 반환 값을 제외한 메서드 오버 로드 합니다.  
  
 스레드가 이미 종료 되는 경우 <xref:System.Threading.Thread.Join%2A> 를 호출할 메서드가 즉시 반환 합니다.  
  
 이 메서드를 포함 하도록 호출 스레드의 상태를 변경 <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>합니다. 호출할 수 없습니다 `Join` 에 있는 스레드에서 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 상태입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 값이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(밀리초)와 같지 않습니다.</exception>
        <exception cref="T:System.Threading.ThreadStateException">스레드가 시작되지 않았습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">스레드가 종료되기를 기다리는 시간으로 설정된 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>표준 COM 및 SendMessage 펌프를 계속 수행하면서 이 인스턴스가 나타내는 스레드가 종료되거나 지정된 시간이 경과할 때까지 호출 스레드를 차단합니다.</summary>
        <returns>스레드가 종료되면 <see langword="true" />이고, <see langword="false" /> 매개 변수에서 지정한 기간이 경과된 후에도 스레드가 종료되지 않으면 <paramref name="timeout" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> 스레드 중 하나가 될 때까지 호출 스레드 (즉, 메서드를 호출 하는 스레드)를 차단 하는 동기화 방법 인 <xref:System.Threading.Thread.Join%2A> 메서드는 완료 된 시간 제한 간격이 경과 또는 합니다. 다음 예제에서는 `Thread1` 호출 스레드는 <xref:System.Threading.Thread.Join> 메서드 `Thread2`,으로 구독이 `Thread1` 할 때 까지는 차단 하도록 `Thread2` 완료 2 분이 지난 또는 합니다.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 경우 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 에 대해 지정 된 `timeout`,이 메서드는 동일 하 게 동작는 <xref:System.Threading.Thread.Join> 반환 값을 제외한 메서드 오버 로드 합니다.  
  
 스레드가 이미 종료 되는 경우 <xref:System.Threading.Thread.Join%2A> 를 호출할 메서드가 즉시 반환 합니다.  
  
 이 메서드를 포함 하도록 현재 스레드의 상태를 변경 <xref:System.Threading.ThreadState.WaitSleepJoin>합니다. 호출할 수 없습니다 `Join` 에 있는 스레드에서 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 상태입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 `TimeSpan` 값과 `Join` 메서드.  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 값이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(밀리초)와 같지 않거나 <see cref="F:System.Int32.MaxValue" />(밀리초)보다 큽니다.</exception>
        <exception cref="T:System.Threading.ThreadStateException">호출자가 <see cref="F:System.Threading.ThreadState.Unstarted" /> 상태의 스레드에 연결하려고 했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 관리되는 스레드의 고유 식별자를 가져옵니다.</summary>
        <value>이 관리되는 스레드의 고유 식별자를 나타내는 정수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드의 <xref:System.Threading.Thread.ManagedThreadId%2A> 속성 값이 해당 스레드는 프로세스 내에서 고유 하 게 식별 하는 데 사용 합니다.  
  
 값은 <xref:System.Threading.Thread.ManagedThreadId%2A> 속성 공용 언어 런타임을 호스트 하는 관리 되지 않는 코드에서 스레드를 파이버를 구현 하는 경우에 시간이 지나면서 달라 지지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>다음과 같이 메모리 액세스를 동기화합니다. 현재 스레드를 실행 중인 프로세서는 <see cref="M:System.Threading.Thread.MemoryBarrier" />에 대한 호출 이전의 메모리 액세스가 <see cref="M:System.Threading.Thread.MemoryBarrier" />에 대한 호출 이후의 메모리 액세스 뒤에 실행되는 방식으로 명령을 다시 정렬할 수 없습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> 메모리 (예: 여러 Intel Itanium 프로세서를 사용 하는 시스템) 순서가 있는 경우 하나의 다중 프로세서 시스템에만 필요 합니다.  
  
 대부분의 용도 C#에 대 한 `lock` 문, Visual Basic `SyncLock` 문, 또는 <xref:System.Threading.Monitor> 편리 하 게 데이터를 동기화 할 클래스를 제공 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드의 이름을 가져오거나 설정합니다.</summary>
        <value>스레드의 이름을 포함하는 문자열이며 설정된 이름이 없으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 쓰기-되 면입니다. 때문에 기본값인 스레드의 <xref:System.Threading.Thread.Name%2A> 속성은 `null`, 여부 이름을 이미 명시적으로 할당 된 스레드를 사용 하 여 비교 하 여 확인할 수 있습니다 `null`합니다.  
  
 에 할당 된 문자열은 <xref:System.Threading.Thread.Name%2A> 속성 모든 유니코드 문자를 포함할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에는 스레드의 이름을 지정 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">집합 작업이 요청되었으나 <see langword="Name" /> 속성이 이미 설정되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드의 예약 우선 순위를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Threading.ThreadPriority" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Threading.ThreadPriority.Normal" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드 중 하나라도 다음과 같은 우선 순위를 할당할 수 있습니다 <xref:System.Threading.ThreadPriority> 값:  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 운영 체제 스레드의 우선 순위를 준수 하도록 필요는 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 스레드 우선 순위를 변경의 결과 보여 줍니다. 3 개의 스레드가 만들어집니다, 하나의 스레드의 우선 순위 설정은 <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, 두 번째 우선 순위로 설정 되어 <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>합니다. 변수를 증가 하는 각 스레드는 `while` 루프와 설정된 된 시간에 대 한 실행 합니다.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">스레드가 <see cref="F:System.Threading.ThreadState.Aborted" />와 같은 최종 상태에 도달한 경우</exception>
        <exception cref="T:System.ArgumentException">set 작업에 대해 지정된 값이 유효한 <see cref="T:System.Threading.ThreadPriority" /> 값이 아닌 경우</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 스레드에 대해 요청된 <see cref="M:System.Threading.Thread.Abort(System.Object)" />를 취소합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 적절 한 사용 권한 가진 코드에서 호출할 수만 있습니다.  
  
 호출할 때 `Abort` 시스템에서 throw 한 스레드를 종료 하는 <xref:System.Threading.ThreadAbortException>합니다. `ThreadAbortException` 응용 프로그램 코드에서 발견 될 수 있지만 하지 않는 한 catch 블록의 끝에 다시 throw 되는 특별 한 예외는 `ResetAbort` 라고 합니다. `ResetAbort` 중단을 요청을 취소 하 고 방지는 `ThreadAbortException` 의 스레드를 종료 합니다.  
  
 참조 <xref:System.Threading.ThreadAbortException> 호출 방법을 보여 주는 예제는 `ResetAbort` 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core만 해당: 이 멤버는 지원되지 않습니다.</exception>
        <exception cref="T:System.Threading.ThreadStateException">현재 스레드에 대해 <see langword="Abort" />가 호출되지 않은 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 현재 스레드에 대한 필수 보안 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 고급 작업 스레드입니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>일시 중단된 스레드를 다시 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  사용 하지 않는 <xref:System.Threading.Thread.Suspend%2A> 및 <xref:System.Threading.Thread.Resume%2A> 스레드 활동을 동기화 하는 메서드. 일시 중단 하면 스레드 코드 실행 알 방법이 없습니다. 보안 권한 확인 하는 동안 잠금을 유지 하는 동안 스레드를 일시 중단, 기타의 스레드는 <xref:System.AppDomain> 차단 될 수 있습니다. 다른 스레드가 클래스 생성자를 실행 하는 동안 스레드를 일시 중단는 <xref:System.AppDomain> 하는 클래스는 차단 사용 하려고 시도 합니다. 교착 상태는 매우 쉽게 발생할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core만 해당: 이 멤버는 지원되지 않습니다.</exception>
        <exception cref="T:System.Threading.ThreadStateException">스레드가 시작되지 않았거나, 중지되었거나, 일시 중단된 상태가 아닙니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 해당 <see cref="T:System.Security.Permissions.SecurityPermission" />이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 고급 작업 스레드입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">새 아파트 상태입니다.</param>
        <summary>스레드를 시작하기 전에 스레드의 아파트 상태를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 스레드가 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 시작 되기 전에 해당 아파트 상태가 설정 되지 않은 경우. 스레드가 시작 되기 전에 아파트 상태를 설정 해야 합니다.  
  
> [!NOTE]
>  기본 응용 프로그램 스레드도 초기화 됩니다 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 기본적으로 합니다. 주 응용 프로그램 스레드의 아파트 상태를 설정 하는 유일한 방법은 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> 적용 하는 것은 <xref:System.STAThreadAttribute> 특성을 진입점 메서드.  
  
 <xref:System.Threading.Thread.SetApartmentState%2A> 메서드를와 함께 <xref:System.Threading.Thread.GetApartmentState%2A> 메서드 및 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드를 대체는 <xref:System.Threading.Thread.ApartmentState%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, 및 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드. 코드 예제에서는 스레드를 만듭니다. 스레드가 시작 되기 전에 <xref:System.Threading.Thread.GetApartmentState%2A> 초기 표시 <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> 상태 및 <xref:System.Threading.Thread.SetApartmentState%2A> 변경 된 상태를 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>합니다. <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드 다음 반환 `false` 상태를 변경 하려고 할 때 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 아파트 상태가 이미 설정 되어 있으므로 합니다. 동일한 작업을 시도 하는 경우 <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> 이 throw 합니다.  
  
 스레드가 시작 된 후의 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드가 다시 사용 됩니다. 이 시간을 throw <xref:System.Threading.ThreadStateException> 스레드가 이미 시작 합니다.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core만 해당: 이 멤버는 macOS 및 Linux 플랫폼에서 지원되지 않습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" />가 잘못된 아파트 상태인 경우</exception>
        <exception cref="T:System.Threading.ThreadStateException">스레드가 이미 시작되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException">아파트 상태가 이미 초기화되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">현재 스레드에 적용할 <see cref="T:System.Threading.CompressedStack" /> 개체입니다.</param>
        <summary>캡처한 <see cref="T:System.Threading.CompressedStack" />을 현재 스레드에 적용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 더 이상 지원 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">모든 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">값을 설정할 <see cref="T:System.LocalDataStoreSlot" />입니다.</param>
        <param name="data">설정하려는 값입니다.</param>
        <summary>해당 스레드의 현재 도메인에 대해 현재 실행 중인 스레드의 지정된 슬롯에서 데이터를 설정합니다. 성능을 향상시키려면 <see cref="T:System.ThreadStaticAttribute" /> 특성으로 표시된 필드를 대신 사용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework에서는 스레드 로컬 저장소 (TLS)를 사용 하기 위한 두 가지 메커니즘을 제공: 스레드 상대 정적 필드 (즉,로 표시 된 필드는 <xref:System.ThreadStaticAttribute> 특성) 및 데이터 슬롯입니다. 스레드 관련 정적 필드 데이터 슬롯의 경우 보다 훨씬 더 나은 성능을 제공 하 고 컴파일 타임 형식 검사를 사용 하도록 설정 합니다. TLS를 사용 하는 방법에 대 한 자세한 내용은 참조 [스레드 로컬 저장소: 스레드 상대 정적 필드 및 데이터 슬롯](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)합니다.  
  
 스레드는 스레드별 데이터를 저장 하는 로컬 저장소 메모리 메커니즘을 사용 합니다. 공용 언어 런타임에서 생성 될 때 각 프로세스에 다중 슬롯 데이터 저장소 배열을 할당 합니다. 스레드는 데이터 저장소에 데이터 슬롯을 할당, 저장 및 검색 데이터의 슬롯에서 값을 하 고 스레드 프로시저 종료 된 후 다시 사용 하기 위해 슬롯을 해제 및 <xref:System.Threading.Thread> 가비지 수집에서 회수 된 개체입니다. 데이터 슬롯은 스레드당 고유 합니다. 다른 스레드가 없습니다. (하더라도 자식 스레드)는 해당 데이터를 가져올 수 있습니다.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> 이 `Shared` 항상 다른 스레드를 참조 하는 변수를 사용 하 여 호출 하는 경우에 현재 실행 중인 스레드에 적용 되는 메서드. 혼동을 피하기 위해 사용 하 여 클래스 이름을 호출할 때 `Shared` 메서드: `Thread.SetData(testSlot, "test data")`합니다.  
  
   
  
## Examples  
 이 섹션에는 두 가지 코드 예제가 포함 되어 있습니다. 로 표시 된 필드를 사용 하는 방법을 보여 주는 첫 번째 예제는 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 하는 특성입니다. 두 번째 예에서는 동일한 작업을 수행 하려면 데이터 슬롯을 사용 하는 방법을 보여 줍니다.  
  
 **첫 번째 예제**  
  
 로 표시 된 필드를 사용 하는 방법을 보여 주는 다음 예제 <xref:System.ThreadStaticAttribute> 스레드 관련 정보를 보관 합니다. 이 방법은 두 번째 예에 표시 되는 방법 보다 더 나은 성능을 제공 합니다.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **두 번째 예제**  
  
 다음 예제에서는 명명된 된 데이터 슬롯을 사용 하 여 스레드 관련 정보를 저장 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 시간 동안 현재 스레드를 일시 중단합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">스레드가 일시 중단되는 밀리초 수입니다. <c>millisecondsTimeout</c> 인수의 값이 0이면 스레드는 실행할 준비가 된 우선 순위가 같은 스레드에 나머지 시간 간격을 내어 줍니다. 실행할 준비가 된 우선 순위가 같은 스레드가 없으면 현재 스레드의 실행이 일시 중단되지 않습니다.</param>
        <summary>지정된 시간(밀리초) 동안 현재 스레드를 일시 중단합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 된 시간 동안 운영 체제에서 스레드를 예약 실행 됩니다. 이 메서드를 포함 하도록 스레드의 상태를 변경 <xref:System.Threading.ThreadState.WaitSleepJoin>합니다.  
  
 지정할 수 있습니다 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 에 대 한는 `millisecondsTimeout` 매개 변수를 무기한으로 스레드를 일시 중단 합니다. 하지만 다른를 사용 하는 권장 <xref:System.Threading?displayProperty=nameWithType> 와 같은 클래스 <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, 또는 <xref:System.Threading.Semaphore> 대신 동기화 할 스레드에 또는 리소스를 관리 합니다.  
  
 특정 속도로 시스템 클록 틱 클록 해상도 호출합니다. 실제 시간 제한은 정확 하 게 지정된 된 제한 시간을 지정된 된 제한 시간 클록 틱 일치 하 게 조정 될 것 이므로 아닐 수 있습니다. 클록의 해상도 대기 시간에 대 한 자세한 내용은 참조는 [함수 절전](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) 항목입니다. 이 메서드를 호출는 [함수 절전](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) Windows 시스템 Api에서에서 합니다.  
  
 이 메서드는 표준 COM 및 SendMessage 펌프를 수행 하지 않습니다.  
  
> [!NOTE]
>  가 있는 스레드를 대기 해야 하는 경우 <xref:System.STAThreadAttribute>, 표준 COM 및 SendMessage 펌프를 수행 하 고 오버 로드 중 하나를 사용 하는 것이 좋습니다. 하지만 <xref:System.Threading.Thread.Join%2A> 시간 제한 간격을 지정 하는 메서드.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Threading.Thread.Sleep%2A> 메서드를 응용 프로그램의 주 스레드를 차단 합니다.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">시간 제한 값이 음수이며 <see cref="F:System.Threading.Timeout.Infinite" />와 같지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">스레드가 일시 중단되는 시간입니다. <c>millisecondsTimeout</c> 인수의 값이 <see cref="F:System.TimeSpan.Zero" />이면 스레드는 실행할 준비가 된 우선 순위가 같은 스레드에 나머지 시간 간격을 내어 줍니다. 실행할 준비가 된 우선 순위가 같은 스레드가 없으면 현재 스레드의 실행이 일시 중단되지 않습니다.</param>
        <summary>지정된 시간 동안 현재 스레드를 일시 중단합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 된 시간 동안 운영 체제에서 스레드를 예약 실행 됩니다. 이 메서드를 포함 하도록 스레드의 상태를 변경 <xref:System.Threading.ThreadState.WaitSleepJoin>합니다.  
  
 지정할 수 있습니다 <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> 에 대 한는 `timeout` 매개 변수를 무기한으로 스레드를 일시 중단 합니다. 하지만 다른를 사용 하는 권장 <xref:System.Threading?displayProperty=nameWithType> 와 같은 클래스 <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, 또는 <xref:System.Threading.Semaphore> 대신 동기화 할 스레드에 또는 리소스를 관리 합니다.  
  
 이 오버 로드의 <xref:System.Threading.Thread.Sleep%2A> 에서 정수 밀리초의 총 수를 사용 하 여 `timeout`합니다. 소수 자릿수 밀리초는 무시 됩니다.  
  
 이 메서드는 표준 COM 및 SendMessage 펌프를 수행 하지 않습니다.  
  
> [!NOTE]
>  가 있는 스레드를 대기 해야 하는 경우 <xref:System.STAThreadAttribute>, 표준 COM 및 SendMessage 펌프를 수행 하 고 오버 로드 중 하나를 사용 하는 것이 좋습니다. 하지만 <xref:System.Threading.Thread.Join%2A> 시간 제한 간격을 지정 하는 메서드.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> 메서드 오버 로드를 2 초 마다에 대 한 다섯 번 응용 프로그램의 주 스레드를 차단 합니다.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 값이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(밀리초)와 같지 않거나 <see cref="F:System.Int32.MaxValue" />(밀리초)보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">스레드 대기 시간을 정의하는 부호 있는 32비트 정수입니다.</param>
        <summary>스레드가 <paramref name="iterations" /> 매개 변수에서 정의하는 시간 동안 대기하도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.SpinWait%2A> 메서드는 잠금을 구현 하는 데 유용 합니다. .NET Framework에서와 같은 클래스 <xref:System.Threading.Monitor> 및 <xref:System.Threading.ReaderWriterLock>를 내부적으로이 메서드를 사용 합니다. <xref:System.Threading.Thread.SpinWait%2A> 기본적으로 넣습니다 프로세서 매우 빽빽한 루프에서 지정한 루프 수로는 `iterations` 매개 변수입니다. 따라서 대기 시간은 프로세서의 속도에 따라 달라 집니다.  
  
 이와 반대로와 <xref:System.Threading.Thread.Sleep%2A> 메서드. 호출 하는 스레드 <xref:System.Threading.Thread.Sleep%2A> 지정한 간격이 0 인 경우에 프로세서 시간의 현재 해당 조각의 나머지 부분을 만듭니다. 에 대 한 0이 아닌 간격 <xref:System.Threading.Thread.Sleep%2A> 시간 간격이 경과할 때까지 스레드가 스레드 스케줄러에서 고려 대상에서 제거 합니다.  
  
 <xref:System.Threading.Thread.SpinWait%2A> 일반적인 응용 프로그램에 일반적으로 유용 하지 않습니다. 대부분의 경우에서.NET Framework; 제공한 동기화 클래스를 사용 해야 예를 들어 호출 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 또는 래핑하는 문을 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` C# 또는 `SyncLock` Visual Basic의).  
  
> [!CAUTION]
>  호출 하는 상태 변경이 임박을 알고 있는 경우 등에서 컨텍스트 전환을 피하려면 하는 드문 경우에는 <xref:System.Threading.Thread.SpinWait%2A> 루프에서 메서드. 코드 <xref:System.Threading.Thread.SpinWait%2A> 실행 다중 프로세서가 있는 컴퓨터에서 발생할 수 있는 문제를 방지 하도록 설계 되었습니다. 예를 들어, 하이퍼 스레딩 기술에서는 사용 하는 여러 Intel 프로세서가 장착 된 컴퓨터에서 <xref:System.Threading.Thread.SpinWait%2A> 특정 상황에서는 프로세서 부족을 방지 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>스레드의 실행 일정을 예약합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>운영 체제에서 현재 인스턴스의 상태를 <see cref="F:System.Threading.ThreadState.Running" />으로 변경하도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 스레드는 <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> 상태 이면 운영 체제 실행을 예약할 수 있습니다. 스레드가 나타내는 메서드의 첫 번째 줄에서 실행이 시작 되는 <xref:System.Threading.ThreadStart> 또는 <xref:System.Threading.ParameterizedThreadStart> 스레드 생성자에 제공 합니다. 에 대 한 호출 <xref:System.Threading.Thread.Start%2A> 호출 스레드를 차단 하지 않습니다.  
  
> [!NOTE]
>  이 오버 로드를 사용 하 여 만든 스레드를 사용 하는 경우는 <xref:System.Threading.ParameterizedThreadStart> 대리자 `null` 스레드에 의해 실행 하는 메서드에 전달 됩니다.  
  
 스레드가 종료 되 면 다시 호출 하 여 `Start`합니다.  
  
   
  
## Examples  
 다음 예제에서는 만들고에서 스레드를 시작 합니다.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">스레드가 이미 시작되었습니다.</exception>
        <exception cref="T:System.OutOfMemoryException">이 스레드를 시작하기 위한 메모리가 부족합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">스레드가 실행하는 메서드에 사용될 데이터가 포함된 개체입니다.</param>
        <summary>운영 체제에서 현재 인스턴스의 상태를 <see cref="F:System.Threading.ThreadState.Running" />으로 변경하도록 하며 경우에 따라 스레드가 실행하는 메서드에 사용될 데이터가 포함된 개체를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 스레드는 <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> 상태 이면 운영 체제 실행을 예약할 수 있습니다. 스레드가 나타내는 메서드의 첫 번째 줄에서 실행이 시작 되는 <xref:System.Threading.ThreadStart> 또는 <xref:System.Threading.ParameterizedThreadStart> 스레드 생성자에 제공 합니다. 에 대 한 호출 <xref:System.Threading.Thread.Start%2A> 호출 스레드를 차단 하지 않습니다.  
  
 스레드가 종료 되 면 다시 호출 하 여 `Start`합니다.  
  
 이 오버 로드와 <xref:System.Threading.ParameterizedThreadStart> 대리자 쉽게 데이터를 전달 하는 스레드 프로시저에 있지만 하는 방법 형식이 안전 하지 않은 모든 개체를이 오버 로드에 전달 될 수 있으므로 합니다. 스레드 프로시저에 데이터를 전달 하는 보다 강력한 방법은 작업자 개체에 데이터 필드와 스레드 프로시저를 넣는 것입니다. 자세한 내용은 참조 [스레드 만들기 및 시작 시 데이터 전달](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Threading.ParameterizedThreadStart> 정적 메서드와 인스턴스 메서드를 사용 하 여 대리자입니다.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">스레드가 이미 시작되었습니다.</exception>
        <exception cref="T:System.OutOfMemoryException">이 스레드를 시작하기 위한 메모리가 부족합니다.</exception>
        <exception cref="T:System.InvalidOperationException">이 스레드는 <see cref="T:System.Threading.ParameterizedThreadStart" /> 대리자 대신 <see cref="T:System.Threading.ThreadStart" /> 대리자를 사용하여 만들었습니다.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>스레드를 일시 중단하며 스레드가 이미 일시 중단된 경우에는 아무런 효과도 나타나지 않습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드가 이미 일시 중단 된 경우이 메서드는 영향을 주지 않습니다.  
  
> [!CAUTION]
>  사용 하지 않는 <xref:System.Threading.Thread.Suspend%2A> 및 <xref:System.Threading.Thread.Resume%2A> 스레드 활동을 동기화 하는 메서드. 일시 중단 하면 스레드 코드 실행 알 방법이 없습니다. 보안 권한 확인 하는 동안 잠금을 유지 하는 동안 스레드를 일시 중단, 기타의 스레드는 <xref:System.AppDomain> 차단 될 수 있습니다. 다른 스레드가 클래스 생성자를 실행 하는 동안 스레드를 일시 중단는 <xref:System.AppDomain> 하는 클래스는 차단 사용 하려고 시도 합니다. 교착 상태는 매우 쉽게 발생할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core만 해당: 이 멤버는 지원되지 않습니다.</exception>
        <exception cref="T:System.Threading.ThreadStateException">스레드가 시작 또는 중단되지 않았습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 해당 <see cref="T:System.Security.Permissions.SecurityPermission" />이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 고급 작업 스레드입니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="rgszNames">매핑할 전달된 이름의 배열입니다.</param>
        <param name="cNames">매핑할 이름의 수입니다.</param>
        <param name="lcid">이름을 해석할 로캘 컨텍스트입니다.</param>
        <param name="rgDispId">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</param>
        <summary>이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">반환할 형식 정보입니다.</param>
        <param name="lcid">형식 정보의 로캘 식별자입니다.</param>
        <param name="ppTInfo">요청된 형식 정보 개체에 대한 포인터를 받습니다.</param>
        <summary>인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</param>
        <summary>개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">멤버를 식별합니다.</param>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="lcid">인수를 해석할 로캘 컨텍스트입니다.</param>
        <param name="wFlags">호출의 컨텍스트를 설명하는 플래그입니다.</param>
        <param name="pDispParams">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="pVarResult">결과를 저장할 위치에 대한 포인터입니다.</param>
        <param name="pExcepInfo">예외 정보가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="puArgErr">오류가 있는 첫 번째 인수의 인덱스입니다.</param>
        <summary>개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 스레드의 상태를 포함하는 값을 가져옵니다.</summary>
        <value>현재 스레드의 상태를 나타내는 <see cref="T:System.Threading.ThreadState" /> 값 중 하나입니다. 초기 값은 <see langword="Unstarted" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.ThreadState%2A> 보다 더 구체적인 정보를 제공 하는 속성은 <xref:System.Threading.Thread.IsAlive%2A> 속성입니다.  
  
> [!IMPORTANT]
>  스레드 상태 디버깅 시나리오에 대 한 관심만입니다. 코드에서 스레드 상태를 사용하여 스레드 활동을 동기화하면 안 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 하는 `ThreadState` 스레드입니다.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">새 아파트 상태입니다.</param>
        <summary>스레드를 시작하기 전에 스레드의 아파트 상태를 설정합니다.</summary>
        <returns>아파트 상태가 설정되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 스레드가 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 시작 되기 전에 해당 아파트 상태가 설정 되지 않은 경우. 스레드가 시작 되기 전에 아파트 상태를 설정 해야 합니다.  
  
> [!NOTE]
>  기본 응용 프로그램 스레드도 초기화 됩니다 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 기본적으로 합니다. 주 응용 프로그램 스레드의 아파트 상태를 설정 하는 유일한 방법은 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> 적용 하는 것은 <xref:System.STAThreadAttribute> 특성을 진입점 메서드.  
  
 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드를와 함께 <xref:System.Threading.Thread.GetApartmentState%2A> 메서드 및 <xref:System.Threading.Thread.SetApartmentState%2A> 메서드를 대체는 <xref:System.Threading.Thread.ApartmentState%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, 및 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드. 코드 예제에서는 스레드를 만듭니다. 스레드가 시작 되기 전에 <xref:System.Threading.Thread.GetApartmentState%2A> 초기 표시 <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> 상태 및 <xref:System.Threading.Thread.SetApartmentState%2A> 변경 된 상태를 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>합니다. <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드 다음 반환 `false` 상태를 변경 하려고 할 때 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 아파트 상태가 이미 설정 되어 있으므로 합니다. 동일한 작업을 시도 하는 경우 <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> 이 throw 합니다.  
  
 스레드가 시작 된 후의 <xref:System.Threading.Thread.TrySetApartmentState%2A> 메서드가 다시 사용 됩니다. 이 시간을 throw <xref:System.Threading.ThreadStateException> 스레드가 이미 시작 합니다.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" />가 잘못된 아파트 상태인 경우</exception>
        <exception cref="T:System.Threading.ThreadStateException">스레드가 이미 시작되었습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">읽을 필드입니다.</param>
        <summary>필드의 값을 읽습니다. 이 값은 프로세서 수나 프로세서 캐시의 상태와 관계없이 컴퓨터의 특정 프로세서에서 마지막으로 쓴 값입니다.</summary>
        <returns>프로세서에서 해당 필드에 쓴 마지막 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileRead%2A> 프로세서에서 메모리 위치에 쓴 최신 값을 가져옵니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">값이 쓰여질 필드입니다.</param>
        <param name="value">쓸 값입니다.</param>
        <summary>이 컴퓨터의 모든 프로세서에서 값을 볼 수 있도록 값을 필드에 즉시 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 동기화의 특수 한 경우에 대 한 합니다. 정상적인 상황에서는 C# `lock` 문, Visual Basic `SyncLock` 문, 및 <xref:System.Threading.Monitor> 클래스 보다 쉽게 대안을 제공 합니다.  
  
 다중 프로세서 시스템에서 <xref:System.Threading.Thread.VolatileWrite%2A> 메모리 위치에 기록 하는 값의 모든 프로세서에 즉시 표시 되는지 확인 합니다. 프로세서 캐시 플러시 필요할 수 있습니다.  
  
 단일 프로세서 시스템 에서도 <xref:System.Threading.Thread.VolatileRead%2A> 및 <xref:System.Threading.Thread.VolatileWrite%2A> 또는 확인 하는 값은 읽기를 메모리에 기록 (예: 프로세서 레지스터)에 캐시 되지 않습니다. 따라서 다른 스레드에서 또는 하드웨어에 의해 업데이트할 수 있는 필드에 대 한 액세스를 동기화에 사용할 수 있습니다.  
  
 이 메서드를 호출 하는 하나의 메모리 액세스를만 영향을 줍니다. 필드에 대 한 유효한 동기화를 제공 하려면 필드에 대 한 모든 액세스 사용 해야 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
> [!NOTE]
>  C#에서 사용 하는 `volatile` 필드에 한정자를 사용 하 여 해당 필드에 대 한 모든 액세스를 보장 <xref:System.Threading.Thread.VolatileRead%2A> 또는 <xref:System.Threading.Thread.VolatileWrite%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>호출 스레드가 현재 프로세서에서 실행할 준비가 되어 있는 다른 스레드에 실행 명령을 내리도록 합니다. 운영 체제에서 실행 명령을 내릴 스레드를 선택합니다.</summary>
        <returns>응용 프로그램에서 다른 스레드로 실행을 전환하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 성공 하면 현재 시간 조각에서 스레드의 나머지가 생성 됩니다. 운영 체제의 우선 순위 및 실행할 수 있는 다른 스레드에서의 상태에 따라 다른 시간 조각에 대 한 호출 스레드를 예약 합니다.  
  
 잠긴 호출 스레드를 실행 하는 프로세서로 제한 됩니다. 운영 체제 해당 프로세서 유휴 또는 낮은 우선 순위의 스레드를 실행 하는 경우에 다른 프로세서로 실행을 전환 되지 않습니다. 현재 프로세서에서 실행할 준비가 된 다른 스레드가 없는 운영 체제 실행을 생성 하지 않습니다 및이 메서드가 반환 `false`합니다.  
  
 이 메서드는 플랫폼 호출을 사용할를 네이티브 Win32 호출 `SwitchToThread` 함수입니다. 호출 해야는 <xref:System.Threading.Thread.Yield%2A> 플랫폼 바이패스 모든 사용자 지정 동작 스레딩 호스트에서 요청을 호출 하기 때문에 플랫폼을 사용 하는 대신 메서드 호출 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>