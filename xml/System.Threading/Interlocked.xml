<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Interlocked.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b857fe3" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2eccf4de-4b1c-4706-8cb3-f46682ccfb724c2592cbe53cf2462457e64a6a4dfa2cd110de24.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4c2592cbe53cf2462457e64a6a4dfa2cd110de24</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b15b8cf0f6dbc1504057c88969d9ef4b790891fe</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/11/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Provides atomic operations for variables that are shared by multiple threads.</source>
          <target state="translated">다중 스레드에서 공유하는 변수에 대한 원자 단위 연산을 제공합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</source>
          <target state="translated">이 클래스의 메서드는 별도 프로세서에서 두 개의 스레드에서 동시에 실행 될 때 또는 스레드가 다른 스레드에 액세스할 수 있는 변수를 업데이트 하는 동안 스케줄러 컨텍스트를 전환할 때 발생할 수 있는 오류 로부터 보호할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The members of this class do not throw exceptions.</source>
          <target state="translated">이 클래스의 멤버는 예외를 throw 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph> methods increment or decrement a variable and store the resulting value in a single operation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph> 메서드 증가 또는 감소 변수 및 결과 값을 한 번의 작업에 저장 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</source>
          <target state="translated">대부분의 컴퓨터에서 변수를 증가 하지 원자성 작업, 다음 단계를 필요로 합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Load a value from an instance variable into a register.</source>
          <target state="translated">레지스터에 인스턴스 변수에서 값을 로드 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Increment or decrement the value.</source>
          <target state="translated">증가 또는 감소 값입니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Store the value in the instance variable.</source>
          <target state="translated">인스턴스 변수에 값을 저장 합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, a thread can be preempted after executing the first two steps.</source>
          <target state="translated">사용 하지 않는 경우 <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, 처음 두 단계를 실행 한 후 선점 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Another thread can then execute all three steps.</source>
          <target state="translated">다른 스레드가 세 단계 모두 실행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</source>
          <target state="translated">첫 번째 스레드가 실행을 다시 시작 하는 경우 인스턴스 변수에서 값을 덮어씁니다을 증가 또는 감소가 두 번째 스레드가 수행한의 효과 손실 됩니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> method atomically exchanges the values of the specified variables.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> 메서드는 지정된 된 변수 값을 원자적으로 교환 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> 에서는 두 개의 작업 메서드: 비교의 결과에 따라 변수 중 하나에서 값을 두 개의 값을 비교 하 고 세 번째를 저장 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">비교 및 교환 작업은 원자성 작업으로 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The following code example shows a thread-safe resource locking mechanism.</source>
          <target state="translated">다음 코드 예제에서는 스레드로부터 안전한 리소스 잠금 메커니즘을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>This type is thread safe.</source>
          <target state="translated">이 형식은 스레드로부터 안전합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Adds two integers and replaces the first integer with the sum, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 두 정수를 더하고 첫 번째 정수를 합계로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>A variable containing the first value to be added.</source>
          <target state="translated">더할 첫 번째 값이 있는 변수입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The sum of the two values is stored in <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">두 값의 합계는 <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>에 저장됩니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The value to be added to the integer at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>에서 정수에 더할 값입니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 두 32비트 정수를 더하고 첫 번째 정수를 합계로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The new value stored at <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>에 저장된 새 값입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>This method handles an overflow condition by wrapping: if the value at <ph id="ph1">`location1`</ph> is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`value`</ph> is 1, the result is <ph id="ph4">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>; if <ph id="ph5">`value`</ph> is 2, the result is (<ph id="ph6">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> + 1); and so on.</source>
          <target state="translated">이 메서드는 오버플로 조건을 여 처리: 경우에 있는 값 <ph id="ph1">`location1`</ph> 은 <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">`value`</ph> 1 이면 결과 <ph id="ph4">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>경우 <ph id="ph5">`value`</ph> 가 2 이면 결과 (<ph id="ph6">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> + 1) 식입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw되지 않습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>A variable containing the first value to be added.</source>
          <target state="translated">더할 첫 번째 값이 있는 변수입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The sum of the two values is stored in <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">두 값의 합계는 <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>에 저장됩니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The value to be added to the integer at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>에서 정수에 더할 값입니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 두 64비트 정수를 더하고 첫 번째 정수를 합계로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The new value stored at <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>에 저장된 새 값입니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>This method handles an overflow condition by wrapping: if the value at <ph id="ph1">`location1`</ph> is <ph id="ph2">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`value`</ph> is 1, the result is <ph id="ph4">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>; if <ph id="ph5">`value`</ph> is 2, the result is (<ph id="ph6">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph> + 1); and so on.</source>
          <target state="translated">이 메서드는 오버플로 조건을 여 처리: 경우에 있는 값 <ph id="ph1">`location1`</ph> 은 <ph id="ph2">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">`value`</ph> 1 이면 결과 <ph id="ph4">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>경우 <ph id="ph5">`value`</ph> 가 2 이면 결과 (<ph id="ph6">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph> + 1) 식입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw되지 않습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> 메서드와의 64 비트 오버 로드는 <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, 및 <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> 메서드는 시스템에만 원자 여기서는 <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> 64 비트입니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">다른 시스템에서 이러한 메서드는 원자성와 관련 서로 하지만 다른 데이터 액세스 방법에 대해 없습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">따라서 32 비트 시스템에서 스레드로부터 안전 해야 64 비트 값에 대 한 액세스 통해 수행 해야의 멤버는 <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Compares two values for equality and, if they are equal, replaces the first value.</source>
          <target state="translated">두 값이 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>피연산자<ept id="p1">&lt;/c&gt;</ept>와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          <target state="translated">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>의 값과 비교할 값입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</source>
          <target state="translated">두 배 정밀도 부동 소수점 숫자가 같은지 비교하여 같으면 두 값 중 하나를 바꿉니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparand`</ph> 에 값 <ph id="ph2">`location1`</ph> 가 같으면 <ph id="ph3">`value`</ph> 에 저장 된 <ph id="ph4">`location1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">그렇지 않으면 작업이 수행되지 않습니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">비교 및 교환 작업은 원자성 작업으로 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">반환 값 <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> 의 원래 값은 <ph id="ph2">`location1`</ph>교환의 여부.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The following code example demonstrates a thread-safe method that accumulates a running total of <ph id="ph1">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated">다음 코드 예제에서는의 누계를 누적 하는 스레드로부터 안전한 메서드를 보여 줍니다. <ph id="ph1">&lt;xref:System.Double&gt;</ph> 값입니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>Two threads add a series of <ph id="ph1">&lt;xref:System.Double&gt;</ph> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</source>
          <target state="translated">두 스레드는 일련의 추가 <ph id="ph1">&lt;xref:System.Double&gt;</ph> 스레드로부터 안전한 방법 및 일반적인 더하기를 사용 하 여 값의 합계를 비교 하는 스레드가 완료 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>On a dual-processor computer, there is a significant difference in the totals.</source>
          <target state="translated">이중 프로세서 컴퓨터에서의 합계에는 큰 차이가 있습니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>In the thread-safe method, the initial value of the running total is saved, and then the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method is used to exchange the newly computed total with the old total.</source>
          <target state="translated">스레드로부터 안전한 방법에서는 누적 합계의 초기 값이 저장 한 다음은 <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> 메서드 누계 새로 계산 된 합계를 교환 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</source>
          <target state="translated">반환 값을 총 합계의 저장 된 값과 같은 없으면 다음 다른 스레드가 업데이트 총 그 동안.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>In that case, the attempt to update the running total must be repeated.</source>
          <target state="translated">이 경우 누계 업데이트를 시도 반복 해야 합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>피연산자<ept id="p1">&lt;/c&gt;</ept>와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          <target state="translated">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>의 값과 비교할 값입니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</source>
          <target state="translated">두 개의 부호 있는 32비트 정수가 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparand`</ph> 에 값 <ph id="ph2">`location1`</ph> 가 같으면 <ph id="ph3">`value`</ph> 에 저장 된 <ph id="ph4">`location1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">그렇지 않으면 작업이 수행되지 않습니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">비교 및 교환 작업은 원자성 작업으로 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">반환 값 <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> 의 원래 값은 <ph id="ph2">`location1`</ph>교환의 여부.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The following code example demonstrates a thread-safe method that accumulates a running total.</source>
          <target state="translated">다음 코드 예제에서는 누계를 누적 하는 스레드로부터 안전한 메서드를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The initial value of the running total is saved, and then the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method is used to exchange the newly computed total with the old total.</source>
          <target state="translated">누적 합계의 초기 값을 저장 한 다음은 <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> 메서드 누계 새로 계산 된 합계를 교환 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</source>
          <target state="translated">반환 값을 총 합계의 저장 된 값과 같은 없으면 다음 다른 스레드가 업데이트 총 그 동안.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>In that case, the attempt to update the running total must be repeated.</source>
          <target state="translated">이 경우 누계 업데이트를 시도 반복 해야 합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> 메서드를.NET Framework 버전 2.0에에서 도입 된 정수에 대 한 누계 스레드로부터 안전한 누적 하는 보다 편리한 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>피연산자<ept id="p1">&lt;/c&gt;</ept>와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          <target state="translated">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>의 값과 비교할 값입니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</source>
          <target state="translated">두 개의 부호 있는 64비트 정수가 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparand`</ph> 에 값 <ph id="ph2">`location1`</ph> 가 같으면 <ph id="ph3">`value`</ph> 에 저장 된 <ph id="ph4">`location1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">그렇지 않으면 작업이 수행되지 않습니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">비교 및 교환 작업은 원자성 작업으로 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">반환 값 <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> 의 원래 값은 <ph id="ph2">`location1`</ph>교환의 여부.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The destination <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>, whose value is compared with the value of <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced by <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>피연산자<ept id="p1">&lt;/c&gt;</ept> 값과 비교되어 <bpt id="p2">&lt;c&gt;</bpt>값<ept id="p2">&lt;/c&gt;</ept>으로 바뀔 수 있는 값을 가진 대상 <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> that replaces the destination value if the comparison results in equality.</source>
          <target state="translated">비교 결과가 같은 경우 대상 값을 바꿀 <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>의 값과 비교할 <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</source>
          <target state="translated">두 플랫폼별 핸들이나 포인터가 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparand`</ph> 에 값 <ph id="ph2">`location1`</ph> 가 같으면 <ph id="ph3">`value`</ph> 에 저장 된 <ph id="ph4">`location1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">그렇지 않으면 작업이 수행되지 않습니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">비교 및 교환 작업은 원자성 작업으로 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The return value of this method is the original value in <ph id="ph1">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">이 메서드의 반환 값은 원래 값에 <ph id="ph1">`location1`</ph>교환의 여부.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> is a platform-specific type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> 플랫폼별 형식이입니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The destination object that is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>피연산자<ept id="p1">&lt;/c&gt;</ept>와 비교되어 바뀔 수 있는 대상 개체입니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The object that replaces the destination object if the comparison results in equality.</source>
          <target state="translated">비교한 결과 같은 경우 대상 개체를 바꾸는 개체입니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The object that is compared to the object at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>의 개체와 비교할 개체입니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Compares two objects for reference equality and, if they are equal, replaces the first object.</source>
          <target state="translated">두 개체의 참조가 같은지 비교하여 같으면 첫 번째 개체를 바꿉니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>If <ph id="ph1">`comparand`</ph> and the object in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparand`</ph> 고의 개체가 <ph id="ph2">`location1`</ph> 가 같으면 <ph id="ph3">`value`</ph> 에 저장 된 <ph id="ph4">`location1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">그렇지 않으면 작업이 수행되지 않습니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">비교 및 교환 작업은 원자성 작업으로 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">반환 값 <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> 의 원래 값은 <ph id="ph2">`location1`</ph>교환의 여부.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Beginning with .NET Framework version 2.0, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29&gt;</ph> method overload provides a type-safe alternative for reference types.</source>
          <target state="translated">.NET Framework 버전 2.0 부터는 <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29&gt;</ph> 메서드 오버 로드 참조 형식에 대 한 형식이 안전한 대체 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The objects are compared for reference equality, rather than <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">개체는 참조 일치 대신 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed.</source>
          <target state="translated">결과적으로, 두 boxed 인스턴스는 동일한 값 형식 (예를 들어 정수 3) 항상 같지 않은 것으로 표시 하 고 작업이 수행 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Do not use this overload with value types.</source>
          <target state="translated">값이 있는이 오버 로드를 사용 하지 마십시오.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>피연산자<ept id="p1">&lt;/c&gt;</ept>와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          <target state="translated">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>의 값과 비교할 값입니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</source>
          <target state="translated">두 단정밀도 부동 소수점 숫자가 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparand`</ph> 에 값 <ph id="ph2">`location1`</ph> 가 같으면 <ph id="ph3">`value`</ph> 에 저장 된 <ph id="ph4">`location1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">그렇지 않으면 작업이 수행되지 않습니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">비교 및 교환 작업은 원자성 작업으로 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">반환 값 <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> 의 원래 값은 <ph id="ph2">`location1`</ph>교환의 여부.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The following code example demonstrates a thread-safe method that accumulates a running total of <ph id="ph1">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">다음 코드 예제에서는의 누계를 누적 하는 스레드로부터 안전한 메서드를 보여 줍니다. <ph id="ph1">&lt;xref:System.Single&gt;</ph> 값입니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>Two threads add a series of <ph id="ph1">&lt;xref:System.Single&gt;</ph> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</source>
          <target state="translated">두 스레드는 일련의 추가 <ph id="ph1">&lt;xref:System.Single&gt;</ph> 스레드로부터 안전한 방법 및 일반적인 더하기를 사용 하 여 값의 합계를 비교 하는 스레드가 완료 합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>On a dual-processor computer, there is a significant difference in the totals.</source>
          <target state="translated">이중 프로세서 컴퓨터에서의 합계에는 큰 차이가 있습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>In the thread-safe method, the initial value of the running total is saved, and then the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method is used to exchange the newly computed total with the old total.</source>
          <target state="translated">스레드로부터 안전한 방법에서는 누적 합계의 초기 값이 저장 한 다음은 <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> 메서드 누계 새로 계산 된 합계를 교환 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</source>
          <target state="translated">반환 값을 총 합계의 저장 된 값과 같은 없으면 다음 다른 스레드가 업데이트 총 그 동안.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>In that case, the attempt to update the running total must be repeated.</source>
          <target state="translated">이 경우 누계 업데이트를 시도 반복 해야 합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The type to be used for <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>, <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept>, and <bpt id="p3">&lt;c&gt;</bpt>comparand<ept id="p3">&lt;/c&gt;</ept>.</source>
          <target state="translated">형식에 사용할 <bpt id="p1">&lt;c&gt;</bpt>수신 위치 1<ept id="p1">&lt;/c&gt;</ept>, <bpt id="p2">&lt;c&gt;</bpt>값<ept id="p2">&lt;/c&gt;</ept>, 및 <bpt id="p3">&lt;c&gt;</bpt>피비교수<ept id="p3">&lt;/c&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This type must be a reference type.</source>
          <target state="translated">이 형식은 참조 형식이어야 합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>피연산자<ept id="p1">&lt;/c&gt;</ept>와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This is a reference parameter (<ph id="ph1">&lt;see langword="ref" /&gt;</ph> in C#, <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">이 매개 변수는 참조 매개 변수입니다(C#에서는 <ph id="ph1">&lt;see langword="ref" /&gt;</ph>이고 Visual Basic에서는 <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>임).</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          <target state="translated">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>의 값과 비교할 값입니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>Compares two instances of the specified reference type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> for equality and, if they are equal, replaces the first one.</source>
          <target state="translated">지정된 참조 형식 <ph id="ph1">&lt;paramref name="T" /&gt;</ph>의 두 인스턴스가 같은지 비교하여 같으면 두 값 중 하나를 바꿉니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparand`</ph> 에 값 <ph id="ph2">`location1`</ph> 가 같으면 <ph id="ph3">`value`</ph> 에 저장 된 <ph id="ph4">`location1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">그렇지 않으면 작업이 수행되지 않습니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The comparison and the exchange are performed as an atomic operation.</source>
          <target state="translated">비교 및 교환 원자 단위 연산으로 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The return value of this method is the original value in <ph id="ph1">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">이 메서드의 반환 값은 원래 값에 <ph id="ph1">`location1`</ph>교환의 여부.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This method only supports reference types.</source>
          <target state="translated">이 메서드는 참조 형식만 지원 합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>There are overloads of the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method for the value types <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, and <ph id="ph6">&lt;xref:System.Double&gt;</ph>, but there is no support for other value types.</source>
          <target state="translated">오버 로드가 <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> 값 형식에 대 한 메서드 <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, 및 <ph id="ph6">&lt;xref:System.Double&gt;</ph>, 있지만 다른 값 형식에 대 한 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This method overload is preferable to the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29&gt;</ph> method overload, because the latter requires the destination object to be accessed late-bound.</source>
          <target state="translated">이 메서드 오버 로드는 것이 좋습니다는 <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29&gt;</ph> 에 런타임에 바인딩된 액세스는 대상 개체 때문에 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Decrements a specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 지정된 변수를 감소시키고 결과를 저장합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The variable whose value is to be decremented.</source>
          <target state="translated">값을 감소시킬 변수입니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>Decrements a specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 지정된 변수를 감소시키고 결과를 저장합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The decremented value.</source>
          <target state="translated">감소한 값입니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>This method handles an overflow condition by wrapping: If <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> - 1 = <ph id="ph5">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">이 메서드는 오버플로 조건을 여 처리: 경우 <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> -1 = <ph id="ph5">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw되지 않습니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</source>
          <target state="translated">다음 예제에서는 중간점 값이 1, 000 개의 난수를 생성 하는 데 필요한 개수 임의의 숫자 범위는 0에서 1, 000를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>To keep track of the number of midpoint values, a variable, <ph id="ph1">`midpointCount`</ph>, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</source>
          <target state="translated">중간점 값, 변수, 개수를 추적 하기 위해 <ph id="ph1">`midpointCount`</ph>, 1, 000 같고 감소 중간점 값을 반환 하는 난수 생성기 때마다 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>Because three threads generate the random numbers, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29&gt;</ph> method is called to ensure that multiple threads don't update <ph id="ph2">`midpointCount`</ph> concurrently.</source>
          <target state="translated">세 개의 스레드는 난수를 생성 하기 때문에 <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29&gt;</ph> 메서드는 여러 스레드가 업데이트 하지 않으면 확인 <ph id="ph2">`midpointCount`</ph> 동시에 합니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>Note that a lock is also used to protect the random number generator, and that a <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object is used to ensure that the <ph id="ph2">`Main`</ph> method doesn't finish execution before the three threads.</source>
          <target state="translated">잠금을 난수 생성기, 및를 보호 하도 사용 되는 <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> 되도록 개체를 사용는 <ph id="ph2">`Main`</ph> 메서드 3 개 스레드 이전 실행이 완료 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers.</source>
          <target state="translated">사용 하 여 다음 예제는 이전 쿼리와 비슷합니다는 50, 000 중간점 임의의 정수를 생성 하는 스레드 프로시저 대신 합니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>In this example, a lambda expression replaces the <ph id="ph1">`GenerateNumbers`</ph> thread procedure, and the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method eliminates the need for the <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.</source>
          <target state="translated">이 예제에서는 람다 식을 대체는 <ph id="ph1">`GenerateNumbers`</ph> 스레드 프로시저에 대 한 호출은 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> 메서드 필요 하지 않습니다는 <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The variable whose value is to be decremented.</source>
          <target state="translated">값을 감소시킬 변수입니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>Decrements the specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 지정된 변수를 감소시키고 결과를 저장합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The decremented value.</source>
          <target state="translated">감소한 값입니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>This method handles an overflow condition by wrapping: if <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> - 1 = <ph id="ph5">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">이 메서드는 오버플로 조건을 여 처리: 경우 <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> -1 = <ph id="ph5">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw되지 않습니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> 메서드와의 64 비트 오버 로드는 <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, 및 <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> 메서드는 시스템에만 원자 여기서는 <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> 64 비트입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">다른 시스템에서 이러한 메서드는 원자성와 관련 서로 하지만 다른 데이터 액세스 방법에 대해 없습니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">따라서 32 비트 시스템에서 스레드로부터 안전 해야 64 비트 값에 대 한 액세스 통해 수행 해야의 멤버는 <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Sets a variable to a specified value as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 변수를 지정된 값으로 설정합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">지정된 값으로 설정할 변수입니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> 매개 변수를 설정할 값입니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 배정밀도 부동 소수점 숫자를 지정된 값으로 설정하고 원래 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">지정된 값으로 설정할 변수입니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> 매개 변수를 설정할 값입니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 부호 있는 32비트 정수를 지정된 값으로 설정하고 원래 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The following code example shows a thread-safe resource locking mechanism.</source>
          <target state="translated">다음 코드 예제에서는 스레드로부터 안전한 리소스 잠금 메커니즘을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">지정된 값으로 설정할 변수입니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> 매개 변수를 설정할 값입니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 부호 있는 64비트 정수를 지정된 값으로 설정하고 원래 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">지정된 값으로 설정할 변수입니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> 매개 변수를 설정할 값입니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 플랫폼별 핸들 또는 포인터를 지정된 값으로 설정하고 원래 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">지정된 값으로 설정할 변수입니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> 매개 변수를 설정할 값입니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 개체를 지정된 값으로 설정하고 참조를 원래 개체로 반환합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>Beginning with .NET Framework version 2.0, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29&gt;</ph> method overload provides a type-safe alternative for reference types.</source>
          <target state="translated">.NET Framework 버전 2.0 부터는 <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29&gt;</ph> 메서드 오버 로드 참조 형식에 대 한 형식이 안전한 대체 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">지정된 값으로 설정할 변수입니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> 매개 변수를 설정할 값입니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 단정밀도 부동 소수점 숫자를 지정된 값으로 설정하고 원래 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The type to be used for <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> and <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">형식에 사용할 <bpt id="p1">&lt;c&gt;</bpt>수신 위치 1<ept id="p1">&lt;/c&gt;</ept> 및 <bpt id="p2">&lt;c&gt;</bpt>값<ept id="p2">&lt;/c&gt;</ept>합니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This type must be a reference type.</source>
          <target state="translated">이 형식은 참조 형식이어야 합니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">지정된 값으로 설정할 변수입니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This is a reference parameter (<ph id="ph1">&lt;see langword="ref" /&gt;</ph> in C#, <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">이 매개 변수는 참조 매개 변수입니다(C#에서는 <ph id="ph1">&lt;see langword="ref" /&gt;</ph>이고 Visual Basic에서는 <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>임).</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> 매개 변수를 설정할 값입니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>Sets a variable of the specified type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">원자성 연산으로 지정된 형식 <ph id="ph1">&lt;paramref name="T" /&gt;</ph>의 변수를 지정된 값으로 설정하고 원래 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 원래 값입니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This method only supports reference types.</source>
          <target state="translated">이 메서드는 참조 형식만 지원 합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>There are overloads of the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> method for the <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, and <ph id="ph6">&lt;xref:System.Double&gt;</ph> value types, but there is no support for other value types.</source>
          <target state="translated">오버 로드가 <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> 에 대 한 메서드는 <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, 및 <ph id="ph6">&lt;xref:System.Double&gt;</ph> 값 형식, 있지만 다른 값 형식에 대 한 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This method overload is preferable to the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29&gt;</ph> method overload, because the latter requires late-bound access to the destination object .</source>
          <target state="translated">이 메서드 오버 로드는 것이 좋습니다는 <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29&gt;</ph> 대상 개체에 대 한 런타임에 바인딩된 액세스 때문에 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location1" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Increments a specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 지정된 변수를 증가시키고 결과를 저장합니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The variable whose value is to be incremented.</source>
          <target state="translated">값을 증가시킬 변수입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>Increments a specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 지정된 변수를 증가시키고 결과를 저장합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The incremented value.</source>
          <target state="translated">증가한 값입니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>This method handles an overflow condition by wrapping: if <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">이 메서드는 오버플로 조건을 여 처리: 경우 <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw되지 않습니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</source>
          <target state="translated">다음 예제에서는 중간점 값이 1, 000 개의 난수를 생성 하는 데 필요한 개수 임의의 숫자 범위는 0에서 1, 000를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>To keep track of the number of midpoint values, a variable, <ph id="ph1">`midpointCount`</ph>, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</source>
          <target state="translated">중간점 값, 변수, 개수를 추적 하기 위해 <ph id="ph1">`midpointCount`</ph>, 0으로 설정 되 고 10, 000 도달할 때까지 중간점 값을 반환 하는 난수 생성기의 때마다 증가 합니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>Because three threads generate the random numbers, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%28System.Int32%40%29&gt;</ph> method is called to ensure that multiple threads don't update <ph id="ph2">`midpointCount`</ph> concurrently.</source>
          <target state="translated">세 개의 스레드는 난수를 생성 하기 때문에 <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%28System.Int32%40%29&gt;</ph> 메서드는 여러 스레드가 업데이트 하지 않으면 확인 <ph id="ph2">`midpointCount`</ph> 동시에 합니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>Note that a lock is also used to protect the random number generator, and that a <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object is used to ensure that the <ph id="ph2">`Main`</ph> method doesn't finish execution before the three threads.</source>
          <target state="translated">잠금을 난수 생성기, 및를 보호 하도 사용 되는 <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> 되도록 개체를 사용는 <ph id="ph2">`Main`</ph> 메서드 3 개 스레드 이전 실행이 완료 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers.</source>
          <target state="translated">사용 하 여 다음 예제는 이전 쿼리와 비슷합니다는 50, 000 중간점 임의의 정수를 생성 하는 스레드 프로시저 대신 합니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>In this example, a lambda expression replaces the <ph id="ph1">`GenerateNumbers`</ph> thread procedure, and the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method eliminates the need for the <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.</source>
          <target state="translated">이 예제에서는 람다 식을 대체는 <ph id="ph1">`GenerateNumbers`</ph> 스레드 프로시저에 대 한 호출은 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> 메서드 필요 하지 않습니다는 <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The variable whose value is to be incremented.</source>
          <target state="translated">값을 증가시킬 변수입니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>Increments a specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 지정된 변수를 증가시키고 결과를 저장합니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The incremented value.</source>
          <target state="translated">증가한 값입니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>This method handles an overflow condition by wrapping: if <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">이 메서드는 오버플로 조건을 여 처리: 경우 <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw되지 않습니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> 메서드와의 64 비트 오버 로드는 <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, 및 <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> 메서드는 시스템에만 원자 여기서는 <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> 64 비트입니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">다른 시스템에서 이러한 메서드는 원자성와 관련 서로 하지만 다른 데이터 액세스 방법에 대해 없습니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">따라서 32 비트 시스템에서 스레드로부터 안전 해야 64 비트 값에 대 한 액세스 통해 수행 해야의 멤버는 <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="location" /&gt;</ph>의 주소는 null 포인터입니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source>Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <ph id="ph1">&lt;see cref="M:System.Threading.Interlocked.MemoryBarrier" /&gt;</ph> execute after memory accesses that follow the call to <ph id="ph2">&lt;see cref="M:System.Threading.Interlocked.MemoryBarrier" /&gt;</ph>.</source>
          <target state="translated">다음과 같이 메모리 액세스를 동기화합니다. 현재 스레드를 실행하는 프로세서는 <ph id="ph1">&lt;see cref="M:System.Threading.Interlocked.MemoryBarrier" /&gt;</ph>에 대한 호출 이전의 메모리 액세스가 <ph id="ph2">&lt;see cref="M:System.Threading.Interlocked.MemoryBarrier" /&gt;</ph>에 대한 호출 이후의 메모리 액세스 뒤에 실행되는 방식으로 명령을 다시 정렬할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source>This method was added to the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class in the <ph id="ph2">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> as a convenience; it's a wrapper for the <ph id="ph3">&lt;xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">에 추가 된이 메서드는 <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> 클래스에 <ph id="ph2">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> 편의 위해;에 대 한 래퍼는는 <ph id="ph3">&lt;xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source><ph id="ph1">&lt;xref:System.Threading.Interlocked.MemoryBarrier%2A&gt;</ph> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.MemoryBarrier%2A&gt;</ph> 약한 메모리 순서 (예를 들어 여러 Intel Itanium 프로세서를 사용 하는 시스템)를 지정 하는 경우 하나의 다중 프로세서 시스템에만 필요 합니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier ways to synchronize data.</source>
          <target state="translated">대부분의 용도 C#에 대 한 <ph id="ph1">`lock`</ph> 문, Visual Basic <ph id="ph2">`SyncLock`</ph> 문, 또는 <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> 편리 하 게 데이터를 동기화 할 클래스를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The 64-bit value to be loaded.</source>
          <target state="translated">로드될 64비트 값입니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>Returns a 64-bit value, loaded as an atomic operation.</source>
          <target state="translated">원자 단위 연산으로 로드된 64비트 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The loaded value.</source>
          <target state="translated">로드된 값입니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> 64 비트 읽기 작업은 원자성 이미 때문에 메서드는 64 비트 시스템에서 필요 없습니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>On 32-bit systems, 64-bit read operations are not atomic unless performed using <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph>.</source>
          <target state="translated">32 비트 시스템에서 64 비트 읽기 작업은 사용 하 여 수행 하지 않는 한 원자성 <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> 메서드와의 64 비트 오버 로드는 <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, 및 <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> 메서드는 시스템에만 원자 여기서는 <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> 64 비트입니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">다른 시스템에서 이러한 메서드는 원자성와 관련 서로 하지만 다른 데이터 액세스 방법에 대해 없습니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">따라서 32 비트 시스템에서 스레드로부터 안전 해야 64 비트 값에 대 한 액세스 통해 수행 해야의 멤버는 <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> is a platform-specific type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> 플랫폼별 형식이입니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>