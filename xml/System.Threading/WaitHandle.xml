<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9c30c9bf2d271da2afe9d173213a99d04fceefda" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531507" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>공유 리소스에 대한 단독 액세스를 기다리는 운영 체제 관련 개체를 캡슐화합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle> 클래스 Win32 동기화 핸들을 캡슐화 하 고는 런타임에서 여러 개의 대기 작업을 허용 하는 모든 동기화 개체를 나타내는 데 사용 됩니다. 대기 핸들 다른 동기화 개체와 비교를 참조 하세요. [동기화 기본 형식 개요](~/docs/standard/threading/overview-of-synchronization-primitives.md)합니다.  
  
 <xref:System.Threading.WaitHandle> 클래스 자체는 추상 클래스입니다. 클래스에서 파생 된 <xref:System.Threading.WaitHandle> 또는 공유 리소스에 대 한 액세스 액세스 해제를 나타내기 위해 신호 메커니즘을 정의 하지만 상속 된 사용 <xref:System.Threading.WaitHandle> 공유 리소스에 대 한 액세스를 기다리는 동안 차단 하는 메서드. 파생 된 클래스 <xref:System.Threading.WaitHandle> 포함:  
  
-   <xref:System.Threading.Mutex> 클래스 참조 [뮤텍스](~/docs/standard/threading/mutexes.md)합니다.  
  
-   <xref:System.Threading.EventWaitHandle> 클래스와 해당 파생된 클래스 <xref:System.Threading.AutoResetEvent> 및 <xref:System.Threading.ManualResetEvent>합니다. [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)를 참조하세요.  
  
-   <xref:System.Threading.Semaphore> 클래스 참조 [세마포 및 SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)합니다.  
  
 인스턴스 메서드를 호출 하 여 개별 대기 핸들에서 스레드가 차단 수 <xref:System.Threading.WaitHandle.WaitOne%2A>에서 파생 클래스에서 상속 됨 <xref:System.Threading.WaitHandle>합니다.  
  
 파생된 클래스의 <xref:System.Threading.WaitHandle> 스레드 선호도에서 서로 다릅니다. 이벤트 대기 핸들 (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, 및 <xref:System.Threading.ManualResetEvent>) 및 세마포에 스레드 선호도 없습니다; 모든 스레드가 이벤트 대기 핸들 또는 세마포를 표시할 수 있습니다. 뮤텍스 반면에 권한이 스레드 선호도 있습니다. 뮤텍스를 소유 하는 스레드를 해제 해야 하 고 스레드가 호출 하는 경우 예외가 throw 되는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드 소유 하지 않는 뮤텍스를 합니다.  
  
 때문에 <xref:System.Threading.WaitHandle> 클래스에서 파생 <xref:System.MarshalByRefObject>를 이러한 클래스를 사용 하 여 응용 프로그램 도메인 경계에 걸쳐 스레드 활동을 동기화 할 수 있습니다.  
  
 해당 파생된 클래스 외에 <xref:System.Threading.WaitHandle> 클래스에는 다양 한 동작이 일어날 때까지 스레드를 차단 하는 정적 메서드 또는 자세한 동기화 개체가 신호를 받기를... 여기에는 다음이 포함됩니다.  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>를 한 대기 핸들이 신호를 보내고 다른 즉시 대기 하는 스레드 수 있습니다.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>를 허용 하는 스레드를 모든 대기 핸들 배열에 신호를 받을 때까지 대기 합니다.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>지정된 된 집합이 대기 핸들 중 하나는 신호가 될 때까지 대기 하는 스레드 수 있습니다.  
  
 이러한 메서드의 오버 로드는 대기 시간 및 들어가기 전에, 다른 스레드 동기화 컨텍스트를 사용할 수 있게 동기화 컨텍스트를 종료 하는 기회를 중단 하는 것에 대 한 제한 시간 간격을 제공 합니다.  
  
> [!IMPORTANT]
>  이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식 또는 여기에서 파생 된 형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다. 직접 형식의 dispose를 호출 해당 <xref:System.Threading.WaitHandle.Close%2A> 에서 메서드는 `try` / `catch` 블록입니다. 작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다. 자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
 <xref:System.Threading.WaitHandle> 구현 하는 <xref:System.IDisposable.Dispose%2A> 패턴입니다. 참조 [삭제 패턴](~/docs/standard/design-guidelines/dispose-pattern.md)합니다. 파생 시키는 경우 <xref:System.Threading.WaitHandle>를 사용 하 여는 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 네이티브 핸들 운영 체제 핸들을 저장 하는 속성입니다. 보호 된 재정의할 필요가 없습니다 <xref:System.Threading.WaitHandle.Dispose%2A> 메서드 추가 관리 되지 않는 리소스를 사용 하지 않는 한 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 스레드 수는 방법 수행 백그라운드 작업 하는 동안 주 스레드 정적을 사용 하 여 완료 작업에 대 한 대기 <xref:System.Threading.WaitHandle.WaitAny%2A> 및 <xref:System.Threading.WaitHandle.WaitAll%2A> 의 메서드는 <xref:System.Threading.WaitHandle> 클래스입니다.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Threading.WaitHandle" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Threading.WaitHandle" /> 에서 보유한 모든 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는의 공용 구현을 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 에 대 한 메서드는 <xref:System.Threading.WaitHandle> 클래스와 해당 파생된 클래스입니다. 호출 하는 표준 구현을 제공는 `Dispose(Boolean)` 오버 로드는 `true` 인수 및 호출 된 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 메서드. 인스턴스에서 보유 한 모든 리소스를 해제 하기 위해이 메서드를 호출 `WaitHandle` 또는 파생된 클래스입니다.  
  
 이 메서드가 호출 되 면 현재 인스턴스에 대 한 참조가 정의 되지 않은 동작이 발생 합니다.  
  
> [!NOTE]
>  항상 호출 <xref:System.Threading.WaitHandle.Close%2A> 또는 <xref:System.Threading.WaitHandle.Dispose> 에 대 한 마지막 참조를 해제 하기 전에 <xref:System.Threading.WaitHandle>합니다. 그렇지 않으면 사용 중인 리소스가 해제 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 해야 하는 <see langword="Dispose(Boolean)" /> 파생 클래스에서 할당 된 리소스를 해제 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.WaitHandle" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Threading.WaitHandle" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 해당 하는 <xref:System.Threading.WaitHandle.Close%2A> 메서드.  
  
> [!NOTE]
>  항상 호출 <xref:System.Threading.WaitHandle.Close%2A> 또는 <xref:System.Threading.WaitHandle.Dispose> 에 대 한 마지막 참조를 해제 하기 전에 <xref:System.Threading.WaitHandle>합니다. 그렇지 않으면 사용 중인 리소스가 해제 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary>파생 클래스에서 재정의된 경우 <see cref="T:System.Threading.WaitHandle" />에서 사용하는 관리되지 않는 리소스를 해제하고 필요에 따라 관리되는 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Threading.WaitHandle.Close%2A> 및 <xref:System.Threading.WaitHandle.Dispose> 있는 메서드는 `explicitDisposing` 매개 변수 설정 `true`합니다.  경우는 `explicitDisposing` 매개 변수는 `true`,이 메서드는 관리 개체가 보유 하는 모든 리소스를 해제 합니다.이 <xref:System.Threading.WaitHandle> 개체에서 참조 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 해야 하는 <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> 파생 클래스에서 할당 된 리소스를 해제 하는 메서드.  
  
 <see cref="M:System.Threading.WaitHandle.Close" /> 또는 <see cref="M:System.Threading.WaitHandle.Dispose" /> 메서드는 다른 개체에서 여러 번 호출할 수 있습니다. 이 메서드를 재정의 하는 경우에 대 한 이전 호출에서 삭제 된 개체를 참조 하지 않도록 해야 <see langword="Dispose" /> 또는 <see langword="Close" />합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>네이티브 운영 체제 핸들을 가져오거나 설정합니다.</summary>
        <value>네이티브 운영 체제 핸들을 나타내는 <see langword="IntPtr" />입니다. 기본값은 <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> 필드의 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 값을 할당 하는 <xref:System.Threading.WaitHandle.Handle%2A> 속성 이전 핸들을 닫지 않습니다. 이 핸들 누수가 발생할 수 있습니다.  
  
 .NET Framework 버전 2.0 이상의;에이 속성을 사용 하지 마십시오 사용 하 여 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성 대신 합니다. 이 속성을 유효한 핸들도 집합은 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성이 아니라로 설정 <xref:System.Threading.WaitHandle.InvalidHandle> 핸들 누수가 발생할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">속성 값을 설정 하려면 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 설정할 수 없습니다.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">파생된 형식에 있어야 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 속성 값을 설정 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>유효하지 않은 네이티브 운영 체제 핸들을 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 내부적으로 초기화 하는 데 사용 된 <xref:System.Threading.WaitHandle.Handle%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>확인 하려면이 값을 사용할 수 있는지 여부를 <see cref="P:System.Threading.WaitHandle.Handle" /> 속성 유효한 네이티브 운영 체제 핸들을 포함 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>네이티브 운영 체제 핸들을 가져오거나 설정합니다.</summary>
        <value>네이티브 운영 체제 핸들을 나타내는 <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 값을 할당 하면는 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성을 이전 핸들이 닫히는 경우 이전 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 개체 수집 됩니다. 수동으로 닫지 마십시오 핸들에이 인해 때문에 프로그램 <xref:System.ObjectDisposedException> 때는 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 핸들을 시도 합니다.  
  
 <xref:System.Threading.WaitHandle> 구현 하는 <xref:System.IDisposable.Dispose%2A> 패턴입니다. 참조 [삭제 패턴](~/docs/standard/design-guidelines/dispose-pattern.md)합니다. 파생 시키는 경우 <xref:System.Threading.WaitHandle>를 사용 하 여는 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 네이티브 핸들 운영 체제 핸들을 저장 하는 속성입니다. 보호 된 재정의할 필요가 없습니다 <xref:System.Threading.WaitHandle.Dispose%2A> 메서드 추가 관리 되지 않는 리소스를 사용 하지 않는 한 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">파생된 형식에 있어야 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 를이 멤버를 호출 합니다.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.WaitHandle" />에 신호하고 다른 신호를 기다립니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">신호를 보낼 <see cref="T:System.Threading.WaitHandle" />입니다.</param>
        <param name="toWaitOn">대기할 <see cref="T:System.Threading.WaitHandle" />입니다.</param>
        <summary>
          <see cref="T:System.Threading.WaitHandle" />에 신호하고 다른 신호를 기다립니다.</summary>
        <returns>
          신호를 보내는 작업과 대기가 모두 성공적으로 완료되면 <see langword="true" />를 반환하고, 대기가 완료되지 않으면 아무 값도 반환되지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 작업은 원자성을 보장 되지 않습니다. 현재 스레드 신호 후 `toSignal` 대기 하기 전에 `toWaitOn`, 다른 프로세서에서 실행 되는 스레드 지 알려 `toWaitOn` 대기 또는 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> 메서드 오버 로드를 주 스레드에서 차단 된 스레드 신호를 보내고는 스레드가 작업을 완료할 때까지 대기할 수 있도록 합니다.  
  
 이 예제에서는 5 개의 스레드를 시작, 있는 경우 차단 될 수 있도록는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 플래그 및 다음 스레드를 하나씩 때마다 해제는 사용자가 ENTER 키를 누를 합니다. 다음 예제에서는 다른 5 개의 스레드를 큐 대기를 사용 하 여 모든 해제는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 플래그입니다.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="toWaitOn" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.STAThreadAttribute" />가 있는 스레드에서 메서드가 호출된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 또는 Windows Millennium Edition에서 이 메서드가 지원되지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" />이 세마포이며 이미 최대 카운트에 도달한 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">신호를 보낼 <see cref="T:System.Threading.WaitHandle" />입니다.</param>
        <param name="toWaitOn">대기할 <see cref="T:System.Threading.WaitHandle" />입니다.</param>
        <param name="millisecondsTimeout">대기할 간격을 나타내는 정수입니다. 값이 <see cref="F:System.Threading.Timeout.Infinite" />, 즉 -1이면 무기한 대기합니다.</param>
        <param name="exitContext">
          대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>제한 시간 간격을 부호 있는 32비트 정수로 지정하고 대기 상태로 들어가기 전에 컨텍스트에 대한 동기화 도메인을 종료할지 여부를 지정하여, <see cref="T:System.Threading.WaitHandle" /> 중 하나에게 알리고 다음을 기다립니다.</summary>
        <returns>
          신호를 보내는 작업과 대기가 모두 성공적으로 완료되면 <see langword="true" />를 반환하고, 신호는 성공적으로 보냈으나 대기가 시간 초과되었으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 작업은 원자성을 보장 되지 않습니다. 현재 스레드 신호 후 `toSignal` 대기 하기 전에 `toWaitOn`, 다른 프로세서에서 실행 되는 스레드 지 알려 `toWaitOn` 대기 또는 합니다.  
  
 경우 `millisecondsTimeout` 가 0 인 메서드를 차단 하지 않습니다. 상태를 테스트는 `toWaitOn` 를 즉시 반환 합니다.  
  
## <a name="notes-on-exiting-the-context"></a>컨텍스트 종료에 대 한 메모  
 `exitContext` 매개 변수 효과가 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스에 대 한 호출 안에 스레드에 있으면 이러한 <xref:System.ContextBoundObject>합니다. 파생 되지 않는 클래스에서 메서드를 현재 실행 되는 경우에 <xref:System.ContextBoundObject>처럼 <xref:System.String>, 기본이 아닌 컨텍스트에서 수 하는 경우는 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 코드는 기본 디렉터리가 아닌 다른 컨텍스트에서 실행 되는 경우 지정 하 `true` 에 대 한 `exitContext` 스레드가 기본이 아닌 관리 되는 컨텍스트를 종료 합니다 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출은 자동으로 동기화 및 동기화 도메인은 클래스에 대 한 코드의 본문 전체. 호출 스택에 있는 멤버의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`는 스레드가 계속 하려면는 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드가 동기화 도메인을 종료 합니다. 경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 컨텍스트의 동기화 도메인을 다시 입력 하는 호출한 스레드가 기다려야 메서드가 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="toWaitOn" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.STAThreadAttribute" />가 있는 스레드에서 메서드가 호출된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 또는 Windows Millennium Edition에서 이 메서드가 지원되지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.WaitHandle" />에서 최대 횟수를 초과하여 신호를 받을 수 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">신호를 보낼 <see cref="T:System.Threading.WaitHandle" />입니다.</param>
        <param name="toWaitOn">대기할 <see cref="T:System.Threading.WaitHandle" />입니다.</param>
        <param name="timeout">대기할 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다. 값이 -1이면 무기한 대기합니다.</param>
        <param name="exitContext">
          대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>제한 시간 간격을 <see cref="T:System.TimeSpan" />으로 지정하고 대기 상태로 들어가기 전에 컨텍스트에 대한 동기화 도메인을 종료할지 여부를 지정하여, <see cref="T:System.Threading.WaitHandle" /> 중 하나에게 알리고 다음을 기다립니다.</summary>
        <returns>
          신호를 보내는 작업과 대기가 모두 성공적으로 완료되면 <see langword="true" />를 반환하고, 신호는 성공적으로 보냈으나 대기가 시간 초과되었으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 작업은 원자성을 보장 되지 않습니다. 현재 스레드 신호 후 `toSignal` 대기 하기 전에 `toWaitOn`, 다른 프로세서에서 실행 되는 스레드 지 알려 `toWaitOn` 대기 또는 합니다.  
  
 에 대 한 최대값 `timeout` 은 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
 경우 `timeout` 가 0 인 메서드를 차단 하지 않습니다. 상태를 테스트는 `toWaitOn` 를 즉시 반환 합니다.  
  
## <a name="notes-on-exiting-the-context"></a>컨텍스트 종료에 대 한 메모  
 `exitContext` 매개 변수 효과가 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스에 대 한 호출 안에 스레드에 있으면 이러한 <xref:System.ContextBoundObject>합니다. 파생 되지 않는 클래스에서 메서드를 현재 실행 되는 경우에 <xref:System.ContextBoundObject>처럼 <xref:System.String>, 기본이 아닌 컨텍스트에서 수 하는 경우는 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 코드는 기본 디렉터리가 아닌 다른 컨텍스트에서 실행 되는 경우 지정 하 `true` 에 대 한 `exitContext` 스레드가 기본이 아닌 관리 되는 컨텍스트를 종료 합니다 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출은 자동으로 동기화 및 동기화 도메인은 클래스에 대 한 코드의 본문 전체. 호출 스택에 있는 멤버의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`는 스레드가 계속 하려면는 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드가 동기화 도메인을 종료 합니다. 경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 컨텍스트의 동기화 도메인을 다시 입력 하는 호출한 스레드가 기다려야 메서드가 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="toWaitOn" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.STAThreadAttribute" />가 있는 스레드에서 메서드가 호출된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 또는 Windows Millennium Edition에서 이 메서드가 지원되지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" />이 세마포이며 이미 최대 카운트에 도달한 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" />이 -1이 아닌 밀리초 단위의 음수 시간으로 계산되는 경우  
  
 또는  
  
 <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다. 이 배열에는 같은 개체에 대한 여러 개의 참조가 포함될 수 없습니다.</param>
        <summary>지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</summary>
        <returns>
          <paramref name="waitHandles" />의 모든 요소가 신호를 받으면 <see langword="true" />를 반환하고, 그렇지 않으면 아무 값도 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드 반환 `true` 뮤텍스가 중단 했습니다. 중단 된 뮤텍스는 심각한 코딩 오류를 나타내는 경우가 많습니다. 시스템 수준 뮤텍스의 경우 (예를 들어 Windows 작업 관리자를 사용)에서 응용 프로그램이 갑자기 종료 되었습니다를 나타낼 수 있습니다. 디버깅에 유용한 정보를 포함 하는 예외입니다.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드가 모든 핸들이 신호를 반환 합니다. 64 개 이상의 핸들을 전달 하는 경우 일부 구현에서는 한 <xref:System.NotSupportedException> throw 됩니다. 배열에 중복 항목이와 함께 호출이 실패 한 <xref:System.DuplicateWaitObjectException>합니다.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.  
  
 이 메서드 오버 로드를 호출 하는 것은 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 메서드 오버 로드 하 고-1을 지정 (또는 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>)에 대 한 `millisecondsTimeout` 및 `true` 에 대 한 `exitContext`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기적으로 만들고 파일 그룹에 쓸 스레드 풀을 사용 하는 방법을 보여 줍니다. 각 쓰기 작업이 완료 되었을 때 작업 항목 및 신호 대기 됩니다. 주 스레드는 신호를 보내 모든 항목에 대 한 대기 하 고 종료 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우 또는  
  
 <see langword="null" /> 배열에 있는 하나 이상의 개체가 <paramref name="waitHandles" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 2.0 이상인 경우</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 [Windows 스토어 앱용 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 또는 [이식 가능한 클래스 라이브러리](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)에서 대신 기본 클래스 예외 <see cref="T:System.ArgumentException" />을 catch합니다.  
  
</para>
          </block>
          <paramref name="waitHandles" /> 배열에 중복된 요소가 포함된 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우  
  
 또는  
  
 <see cref="T:System.STAThreadAttribute" /> 특성이 현재 스레드에 대한 스레드 프로시저에 적용되고 <paramref name="waitHandles" />에 둘 이상의 요소가 포함되어 있는 경우</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 1.0 또는 1.1인 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 종료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다. 이 배열에는 같은 개체(중복 개체)에 대한 여러 개의 참조가 포함될 수 없습니다.</param>
        <param name="millisecondsTimeout">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
        <summary>시간 간격을 지정하는 <see cref="T:System.Int32" /> 값을 사용하여 지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</summary>
        <returns>
          <paramref name="waitHandles" />에 있는 모든 요소가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> 대기가 종료, 즉 모든 핸들이 신호를 받거나 시간 초과 하는 경우 메서드를 반환 합니다. 64 개 이상의 핸들을 전달 하는 경우 일부 구현에서는 한 <xref:System.NotSupportedException> throw 됩니다. 배열에 중복 항목이 있는지와 호출 실패는 <xref:System.DuplicateWaitObjectException>합니다.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.  
  
 이이 메서드 오버 로드는 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 오버 로드를 지정 하 고 `false` 에 대 한 `exitContext`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" />가 요소가 없는 배열인 경우</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 [Windows 스토어 앱용 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 또는 [이식 가능한 클래스 라이브러리](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)에서 대신 기본 클래스 예외 <see cref="T:System.ArgumentException" />을 catch합니다.  
  
</para>
          </block>
          <paramref name="waitHandles" /> 배열에 중복된 요소가 포함된 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우  
  
 또는  
  
 <see cref="T:System.STAThreadAttribute" /> 특성이 현재 스레드에 대한 스레드 프로시저에 적용되고 <paramref name="waitHandles" />에 둘 이상의 요소가 포함되어 있는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다. 이 배열에는 같은 개체에 대한 여러 개의 참조가 포함될 수 없습니다.</param>
        <param name="timeout">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>
          <see cref="T:System.TimeSpan" /> 값을 사용하여 시간 간격을 지정함으로써 지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</summary>
        <returns>
          <paramref name="waitHandles" />에 있는 모든 요소가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> 대기가 종료 즉, 모든 핸들이 신호 또는 제한 시간이 초과 하는 경우 메서드를 반환 합니다. 64 개 이상의 핸들을 전달 하는 경우 일부 구현에서는 한 <xref:System.NotSupportedException> throw 됩니다. 배열에 중복 항목이, 호출이 실패 합니다.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.  
  
 에 대 한 최대값 `timeout` 은 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
 이이 메서드 오버 로드는 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> 오버 로드를 지정 하 고 `false` 에 대 한 `exitContext`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" />가 요소가 없는 배열인 경우</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 [Windows 스토어 앱용 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 또는 [이식 가능한 클래스 라이브러리](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)에서 대신 기본 클래스 예외 <see cref="T:System.ArgumentException" />을 catch합니다.  
  
</para>
          </block>
          <paramref name="waitHandles" /> 배열에 중복된 요소가 포함된 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우  
  
 또는  
  
 <see cref="T:System.STAThreadAttribute" /> 특성이 현재 스레드에 대한 스레드 프로시저에 적용되고 <paramref name="waitHandles" />에 둘 이상의 요소가 포함되어 있는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.  
  
 또는  
  
 <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 종료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다. 이 배열에는 같은 개체(중복 개체)에 대한 여러 개의 참조가 포함될 수 없습니다.</param>
        <param name="millisecondsTimeout">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
        <param name="exitContext">
          대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>
          <see cref="T:System.Int32" /> 값을 사용하여 시간 간격을 지정하고 대기 전에 동기화 도메인을 끝낼지 여부를 지정하여 지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</summary>
        <returns>
          <paramref name="waitHandles" />에 있는 모든 요소가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드 반환 `true` 뮤텍스가 중단 했습니다. 중단 된 뮤텍스는 심각한 코딩 오류를 나타내는 경우가 많습니다. 시스템 수준 뮤텍스의 경우 (예를 들어 Windows 작업 관리자를 사용)에서 응용 프로그램이 갑자기 종료 되었습니다를 나타낼 수 있습니다. 디버깅에 유용한 정보를 포함 하는 예외입니다.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> 대기가 종료, 즉 모든 핸들이 신호를 받거나 시간 초과 하는 경우 메서드를 반환 합니다. 64 개 이상의 핸들을 전달 하는 경우 일부 구현에서는 한 <xref:System.NotSupportedException> throw 됩니다. 배열에 중복 항목이 있는지와 호출 실패는 <xref:System.DuplicateWaitObjectException>합니다.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.  
  
## <a name="notes-on-exiting-the-context"></a>컨텍스트 종료에 대 한 메모  
 `exitContext` 매개 변수 효과가 <xref:System.Threading.WaitHandle.WaitAll%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스에 대 한 호출 안에 스레드에 있으면 이러한 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에서 메서드를 현재 실행 되는 경우에 <xref:System.ContextBoundObject>처럼 <xref:System.String>, 기본이 아닌 컨텍스트에서 수 하는 경우는 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 코드는 기본 디렉터리가 아닌 다른 컨텍스트에서 실행 되는 경우 지정 하 `true` 에 대 한 `exitContext` 스레드가 기본이 아닌 관리 되는 컨텍스트를 종료 합니다 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다는 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 특성입니다. 이 경우 클래스의 멤버에 대 한 모든 호출은 자동으로 동기화 및 동기화 도메인은 클래스에 대 한 코드의 본문 전체. 호출 스택에 있는 멤버의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`는 스레드가 계속 하려면는 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드가 동기화 도메인을 종료 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 컨텍스트의 동기화 도메인을 다시 입력 하는 호출한 스레드가 기다려야 메서드가 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기적으로 만들고 파일 그룹에 쓸 스레드 풀을 사용 하는 방법을 보여 줍니다. 각 쓰기 작업이 완료 되었을 때 작업 항목 및 신호 대기 됩니다. 주 스레드는 신호를 보내 모든 항목에 대 한 대기 하 고 종료 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 2.0 이상인 경우</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles" /> 배열에 중복된 요소가 포함된 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우  
  
 또는  
  
 <see cref="T:System.STAThreadAttribute" /> 특성이 현재 스레드에 대한 스레드 프로시저에 적용되고 <paramref name="waitHandles" />에 둘 이상의 요소가 포함되어 있는 경우</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 1.0 또는 1.1인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다. 이 배열에는 같은 개체에 대한 여러 개의 참조가 포함될 수 없습니다.</param>
        <param name="timeout">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="exitContext">
          대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>
          <see cref="T:System.TimeSpan" /> 값을 사용하여 시간 간격을 측정하고 대기 전에 동기화 도메인을 끝낼지 여부를 지정하여 지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</summary>
        <returns>
          <paramref name="waitHandles" />에 있는 모든 요소가 신호를 받으면 <see langword="true" />를 반환하고, 그렇지 않으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드 반환 `true` 뮤텍스가 중단 했습니다. 중단 된 뮤텍스는 심각한 코딩 오류를 나타내는 경우가 많습니다. 시스템 수준 뮤텍스의 경우 (예를 들어 Windows 작업 관리자를 사용)에서 응용 프로그램이 갑자기 종료 되었습니다를 나타낼 수 있습니다. 디버깅에 유용한 정보를 포함 하는 예외입니다.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> 대기가 종료 즉, 모든 핸들이 신호 또는 제한 시간이 초과 하는 경우 메서드를 반환 합니다. 64 개 이상의 핸들을 전달 하는 경우 일부 구현에서는 한 <xref:System.NotSupportedException> throw 됩니다. 배열에 중복 항목이, 호출이 실패 합니다.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.  
  
 에 대 한 최대값 `timeout` 은 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
## <a name="notes-on-exiting-the-context"></a>컨텍스트 종료에 대 한 메모  
 `exitContext` 매개 변수 효과가 <xref:System.Threading.WaitHandle.WaitAll%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스에 대 한 호출 안에 스레드에 있으면 이러한 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에서 메서드를 현재 실행 되는 경우에 <xref:System.ContextBoundObject>처럼 <xref:System.String>, 기본이 아닌 컨텍스트에서 수 하는 경우는 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 코드는 기본 디렉터리가 아닌 다른 컨텍스트에서 실행 되는 경우 지정 하 `true` 에 대 한 `exitContext` 스레드가 기본이 아닌 관리 되는 컨텍스트를 종료 합니다 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드. 호출 후 원래 컨텍스트로 돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출은 자동으로 동기화 및 동기화 도메인은 클래스에 대 한 코드의 본문 전체. 호출 스택에 있는 멤버의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`는 스레드가 계속 하려면는 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드가 동기화 도메인을 종료 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 컨텍스트의 동기화 도메인을 다시 입력 하는 호출한 스레드가 기다려야 메서드가 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기적으로 만들고 파일 그룹에 쓸 스레드 풀을 사용 하는 방법을 보여 줍니다. 각 쓰기 작업이 완료 되었을 때 작업 항목 및 신호 대기 됩니다. 주 스레드는 신호를 보내 모든 항목에 대 한 대기 하 고 종료 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 2.0 이상인 경우</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles" /> 배열에 중복된 요소가 포함된 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우  
  
 또는  
  
 <see cref="T:System.STAThreadAttribute" /> 특성이 현재 스레드에 대한 스레드 프로시저에 적용되고 <paramref name="waitHandles" />에 둘 이상의 요소가 포함되어 있는 경우</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 1.0 또는 1.1인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.  
  
 또는  
  
 <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 종료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</param>
        <summary>지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</summary>
        <returns>대기를 만족한 개체의 배열 인덱스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드 반환 `true` 뮤텍스 중단 되기 때문에 대기가 완료 되는 경우. 중단 된 뮤텍스는 심각한 코딩 오류를 나타내는 경우가 많습니다. 시스템 수준 뮤텍스의 경우 (예를 들어 Windows 작업 관리자를 사용)에서 응용 프로그램이 갑자기 종료 되었습니다를 나타낼 수 있습니다. 디버깅에 유용한 정보를 포함 하는 예외입니다.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단된 된 뮤텍스 때문입니다. 경우 `waitHandles` 출시 된 뮤텍스 중단 된 뮤텍스 보다 낮은 인덱스 값을 포함 된 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.  
  
> [!NOTE]
>  버전의.NET Framework 버전 2.0, 스레드가 종료 되거나 명시적으로 해제 하지 않고 중단 하는 경우 이전에 <xref:System.Threading.Mutex>, 해당 `Mutex` 에 인덱스 0 (영)에 `WaitAny` 배열 인덱스에서 반환 된 다른 스레드에서 `WaitAny` 은 0이 아닌 128입니다.  
  
 이 핸들은 신호를 받을 때 반환 됩니다. 둘 이상의 개체가 호출 하는 동안 신호를 받은, 하는 경우 반환 값은 모든 신호를 받은 개체의 가장 작은 인덱스 값을 가진 신호를 받은 개체의 배열 인덱스입니다. 개 이상의 64 핸들을 전달 하는 경우 일부 구현에서는 한 <xref:System.NotSupportedException> throw 됩니다.  
  
 이 메서드 오버 로드를 호출 하는 것은 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 메서드 오버 로드 하 고-1을 지정 (또는 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>)에 대 한 `millisecondsTimeout` 및 `true` 에 대 한 `exitContext`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출은 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" />가 요소가 없는 배열이고 .NET Framework 버전이 1.0 또는 1.1인 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" />을를은 아무런 요소도 갖고 있지 않은 배열이며 .NET Framework 버전은 2.0 이상입니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</param>
        <param name="millisecondsTimeout">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
        <summary>부호 있는 32비트 정수를 사용하여 시간 간격을 지정함으로써 지정된 배열의 임의 요소가 신호를 받기를 기다립니다.</summary>
        <returns>대기를 만족하는 개체의 배열 인덱스이거나 대기를 만족하는 개체가 없고 <paramref name="millisecondsTimeout" />과 동일한 시간 간격이 전달된 경우 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단된 된 뮤텍스 때문입니다. 경우 `waitHandles` 출시 된 뮤텍스 중단 된 뮤텍스 보다 낮은 인덱스 값을 포함 된 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.  
  
 이 핸들은 신호를 받거나 시간 초과 대기가 종료 되 면 반환 됩니다. 둘 이상의 개체가 호출 하는 동안 신호를 받은, 하는 경우 반환 값은 모든 신호를 받은 개체의 가장 작은 인덱스 값을 가진 신호를 받은 개체의 배열 인덱스입니다. 개 이상의 64 핸들을 전달 하는 경우 일부 구현에서는 한 <xref:System.NotSupportedException> throw 됩니다.  
  
 이이 메서드 오버 로드는 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 오버 로드를 지정 하 고 `false` 에 대 한 `exitContext`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" />가 요소가 없는 배열인 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</param>
        <param name="timeout">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>
          <see cref="T:System.TimeSpan" />을 사용하여 시간 간격을 지정함으로써 지정된 배열의 임의 요소가 신호를 받기를 기다립니다.</summary>
        <returns>대기를 만족하는 개체의 배열 인덱스이거나 대기를 만족하는 개체가 없고 <paramref name="timeout" />과 동일한 시간 간격이 전달된 경우 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단된 된 뮤텍스 때문입니다. 경우 `waitHandles` 출시 된 뮤텍스 중단 된 뮤텍스 보다 낮은 인덱스 값을 포함 된 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.  
  
 이 핸들은 신호를 받거나 시간 초과 대기가 종료 되 면 반환 됩니다. 둘 이상의 개체가 호출 하는 동안 신호를 받은, 하는 경우 반환 값은 모든 신호를 받은 개체의 가장 작은 인덱스 값을 가진 신호를 받은 개체의 배열 인덱스입니다. 개 이상의 64 핸들을 전달 하는 경우 일부 구현에서는 한 <xref:System.NotSupportedException> throw 됩니다.  
  
 에 대 한 최대값 `timeout` 은 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
 이이 메서드 오버 로드는 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> 오버 로드를 지정 하 고 `false` 에 대 한 `exitContext`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.  
  
 또는  
  
 <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" />가 요소가 없는 배열인 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</param>
        <param name="millisecondsTimeout">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
        <param name="exitContext">
          대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>부호 있는 32비트 정수를 사용하여 시간 간격을 지정하고 대기 전에 동기화 도메인을 종료할지를 지정하여 지정된 배열의 요소가 신호를 받기를 기다립니다.</summary>
        <returns>대기를 만족하는 개체의 배열 인덱스이거나 대기를 만족하는 개체가 없고 <paramref name="millisecondsTimeout" />과 동일한 시간 간격이 전달된 경우 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드 반환 `true` 뮤텍스 중단 되기 때문에 대기가 완료 되는 경우. 중단 된 뮤텍스는 심각한 코딩 오류를 나타내는 경우가 많습니다. 시스템 수준 뮤텍스의 경우 (예를 들어 Windows 작업 관리자를 사용)에서 응용 프로그램이 갑자기 종료 되었습니다를 나타낼 수 있습니다. 디버깅에 유용한 정보를 포함 하는 예외입니다.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단된 된 뮤텍스 때문입니다. 경우 `waitHandles` 출시 된 뮤텍스 중단 된 뮤텍스 보다 낮은 인덱스 값을 포함 된 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.  
  
> [!NOTE]
>  버전의.NET Framework 버전 2.0, 스레드가 종료 되거나 명시적으로 해제 하지 않고 중단 하는 경우 이전에 <xref:System.Threading.Mutex>, 해당 `Mutex` 에 인덱스 0 (영)에 `WaitAny` 배열 인덱스에서 반환 된 다른 스레드에서 `WaitAny` 은 0이 아닌 128입니다.  
  
 이 핸들은 신호를 받거나 시간 초과 대기가 종료 되 면 반환 됩니다. 둘 이상의 개체가 호출 하는 동안 신호를 받은, 하는 경우 반환 값은 모든 신호를 받은 개체의 가장 작은 인덱스 값을 가진 신호를 받은 개체의 배열 인덱스입니다. 개 이상의 64 핸들을 전달 하는 경우 일부 구현에서는 한 <xref:System.NotSupportedException> throw 됩니다.  
  
## <a name="notes-on-exiting-the-context"></a>컨텍스트 종료에 대 한 메모  
 `exitContext` 매개 변수 효과가 <xref:System.Threading.WaitHandle.WaitAny%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스에 대 한 호출 안에 스레드에 있으면 이러한 <xref:System.ContextBoundObject>합니다. 파생 되지 않는 클래스에서 메서드를 현재 실행 되는 경우에 <xref:System.ContextBoundObject>처럼 <xref:System.String>, 기본이 아닌 컨텍스트에서 수 하는 경우는 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 코드는 기본 디렉터리가 아닌 다른 컨텍스트에서 실행 되는 경우 지정 하 `true` 에 대 한 `exitContext` 스레드가 기본이 아닌 관리 되는 컨텍스트를 종료 합니다 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출은 자동으로 동기화 및 동기화 도메인은 클래스에 대 한 코드의 본문 전체. 호출 스택에 있는 멤버의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`는 스레드가 계속 하려면는 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드가 동기화 도메인을 종료 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 컨텍스트의 동기화 도메인을 다시 입력 하는 호출한 스레드가 기다려야 메서드가 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동시에 여러 디스크에 파일을 검색 하는 스레드 풀을 사용 하는 방법을 보여 줍니다. 공간 고려 사항에 대 한 각 디스크의 루트 디렉터리에만 검색 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" />가 요소가 없는 배열이고 .NET Framework 버전이 1.0 또는 1.1인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" />을를은 아무런 요소도 갖고 있지 않은 배열이며 .NET Framework 버전은 2.0 이상입니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</param>
        <param name="timeout">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="exitContext">
          대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>
          <see cref="T:System.TimeSpan" /> 값으로 시간 간격을 지정하고 대기 전에 동기화 도메인을 끝낼지 여부를 지정한 다음 지정된 배열의 요소가 신호를 받기를 기다립니다.</summary>
        <returns>대기를 만족하는 개체의 배열 인덱스이거나 대기를 만족하는 개체가 없고 <paramref name="timeout" />과 동일한 시간 간격이 전달된 경우 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드 반환 `true` 뮤텍스 중단 되기 때문에 대기가 완료 되는 경우. 중단 된 뮤텍스는 심각한 코딩 오류를 나타내는 경우가 많습니다. 시스템 수준 뮤텍스의 경우 (예를 들어 Windows 작업 관리자를 사용)에서 응용 프로그램이 갑자기 종료 되었습니다를 나타낼 수 있습니다. 디버깅에 유용한 정보를 포함 하는 예외입니다.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단된 된 뮤텍스 때문입니다. 경우 `waitHandles` 출시 된 뮤텍스 중단 된 뮤텍스 보다 낮은 인덱스 값을 포함 된 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.  
  
> [!NOTE]
>  버전의.NET Framework 버전 2.0, 스레드가 종료 되거나 명시적으로 해제 하지 않고 중단 하는 경우 이전에 <xref:System.Threading.Mutex>, 해당 `Mutex` 에 인덱스 0 (영)에 `WaitAny` 배열 인덱스에서 반환 된 다른 스레드에서 `WaitAny` 은 0이 아닌 128입니다.  
  
 이 핸들은 신호를 받거나 시간 초과 대기가 종료 되 면 반환 됩니다. 둘 이상의 개체가 호출 하는 동안 신호를 받은, 하는 경우 반환 값은 모든 신호를 받은 개체의 가장 작은 인덱스 값을 가진 신호를 받은 개체의 배열 인덱스입니다. 개 이상의 64 핸들을 전달 하는 경우 일부 구현에서는 한 <xref:System.NotSupportedException> throw 됩니다.  
  
 에 대 한 최대값 `timeout` 은 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
## <a name="notes-on-exiting-the-context"></a>컨텍스트 종료에 대 한 메모  
 `exitContext` 매개 변수 효과가 <xref:System.Threading.WaitHandle.WaitAny%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스에 대 한 호출 안에 스레드에 있으면 이러한 <xref:System.ContextBoundObject>합니다. 파생 되지 않는 클래스에서 메서드를 현재 실행 되는 경우에 <xref:System.ContextBoundObject>처럼 <xref:System.String>, 기본이 아닌 컨텍스트에서 수 하는 경우는 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 코드는 기본 디렉터리가 아닌 다른 컨텍스트에서 실행 되는 경우 지정 하 `true` 에 대 한 `exitContext` 스레드가 기본이 아닌 관리 되는 컨텍스트를 종료 합니다 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출은 자동으로 동기화 및 동기화 도메인은 클래스에 대 한 코드의 본문 전체. 호출 스택에 있는 멤버의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`는 스레드가 계속 하려면는 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드가 동기화 도메인을 종료 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 컨텍스트의 동기화 도메인을 다시 입력 하는 호출한 스레드가 기다려야 메서드가 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동시에 여러 디스크에 파일을 검색 하는 스레드 풀을 사용 하는 방법을 보여 줍니다. 공간 고려 사항에 대 한 각 디스크의 루트 디렉터리에만 검색 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" />가 요소가 없는 배열이고 .NET Framework 버전이 1.0 또는 1.1인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.  
  
 또는  
  
 <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" />을를은 아무런 요소도 갖고 있지 않은 배열이며 .NET Framework 버전은 2.0 이상입니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Threading.WaitHandle" />이(가) 신호를 받을 때까지 현재 스레드를 차단합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Threading.WaitHandle" />이(가) 신호를 받을 때까지 현재 스레드를 차단합니다.</summary>
        <returns>
          현재 인스턴스가 신호를 받으면 <see langword="true" />를 반환합니다. 현재 인스턴스가 신호를 받지 않으면 <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />은(는) 아무 값도 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드 반환 `true` 뮤텍스가 중단 했습니다. 중단 된 뮤텍스는 심각한 코딩 오류를 나타내는 경우가 많습니다. 시스템 수준 뮤텍스의 경우 (예를 들어 Windows 작업 관리자를 사용)에서 응용 프로그램이 갑자기 종료 되었습니다를 나타낼 수 있습니다. 디버깅에 유용한 정보를 포함 하는 예외입니다.  
  
 현재 인스턴스가 신호를 받을 때까지 무제한으로이 메서드 블록의 호출자입니다. 될 때까지 차단 하려면이 메서드를 사용 하 여 한 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다. 자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.  
  
 이 메서드 오버 로드를 호출 하는 것은 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 메서드 오버 로드 하 고-1을 지정 또는 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 첫 번째 매개 변수에 대 한 및 `false` 두 번째 매개 변수에 대 한 합니다.  
  
 파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 유지할 프로세스는 백그라운드 스레드가 실행을 완료할 때까지 대기 하는 동안 대기 핸들을 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">현재 인스턴스가 이미 삭제된 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">현재 인스턴스가 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
        <summary>부호 있는 32비트 정수로 시간 간격(밀리초)을 지정하여 현재 <see cref="T:System.Threading.WaitHandle" />이 신호를 받을 때까지 현재 스레드를 차단합니다.</summary>
        <returns>
          현재 인스턴스가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다. 될 때까지 차단 하려면이 메서드를 사용 하 여 한 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다. 자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.  
  
 파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.  
  
 이이 메서드 오버 로드는 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 오버 로드를 지정 하 고 `false` 에 대 한 `exitContext`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 유지할 프로세스는 백그라운드 스레드가 실행을 완료할 때까지 대기 하는 동안 대기 핸들을 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">현재 인스턴스가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">현재 인스턴스가 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>
          <see cref="T:System.TimeSpan" />로 시간 간격을 지정하여 현재 인스턴스가 신호를 받을 때까지 현재 스레드를 차단합니다.</summary>
        <returns>
          현재 인스턴스가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다. 될 때까지 차단 하려면이 메서드를 사용 하 여 한 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다. 자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.  
  
 파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.  
  
 에 대 한 최대값 `timeout` 은 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
 이이 메서드 오버 로드는 <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> 오버 로드를 지정 하 고 `false` 에 대 한 `exitContext`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">현재 인스턴스가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.  
  
 또는  
  
 <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">현재 인스턴스가 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</param>
        <param name="exitContext">
          대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>부호 있는 32비트 정수로 시간 간격을 지정하고 대기 전에 동기화 도메인을 끝낼지 여부를 지정하여 현재 <see cref="T:System.Threading.WaitHandle" />이 신호를 받을 때까지 현재 스레드를 차단합니다.</summary>
        <returns>
          현재 인스턴스가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드 반환 `true` 뮤텍스가 중단 했습니다. 중단 된 뮤텍스는 심각한 코딩 오류를 나타내는 경우가 많습니다. 시스템 수준 뮤텍스의 경우 (예를 들어 Windows 작업 관리자를 사용)에서 응용 프로그램이 갑자기 종료 되었습니다를 나타낼 수 있습니다. 디버깅에 유용한 정보를 포함 하는 예외입니다.  
  
 현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다. 될 때까지 차단 하려면이 메서드를 사용 하 여 한 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다. 자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.  
  
 파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.  
  
## <a name="notes-on-exiting-the-context"></a>컨텍스트 종료에 대 한 메모  
 `exitContext` 매개 변수 효과가 <xref:System.Threading.WaitHandle.WaitOne%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스에 대 한 호출 안에 스레드에 있으면 이러한 <xref:System.ContextBoundObject>합니다. 파생 되지 않는 클래스에서 메서드를 현재 실행 되는 경우에 <xref:System.ContextBoundObject>처럼 <xref:System.String>, 기본이 아닌 컨텍스트에서 수 하는 경우는 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 코드는 기본 디렉터리가 아닌 다른 컨텍스트에서 실행 되는 경우 지정 하 `true` 에 대 한 `exitContext` 스레드가 기본이 아닌 관리 되는 컨텍스트를 종료 합니다 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출은 자동으로 동기화 및 동기화 도메인은 클래스에 대 한 코드의 본문 전체. 호출 스택에 있는 멤버의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`는 스레드가 계속 하려면는 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드가 동기화 도메인을 종료 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 컨텍스트의 동기화 도메인을 다시 입력 하는 호출한 스레드가 기다려야 메서드가 반환 합니다.  
  
   
  
## Examples  
 다음 예제와 방법을 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 동기화 도메인 내에서 호출 될 때 동작 하는 메서드 오버 로드 합니다. 스레드 대기 먼저 `exitContext` 로 설정 `false` 및 대기 시간 제한이 만료 될 때까지 차단 합니다. 두 번째 스레드가 실행 하는 첫 번째 스레드가 종료 된 상태에서 대기 후 `exitContext` 로 설정 `true`합니다. 이 두 번째 스레드에 대 한 대기 핸들이 신호를 보내 호출이 차단 되지 않으며, 및 스레드는 대기 시간이 초과 하기 전에 완료 합니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">현재 인스턴스가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">현재 인스턴스가 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="exitContext">
          대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>
          <see cref="T:System.TimeSpan" />로 시간 간격을 지정하고 대기 전에 동기화 도메인을 끝낼지 여부를 지정하여 현재 인스턴스가 신호를 받을 때까지 현재 스레드를 차단합니다.</summary>
        <returns>
          현재 인스턴스가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 인 메서드를 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드 반환 `true` 뮤텍스가 중단 했습니다. 중단 된 뮤텍스는 심각한 코딩 오류를 나타내는 경우가 많습니다. 시스템 수준 뮤텍스의 경우 (예를 들어 Windows 작업 관리자를 사용)에서 응용 프로그램이 갑자기 종료 되었습니다를 나타낼 수 있습니다. 디버깅에 유용한 정보를 포함 하는 예외입니다.  
  
 현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다. 될 때까지 차단 하려면이 메서드를 사용 하 여 한 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다. 자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.  
  
 파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.  
  
 에 대 한 최대값 `timeout` 은 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
## <a name="notes-on-exiting-the-context"></a>컨텍스트 종료에 대 한 메모  
 `exitContext` 매개 변수 효과가 <xref:System.Threading.WaitHandle.WaitOne%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스에 대 한 호출 안에 스레드에 있으면 이러한 <xref:System.ContextBoundObject>합니다. 파생 되지 않는 클래스에서 메서드를 현재 실행 되는 경우에 <xref:System.ContextBoundObject>처럼 <xref:System.String>, 기본이 아닌 컨텍스트에서 수 하는 경우는 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 코드는 기본 디렉터리가 아닌 다른 컨텍스트에서 실행 되는 경우 지정 하 `true` 에 대 한 `exitContext` 스레드가 기본이 아닌 관리 되는 컨텍스트를 종료 합니다 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출은 자동으로 동기화 및 동기화 도메인은 클래스에 대 한 코드의 본문 전체. 호출 스택에 있는 멤버의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`는 스레드가 계속 하려면는 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드가 동기화 도메인을 종료 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 컨텍스트의 동기화 도메인을 다시 입력 하는 호출한 스레드가 기다려야 메서드가 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 유지할 프로세스는 백그라운드 스레드가 실행을 완료할 때까지 대기 하는 동안 대기 핸들을 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">현재 인스턴스가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.  
  
 또는  
  
 <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다. 이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">현재 인스턴스가 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>대기 핸들이 신호를 받기 전에 <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 작업이 제한 시간을 초과했음을 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필드의 가능한 반환 값 중 하나는 `WaitAny`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동시에 여러 디스크에 파일을 검색 하는 스레드 풀을 사용 하는 방법을 보여 줍니다. 공간 고려 사항에 대 한 각 디스크의 루트 디렉터리에만 검색 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>