<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7e662ed5dda251c583c6d82a839ce57c9d160f65" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49131110" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="3d883-101">공유 리소스에 대한 단독 액세스를 기다리는 운영 체제 관련 개체를 캡슐화합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3d883-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-102"><xref:System.Threading.WaitHandle> 클래스 네이티브 운영 체제 동기화 핸들을 캡슐화 하 고 런타임에서 여러 개의 대기 작업을 허용 하는 모든 동기화 개체를 나타내는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="3d883-103">다른 동기화 개체를 사용 하 여 대기 핸들의 비교를 참조 하세요 [동기화 기본 형식 개요](~/docs/standard/threading/overview-of-synchronization-primitives.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="3d883-104"><xref:System.Threading.WaitHandle> 클래스 자체는 추상 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="3d883-105">파생 된 클래스 <xref:System.Threading.WaitHandle> 신호 메커니즘을 수행 하거나 공유 리소스에 대 한 액세스를 해제 의미를 정의 하지만 상속 된 사용 <xref:System.Threading.WaitHandle> 공유 리소스에 대 한 액세스를 기다리는 동안 차단 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="3d883-106">파생 된 클래스가 <xref:System.Threading.WaitHandle> 포함:</span><span class="sxs-lookup"><span data-stu-id="3d883-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="3d883-107"><xref:System.Threading.Mutex> 클래스</span><span class="sxs-lookup"><span data-stu-id="3d883-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="3d883-108">참조 [뮤텍스](~/docs/standard/threading/mutexes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="3d883-109">합니다 <xref:System.Threading.EventWaitHandle> 클래스와 파생된 클래스인 <xref:System.Threading.AutoResetEvent> 및 <xref:System.Threading.ManualResetEvent>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="3d883-110">[EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3d883-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="3d883-111"><xref:System.Threading.Semaphore> 클래스</span><span class="sxs-lookup"><span data-stu-id="3d883-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="3d883-112">참조 [세마포 및 SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="3d883-113">인스턴스 메서드를 호출 하 여 개별 대기 핸들에서 스레드가 차단할 수 있습니다 <xref:System.Threading.WaitHandle.WaitOne%2A>에서 파생 된 클래스에 상속 되는 <xref:System.Threading.WaitHandle>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="3d883-114">파생된 클래스 <xref:System.Threading.WaitHandle> 스레드 선호도 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="3d883-115">이벤트 대기 핸들 (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, 및 <xref:System.Threading.ManualResetEvent>) 세마포에 스레드 선호도 없습니다 하 고 모든 스레드를 이벤트 대기 핸들 또는 세마포 신호를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="3d883-116">뮤텍스, 반면에 권한이 스레드 선호도 있습니다. 뮤텍스를 소유 하는 스레드를 해제 해야 하 고 스레드 호출 하는 경우 예외가 throw 되는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 소유 하지 않는 뮤텍스를 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="3d883-117">때문에 합니다 <xref:System.Threading.WaitHandle> 클래스에서 파생 되며 <xref:System.MarshalByRefObject>, 이러한 클래스를 사용 하 여 응용 프로그램 도메인 경계를 넘어 스레드의 활동을 동기화 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="3d883-118">파생된 클래스 외에도 <xref:System.Threading.WaitHandle> 클래스 개수가 하나 될 때까지 스레드를 차단 하는 정적 메서드 또는 동기화 개체가 신호를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="3d883-119">여기에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-119">These include:</span></span>  
  
-   <span data-ttu-id="3d883-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>에 하나의 대기 핸들이 신호를 보내고 다른 곧바로 대기 하기 위한 스레드 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="3d883-121"><xref:System.Threading.WaitHandle.WaitAll%2A>을 허용 하는 스레드가 모든 대기 핸들 배열에 신호를 받을 때까지 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="3d883-122"><xref:System.Threading.WaitHandle.WaitAny%2A>을 허용 하는 스레드가 대기 핸들의 지정된 된 집합 중 하나에서 신호 될 때까지 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="3d883-123">이러한 메서드의 오버 로드는 대기 및 동기화 컨텍스트를 사용 하 여 다른 스레드를 허용 하는 대기를 시작 하기 전에 동기화 컨텍스트를 종료 하는 기회를 중단 하는 것에 대 한 제한 시간 간격을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3d883-124">이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="3d883-125">형식 또는 여기에서 파생 된 형식을 사용 하 여 마쳤으면 직접 또는 간접적으로으로 삭제 해야 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="3d883-126">직접 형식의 dispose 호출 해당 <xref:System.Threading.WaitHandle.Close%2A> 의 메서드를 `try` / `catch` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="3d883-127">삭제 하지 직접, 언어 구문 같은 사용 `using` (C#에서) 또는 `Using` (Visual Basic에서는).</span><span class="sxs-lookup"><span data-stu-id="3d883-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="3d883-128">자세한 내용은 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하세요.를 <xref:System.IDisposable> 인터페이스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="3d883-129"><xref:System.Threading.WaitHandle> 구현 된 <xref:System.IDisposable.Dispose%2A> 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="3d883-130">참조 [삭제 패턴](~/docs/standard/design-guidelines/dispose-pattern.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="3d883-131">파생 하는 경우 <xref:System.Threading.WaitHandle>를 사용 하 여는 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 에 네이티브 운영 체제 핸들을 저장 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="3d883-132">보호 된 재정의할 필요가 없습니다 <xref:System.Threading.WaitHandle.Dispose%2A> 메서드 사용 하지 않는 경우 관리 되지 않는 리소스를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-133">다음 코드 예제에서는 두 개의 스레드 수는 어떻게 수행 주 하는 동안 백그라운드 작업 스레드 작업이 정적을 사용 하 여 완료 되기를 기다립니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 하 고 <xref:System.Threading.WaitHandle.WaitAll%2A> 의 메서드는 <xref:System.Threading.WaitHandle> 클래스.</span><span class="sxs-lookup"><span data-stu-id="3d883-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="3d883-134">이 형식은 스레드로부터 안전합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3d883-134">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="3d883-135">스레딩</span>
      <span class="sxs-lookup">
        <span data-stu-id="3d883-135">Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">
      <span data-ttu-id="3d883-136">스레딩 개체 및 기능</span>
      <span class="sxs-lookup">
        <span data-stu-id="3d883-136">Threading Objects and Features</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">
      <span data-ttu-id="3d883-137">뮤텍스</span>
      <span class="sxs-lookup">
        <span data-stu-id="3d883-137">Mutexes</span>
      </span>
    </related>
    <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
      <span data-ttu-id="3d883-138">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</span>
      <span class="sxs-lookup">
        <span data-stu-id="3d883-138">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
      <span data-ttu-id="3d883-139">세마포</span>
      <span class="sxs-lookup">
        <span data-stu-id="3d883-139">Semaphores</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3d883-140">
            <see cref="T:System.Threading.WaitHandle" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-140">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3d883-141">현재 <see cref="T:System.Threading.WaitHandle" /> 에서 보유한 모든 리소스를 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-141">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-142">이 메서드는 공용 구현의 합니다 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 에 대 한 메서드는 <xref:System.Threading.WaitHandle> 클래스와 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-142">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="3d883-143">호출 하는 표준 구현을 제공 합니다 `Dispose(Boolean)` 오버 로드를 `true` 인수 및 호출을 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-143">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3d883-144">인스턴스에서 보유 한 모든 리소스를 해제 하려면이 메서드를 호출 `WaitHandle` 또는 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-144">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="3d883-145">이 메서드가 호출 되 면 현재 인스턴스에 대 한 참조가 정의 되지 않은 동작이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-145">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d883-146">항상 호출 <xref:System.Threading.WaitHandle.Close%2A> 나 <xref:System.Threading.WaitHandle.Dispose> 에 대 한 마지막 참조를 해제 하기 전에 <xref:System.Threading.WaitHandle>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-146">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="3d883-147">그렇지 않은 경우 사용 중인 리소스가 해제 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-147">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="3d883-148">재정의 해야 하는 <see langword="Dispose(Boolean)" /> 파생 된 클래스에 할당 된 리소스를 해제 하는 방법입니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3d883-148">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">
          <span data-ttu-id="3d883-149">Dispose 메서드 구현</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-149">Implementing a Dispose Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3d883-150">
            <see cref="T:System.Threading.WaitHandle" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3d883-151">
            <see cref="T:System.Threading.WaitHandle" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-151">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-152">이 메서드는 해당 하는 <xref:System.Threading.WaitHandle.Close%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-152">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d883-153">항상 호출 <xref:System.Threading.WaitHandle.Close%2A> 나 <xref:System.Threading.WaitHandle.Dispose> 에 대 한 마지막 참조를 해제 하기 전에 <xref:System.Threading.WaitHandle>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-153">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="3d883-154">그렇지 않은 경우 사용 중인 리소스가 해제 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-154">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">
          <span data-ttu-id="3d883-155">관리되지 않는 리소스 정리</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-155">Cleaning Up Unmanaged Resources</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="3d883-156">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-156">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-157">파생 클래스에서 재정의된 경우 <see cref="T:System.Threading.WaitHandle" />에서 사용하는 관리되지 않는 리소스를 해제하고 필요에 따라 관리되는 리소스를 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-157">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-158">이 메서드는 합니다 <xref:System.Threading.WaitHandle.Close%2A> 및 <xref:System.Threading.WaitHandle.Dispose> 메서드를 `explicitDisposing` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-158">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="3d883-159">경우는 `explicitDisposing` 매개 변수가 `true`,이 메서드는 관리 되는 개체가 보유 한 모든 리소스를 해제이 <xref:System.Threading.WaitHandle> 개체 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-159">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="3d883-160">재정의 해야 하는 <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> 파생 된 클래스에 할당 된 리소스를 해제 하는 방법입니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3d883-160">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
            <span data-ttu-id="3d883-161">합니다 <see cref="M:System.Threading.WaitHandle.Close" /> 또는 <see cref="M:System.Threading.WaitHandle.Dispose" /> 메서드 다른 개체에서 여러 번 호출할 수 있습니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3d883-161">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="3d883-162">이 메서드를 재정의 하는 경우에 대 한 이전 호출에서 이전에 삭제 된 개체를 참조 하지 않도록 주의 <see langword="Dispose" /> 또는 <see langword="Close" />합니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3d883-162">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">
          <span data-ttu-id="3d883-163">Dispose 메서드 구현</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-163">Implementing a Dispose Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3d883-164">네이티브 운영 체제 핸들을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-164">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3d883-165">네이티브 운영 체제 핸들을 나타내는 <see langword="IntPtr" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-165">An <see langword="IntPtr" /> representing the native operating system handle.</span>
          </span>
          <span data-ttu-id="3d883-166">기본값은 <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> 필드의 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-166">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-167">새 값을 할당 합니다 <xref:System.Threading.WaitHandle.Handle%2A> 속성 이전 핸들을 닫지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-167">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="3d883-168">이 핸들 누수가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-168">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="3d883-169">.NET Framework 버전 2.0 이상이;에이 속성을 사용 하지 마십시오 사용 된 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-169">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="3d883-170">이 속성을 유효한 핸들도 설정 합니다 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성이 아니라 설정 <xref:System.Threading.WaitHandle.InvalidHandle> 핸들 누수가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-170">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="3d883-171">속성 값을 설정 하려면 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-171">Requires full trust for the immediate caller to set the property value.</span>
          </span>
          <span data-ttu-id="3d883-172">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-172">This member cannot be set by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="3d883-173">파생된 형식에 있어야 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 속성 값을 설정 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-173">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3d883-174">유효하지 않은 네이티브 운영 체제 핸들을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-174">Represents an invalid native operating system handle.</span>
          </span>
          <span data-ttu-id="3d883-175">이 필드는 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-175">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-176">초기화를 내부적으로 사용 된 <xref:System.Threading.WaitHandle.Handle%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-176">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="3d883-177">확인 하려면이 값을 사용할 수 있는지 여부를 <see cref="P:System.Threading.WaitHandle.Handle" /> 속성에 유효한 기본 운영 체제 핸들을 포함 합니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3d883-177">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3d883-178">네이티브 운영 체제 핸들을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-178">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3d883-179">네이티브 운영 체제 핸들을 나타내는 <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-179">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-180">새 값을 할당 하는 경우는 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성을 이전 핸들이 닫힐 때 이전 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 개체가 수집 되 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-180">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="3d883-181">수동으로 닫지 핸들,이 인해 때문에 <xref:System.ObjectDisposedException> 경우는 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 핸들을 종료 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-181">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="3d883-182"><xref:System.Threading.WaitHandle> 구현 된 <xref:System.IDisposable.Dispose%2A> 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-182"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="3d883-183">참조 [삭제 패턴](~/docs/standard/design-guidelines/dispose-pattern.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-183">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="3d883-184">파생 하는 경우 <xref:System.Threading.WaitHandle>를 사용 하 여는 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성에 대 한 기본 핸들 운영 체제 핸들을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-184">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="3d883-185">보호 된 재정의할 필요가 없습니다 <xref:System.Threading.WaitHandle.Dispose%2A> 메서드 사용 하지 않는 경우 관리 되지 않는 리소스를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-185">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="3d883-186">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-186">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="3d883-187">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-187">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="3d883-188">파생된 형식에 있어야 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 이 멤버를 호출 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-188">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3d883-189">
            <see cref="T:System.Threading.WaitHandle" />에 신호하고 다른 신호를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-189">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="3d883-190">신호를 보낼 <see cref="T:System.Threading.WaitHandle" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-190">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="3d883-191">대기할 <see cref="T:System.Threading.WaitHandle" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-191">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-192">
            <see cref="T:System.Threading.WaitHandle" />에 신호하고 다른 신호를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-192">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-193">신호를 보내는 작업과 대기가 모두 성공적으로 완료되면 <see langword="true" />를 반환하고, 대기가 완료되지 않으면 아무 값도 반환되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-193">
              <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-194">이 작업은 원자성을 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-194">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="3d883-195">현재 스레드가 신호 후 `toSignal` 대기 하기 전에 `toWaitOn`, 다른 프로세서에서 실행 되는 스레드 수 신호 `toWaitOn` 대기 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-195">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-196">다음 코드 예제에서는 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> 메서드 오버 로드는 주 스레드가 차단 된 스레드가 신호를 보내고 스레드가 작업을 완료할 때까지 대기할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-196">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="3d883-197">이 예제에서는 5 개의 스레드를 시작에서 차단 될 수는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 플래그 및 사용자가 ENTER 키를 누를 릴리스 스레드를 하나씩 시간 후 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-197">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="3d883-198">다음 예제에서는 다른 5 개의 스레드가 큐를 사용 하 여 모든 릴리스 하는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-198">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-199">
            <paramref name="toSignal" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-199">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-200">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-200">-or-</span>
          </span>
          <span data-ttu-id="3d883-201">
            <paramref name="toWaitOn" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-201">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-202">
            <see cref="T:System.STAThreadAttribute" />가 있는 스레드에서 메서드가 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-202">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="3d883-203">Windows 98 또는 Windows Millennium Edition에서 이 메서드가 지원되지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-203">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-204">
            <paramref name="toSignal" />이 세마포이며 이미 최대 카운트에 도달한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-204">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-205">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-205">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-206">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-206">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="3d883-207">신호를 보낼 <see cref="T:System.Threading.WaitHandle" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-207">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="3d883-208">대기할 <see cref="T:System.Threading.WaitHandle" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-208">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="3d883-209">대기할 간격을 나타내는 정수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-209">An integer that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="3d883-210">값이 <see cref="F:System.Threading.Timeout.Infinite" />, 즉 -1이면 무기한 대기합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-210">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="3d883-211">대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-211">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-212">제한 시간 간격을 부호 있는 32비트 정수로 지정하고 대기 상태로 들어가기 전에 컨텍스트에 대한 동기화 도메인을 종료할지 여부를 지정하여, <see cref="T:System.Threading.WaitHandle" /> 중 하나에게 알리고 다음을 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-212">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-213">신호를 보내는 작업과 대기가 모두 성공적으로 완료되면 <see langword="true" />를 반환하고, 신호는 성공적으로 보냈으나 대기가 시간 초과되었으면 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-213">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-214">이 작업은 원자성을 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-214">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="3d883-215">현재 스레드가 신호 후 `toSignal` 대기 하기 전에 `toWaitOn`, 다른 프로세서에서 실행 되는 스레드 수 신호 `toWaitOn` 대기 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-215">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="3d883-216">경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-216">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-217">상태를 테스트 합니다 `toWaitOn` 를 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-217">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="3d883-218">종료 컨텍스트에 대 한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="3d883-218">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="3d883-219">합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-219">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="3d883-220">파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-220">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="3d883-221">파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-221">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="3d883-222">사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-222">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="3d883-223">스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-223">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="3d883-224">컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-224">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="3d883-225">이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-225">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="3d883-226">멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-226">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="3d883-227">경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-227">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-228">
            <paramref name="toSignal" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-228">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-229">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-229">-or-</span>
          </span>
          <span data-ttu-id="3d883-230">
            <paramref name="toWaitOn" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-230">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-231">
            <see cref="T:System.STAThreadAttribute" />가 있는 스레드에서 메서드가 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-231">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="3d883-232">Windows 98 또는 Windows Millennium Edition에서 이 메서드가 지원되지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-232">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-233">
            <see cref="T:System.Threading.WaitHandle" />에서 최대 횟수를 초과하여 신호를 받을 수 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-233">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-234">
            <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-234">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-235">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-235">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-236">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-236">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="3d883-237">신호를 보낼 <see cref="T:System.Threading.WaitHandle" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-237">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="3d883-238">대기할 <see cref="T:System.Threading.WaitHandle" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-238">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="3d883-239">대기할 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-239">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="3d883-240">값이 -1이면 무기한 대기합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-240">If the value is -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="3d883-241">대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-241">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-242">제한 시간 간격을 <see cref="T:System.TimeSpan" />으로 지정하고 대기 상태로 들어가기 전에 컨텍스트에 대한 동기화 도메인을 종료할지 여부를 지정하여, <see cref="T:System.Threading.WaitHandle" /> 중 하나에게 알리고 다음을 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-242">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-243">신호를 보내는 작업과 대기가 모두 성공적으로 완료되면 <see langword="true" />를 반환하고, 신호는 성공적으로 보냈으나 대기가 시간 초과되었으면 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-243">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-244">이 작업은 원자성을 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-244">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="3d883-245">현재 스레드가 신호 후 `toSignal` 대기 하기 전에 `toWaitOn`, 다른 프로세서에서 실행 되는 스레드 수 신호 `toWaitOn` 대기 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-245">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="3d883-246">에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-246">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3d883-247">경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-247">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-248">상태를 테스트 합니다 `toWaitOn` 를 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-248">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="3d883-249">종료 컨텍스트에 대 한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="3d883-249">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="3d883-250">합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-250">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="3d883-251">파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-251">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="3d883-252">파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-252">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="3d883-253">사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-253">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="3d883-254">스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-254">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="3d883-255">컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-255">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="3d883-256">이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-256">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="3d883-257">멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-257">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="3d883-258">경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-258">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-259">
            <paramref name="toSignal" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-259">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-260">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-260">-or-</span>
          </span>
          <span data-ttu-id="3d883-261">
            <paramref name="toWaitOn" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-261">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-262">
            <see cref="T:System.STAThreadAttribute" />가 있는 스레드에서 메서드가 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-262">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="3d883-263">Windows 98 또는 Windows Millennium Edition에서 이 메서드가 지원되지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-263">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-264">
            <paramref name="toSignal" />이 세마포이며 이미 최대 카운트에 도달한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-264">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-265">
            <paramref name="timeout" />이 -1이 아닌 밀리초 단위의 음수 시간으로 계산되는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-265">
              <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span>
          </span>
          <span data-ttu-id="3d883-266">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-266">-or-</span>
          </span>
          <span data-ttu-id="3d883-267">
            <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-267">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-268">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-268">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-269">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-269">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3d883-270">지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-270">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="3d883-271">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-271">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="3d883-272">이 배열에는 같은 개체에 대한 여러 개의 참조가 포함될 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-272">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-273">지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-273">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-274">
            <paramref name="waitHandles" />의 모든 요소가 신호를 받으면 <see langword="true" />를 반환하고, 그렇지 않으면 아무 값도 반환하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-274">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-275"><xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-275"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="3d883-276">이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="3d883-276">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="3d883-277">중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-277">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="3d883-278">시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-278">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="3d883-279">예외를 디버깅 하는 데 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-279">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="3d883-280"><xref:System.Threading.WaitHandle.WaitAll%2A> 메서드 핸들을 모두 신호를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-280">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="3d883-281">일부 구현에서는 64 개 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-281">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="3d883-282">사용 하 여 호출이 실패 하면 중복을 포함 하는 경우는 <xref:System.DuplicateWaitObjectException>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-282">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d883-283">합니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-283">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="3d883-284">이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 메서드 오버 로드 하 고-1을 지정 (또는 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>)에 대 한 `millisecondsTimeout` 하 고 `true` 에 대 한 `exitContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-284">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-285">다음 코드 예제에서는 비동기적으로 만들고 그룹 파일에 쓰는 데 스레드 풀을 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-285">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="3d883-286">각 쓰기 작업이 완료 되 면 작업 항목 및 신호 대기 중입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-286">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="3d883-287">주 스레드가 신호를 보낼 모든 항목에 대 한 대기 및 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-287">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-288">
            <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-288">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-289">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-289">-or-</span>
          </span>
          <span data-ttu-id="3d883-290">
            <see langword="null" /> 배열에 있는 하나 이상의 개체가 <paramref name="waitHandles" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-290">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-291">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-291">-or-</span>
          </span>
          <span data-ttu-id="3d883-292">
            <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 2.0 이상인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-292">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="3d883-293">
                <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.ArgumentException" />을 catch합니다.</span>
              <span class="sxs-lookup">
                <span data-stu-id="3d883-293">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="3d883-294">
            <paramref name="waitHandles" /> 배열에 중복된 요소가 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-294">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-295">
            <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-295">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="3d883-296">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-296">-or-</span>
          </span>
          <span data-ttu-id="3d883-297">
            <see cref="T:System.STAThreadAttribute" /> 특성이 현재 스레드에 대한 스레드 프로시저에 적용되고 <paramref name="waitHandles" />에 둘 이상의 요소가 포함되어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-297">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3d883-298">
            <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 1.0 또는 1.1인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-298">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-299">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-299">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-300">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-300">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-301">
            <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-301">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="3d883-302">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-302">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="3d883-303">이 배열에는 같은 개체(중복 개체)에 대한 여러 개의 참조가 포함될 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-303">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="3d883-304">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-304">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-305">시간 간격을 지정하는 <see cref="T:System.Int32" /> 값을 사용하여 지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-305">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-306">
            <paramref name="waitHandles" />에 있는 모든 요소가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-306">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-307">경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-307">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-308">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-308">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-309"><xref:System.Threading.WaitHandle.WaitAll%2A> 대기 종료 되 면, 즉 모든 핸들은 신호를 받거나 시간 초과 시 메서드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-309">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="3d883-310">일부 구현에서는 64 개 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-310">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="3d883-311">배열에 중복 항목이 있는지 호출이 실패 하는 <xref:System.DuplicateWaitObjectException>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-311">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d883-312">합니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-312">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="3d883-313">이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-313">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-314">
            <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-314">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-315">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-315">-or-</span>
          </span>
          <span data-ttu-id="3d883-316">
            <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-316">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-317">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-317">-or-</span>
          </span>
          <span data-ttu-id="3d883-318">
            <paramref name="waitHandles" />가 요소가 없는 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-318">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="3d883-319">
                <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.ArgumentException" />을 catch합니다.</span>
              <span class="sxs-lookup">
                <span data-stu-id="3d883-319">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="3d883-320">
            <paramref name="waitHandles" /> 배열에 중복된 요소가 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-320">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-321">
            <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-321">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="3d883-322">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-322">-or-</span>
          </span>
          <span data-ttu-id="3d883-323">
            <see cref="T:System.STAThreadAttribute" /> 특성이 현재 스레드에 대한 스레드 프로시저에 적용되고 <paramref name="waitHandles" />에 둘 이상의 요소가 포함되어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-323">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-324">
            <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-324">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-325">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-325">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-326">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-326">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-327">
            <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-327">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="3d883-328">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-328">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="3d883-329">이 배열에는 같은 개체에 대한 여러 개의 참조가 포함될 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-329">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="3d883-330">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-330">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-331">
            <see cref="T:System.TimeSpan" /> 값을 사용하여 시간 간격을 지정함으로써 지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-331">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-332">
            <paramref name="waitHandles" />에 있는 모든 요소가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-332">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-333">경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-333">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-334">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-334">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-335"><xref:System.Threading.WaitHandle.WaitAll%2A> 메서드 즉, 모든 핸들이 신호를 대기 종료 되거나 제한 시간이 때 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-335">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="3d883-336">일부 구현에서는 64 개 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-336">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="3d883-337">중복 항목을 포함 하는 경우 호출이 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-337">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d883-338">합니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-338">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="3d883-339">에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-339">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3d883-340">이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-340">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-341">
            <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-341">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-342">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-342">-or-</span>
          </span>
          <span data-ttu-id="3d883-343">
            <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-343">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-344">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-344">-or-</span>
          </span>
          <span data-ttu-id="3d883-345">
            <paramref name="waitHandles" />가 요소가 없는 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-345">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="3d883-346">
                <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.ArgumentException" />을 catch합니다.</span>
              <span class="sxs-lookup">
                <span data-stu-id="3d883-346">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="3d883-347">
            <paramref name="waitHandles" /> 배열에 중복된 요소가 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-347">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-348">
            <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-348">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="3d883-349">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-349">-or-</span>
          </span>
          <span data-ttu-id="3d883-350">
            <see cref="T:System.STAThreadAttribute" /> 특성이 현재 스레드에 대한 스레드 프로시저에 적용되고 <paramref name="waitHandles" />에 둘 이상의 요소가 포함되어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-350">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-351">
            <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-351">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="3d883-352">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-352">-or-</span>
          </span>
          <span data-ttu-id="3d883-353">
            <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-353">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-354">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-354">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-355">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-355">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-356">
            <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-356">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="3d883-357">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-357">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="3d883-358">이 배열에는 같은 개체(중복 개체)에 대한 여러 개의 참조가 포함될 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-358">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="3d883-359">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-359">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="3d883-360">대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-360">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-361">
            <see cref="T:System.Int32" /> 값을 사용하여 시간 간격을 지정하고 대기 전에 동기화 도메인을 끝낼지 여부를 지정하여 지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-361">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-362">
            <paramref name="waitHandles" />에 있는 모든 요소가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-362">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-363">경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-363">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-364">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-364">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-365"><xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-365"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="3d883-366">이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="3d883-366">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="3d883-367">중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-367">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="3d883-368">시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-368">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="3d883-369">예외를 디버깅 하는 데 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-369">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="3d883-370"><xref:System.Threading.WaitHandle.WaitAll%2A> 대기 종료 되 면, 즉 모든 핸들은 신호를 받거나 시간 초과 시 메서드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-370">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="3d883-371">일부 구현에서는 64 개 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-371">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="3d883-372">배열에 중복 항목이 있는지 호출이 실패 하는 <xref:System.DuplicateWaitObjectException>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-372">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d883-373">합니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-373">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="3d883-374">종료 컨텍스트에 대 한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="3d883-374">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="3d883-375">합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitAll%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-375">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="3d883-376">파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-376">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="3d883-377">파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-377">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="3d883-378">사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-378">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="3d883-379">스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-379">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="3d883-380">컨텍스트 바인딩 클래스에 유용할 수 있습니다는 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-380">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="3d883-381">이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-381">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="3d883-382">멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-382">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="3d883-383">경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-383">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-384">다음 코드 예제에서는 비동기적으로 만들고 그룹 파일에 쓰는 데 스레드 풀을 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-384">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="3d883-385">각 쓰기 작업이 완료 되 면 작업 항목 및 신호 대기 중입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-385">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="3d883-386">주 스레드가 신호를 보낼 모든 항목에 대 한 대기 및 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-386">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-387">
            <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-387">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-388">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-388">-or-</span>
          </span>
          <span data-ttu-id="3d883-389">
            <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-389">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-390">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-390">-or-</span>
          </span>
          <span data-ttu-id="3d883-391">
            <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 2.0 이상인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-391">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="3d883-392">
            <paramref name="waitHandles" /> 배열에 중복된 요소가 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-392">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-393">
            <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-393">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="3d883-394">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-394">-or-</span>
          </span>
          <span data-ttu-id="3d883-395">
            <see cref="T:System.STAThreadAttribute" /> 특성이 현재 스레드에 대한 스레드 프로시저에 적용되고 <paramref name="waitHandles" />에 둘 이상의 요소가 포함되어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-395">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3d883-396">
            <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 1.0 또는 1.1인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-396">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-397">
            <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-397">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-398">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-398">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-399">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-399">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-400">
            <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-400">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="3d883-401">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-401">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="3d883-402">이 배열에는 같은 개체에 대한 여러 개의 참조가 포함될 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-402">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="3d883-403">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-403">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="3d883-404">대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-404">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-405">
            <see cref="T:System.TimeSpan" /> 값을 사용하여 시간 간격을 측정하고 대기 전에 동기화 도메인을 끝낼지 여부를 지정하여 지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-405">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-406">
            <paramref name="waitHandles" />에 있는 모든 요소가 신호를 받으면 <see langword="true" />를 반환하고, 그렇지 않으면 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-406">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-407">경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-407">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-408">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-408">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-409"><xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-409"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="3d883-410">이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="3d883-410">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="3d883-411">중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-411">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="3d883-412">시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-412">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="3d883-413">예외를 디버깅 하는 데 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-413">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="3d883-414"><xref:System.Threading.WaitHandle.WaitAll%2A> 메서드 즉, 모든 핸들이 신호를 대기 종료 되거나 제한 시간이 때 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-414">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="3d883-415">일부 구현에서는 64 개 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-415">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="3d883-416">중복 항목을 포함 하는 경우 호출이 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-416">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d883-417">합니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-417">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="3d883-418">에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-418">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="3d883-419">종료 컨텍스트에 대 한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="3d883-419">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="3d883-420">합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitAll%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-420">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="3d883-421">파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-421">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="3d883-422">파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-422">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="3d883-423">사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-423">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="3d883-424">호출 후 원래 컨텍스트로 돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-424">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="3d883-425">컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-425">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="3d883-426">이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-426">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="3d883-427">멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-427">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="3d883-428">경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-428">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-429">다음 코드 예제에서는 비동기적으로 만들고 그룹 파일에 쓰는 데 스레드 풀을 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-429">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="3d883-430">각 쓰기 작업이 완료 되 면 작업 항목 및 신호 대기 중입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-430">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="3d883-431">주 스레드가 신호를 보낼 모든 항목에 대 한 대기 및 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-431">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-432">
            <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-432">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-433">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-433">-or-</span>
          </span>
          <span data-ttu-id="3d883-434">
            <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-434">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-435">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-435">-or-</span>
          </span>
          <span data-ttu-id="3d883-436">
            <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 2.0 이상인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-436">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="3d883-437">
            <paramref name="waitHandles" /> 배열에 중복된 요소가 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-437">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-438">
            <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-438">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="3d883-439">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-439">-or-</span>
          </span>
          <span data-ttu-id="3d883-440">
            <see cref="T:System.STAThreadAttribute" /> 특성이 현재 스레드에 대한 스레드 프로시저에 적용되고 <paramref name="waitHandles" />에 둘 이상의 요소가 포함되어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-440">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3d883-441">
            <paramref name="waitHandles" />가 요소가 없는 배열이며 .NET Framework 버전이 1.0 또는 1.1인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-441">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-442">
            <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-442">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="3d883-443">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-443">-or-</span>
          </span>
          <span data-ttu-id="3d883-444">
            <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-444">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-445">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-445">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-446">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-446">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-447">
            <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-447">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3d883-448">지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-448">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="3d883-449">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-449">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-450">지정된 배열의 모든 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-450">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-451">대기를 만족한 개체의 배열 인덱스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-451">The array index of the object that satisfied the wait.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-452"><xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-452"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="3d883-453">이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 되기 때문에 대기가 완료 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-453">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="3d883-454">중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-454">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="3d883-455">시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-455">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="3d883-456">예외를 디버깅 하는 데 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-456">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="3d883-457">합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단 된 뮤텍스 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-457">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="3d883-458">하는 경우 `waitHandles` 중단된 된 뮤텍스를 보다 낮은 인덱스 번호를 사용 하 여 출시 된 뮤텍스를 포함 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-458">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d883-459">.NET Framework 버전 2.0에서 스레드가 종료 되거나 명시적으로 해제 하지 않고 중단 하는 경우 이전 버전에서을 <xref:System.Threading.Mutex>, 하 고 `Mutex` 0 (영) 인덱스에 `WaitAny` 배열에서 반환 된 인덱스가 다른 스레드에서 `WaitAny` 는 0 대신 128입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-459">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="3d883-460">이 메서드는 모든 핸들 신호가 전달 될 때 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-460">This method returns when any handle is signaled.</span></span> <span data-ttu-id="3d883-461">둘 이상의 개체를 호출 하는 동안 신호 하는 경우 반환 값은 모든 신호를 받은 개체의 인덱스 값이 가장 작은 신호를 받은 개체의 배열 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-461">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="3d883-462">일부 구현에서는 자세히 64 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-462">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="3d883-463">이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 메서드 오버 로드 하 고-1을 지정 (또는 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>)에 대 한 `millisecondsTimeout` 하 고 `true` 에 대 한 `exitContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-463">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-464">다음 코드 예제에서는 호출 된 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-464">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-465">
            <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-465">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-466">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-466">-or-</span>
          </span>
          <span data-ttu-id="3d883-467">
            <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-467">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-468">
            <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-468">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3d883-469">
            <paramref name="waitHandles" />가 요소가 없는 배열이고 .NET Framework 버전이 1.0 또는 1.1인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-469">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-470">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-470">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-471">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-471">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d883-472">
            <paramref name="waitHandles" />을를은 아무런 요소도 갖고 있지 않은 배열이며 .NET Framework 버전은 2.0 이상입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-472">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-473">
            <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-473">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="3d883-474">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-474">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="3d883-475">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-475">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-476">부호 있는 32비트 정수를 사용하여 시간 간격을 지정함으로써 지정된 배열의 임의 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-476">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-477">대기를 만족하는 개체의 배열 인덱스이거나 대기를 만족하는 개체가 없고 <paramref name="millisecondsTimeout" />과 동일한 시간 간격이 전달된 경우 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-477">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-478">경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-478">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-479">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-479">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-480">합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단 된 뮤텍스 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-480">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="3d883-481">하는 경우 `waitHandles` 중단된 된 뮤텍스를 보다 낮은 인덱스 번호를 사용 하 여 출시 된 뮤텍스를 포함 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-481">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="3d883-482">이 메서드는 대기 종료 되 면 핸들은 신호를 받거나 시간 초과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-482">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="3d883-483">둘 이상의 개체를 호출 하는 동안 신호 하는 경우 반환 값은 모든 신호를 받은 개체의 인덱스 값이 가장 작은 신호를 받은 개체의 배열 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-483">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="3d883-484">일부 구현에서는 자세히 64 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-484">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="3d883-485">이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-485">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-486">
            <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-486">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-487">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-487">-or-</span>
          </span>
          <span data-ttu-id="3d883-488">
            <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-488">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-489">
            <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-489">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-490">
            <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-490">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-491">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-491">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-492">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-492">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d883-493">
            <paramref name="waitHandles" />가 요소가 없는 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-493">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-494">
            <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-494">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="3d883-495">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-495">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="3d883-496">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-496">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-497">
            <see cref="T:System.TimeSpan" />을 사용하여 시간 간격을 지정함으로써 지정된 배열의 임의 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-497">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-498">대기를 만족하는 개체의 배열 인덱스이거나 대기를 만족하는 개체가 없고 <paramref name="timeout" />과 동일한 시간 간격이 전달된 경우 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-498">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-499">경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-499">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-500">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-500">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-501">합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단 된 뮤텍스 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-501">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="3d883-502">하는 경우 `waitHandles` 중단된 된 뮤텍스를 보다 낮은 인덱스 번호를 사용 하 여 출시 된 뮤텍스를 포함 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-502">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="3d883-503">이 메서드는 대기 종료 되 면 핸들은 신호를 받거나 시간 초과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-503">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="3d883-504">둘 이상의 개체를 호출 하는 동안 신호 하는 경우 반환 값은 모든 신호를 받은 개체의 인덱스 값이 가장 작은 신호를 받은 개체의 배열 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-504">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="3d883-505">일부 구현에서는 자세히 64 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-505">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="3d883-506">에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-506">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3d883-507">이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-507">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-508">
            <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-508">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-509">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-509">-or-</span>
          </span>
          <span data-ttu-id="3d883-510">
            <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-510">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-511">
            <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-511">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-512">
            <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-512">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="3d883-513">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-513">-or-</span>
          </span>
          <span data-ttu-id="3d883-514">
            <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-514">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-515">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-515">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-516">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-516">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d883-517">
            <paramref name="waitHandles" />가 요소가 없는 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-517">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-518">
            <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-518">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="3d883-519">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-519">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="3d883-520">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-520">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="3d883-521">대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-521">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-522">부호 있는 32비트 정수를 사용하여 시간 간격을 지정하고 대기 전에 동기화 도메인을 종료할지를 지정하여 지정된 배열의 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-522">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-523">대기를 만족하는 개체의 배열 인덱스이거나 대기를 만족하는 개체가 없고 <paramref name="millisecondsTimeout" />과 동일한 시간 간격이 전달된 경우 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-523">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-524">경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-524">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-525">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-525">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-526"><xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-526"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="3d883-527">이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 되기 때문에 대기가 완료 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-527">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="3d883-528">중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-528">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="3d883-529">시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-529">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="3d883-530">예외를 디버깅 하는 데 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-530">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="3d883-531">합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단 된 뮤텍스 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-531">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="3d883-532">하는 경우 `waitHandles` 중단된 된 뮤텍스를 보다 낮은 인덱스 번호를 사용 하 여 출시 된 뮤텍스를 포함 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-532">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d883-533">.NET Framework 버전 2.0에서 스레드가 종료 되거나 명시적으로 해제 하지 않고 중단 하는 경우 이전 버전에서을 <xref:System.Threading.Mutex>, 하 고 `Mutex` 0 (영) 인덱스에 `WaitAny` 배열에서 반환 된 인덱스가 다른 스레드에서 `WaitAny` 는 0 대신 128입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-533">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="3d883-534">이 메서드는 대기 종료 되 면 핸들은 신호를 받거나 시간 초과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-534">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="3d883-535">둘 이상의 개체를 호출 하는 동안 신호 하는 경우 반환 값은 모든 신호를 받은 개체의 인덱스 값이 가장 작은 신호를 받은 개체의 배열 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-535">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="3d883-536">일부 구현에서는 자세히 64 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-536">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="3d883-537">종료 컨텍스트에 대 한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="3d883-537">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="3d883-538">합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitAny%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-538">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="3d883-539">파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-539">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="3d883-540">파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-540">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="3d883-541">사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-541">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="3d883-542">스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-542">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="3d883-543">컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-543">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="3d883-544">이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-544">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="3d883-545">멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-545">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="3d883-546">경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-546">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-547">다음 코드 예제에서는 스레드 풀을 사용 하 여 동시에 여러 디스크에 파일을 검색 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-547">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="3d883-548">공간 고려 사항에 대 한 각 디스크의 루트 디렉터리에만 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-548">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-549">
            <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-549">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-550">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-550">-or-</span>
          </span>
          <span data-ttu-id="3d883-551">
            <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-551">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-552">
            <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-552">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3d883-553">
            <paramref name="waitHandles" />가 요소가 없는 배열이고 .NET Framework 버전이 1.0 또는 1.1인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-553">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-554">
            <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-554">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-555">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-555">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-556">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-556">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d883-557">
            <paramref name="waitHandles" />을를은 아무런 요소도 갖고 있지 않은 배열이며 .NET Framework 버전은 2.0 이상입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-557">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-558">
            <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-558">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="3d883-559">현재 인스턴스에서 기다릴 개체가 포함된 <see langword="WaitHandle" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-559">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="3d883-560">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-560">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="3d883-561">대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-561">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-562">
            <see cref="T:System.TimeSpan" /> 값으로 시간 간격을 지정하고 대기 전에 동기화 도메인을 끝낼지 여부를 지정한 다음 지정된 배열의 요소가 신호를 받기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-562">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-563">대기를 만족하는 개체의 배열 인덱스이거나 대기를 만족하는 개체가 없고 <paramref name="timeout" />과 동일한 시간 간격이 전달된 경우 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-563">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-564">경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-564">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-565">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-565">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-566"><xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-566"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="3d883-567">이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 되기 때문에 대기가 완료 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-567">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="3d883-568">중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-568">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="3d883-569">시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-569">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="3d883-570">예외를 디버깅 하는 데 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-570">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="3d883-571">합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단 된 뮤텍스 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-571">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="3d883-572">하는 경우 `waitHandles` 중단된 된 뮤텍스를 보다 낮은 인덱스 번호를 사용 하 여 출시 된 뮤텍스를 포함 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-572">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d883-573">.NET Framework 버전 2.0에서 스레드가 종료 되거나 명시적으로 해제 하지 않고 중단 하는 경우 이전 버전에서을 <xref:System.Threading.Mutex>, 하 고 `Mutex` 0 (영) 인덱스에 `WaitAny` 배열에서 반환 된 인덱스가 다른 스레드에서 `WaitAny` 는 0 대신 128입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-573">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="3d883-574">이 메서드는 대기 종료 되 면 핸들은 신호를 받거나 시간 초과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-574">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="3d883-575">둘 이상의 개체를 호출 하는 동안 신호 하는 경우 반환 값은 모든 신호를 받은 개체의 인덱스 값이 가장 작은 신호를 받은 개체의 배열 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-575">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="3d883-576">일부 구현에서는 자세히 64 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-576">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="3d883-577">에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-577">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="3d883-578">종료 컨텍스트에 대 한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="3d883-578">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="3d883-579">합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitAny%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-579">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="3d883-580">파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-580">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="3d883-581">파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-581">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="3d883-582">사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-582">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="3d883-583">스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-583">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="3d883-584">컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-584">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="3d883-585">이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-585">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="3d883-586">멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-586">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="3d883-587">경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-587">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-588">다음 코드 예제에서는 스레드 풀을 사용 하 여 동시에 여러 디스크에 파일을 검색 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-588">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="3d883-589">공간 고려 사항에 대 한 각 디스크의 루트 디렉터리에만 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-589">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d883-590">
            <paramref name="waitHandles" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-590">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3d883-591">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-591">-or-</span>
          </span>
          <span data-ttu-id="3d883-592">
            <paramref name="waitHandles" /> 배열에 있는 하나 이상의 개체가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-592">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d883-593">
            <paramref name="waitHandles" />의 개체 수가 시스템에서 허용하는 것보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-593">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="3d883-594">
            <paramref name="waitHandles" />가 요소가 없는 배열이고 .NET Framework 버전이 1.0 또는 1.1인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-594">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-595">
            <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-595">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="3d883-596">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-596">-or-</span>
          </span>
          <span data-ttu-id="3d883-597">
            <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-597">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-598">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-598">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-599">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-599">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d883-600">
            <paramref name="waitHandles" />을를은 아무런 요소도 갖고 있지 않은 배열이며 .NET Framework 버전은 2.0 이상입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-600">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-601">
            <paramref name="waitHandles" /> 배열에 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-601">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3d883-602">현재 <see cref="T:System.Threading.WaitHandle" />이(가) 신호를 받을 때까지 현재 스레드를 차단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-602">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3d883-603">현재 <see cref="T:System.Threading.WaitHandle" />이(가) 신호를 받을 때까지 현재 스레드를 차단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-603">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-604">현재 인스턴스가 신호를 받으면 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-604">
              <see langword="true" /> if the current instance receives a signal.</span>
          </span>
          <span data-ttu-id="3d883-605">현재 인스턴스가 신호를 받지 않으면 <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />은(는) 아무 값도 반환하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-605">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-606"><xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-606"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="3d883-607">이전 버전에서의 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="3d883-607">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="3d883-608">중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-608">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="3d883-609">시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-609">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="3d883-610">예외를 디버깅 하는 데 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-610">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="3d883-611">현재 인스턴스가 신호를 받을 때까지 무기한으로이 메서드 블록의 호출자입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-611">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="3d883-612">이 메서드를 사용 하 여 될 때까지 차단는 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-612">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="3d883-613">자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-613">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="3d883-614">이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 메서드 오버 로드 하 고-1을 지정 또는 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 첫 번째 매개 변수 및 `false` 두 번째 매개 변수에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-614">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="3d883-615">파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-615">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-616">다음 코드 예제에는 백그라운드 스레드 실행이 완료를 기다리는 동안 종료 프로세스를 유지 하도록 대기 핸들을 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-616">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="3d883-617">현재 인스턴스가 이미 삭제된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-617">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-618">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-618">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-619">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-619">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-620">현재 인스턴스가 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-620">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="3d883-621">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-621">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-622">부호 있는 32비트 정수로 시간 간격(밀리초)을 지정하여 현재 <see cref="T:System.Threading.WaitHandle" />이 신호를 받을 때까지 현재 스레드를 차단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-622">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-623">현재 인스턴스가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-623">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-624">경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-624">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-625">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-625">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-626">현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-626">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="3d883-627">이 메서드를 사용 하 여 될 때까지 차단는 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-627">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="3d883-628">자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-628">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="3d883-629">파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-629">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="3d883-630">이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-630">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-631">다음 코드 예제에는 백그라운드 스레드 실행이 완료를 기다리는 동안 종료 프로세스를 유지 하도록 대기 핸들을 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-631">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="3d883-632">현재 인스턴스가 이미 삭제된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-632">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-633">
            <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-633">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-634">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-634">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-635">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-635">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-636">현재 인스턴스가 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-636">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="3d883-637">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-637">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-638">
            <see cref="T:System.TimeSpan" />로 시간 간격을 지정하여 현재 인스턴스가 신호를 받을 때까지 현재 스레드를 차단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-638">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-639">현재 인스턴스가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-639">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-640">경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-640">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-641">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-641">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-642">현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-642">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="3d883-643">이 메서드를 사용 하 여 될 때까지 차단는 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-643">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="3d883-644">자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-644">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="3d883-645">파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-645">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="3d883-646">에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-646">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3d883-647">이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-647">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="3d883-648">현재 인스턴스가 이미 삭제된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-648">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-649">
            <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-649">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="3d883-650">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-650">-or-</span>
          </span>
          <span data-ttu-id="3d883-651">
            <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-651">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-652">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-652">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-653">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-653">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-654">현재 인스턴스가 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-654">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="3d883-655">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-655">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="3d883-656">대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-656">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-657">부호 있는 32비트 정수로 시간 간격을 지정하고 대기 전에 동기화 도메인을 끝낼지 여부를 지정하여 현재 <see cref="T:System.Threading.WaitHandle" />이 신호를 받을 때까지 현재 스레드를 차단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-657">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-658">현재 인스턴스가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-658">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-659">경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-659">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-660">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-660">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-661"><xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-661"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="3d883-662">이전 버전에서의 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="3d883-662">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="3d883-663">중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-663">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="3d883-664">시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-664">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="3d883-665">예외를 디버깅 하는 데 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-665">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="3d883-666">현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-666">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="3d883-667">이 메서드를 사용 하 여 될 때까지 차단는 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-667">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="3d883-668">자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-668">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="3d883-669">파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-669">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="3d883-670">종료 컨텍스트에 대 한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="3d883-670">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="3d883-671">합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitOne%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-671">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="3d883-672">파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-672">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="3d883-673">파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-673">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="3d883-674">사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-674">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="3d883-675">스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-675">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="3d883-676">컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-676">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="3d883-677">이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-677">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="3d883-678">멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-678">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="3d883-679">경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-679">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-680">다음 예제와 방법을 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 동기화 도메인 내에서 호출 될 때 동작 하는 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-680">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="3d883-681">사용 하 여 스레드가 대기 하는 먼저 `exitContext` 로 `false` 및 대기 시간 제한이 만료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-681">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="3d883-682">두 번째 스레드가 실행 후 첫 번째 스레드가 종료 되 고 사용 하 여 대기 `exitContext` 로 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-682">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="3d883-683">이 두 번째 스레드에 대 한 대기 핸들이 신호에 대 한 호출 차단 되지 않은 경우 및 스레드 대기 시간 제한 전에 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-683">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="3d883-684">현재 인스턴스가 이미 삭제된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-684">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-685">
            <paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-685">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-686">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-686">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-687">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-687">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-688">현재 인스턴스가 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-688">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="3d883-689">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-689">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="3d883-690">대기 전에 컨텍스트에 대한 동기화 도메인을 종료하고(동기화된 컨텍스트에 있는 경우) 이 도메인을 다시 가져오려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-690">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3d883-691">
            <see cref="T:System.TimeSpan" />로 시간 간격을 지정하고 대기 전에 동기화 도메인을 끝낼지 여부를 지정하여 현재 인스턴스가 신호를 받을 때까지 현재 스레드를 차단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-691">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3d883-692">현재 인스턴스가 신호를 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-692">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-693">경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-693">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="3d883-694">대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-694">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="3d883-695"><xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-695"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="3d883-696">이전 버전에서의 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="3d883-696">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="3d883-697">중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-697">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="3d883-698">시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-698">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="3d883-699">예외를 디버깅 하는 데 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-699">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="3d883-700">현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-700">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="3d883-701">이 메서드를 사용 하 여 될 때까지 차단는 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-701">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="3d883-702">자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-702">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="3d883-703">파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-703">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="3d883-704">에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-704">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="3d883-705">종료 컨텍스트에 대 한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="3d883-705">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="3d883-706">합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitOne%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-706">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="3d883-707">파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-707">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="3d883-708">파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-708">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="3d883-709">사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3d883-709">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="3d883-710">스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-710">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="3d883-711">컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-711">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="3d883-712">이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-712">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="3d883-713">멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-713">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="3d883-714">경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-714">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-715">다음 코드 예제에는 백그라운드 스레드 실행이 완료를 기다리는 동안 종료 프로세스를 유지 하도록 대기 핸들을 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-715">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="3d883-716">현재 인스턴스가 이미 삭제된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-716">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d883-717">
            <paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-717">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="3d883-718">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-718">-or-</span>
          </span>
          <span data-ttu-id="3d883-719">
            <paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-719">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="3d883-720">스레드가 뮤텍스를 해제하지 않고 종료되었으므로 대기가 완료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-720">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="3d883-721">이 예외가 Windows 98 또는 Windows Millennium Edition에서는 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-721">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d883-722">현재 인스턴스가 다른 응용 프로그램 도메인에 있는 <see cref="T:System.Threading.WaitHandle" />에 대한 투명 프록시인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-722">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="3d883-723">대기 핸들이 신호를 받기 전에 <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 작업이 제한 시간을 초과했음을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-723">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span>
          </span>
          <span data-ttu-id="3d883-724">이 필드는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3d883-724">This field is constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d883-725">이 필드의 가능한 반환 값 중 하나는 `WaitAny`합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-725">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d883-726">다음 코드 예제에서는 스레드 풀을 사용 하 여 동시에 여러 디스크에 파일을 검색 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-726">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="3d883-727">공간 고려 사항에 대 한 각 디스크의 루트 디렉터리에만 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3d883-727">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>