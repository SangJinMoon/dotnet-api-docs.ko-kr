<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a13a27594fa1d97d7387994076cdc3b3a30d735d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609276" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle> 클래스는 Win32 동기화 핸들을 캡슐화 하 고 런타임에서 여러 개의 대기 작업을 허용 하는 모든 동기화 개체를 나타내는 데 사용 됩니다. 다른 동기화 개체를 사용 하 여 대기 핸들의 비교를 참조 하세요 [동기화 기본 형식 개요](~/docs/standard/threading/overview-of-synchronization-primitives.md)합니다.  
  
 <xref:System.Threading.WaitHandle> 클래스 자체는 추상 클래스입니다. 파생 된 클래스 <xref:System.Threading.WaitHandle> 신호 메커니즘을 수행 하거나 공유 리소스에 대 한 액세스를 해제 의미를 정의 하지만 상속 된 사용 <xref:System.Threading.WaitHandle> 공유 리소스에 대 한 액세스를 기다리는 동안 차단 하는 방법입니다. 파생 된 클래스가 <xref:System.Threading.WaitHandle> 포함:  
  
-   <xref:System.Threading.Mutex> 클래스 참조 [뮤텍스](~/docs/standard/threading/mutexes.md)합니다.  
  
-   합니다 <xref:System.Threading.EventWaitHandle> 클래스와 파생된 클래스인 <xref:System.Threading.AutoResetEvent> 및 <xref:System.Threading.ManualResetEvent>합니다. [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)를 참조하세요.  
  
-   <xref:System.Threading.Semaphore> 클래스 참조 [세마포 및 SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)합니다.  
  
 인스턴스 메서드를 호출 하 여 개별 대기 핸들에서 스레드가 차단할 수 있습니다 <xref:System.Threading.WaitHandle.WaitOne%2A>에서 파생 된 클래스에 상속 되는 <xref:System.Threading.WaitHandle>합니다.  
  
 파생된 클래스 <xref:System.Threading.WaitHandle> 스레드 선호도 다릅니다. 이벤트 대기 핸들 (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, 및 <xref:System.Threading.ManualResetEvent>) 세마포에 스레드 선호도 없습니다 하 고 모든 스레드를 이벤트 대기 핸들 또는 세마포 신호를 보낼 수 있습니다. 뮤텍스, 반면에 권한이 스레드 선호도 있습니다. 뮤텍스를 소유 하는 스레드를 해제 해야 하 고 스레드 호출 하는 경우 예외가 throw 되는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 소유 하지 않는 뮤텍스를 메서드.  
  
 때문에 합니다 <xref:System.Threading.WaitHandle> 클래스에서 파생 되며 <xref:System.MarshalByRefObject>, 이러한 클래스를 사용 하 여 응용 프로그램 도메인 경계를 넘어 스레드의 활동을 동기화 할 수 있습니다.  
  
 파생된 클래스 외에도 <xref:System.Threading.WaitHandle> 클래스 개수가 하나 될 때까지 스레드를 차단 하는 정적 메서드 또는 동기화 개체가 신호를 받기를... 여기에는 다음이 포함됩니다.  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>에 하나의 대기 핸들이 신호를 보내고 다른 곧바로 대기 하기 위한 스레드 수 있습니다.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>을 허용 하는 스레드가 모든 대기 핸들 배열에 신호를 받을 때까지 대기 해야 합니다.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>을 허용 하는 스레드가 대기 핸들의 지정된 된 집합 중 하나에서 신호 될 때까지 대기 해야 합니다.  
  
 이러한 메서드의 오버 로드는 대기 및 동기화 컨텍스트를 사용 하 여 다른 스레드를 허용 하는 대기를 시작 하기 전에 동기화 컨텍스트를 종료 하는 기회를 중단 하는 것에 대 한 제한 시간 간격을 제공 합니다.  
  
> [!IMPORTANT]
>  이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식 또는 여기에서 파생 된 형식을 사용 하 여 마쳤으면 직접 또는 간접적으로으로 삭제 해야 있습니다. 직접 형식의 dispose 호출 해당 <xref:System.Threading.WaitHandle.Close%2A> 의 메서드를 `try` / `catch` 블록입니다. 삭제 하지 직접, 언어 구문 같은 사용 `using` (C#에서) 또는 `Using` (Visual Basic에서는). 자세한 내용은 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하세요.를 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
 <xref:System.Threading.WaitHandle> 구현 된 <xref:System.IDisposable.Dispose%2A> 패턴입니다. 참조 [삭제 패턴](~/docs/standard/design-guidelines/dispose-pattern.md)합니다. 파생 하는 경우 <xref:System.Threading.WaitHandle>를 사용 하 여는 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성에 대 한 기본 핸들 운영 체제 핸들을 저장 합니다. 보호 된 재정의할 필요가 없습니다 <xref:System.Threading.WaitHandle.Dispose%2A> 메서드 사용 하지 않는 경우 관리 되지 않는 리소스를 추가 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 스레드 수는 어떻게 수행 주 하는 동안 백그라운드 작업 스레드 작업이 정적을 사용 하 여 완료 되기를 기다립니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 하 고 <xref:System.Threading.WaitHandle.WaitAll%2A> 의 메서드는 <xref:System.Threading.WaitHandle> 클래스.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 공용 구현의 합니다 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 에 대 한 메서드는 <xref:System.Threading.WaitHandle> 클래스와 파생된 클래스입니다. 호출 하는 표준 구현을 제공 합니다 `Dispose(Boolean)` 오버 로드를 `true` 인수 및 호출을 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 메서드. 인스턴스에서 보유 한 모든 리소스를 해제 하려면이 메서드를 호출 `WaitHandle` 또는 파생된 클래스입니다.  
  
 이 메서드가 호출 되 면 현재 인스턴스에 대 한 참조가 정의 되지 않은 동작이 발생 합니다.  
  
> [!NOTE]
>  항상 호출 <xref:System.Threading.WaitHandle.Close%2A> 나 <xref:System.Threading.WaitHandle.Dispose> 에 대 한 마지막 참조를 해제 하기 전에 <xref:System.Threading.WaitHandle>합니다. 그렇지 않은 경우 사용 중인 리소스가 해제 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 해야 하는 <see langword="Dispose(Boolean)" /> 파생 된 클래스에 할당 된 리소스를 해제 하는 방법입니다.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 해당 하는 <xref:System.Threading.WaitHandle.Close%2A> 메서드.  
  
> [!NOTE]
>  항상 호출 <xref:System.Threading.WaitHandle.Close%2A> 나 <xref:System.Threading.WaitHandle.Dispose> 에 대 한 마지막 참조를 해제 하기 전에 <xref:System.Threading.WaitHandle>합니다. 그렇지 않은 경우 사용 중인 리소스가 해제 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 합니다 <xref:System.Threading.WaitHandle.Close%2A> 및 <xref:System.Threading.WaitHandle.Dispose> 메서드를 `explicitDisposing` 매개 변수 설정 `true`합니다.  경우는 `explicitDisposing` 매개 변수가 `true`,이 메서드는 관리 되는 개체가 보유 한 모든 리소스를 해제이 <xref:System.Threading.WaitHandle> 개체 참조입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 해야 하는 <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> 파생 된 클래스에 할당 된 리소스를 해제 하는 방법입니다.  합니다 <see cref="M:System.Threading.WaitHandle.Close" /> 또는 <see cref="M:System.Threading.WaitHandle.Dispose" /> 메서드 다른 개체에서 여러 번 호출할 수 있습니다. 이 메서드를 재정의 하는 경우에 대 한 이전 호출에서 이전에 삭제 된 개체를 참조 하지 않도록 주의 <see langword="Dispose" /> 또는 <see langword="Close" />합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the native operating system handle.</summary>
        <value>네이티브 운영 체제 핸들을 나타내는 <see langword="IntPtr" />입니다. 기본값은 <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> 필드의 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 값을 할당 합니다 <xref:System.Threading.WaitHandle.Handle%2A> 속성 이전 핸들을 닫지 않습니다. 이 핸들 누수가 발생할 수 있습니다.  
  
 .NET Framework 버전 2.0 이상이;에이 속성을 사용 하지 마십시오 사용 된 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성 대신 합니다. 이 속성을 유효한 핸들도 설정 합니다 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성이 아니라 설정 <xref:System.Threading.WaitHandle.InvalidHandle> 핸들 누수가 발생할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">속성 값을 설정 하려면 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 설정할 수 없습니다.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">파생된 형식에 있어야 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 속성 값을 설정 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents an invalid native operating system handle. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기화를 내부적으로 사용 된 <xref:System.Threading.WaitHandle.Handle%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>확인 하려면이 값을 사용할 수 있는지 여부를 <see cref="P:System.Threading.WaitHandle.Handle" /> 속성에 유효한 기본 운영 체제 핸들을 포함 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the native operating system handle.</summary>
        <value>네이티브 운영 체제 핸들을 나타내는 <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 값을 할당 하는 경우는 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성을 이전 핸들이 닫힐 때 이전 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 개체가 수집 되 합니다. 수동으로 닫지 핸들,이 인해 때문에 <xref:System.ObjectDisposedException> 경우는 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 핸들을 종료 하려고 합니다.  
  
 <xref:System.Threading.WaitHandle> 구현 된 <xref:System.IDisposable.Dispose%2A> 패턴입니다. 참조 [삭제 패턴](~/docs/standard/design-guidelines/dispose-pattern.md)합니다. 파생 하는 경우 <xref:System.Threading.WaitHandle>를 사용 하 여는 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 속성에 대 한 기본 핸들 운영 체제 핸들을 저장 합니다. 보호 된 재정의할 필요가 없습니다 <xref:System.Threading.WaitHandle.Dispose%2A> 메서드 사용 하지 않는 경우 관리 되지 않는 리소스를 추가 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">파생된 형식에 있어야 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 이 멤버를 호출 합니다.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 작업은 원자성을 보장 되지 않습니다. 현재 스레드가 신호 후 `toSignal` 대기 하기 전에 `toWaitOn`, 다른 프로세서에서 실행 되는 스레드 수 신호 `toWaitOn` 대기 또는 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> 메서드 오버 로드는 주 스레드가 차단 된 스레드가 신호를 보내고 스레드가 작업을 완료할 때까지 대기할 수 있도록 합니다.  
  
 이 예제에서는 5 개의 스레드를 시작에서 차단 될 수는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 플래그 및 사용자가 ENTER 키를 누를 릴리스 스레드를 하나씩 시간 후 합니다. 다음 예제에서는 다른 5 개의 스레드가 큐를 사용 하 여 모든 릴리스 하는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 플래그입니다.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> is a semaphore, and it already has a full count.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <param name="millisecondsTimeout">An integer that represents the interval to wait. If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 작업은 원자성을 보장 되지 않습니다. 현재 스레드가 신호 후 `toSignal` 대기 하기 전에 `toWaitOn`, 다른 프로세서에서 실행 되는 스레드 수 신호 `toWaitOn` 대기 또는 합니다.  
  
 경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다. 상태를 테스트 합니다 `toWaitOn` 를 즉시 반환 합니다.  
  
## <a name="notes-on-exiting-the-context"></a>종료 컨텍스트에 대 한 참고 사항  
 합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다. 멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다. 경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the interval to wait. If the value is -1, the wait is infinite.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 작업은 원자성을 보장 되지 않습니다. 현재 스레드가 신호 후 `toSignal` 대기 하기 전에 `toWaitOn`, 다른 프로세서에서 실행 되는 스레드 수 신호 `toWaitOn` 대기 또는 합니다.  
  
 에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
 경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다. 상태를 테스트 합니다 `toWaitOn` 를 즉시 반환 합니다.  
  
## <a name="notes-on-exiting-the-context"></a>종료 컨텍스트에 대 한 참고 사항  
 합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다. 멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다. 경우는 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> is a semaphore, and it already has a full count.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Waits for all the elements in the specified array to receive a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <summary>Waits for all the elements in the specified array to receive a signal.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우. 중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다. 시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다. 예외를 디버깅 하는 데 유용한 정보를 포함합니다.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드 핸들을 모두 신호를 반환 합니다. 일부 구현에서는 64 개 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다. 사용 하 여 호출이 실패 하면 중복을 포함 하는 경우는 <xref:System.DuplicateWaitObjectException>합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 메서드 오버 로드 하 고-1을 지정 (또는 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>)에 대 한 `millisecondsTimeout` 하 고 `true` 에 대 한 `exitContext`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기적으로 만들고 그룹 파일에 쓰는 데 스레드 풀을 사용 하는 방법을 보여 줍니다. 각 쓰기 작업이 완료 되 면 작업 항목 및 신호 대기 중입니다. 주 스레드가 신호를 보낼 모든 항목에 대 한 대기 및 종료 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />. -or-  One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> 대기 종료 되 면, 즉 모든 핸들은 신호를 받거나 시간 초과 시 메서드를 반환 합니다. 일부 구현에서는 64 개 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다. 배열에 중복 항목이 있는지 호출이 실패 하는 <xref:System.DuplicateWaitObjectException>합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.  
  
 이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드 즉, 모든 핸들이 신호를 대기 종료 되거나 제한 시간이 때 반환 합니다. 일부 구현에서는 64 개 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다. 중복 항목을 포함 하는 경우 호출이 실패 합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.  
  
 에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
 이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우. 중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다. 시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다. 예외를 디버깅 하는 데 유용한 정보를 포함합니다.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> 대기 종료 되 면, 즉 모든 핸들은 신호를 받거나 시간 초과 시 메서드를 반환 합니다. 일부 구현에서는 64 개 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다. 배열에 중복 항목이 있는지 호출이 실패 하는 <xref:System.DuplicateWaitObjectException>합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.  
  
## <a name="notes-on-exiting-the-context"></a>종료 컨텍스트에 대 한 참고 사항  
 합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitAll%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다는 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 특성입니다. 이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다. 멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기적으로 만들고 그룹 파일에 쓰는 데 스레드 풀을 사용 하는 방법을 보여 줍니다. 각 쓰기 작업이 완료 되 면 작업 항목 및 신호 대기 중입니다. 주 스레드가 신호를 보낼 모든 항목에 대 한 대기 및 종료 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우. 중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다. 시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다. 예외를 디버깅 하는 데 유용한 정보를 포함합니다.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드 즉, 모든 핸들이 신호를 대기 종료 되거나 제한 시간이 때 반환 합니다. 일부 구현에서는 64 개 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다. 중복 항목을 포함 하는 경우 호출이 실패 합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 가 있는 스레드에서 메서드가 지원 되지 않습니다 <xref:System.STAThreadAttribute>합니다.  
  
 에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
## <a name="notes-on-exiting-the-context"></a>종료 컨텍스트에 대 한 참고 사항  
 합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitAll%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드. 호출 후 원래 컨텍스트로 돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다. 멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기적으로 만들고 그룹 파일에 쓰는 데 스레드 풀을 사용 하는 방법을 보여 줍니다. 각 쓰기 작업이 완료 되 면 작업 항목 및 신호 대기 중입니다. 주 스레드가 신호를 보낼 모든 항목에 대 한 대기 및 종료 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Waits for any of the elements in the specified array to receive a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal.</summary>
        <returns>The array index of the object that satisfied the wait.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 되기 때문에 대기가 완료 되 면 합니다. 중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다. 시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다. 예외를 디버깅 하는 데 유용한 정보를 포함합니다.  
  
 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단 된 뮤텍스 때문입니다. 하는 경우 `waitHandles` 중단된 된 뮤텍스를 보다 낮은 인덱스 번호를 사용 하 여 출시 된 뮤텍스를 포함 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.  
  
> [!NOTE]
>  .NET Framework 버전 2.0에서 스레드가 종료 되거나 명시적으로 해제 하지 않고 중단 하는 경우 이전 버전에서을 <xref:System.Threading.Mutex>, 하 고 `Mutex` 0 (영) 인덱스에 `WaitAny` 배열에서 반환 된 인덱스가 다른 스레드에서 `WaitAny` 는 0 대신 128입니다.  
  
 이 메서드는 모든 핸들 신호가 전달 될 때 반환 합니다. 둘 이상의 개체를 호출 하는 동안 신호 하는 경우 반환 값은 모든 신호를 받은 개체의 인덱스 값이 가장 작은 신호를 받은 개체의 배열 인덱스입니다. 일부 구현에서는 자세히 64 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 메서드 오버 로드 하 고-1을 지정 (또는 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>)에 대 한 `millisecondsTimeout` 하 고 `true` 에 대 한 `exitContext`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출 된 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단 된 뮤텍스 때문입니다. 하는 경우 `waitHandles` 중단된 된 뮤텍스를 보다 낮은 인덱스 번호를 사용 하 여 출시 된 뮤텍스를 포함 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.  
  
 이 메서드는 대기 종료 되 면 핸들은 신호를 받거나 시간 초과 반환 합니다. 둘 이상의 개체를 호출 하는 동안 신호 하는 경우 반환 값은 모든 신호를 받은 개체의 인덱스 값이 가장 작은 신호를 받은 개체의 배열 인덱스입니다. 일부 구현에서는 자세히 64 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.  
  
 이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단 된 뮤텍스 때문입니다. 하는 경우 `waitHandles` 중단된 된 뮤텍스를 보다 낮은 인덱스 번호를 사용 하 여 출시 된 뮤텍스를 포함 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.  
  
 이 메서드는 대기 종료 되 면 핸들은 신호를 받거나 시간 초과 반환 합니다. 둘 이상의 개체를 호출 하는 동안 신호 하는 경우 반환 값은 모든 신호를 받은 개체의 인덱스 값이 가장 작은 신호를 받은 개체의 배열 인덱스입니다. 일부 구현에서는 자세히 64 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.  
  
 에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
 이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 되기 때문에 대기가 완료 되 면 합니다. 중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다. 시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다. 예외를 디버깅 하는 데 유용한 정보를 포함합니다.  
  
 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단 된 뮤텍스 때문입니다. 하는 경우 `waitHandles` 중단된 된 뮤텍스를 보다 낮은 인덱스 번호를 사용 하 여 출시 된 뮤텍스를 포함 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.  
  
> [!NOTE]
>  .NET Framework 버전 2.0에서 스레드가 종료 되거나 명시적으로 해제 하지 않고 중단 하는 경우 이전 버전에서을 <xref:System.Threading.Mutex>, 하 고 `Mutex` 0 (영) 인덱스에 `WaitAny` 배열에서 반환 된 인덱스가 다른 스레드에서 `WaitAny` 는 0 대신 128입니다.  
  
 이 메서드는 대기 종료 되 면 핸들은 신호를 받거나 시간 초과 반환 합니다. 둘 이상의 개체를 호출 하는 동안 신호 하는 경우 반환 값은 모든 신호를 받은 개체의 인덱스 값이 가장 작은 신호를 받은 개체의 배열 인덱스입니다. 일부 구현에서는 자세히 64 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.  
  
## <a name="notes-on-exiting-the-context"></a>종료 컨텍스트에 대 한 참고 사항  
 합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitAny%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다. 멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 스레드 풀을 사용 하 여 동시에 여러 디스크에 파일을 검색 하는 방법에 설명 합니다. 공간 고려 사항에 대 한 각 디스크의 루트 디렉터리에만 검색 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 되기 때문에 대기가 완료 되 면 합니다. 중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다. 시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다. 예외를 디버깅 하는 데 유용한 정보를 포함합니다.  
  
 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 throw는 <xref:System.Threading.AbandonedMutexException> 만 대기 작업이 완료 되 면 중단 된 뮤텍스 때문입니다. 하는 경우 `waitHandles` 중단된 된 뮤텍스를 보다 낮은 인덱스 번호를 사용 하 여 출시 된 뮤텍스를 포함 합니다 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드가 정상적으로 완료 되 고 예외가 throw 되지 않습니다.  
  
> [!NOTE]
>  .NET Framework 버전 2.0에서 스레드가 종료 되거나 명시적으로 해제 하지 않고 중단 하는 경우 이전 버전에서을 <xref:System.Threading.Mutex>, 하 고 `Mutex` 0 (영) 인덱스에 `WaitAny` 배열에서 반환 된 인덱스가 다른 스레드에서 `WaitAny` 는 0 대신 128입니다.  
  
 이 메서드는 대기 종료 되 면 핸들은 신호를 받거나 시간 초과 반환 합니다. 둘 이상의 개체를 호출 하는 동안 신호 하는 경우 반환 값은 모든 신호를 받은 개체의 인덱스 값이 가장 작은 신호를 받은 개체의 배열 인덱스입니다. 일부 구현에서는 자세히 64 핸들을 전달 하는 경우는 <xref:System.NotSupportedException> throw 됩니다.  
  
 에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
## <a name="notes-on-exiting-the-context"></a>종료 컨텍스트에 대 한 참고 사항  
 합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitAny%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다. 멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 스레드 풀을 사용 하 여 동시에 여러 디스크에 파일을 검색 하는 방법에 설명 합니다. 공간 고려 사항에 대 한 각 디스크의 루트 디렉터리에만 검색 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal. If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우. 중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다. 시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다. 예외를 디버깅 하는 데 유용한 정보를 포함합니다.  
  
 현재 인스턴스가 신호를 받을 때까지 무기한으로이 메서드 블록의 호출자입니다. 이 메서드를 사용 하 여 될 때까지 차단는 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다. 자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 메서드 오버 로드 하 고-1을 지정 또는 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 첫 번째 매개 변수 및 `false` 두 번째 매개 변수에 대 한 합니다.  
  
 파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 백그라운드 스레드 실행이 완료를 기다리는 동안 종료 프로세스를 유지 하도록 대기 핸들을 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다. 이 메서드를 사용 하 여 될 때까지 차단는 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다. 자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.  
  
 파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.  
  
 이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 백그라운드 스레드 실행이 완료를 기다리는 동안 종료 프로세스를 유지 하도록 대기 핸들을 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <summary>Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다. 이 메서드를 사용 하 여 될 때까지 차단는 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다. 자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.  
  
 파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.  
  
 에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
 이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> 오버 로드 하 고 지정 `false` 에 대 한 `exitContext`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `millisecondsTimeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우. 중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다. 시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다. 예외를 디버깅 하는 데 유용한 정보를 포함합니다.  
  
 현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다. 이 메서드를 사용 하 여 될 때까지 차단는 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다. 자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.  
  
 파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.  
  
## <a name="notes-on-exiting-the-context"></a>종료 컨텍스트에 대 한 참고 사항  
 합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitOne%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다. 멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.  
  
   
  
## Examples  
 다음 예제와 방법을 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 동기화 도메인 내에서 호출 될 때 동작 하는 메서드 오버 로드 합니다. 사용 하 여 스레드가 대기 하는 먼저 `exitContext` 로 `false` 및 대기 시간 제한이 만료 될 때까지 차단 합니다. 두 번째 스레드가 실행 후 첫 번째 스레드가 종료 되 고 사용 하 여 대기 `exitContext` 로 `true`합니다. 이 두 번째 스레드에 대 한 대기 핸들이 신호에 대 한 호출 차단 되지 않은 경우 및 스레드 대기 시간 제한 전에 완료 합니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `timeout` 가 0 이면 메서드는 차단 하지 않습니다. 대기 핸들의 상태를 테스트 하 고 즉시 반환 합니다.  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 버전 2.0의에서 새로운 기능입니다. 이전 버전에서의 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드가 반환 되는 `true` 뮤텍스는 중단 하는 경우. 중단 된 뮤텍스는 종종 심각한 코딩 오류를 나타냅니다. 시스템 차원 뮤텍스의 경우 (예를 들어 Windows 작업 관리자 사용)가 응용 프로그램이 갑자기 종료 된 나타낼 수 있습니다. 예외를 디버깅 하는 데 유용한 정보를 포함합니다.  
  
 현재 인스턴스가 신호를 받거나 시간 초과 될 때까지이 메서드 블록의 호출자에 게 발생 합니다. 이 메서드를 사용 하 여 될 때까지 차단는 <xref:System.Threading.WaitHandle> 다른 스레드의 신호를 받으면와 같은 비동기 작업이 완료 될 때 생성 됩니다. 자세한 내용은 참조는 <xref:System.IAsyncResult> 인터페이스입니다.  
  
 파생된 클래스의 동작을 사용자 지정 하려면이 메서드를 재정의 합니다.  
  
 에 대 한 최대값 `timeout` 는 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.  
  
## <a name="notes-on-exiting-the-context"></a>종료 컨텍스트에 대 한 참고 사항  
 합니다 `exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.WaitHandle.WaitOne%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드. 스레드 호출 후 원래 컨텍스트로 되돌아갑니다는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다이 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>합니다. 이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다. 멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다. 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 백그라운드 스레드 실행이 완료를 기다리는 동안 종료 프로세스를 유지 하도록 대기 핸들을 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled. This field is constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필드의 가능한 반환 값 중 하나는 `WaitAny`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 스레드 풀을 사용 하 여 동시에 여러 디스크에 파일을 검색 하는 방법에 설명 합니다. 공간 고려 사항에 대 한 각 디스크의 루트 디렉터리에만 검색 됩니다.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>