<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Mutex.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac56bce0feaf14f66f8608164cfa777620d7f3b329f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6bce0feaf14f66f8608164cfa777620d7f3b329f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>A synchronization primitive that can also be used for interprocess synchronization.</source>
          <target state="translated">프로세스 간 동기화에 사용할 수도 있는 동기화 기본 형식입니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</source>
          <target state="translated">둘 이상의 스레드를 동시에 공유 리소스에 액세스 해야 할 때 시스템에는 동기화 메커니즘을 한 번에 한 스레드만 리소스를 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 하나의 스레드를 공유 리소스에 대 한 단독 액세스를 부여 하는 기본 동기화 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</source>
          <target state="translated">뮤텍스를 획득 하는 스레드를 첫 번째 스레드가 뮤텍스를 해제 하기 전까지 해당 뮤텍스를 획득 하려고 하는 두 번째 스레드가 일시 중단 됩니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">이 형식이 구현 하는 <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">직접 형식의 dispose를 호출 해당 <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> 에서 메서드는 <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> 블록입니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 <ph id="ph1">`using`</ph> (C#에서) 또는 <ph id="ph2">`Using`</ph> (Visual Basic)에서는 합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> 인터페이스 항목입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method to request ownership of a mutex.</source>
          <target state="translated">사용할 수는 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> 뮤텍스의 소유권을 요청 하는 메서드.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The calling thread blocks until one of the following occurs:</source>
          <target state="translated">호출 스레드가 차단 다음 중 하나가 발생할 때까지:</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The mutex is signaled to indicate that it is not owned.</source>
          <target state="translated">뮤텍스를 소유 하지 않은 나타내는 신호를 받는 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`true`</ph>, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</source>
          <target state="translated">이런 경우는 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 메서드 반환 <ph id="ph2">`true`</ph>, 호출 스레드가 뮤텍스의 소유권을 가정 하 고는 뮤텍스로 보호 된 리소스에 액세스 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When it has finished accessing the resource, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the mutex.</source>
          <target state="translated">스레드 호출 해야 리소스에 액세스 완료 될 때는 <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 뮤텍스의 소유권을 해제 하려면 메서드.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The first example in the Examples section illustrates this pattern.</source>
          <target state="translated">"예" 섹션의 첫 번째 예제에서는이 패턴을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The time-out interval specified in the call to a <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method that has a <ph id="ph2">`millisecondsTimeout`</ph> or <ph id="ph3">`timeout`</ph> parameter has elapsed.</source>
          <target state="translated">에 대 한 호출에 지정 된 시간 제한 간격은 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 변수가 있는 메서드는 <ph id="ph2">`millisecondsTimeout`</ph> 또는 <ph id="ph3">`timeout`</ph> 경과 된 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`false`</ph>, and the calling thread makes no further attempt to acquire ownership of the mutex.</source>
          <target state="translated">이런 경우는 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 메서드 반환 <ph id="ph2">`false`</ph>, 호출 스레드가 뮤텍스의 소유권을 획득 하려는 추가 시도 하지으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</source>
          <target state="translated">이 경우 호출 스레드에 뮤텍스의 보호 되는 리소스에 대 한 액세스 거부 되었습니다 되도록 코드를 구성 해야 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because the thread never acquired ownership of the mutex, it must not call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">호출 하지 않아야 스레드가 되지 뮤텍스의 소유권을 획득 하기 때문에 <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The second example in the Examples section illustrates this pattern.</source>
          <target state="translated">"예" 섹션의 두 번째 예제에서는이 패턴을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 뮤텍스를 가져온 스레드에서만 해제 될 수 있으므로 클래스는 스레드 id를 적용 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>By contrast, the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity.</source>
          <target state="translated">반면,는 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 클래스 스레드 id를 적용 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>A mutex can also be passed across application domain boundaries.</source>
          <target state="translated">뮤텍스 응용 프로그램 도메인 경계를 넘어 전달할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The thread that owns a mutex can request the same mutex in repeated calls to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> without blocking its execution.</source>
          <target state="translated">뮤텍스를 소유 하는 스레드는 같은 뮤텍스를 반복적으로 호출을 요청할 수 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 실행을 차단 하지 않고 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>However, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method the same number of times to release ownership of the mutex.</source>
          <target state="translated">그러나 스레드 호출 해야 합니다는 <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 메서드 뮤텍스의 소유권을 해제 하려면 동일한 횟수입니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class inherits from <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>, you can also call the static <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> methods to synchronize access to a protected resource.</source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 클래스에서 상속 <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>, 정적을 호출할 수도 있습니다 <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> 보호 된 리소스에 대 한 액세스를 동기화 하는 메서드.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
          <target state="translated">스레드가 뮤텍스를 소유 하는 동안 종료 되 면 뮤텍스가 중단 됩니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The state of the mutex is set to signaled, and the next waiting thread gets ownership.</source>
          <target state="translated">뮤텍스 상태 신호 받음으로 설정 되어 다음 대기 스레드가 소유권을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the abandoned mutex.</source>
          <target state="translated">.NET Framework 버전 2.0 부터는 <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> 중단 된 뮤텍스를 획득 하는 다음 스레드에서 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Before version 2.0 of the .NET Framework, no exception was thrown.</source>
          <target state="translated">.NET Framework 버전 2.0 이전 예외가 throw 되었습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
          <target state="translated">중단 된 뮤텍스는 코드의 심각한 오류를 나타내는 경우가 많습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
          <target state="translated">스레드가 뮤텍스를 해제 하지 않고 종료 되 면 뮤텍스의 보호를 받는 데이터 구조 일관성 있는 상태가 아닐 수 있습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
          <target state="translated">뮤텍스의 소유권을 요청 하는 다음 스레드에서이 예외를 처리 하 고 데이터 구조의 무결성을 확인할 수 있으면 계속 수 있습니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">시스템 차원 뮤텍스의 경우 중단된 뮤텍스는 응용 프로그램이 갑자기 종료되었음을 나타낼 수 있습니다(예: Windows 작업 관리자를 사용하여).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</source>
          <target state="translated">뮤텍스는 다음 두 가지 유형: 이며 명명 되지 않은 시스템 뮤텍스를 명명 된 로컬 뮤텍스 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>A local mutex exists only within your process.</source>
          <target state="translated">로컬 뮤텍스는 프로세스 내에만 존재합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>It can be used by any thread in your process that has a reference to the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the mutex.</source>
          <target state="translated">에 대 한 참조 프로세스의 모든 스레드에서 사용할 수는 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 뮤텍스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Each unnamed <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object represents a separate local mutex.</source>
          <target state="translated">명명 되지 않은 각 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 개체는 별도 로컬 뮤텍스를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</source>
          <target state="translated">명명 된 시스템 뮤텍스는 운영 체제 전체에 표시 되 고 프로세스 작업을 동기화 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can create a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex by using a constructor that accepts a name.</source>
          <target state="translated">만들 수는 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 이름을 허용 하는 생성자를 사용 하 여 명명된 된 시스템 뮤텍스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The operating-system object can be created at the same time, or it can exist before the creation of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object.</source>
          <target state="translated">같은 시간에 운영 체제 개체를 만들 수 있고 만들기 전에 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex, and you can use the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method to open an existing named system mutex.</source>
          <target state="translated">동일한 명명된 시스템 뮤텍스를 나타내는 여러 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 개체를 만들 수 있으며 <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> 메서드를 사용하여 기존 명명된 시스템 뮤텍스를 열 수 있습니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">이름이 접두사로 시작 하는 경우 "Global<ph id="ph1">\\</ph>", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">이름이 접두사로 시작 하는 경우 "로컬<ph id="ph1">\\</ph>", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬<ph id="ph1">\\</ph>"입니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">즉, 접두사 이름은 "Global<ph id="ph1">\\</ph>" 및 "로컬<ph id="ph2">\\</ph>" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">이 예제에서는 로컬 방법을 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the thread.</source>
          <target state="translated">호출 해야 하므로 각 호출 스레드가 뮤텍스의 소유권을 가져올 때까지 차단 되는 <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 스레드가 소유권을 해제 하려면 메서드.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In the following example, each thread calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29&gt;</ph> method to acquire the mutex.</source>
          <target state="translated">다음 예제에서는 각 스레드가 호출는 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29&gt;</ph> 뮤텍스를 획득 하는 메서드.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If the time-out interval elapses, the method returns <ph id="ph1">`false`</ph>, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</source>
          <target state="translated">메서드가 반환 하는 경우 시간 제한 간격이 지나면 <ph id="ph1">`false`</ph>, 스레드가 뮤텍스를 획득 아니고 뮤텍스의 보호 리소스에 액세스 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method is called only by the thread that acquires the mutex.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 메서드만 뮤텍스를 획득 하는 스레드에 의해 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This type is thread safe.</source>
          <target state="translated">이 형식은 스레드로부터 안전합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with default properties.</source>
          <target state="translated">기본 속성을 사용하여 <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>Calling this constructor overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor overload and specifying <ph id="ph2">`false`</ph> for initial ownership of the mutex.</source>
          <target state="translated">이 생성자 오버 로드는이 <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> 생성자 오버 로드를 지정 하 고 <ph id="ph2">`false`</ph> 뮤텍스의 초기 소유권에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>That is, the calling thread does not own the mutex.</source>
          <target state="translated">즉, 호출 스레드가 뮤텍스를 소유 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>The following code example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">다음 코드 예제는 로컬 방법을 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>The thread that creates the mutex does not own it initially.</source>
          <target state="translated">뮤텍스를 만드는 스레드는를 소유 하지 않습니다 처음 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the mutex; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">호출한 스레드에 뮤텍스의 초기 소유권을 부여하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</source>
          <target state="translated">호출한 스레드가 뮤텍스의 초기 소유권을 가져야 할지를 나타내는 부울 값을 사용하여 <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>The following code example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">다음 코드 예제는 로컬 방법을 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>The thread that creates the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> owns it initially.</source>
          <target state="translated">만드는 스레드는는 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 처음 소유 합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 호출의 결과로 명명된 시스템 뮤텍스가 만들어지는 경우 호출한 스레드에 명명된 시스템 뮤텍스의 초기 소유권을 부여하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>의 이름입니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">값이 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이면 <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>이(가) 명명되지 않습니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</source>
          <target state="translated">호출 스레드가 뮤텍스의 초기 소유권을 가져야 할지를 나타내는 부울 값과 뮤텍스 이름인 문자열을 사용하여 <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</source>
          <target state="translated">경우 <ph id="ph1">`name`</ph> 않습니다 <ph id="ph2">`null`</ph> 및 <ph id="ph3">`initiallyOwned`</ph> 은 <ph id="ph4">`true`</ph>,이 호출의 결과로 명명 된 시스템 뮤텍스가 만들어진 경우에 호출 스레드가 뮤텍스를 소유 합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Since there is no mechanism for determining whether the named system mutex was created, it is better to specify <ph id="ph1">`false`</ph> for <ph id="ph2">`initiallyOwned`</ph> when calling this constructor overload.</source>
          <target state="translated">지정 하는 것이 좋습니다 명명 된 시스템 뮤텍스가 만들어졌는지 여부를 결정 하기 위한 메커니즘이 없으므로 <ph id="ph1">`false`</ph> 에 대 한 <ph id="ph2">`initiallyOwned`</ph> 이 생성자 오버 로드를 호출할 때입니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor if you need to determine initial ownership.</source>
          <target state="translated">사용할 수는 <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> 시스템 뮤텍스의 초기 소유권을 확인 해야 하는 경우에 생성자입니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">여러 개 만들 수 있습니다 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">명명된 된 뮤텍스에 액세스 제어 보안을 이미 만들어졌습니다 하 고 호출자에 게 없는 경우 <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">기존 스레드 작업을 동기화 하는 데 필요한 이러한 권한이 포함 된 명명 된 뮤텍스를 열려면 참조는 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">지정 하는 경우 <ph id="ph1">`null`</ph> 또는 빈 문자열을 <ph id="ph2">`name`</ph>를 호출한 것 처럼 로컬 뮤텍스가 만들어지는 <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">이 경우 <ph id="ph1">`createdNew`</ph> 항상 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">시스템 수준 되기 때문에 명명 된 뮤텍스 프로세스 경계를 넘어 리소스 사용을 조정 하 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">이름이 접두사로 시작 하는 경우 "Global<ph id="ph1">\\</ph>", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">이름이 접두사로 시작 하는 경우 "로컬<ph id="ph1">\\</ph>", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬<ph id="ph1">\\</ph>"입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">즉, 접두사 이름은 "Global<ph id="ph1">\\</ph>" 및 "로컬<ph id="ph2">\\</ph>" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The following example shows how a named mutex is used to signal between threads running in two separate processes.</source>
          <target state="translated">다음 예제에서는 명명된 된 뮤텍스 두 개의 별도 프로세스에서 실행 되는 스레드 간에 신호 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Run this program from two or more command windows.</source>
          <target state="translated">두 개 이상의 명령 창에서이 프로그램을 실행 합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Each process creates a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the named mutex <ph id="ph2">`MyMutex`</ph>.</source>
          <target state="translated">각 프로세스는 한 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 명명 된 뮤텍스를 나타내는 <ph id="ph2">`MyMutex`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is a system object whose lifetime is bounded by the lifetimes of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it.</source>
          <target state="translated">명명 된 뮤텍스는 수명이의 수명을으로 제한 된 시스템 개체는 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 뮤텍스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is created when the first process creates its <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object; in this example, the named mutex is owned by the first process that runs the program.</source>
          <target state="translated">명명 된 뮤텍스는 첫 번째 프로세스 때 만들어집니다 해당 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 개체; 프로그램을 실행 하는 첫 번째 프로세스가이 예제에서는 명명 된 뮤텍스가 소유 합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is destroyed when all the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it have been released.</source>
          <target state="translated">명명 된 뮤텍스 소멸 될 때 모든는 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 뮤텍스를 나타내는 릴리스 되었습니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</source>
          <target state="translated">이 예제에서 사용 하는 생성자 오버 로드 호출 스레드 명명된 뮤텍스의 초기 소유권을 부여 되었는지 여부를 알 수 없습니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</source>
          <target state="translated">스레드 명명 된 뮤텍스 만든다고 제어할 수 있습니다 하지 않는 한 시스템 뮤텍스의 초기 소유권을 요청 하려면이 생성자를 사용 하지 해야 합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">명명된 뮤텍스가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>이 없는 경우</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 뮤텍스를 만들 수 없는 경우</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 호출의 결과로 명명된 시스템 뮤텍스가 만들어지는 경우 호출한 스레드에 명명된 시스템 뮤텍스의 초기 소유권을 부여하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>의 이름입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">값이 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이면 <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>이(가) 명명되지 않습니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system mutex already existed.</source>
          <target state="translated">이 메서드가 반환될 때 로컬 뮤텍스가 만들어진 경우(즉, <bpt id="p1">&lt;c&gt;</bpt>이름<ept id="p1">&lt;/c&gt;</ept>이 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이거나 빈 문자열인 경우)나 지정된 명명된 시스템 뮤텍스가 만들어진 경우에는 <ph id="ph1">&lt;see langword="true" /&gt;</ph>인 부울이 포함되고, 지정된 명명된 시스템 뮤텍스가 이미 있는 경우에는 <ph id="ph3">&lt;see langword="false" /&gt;</ph>가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</source>
          <target state="translated">호출한 스레드가 뮤텍스의 초기 소유권을 가져야 할지를 나타내는 부울 값, 뮤텍스의 이름인 문자열 및 메서드에서 반환할 때 호출한 스레드에 뮤텍스의 초기 소유권이 부여되었는지를 나타내는 부울 값을 사용하여 <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
          <target state="translated">경우 <ph id="ph1">`name`</ph> 않습니다 <ph id="ph2">`null`</ph> 및 <ph id="ph3">`initiallyOwned`</ph> 은 <ph id="ph4">`true`</ph>, 경우에만 명명 된 뮤텍스를 소유 하는 호출 스레드에서 <ph id="ph5">`createdNew`</ph> 은 <ph id="ph6">`true`</ph> 호출 후 합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">그렇지 않으면 스레드가 않으면 호출 하 여는 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">여러 개 만들 수 있습니다 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph> rights, an exception is thrown.</source>
          <target state="translated">명명된 된 뮤텍스에 액세스 제어 보안을 이미 만들어졌습니다 하 고 호출자에 게 없는 경우 <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph> 권한, 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">기존 스레드 작업을 동기화 하는 데 필요한 이러한 권한이 포함 된 명명 된 뮤텍스를 열려면 참조는 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">지정 하는 경우 <ph id="ph1">`null`</ph> 또는 빈 문자열을 <ph id="ph2">`name`</ph>를 호출한 것 처럼 로컬 뮤텍스가 만들어지는 <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">이 경우 <ph id="ph1">`createdNew`</ph> 항상 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">시스템 수준 되기 때문에 명명 된 뮤텍스 프로세스 경계를 넘어 리소스 사용을 조정 하 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">이름이 접두사로 시작 하는 경우 "Global<ph id="ph1">\\</ph>", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">이름이 접두사로 시작 하는 경우 "로컬<ph id="ph1">\\</ph>", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬<ph id="ph1">\\</ph>"입니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">즉, 접두사 이름은 "Global<ph id="ph1">\\</ph>" 및 "로컬<ph id="ph2">\\</ph>" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The following code example shows how a named mutex is used to signal between processes or threads.</source>
          <target state="translated">다음 코드 예제에서는 명명된 된 뮤텍스 프로세스 또는 스레드 간에 신호 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Run this program from two or more command windows.</source>
          <target state="translated">두 개 이상의 명령 창에서이 프로그램을 실행 합니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Each process creates a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the named mutex "MyMutex".</source>
          <target state="translated">각 프로세스는 한 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> "인 MyMutex" 명명 된 뮤텍스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is a system object.</source>
          <target state="translated">명명 된 뮤텍스는 시스템 개체입니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In this example, its lifetime is bounded by the lifetimes of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it.</source>
          <target state="translated">이 예제에서는 그 수명은의 수명에 의해 제한 됩니다는 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 뮤텍스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is created when the first process creates its local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object, and destroyed when all the <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it have been released.</source>
          <target state="translated">첫 번째 프로세스는 로컬에서 명명 된 뮤텍스 생성 됩니다 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 개체를 소멸 될 때 모든는 <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> 뮤텍스를 나타내는 릴리스 되었습니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is initially owned by the first process.</source>
          <target state="translated">명명 된 뮤텍스는 처음 첫 번째 프로세스에 의해 소유 됩니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The second process and any subsequent processes wait for earlier processes to release the named mutex.</source>
          <target state="translated">두 번째 프로세스 및 모든 후속 프로세스 이전 프로세스 명명 된 뮤텍스를 해제 될 때까지 기다립니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">명명된 뮤텍스가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>이 없는 경우</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 뮤텍스를 만들 수 없는 경우</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 호출의 결과로 명명된 시스템 뮤텍스가 만들어지는 경우 호출한 스레드에 명명된 시스템 뮤텍스의 초기 소유권을 부여하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The name of the system mutex.</source>
          <target state="translated">시스템 뮤텍스의 이름입니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">값이 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이면 <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>이(가) 명명되지 않습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system mutex already existed.</source>
          <target state="translated">이 메서드가 반환될 때 로컬 뮤텍스가 만들어진 경우(즉, <bpt id="p1">&lt;c&gt;</bpt>이름<ept id="p1">&lt;/c&gt;</ept>이 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이거나 빈 문자열인 경우)나 지정된 명명된 시스템 뮤텍스가 만들어진 경우에는 <ph id="ph1">&lt;see langword="true" /&gt;</ph>인 부울이 포함되고, 지정된 명명된 시스템 뮤텍스가 이미 있는 경우에는 <ph id="ph3">&lt;see langword="false" /&gt;</ph>가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
          <target state="translated">명명된 시스템 뮤텍스에 적용할 액세스 제어 보안을 나타내는 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</source>
          <target state="translated">호출한 스레드가 뮤텍스의 초기 소유권을 가져야 할지를 나타내는 부울 값, 뮤텍스의 이름인 문자열 및 메서드에서 반환할 때 호출한 스레드에 뮤텍스의 초기 소유권이 부여되었는지와 명명된 뮤텍스에 적용할 액세스 제어 보안을 나타내는 부울 변수를 사용하여 <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
          <target state="translated">경우 <ph id="ph1">`name`</ph> 않습니다 <ph id="ph2">`null`</ph> 및 <ph id="ph3">`initiallyOwned`</ph> 은 <ph id="ph4">`true`</ph>, 경우에만 명명 된 뮤텍스를 소유 하는 호출 스레드에서 <ph id="ph5">`createdNew`</ph> 은 <ph id="ph6">`true`</ph> 호출 후 합니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">그렇지 않으면 스레드가 않으면 호출 하 여는 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</source>
          <target state="translated">이 생성자를 사용 하 여 인해 다른 코드에서 뮤텍스의 제어권을 만들 때 명명 된 시스템 뮤텍스에 액세스 제어 보안을 적용 합니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">여러 개 만들 수 있습니다 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named system mutex does not exist, it is created with the specified access control security.</source>
          <target state="translated">명명된 된 시스템 뮤텍스가 존재 하지 않는 경우 지정 된 액세스 제어 보안으로 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named mutex exists, the specified access control security is ignored.</source>
          <target state="translated">명명 된 뮤텍스가 존재 하는 경우 지정 된 액세스 제어 보안 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object even if <ph id="ph2">`mutexSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">새로 만든에 대 한 모든 권한을 호출자에 게 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 경우에도 개체 <ph id="ph2">`mutexSecurity`</ph> 거부 없거나 현재 사용자에 게 일부 액세스 권한을 부여에 실패 합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object to represent the same named mutex, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">그러나 현재 사용자가 다른 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 개체를 나타내는 동일한 명명 된 뮤텍스를 사용 하 여 생성자 또는 <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> 메서드를 Windows 액세스 제어 보안 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">명명된 된 뮤텍스에 액세스 제어 보안을 이미 만들어졌습니다 하 고 호출자에 게 없는 경우 <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">기존 스레드 작업을 동기화 하는 데 필요한 이러한 권한이 포함 된 명명 된 뮤텍스를 열려면 참조는 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">지정 하는 경우 <ph id="ph1">`null`</ph> 또는 빈 문자열을 <ph id="ph2">`name`</ph>를 호출한 것 처럼 로컬 뮤텍스가 만들어지는 <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">이 경우 <ph id="ph1">`createdNew`</ph> 항상 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">시스템 수준 되기 때문에 명명 된 뮤텍스 프로세스 경계를 넘어 리소스 사용을 조정 하 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">이름이 접두사로 시작 하는 경우 "Global<ph id="ph1">\\</ph>", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">이름이 접두사로 시작 하는 경우 "로컬<ph id="ph1">\\</ph>", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬<ph id="ph1">\\</ph>"입니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">즉, 접두사 이름은 "Global<ph id="ph1">\\</ph>" 및 "로컬<ph id="ph2">\\</ph>" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">이 예제에서는 사용은 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 뮤텍스를 엽니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">명명된 뮤텍스가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>이 없는 경우</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 뮤텍스를 만들 수 없는 경우</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security for the named mutex.</source>
          <target state="translated">명명된 뮤텍스에 대한 액세스 제어 보안을 나타내는 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security for the named mutex.</source>
          <target state="translated">명명된 뮤텍스에 대한 액세스 제어 보안을 나타내는 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> 메서드 플래그 (비트 OR 연산을 사용 하 여 결합)는 다음과 같은 조합을 사용 하 여 사용 권한을 검색할: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, 및 <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">사용자에 게 있어야 <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> 이 메서드를 호출 하는 뮤텍스를 열려 있어야와 <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">이 예제에서는 사용은 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions, using the <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 하 여 사용 권한을 변경 하는 데 필요한 권한을 뮤텍스를 여는 <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object represents a named system mutex, but the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> 개체가 명명된 시스템 뮤텍스를 나타내지만 사용자에게 <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>가 없는 경우</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object represents a named system mutex, and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> 개체가 명명된 시스템 뮤텍스를 나타내지만 <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>를 사용하여 열리지 않은 경우</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Windows 98 또는 Windows Millennium Edition에서 지원되지 않는 경우</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Opens a specified named mutex, if it already exists.</source>
          <target state="translated">이미 있는 경우 지정한 명명된 뮤텍스를 엽니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">열려는 시스템 뮤텍스의 이름입니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Opens the specified named mutex, if it already exists.</source>
          <target state="translated">이미 있는 경우 지정한 명명된 뮤텍스를 엽니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>An object that represents the named system mutex.</source>
          <target state="translated">명명된 시스템 뮤텍스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open the specified named system mutex.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> 명명 된 시스템 뮤텍스가 메서드는 지정 된 열려고 시도 합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
          <target state="translated">된 시스템 뮤텍스가 존재 하지 않는 경우이 메서드는 시스템 개체를 만들지 않고 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 <ph id="ph1">`name`</ph> 동일한 반드시 반환 하지 않는 <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">이 메서드 오버 로드 하는 것은 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> 메서드 오버 로드를 지정 하 고 <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">지정 하는 <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> 플래그에 뮤텍스를 대기 하는 스레드를 사용 하 고 지정 하는 <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> 플래그를 호출 하는 스레드를 사용할 수 있습니다는 <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">이 예제에서는 사용은 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 뮤텍스를 엽니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The named mutex does not exist.</source>
          <target state="translated">명명된 뮤텍스가 없는 경우</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">명명된 뮤텍스가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">열려는 시스템 뮤텍스의 이름입니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Opens the specified named mutex, if it already exists, with the desired security access.</source>
          <target state="translated">이미 있는 경우 지정한 명명된 뮤텍스를 원하는 보안 액세스로 엽니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>An object that represents the named system mutex.</source>
          <target state="translated">명명된 시스템 뮤텍스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> 매개 변수를 포함 해야 합니다는 <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> 뮤텍스를 대기 하는 스레드를 허용 하도록 플래그 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> 호출 하는 스레드를 허용 하도록 플래그는 <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open an existing named mutex.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> 메서드는 기존의 명명 된 뮤텍스를 열려고 합니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
          <target state="translated">된 시스템 뮤텍스가 존재 하지 않는 경우이 메서드는 시스템 개체를 만들지 않고 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 <ph id="ph1">`name`</ph> 동일한 반드시 반환 하지 않는 <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">이 예제에서는 사용은 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 뮤텍스를 엽니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The named mutex does not exist.</source>
          <target state="translated">명명된 뮤텍스가 없는 경우</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The named mutex exists, but the user does not have the desired security access.</source>
          <target state="translated">명명된 뮤텍스가 있지만 사용자에게 필요한 보안 액세스가 없습니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Releases the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> once.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>을(를) 한 번 해제합니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Whenever a thread acquires a mutex (for example, by calling its <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method), it must subsequently call <ph id="ph2">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</source>
          <target state="translated">스레드가 뮤텍스를 획득 될 때마다 (예를 들어 호출 하 여 해당 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 메서드), 이후에 호출 해야 <ph id="ph2">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 뮤텍스의 소유권을 사용 하지 못하고 뮤텍스의 소유권을 얻으려고 시도 하는 다른 스레드를 차단 해제를 합니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If the attempt to get ownership of the mutex fails (for example, when a call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method with a <ph id="ph2">`millisecondsTimeout`</ph> or a <ph id="ph3">`timeout`</ph> parameter returns <ph id="ph4">`false`</ph> because the request times out), the thread shouldn't call <ph id="ph5">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</source>
          <target state="translated">뮤텍스의 소유권을 가져오려는 시도가 실패 하는 경우 (예를 들어 경우에 대 한 호출은 <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> 메서드는 <ph id="ph2">`millisecondsTimeout`</ph> 또는 <ph id="ph3">`timeout`</ph> 매개 변수를 반환 <ph id="ph4">`false`</ph> 요청 시간이 초과 하기 때문에), 스레드 호출 해서는 안 <ph id="ph5">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>,이 대/소문자는 스레드도 하지 수 있어야 뮤텍스의 다음 예제와 같이 보호를 받는 리소스에 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</source>
          <target state="translated">뮤텍스를 소유 하는 스레드 실행을 차단 하지 않고 반복 된 대기 함수 호출에 같은 뮤텍스를 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The number of calls is kept by the common language runtime.</source>
          <target state="translated">공용 언어 런타임에 의해 호출 수가 유지 됩니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The thread must call <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> the same number of times to release ownership of the mutex.</source>
          <target state="translated">스레드에서 <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 뮤텍스의 소유권을 해제 하려면 동일한 횟수입니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
          <target state="translated">스레드가 뮤텍스를 소유 하는 동안 종료 되 면 뮤텍스가 중단 됩니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The state of the mutex is set to signaled and the next waiting thread gets ownership.</source>
          <target state="translated">뮤텍스 상태 신호 설정 되 고 대기 중인 다음 스레드가 소유권을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If no one owns the mutex, the state of the mutex is signaled.</source>
          <target state="translated">뮤텍스를 소유 아무도 뮤텍스의 상태 신호입니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the mutex.</source>
          <target state="translated">.NET Framework 버전 2.0 부터는 <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> 뮤텍스를 획득 하는 다음 스레드에서 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Prior to version 2.0 of the .NET Framework, no exception was thrown.</source>
          <target state="translated">.NET Framework 버전 2.0 이전 예외가 throw 되었습니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
          <target state="translated">중단 된 뮤텍스는 코드의 심각한 오류를 나타내는 경우가 많습니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
          <target state="translated">스레드가 뮤텍스를 해제 하지 않고 종료 되 면 뮤텍스의 보호를 받는 데이터 구조 일관성 있는 상태가 아닐 수 있습니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
          <target state="translated">뮤텍스의 소유권을 요청 하는 다음 스레드에서이 예외를 처리 하 고 데이터 구조의 무결성을 확인할 수 있으면 계속 수 있습니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">시스템 차원 뮤텍스의 경우 중단된 뮤텍스는 응용 프로그램이 갑자기 종료되었음을 나타낼 수 있습니다(예: Windows 작업 관리자를 사용하여).</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The following example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">다음 예제에서는 로컬 방법을 <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The thread that creates the mutex does not own it initially.</source>
          <target state="translated">뮤텍스를 만드는 스레드는를 소유 하지 않습니다 처음 합니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method is used to release the mutex when it is no longer needed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 메서드는 더 이상 필요 없는 뮤텍스를 해제 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The calling thread does not own the mutex.</source>
          <target state="translated">호출 스레드가 뮤텍스를 소유하지 않습니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The current instance has already been disposed.</source>
          <target state="translated">현재 인스턴스가 이미 삭제된 경우</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
          <target state="translated">명명된 시스템 뮤텍스에 적용할 액세스 제어 보안을 나타내는 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>Sets the access control security for a named system mutex.</source>
          <target state="translated">명명된 시스템 뮤텍스에 액세스 제어 보안을 설정합니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">사용자에 게 있어야 <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> 뮤텍스 및이 메서드를 호출 하는 권한으로 연 해야 <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">이 예제에서는 사용은 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions, using the <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">예외가 발견 되 고 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> 메서드 오버 로드를 읽고 사용 하 여 사용 권한을 변경 하는 데 필요한 권한을 뮤텍스를 여는 <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;paramref name="mutexSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mutexSecurity" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">사용자에게 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>가 없는 경우</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The mutex was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">뮤텍스가 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>를 사용하여 열리지 않은 경우</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object does not represent a named system mutex.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> 개체가 명명된 시스템 뮤텍스를 나타내지 않는 경우</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">지정한 명명된 뮤텍스(이미 존재하는 경우)를 열고 작업이 수행되었는지를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">열려는 시스템 뮤텍스의 이름입니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">이 메서드가 반환될 때 호출이 성공적으로 실행된 경우 이름이 지정된 뮤텍스를 나타내는 <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> 개체를 포함하고 호출에 실패한 경우는 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을(를) 포함해야 합니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">지정한 명명된 뮤텍스(이미 존재하는 경우)를 열고 작업이 수행되었는지를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">명명된 뮤텍스를 열었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>If the named mutex does not exist, this method does not create it.</source>
          <target state="translated">명명 된 뮤텍스가 존재 하지 않는 경우이 메서드가 만드는 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
          <target state="translated">대신이 메서드 오버 로드를 사용 하 여 명명된 된 뮤텍스 있는지 잘 모르는 경우는 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> 뮤텍스가 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 <ph id="ph1">`name`</ph> 동일한 반드시 반환 하지 않는 <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">이 메서드 오버 로드 하는 것은 <ph id="ph1">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> 메서드 오버 로드를 지정 하 고 <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">지정 하는 <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> 플래그에 뮤텍스를 대기 하는 스레드를 사용 하 고 지정 하는 <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> 플래그를 호출 하는 스레드를 사용할 수 있습니다는 <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">명명된 뮤텍스가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">열려는 시스템 뮤텍스의 이름입니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">이 메서드가 반환될 때 호출이 성공적으로 실행된 경우 이름이 지정된 뮤텍스를 나타내는 <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> 개체를 포함하고 호출에 실패한 경우는 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을(를) 포함해야 합니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">지정된 명명된 뮤텍스를 원하는 보안 액세스 상태에서 열고 작업이 수행되었는지를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">명명된 뮤텍스를 열었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>If the named mutex does not exist, this method does not create it.</source>
          <target state="translated">명명 된 뮤텍스가 존재 하지 않는 경우이 메서드가 만드는 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> 있는 생성자는 <ph id="ph2">`name`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
          <target state="translated">대신이 메서드 오버 로드를 사용 하 여 명명된 된 뮤텍스 있는지 잘 모르는 경우는 <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> 뮤텍스가 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> 매개 변수를 포함 해야 합니다는 <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> 뮤텍스를 대기 하는 스레드를 허용 하도록 플래그 및 <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> 호출 하는 스레드를 허용 하도록 플래그는 <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 <ph id="ph1">`name`</ph> 동일한 반드시 반환 하지 않는 <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 빈 문자열인 경우</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 260자 보다 긴 경우</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">명명된 뮤텍스가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>