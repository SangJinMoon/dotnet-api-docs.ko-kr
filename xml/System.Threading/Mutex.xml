<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6bce0feaf14f66f8608164cfa777620d7f3b329f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530997" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>프로세스 간 동기화에 사용할 수도 있는 동기화 기본 형식입니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 둘 이상의 스레드를 동시에 공유 리소스에 액세스 해야 할 때 시스템에는 동기화 메커니즘을 한 번에 한 스레드만 리소스를 사용 해야 합니다. <xref:System.Threading.Mutex> 하나의 스레드를 공유 리소스에 대 한 단독 액세스를 부여 하는 기본 동기화 합니다. 뮤텍스를 획득 하는 스레드를 첫 번째 스레드가 뮤텍스를 해제 하기 전까지 해당 뮤텍스를 획득 하려고 하는 두 번째 스레드가 일시 중단 됩니다.  
  
> [!IMPORTANT]
>  이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다. 직접 형식의 dispose를 호출 해당 <xref:System.IDisposable.Dispose%2A> 에서 메서드는 `try` / `catch` 블록입니다. 작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다. 자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
 사용할 수는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 뮤텍스의 소유권을 요청 하는 메서드. 호출 스레드가 차단 다음 중 하나가 발생할 때까지:  
  
-   뮤텍스를 소유 하지 않은 나타내는 신호를 받는 합니다. 이런 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드 반환 `true`, 호출 스레드가 뮤텍스의 소유권을 가정 하 고는 뮤텍스로 보호 된 리소스에 액세스 하 고 있습니다. 스레드 호출 해야 리소스에 액세스 완료 될 때는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 뮤텍스의 소유권을 해제 하려면 메서드. "예" 섹션의 첫 번째 예제에서는이 패턴을 보여 줍니다.  
  
-   에 대 한 호출에 지정 된 시간 제한 간격은 <xref:System.Threading.WaitHandle.WaitOne%2A> 변수가 있는 메서드는 `millisecondsTimeout` 또는 `timeout` 경과 된 매개 변수입니다. 이런 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드 반환 `false`, 호출 스레드가 뮤텍스의 소유권을 획득 하려는 추가 시도 하지으로 만듭니다. 이 경우 호출 스레드에 뮤텍스의 보호 되는 리소스에 대 한 액세스 거부 되었습니다 되도록 코드를 구성 해야 합니다. 호출 하지 않아야 스레드가 되지 뮤텍스의 소유권을 획득 하기 때문에 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드. "예" 섹션의 두 번째 예제에서는이 패턴을 보여 줍니다.  
  
 <xref:System.Threading.Mutex> 뮤텍스를 가져온 스레드에서만 해제 될 수 있으므로 클래스는 스레드 id를 적용 합니다. 반면,는 <xref:System.Threading.Semaphore> 클래스 스레드 id를 적용 하지 않습니다. 뮤텍스 응용 프로그램 도메인 경계를 넘어 전달할 수도 있습니다.  
  
 뮤텍스를 소유 하는 스레드는 같은 뮤텍스를 반복적으로 호출을 요청할 수 <xref:System.Threading.WaitHandle.WaitOne%2A> 실행을 차단 하지 않고 있습니다. 그러나 스레드 호출 해야 합니다는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드 뮤텍스의 소유권을 해제 하려면 동일한 횟수입니다.  
  
 때문에 <xref:System.Threading.Mutex> 클래스에서 상속 <xref:System.Threading.WaitHandle>, 정적을 호출할 수도 있습니다 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> 및 <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> 보호 된 리소스에 대 한 액세스를 동기화 하는 메서드.  
  
 스레드가 뮤텍스를 소유 하는 동안 종료 되 면 뮤텍스가 중단 됩니다. 뮤텍스 상태 신호 받음으로 설정 되어 다음 대기 스레드가 소유권을 가져옵니다. .NET Framework 버전 2.0 부터는 <xref:System.Threading.AbandonedMutexException> 중단 된 뮤텍스를 획득 하는 다음 스레드에서 throw 됩니다. .NET Framework 버전 2.0 이전 예외가 throw 되었습니다.  
  
> [!CAUTION]
>  중단 된 뮤텍스는 코드의 심각한 오류를 나타내는 경우가 많습니다. 스레드가 뮤텍스를 해제 하지 않고 종료 되 면 뮤텍스의 보호를 받는 데이터 구조 일관성 있는 상태가 아닐 수 있습니다. 뮤텍스의 소유권을 요청 하는 다음 스레드에서이 예외를 처리 하 고 데이터 구조의 무결성을 확인할 수 있으면 계속 수 있습니다.  
  
 시스템 차원 뮤텍스의 경우 중단된 뮤텍스는 응용 프로그램이 갑자기 종료되었음을 나타낼 수 있습니다(예: Windows 작업 관리자를 사용하여).  
  
 뮤텍스는 다음 두 가지 유형: 이며 명명 되지 않은 시스템 뮤텍스를 명명 된 로컬 뮤텍스 합니다. 로컬 뮤텍스는 프로세스 내에만 존재합니다. 에 대 한 참조 프로세스의 모든 스레드에서 사용할 수는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 개체입니다. 명명 되지 않은 각 <xref:System.Threading.Mutex> 개체는 별도 로컬 뮤텍스를 나타냅니다.  
  
 명명 된 시스템 뮤텍스는 운영 체제 전체에 표시 되 고 프로세스 작업을 동기화 할 수 있습니다. 만들 수는 <xref:System.Threading.Mutex> 이름을 허용 하는 생성자를 사용 하 여 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 같은 시간에 운영 체제 개체를 만들 수 있고 만들기 전에 <xref:System.Threading.Mutex> 개체입니다. 동일한 명명된 시스템 뮤텍스를 나타내는 여러 <xref:System.Threading.Mutex> 개체를 만들 수 있으며 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드를 사용하여 기존 명명된 시스템 뮤텍스를 열 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다. 이름이 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 이름이 접두사로 시작 하는 경우 "로컬\\", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서. 즉, 접두사 이름은 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 이 예제에서는 로컬 방법을 <xref:System.Threading.Mutex> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다. 호출 해야 하므로 각 호출 스레드가 뮤텍스의 소유권을 가져올 때까지 차단 되는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 스레드가 소유권을 해제 하려면 메서드.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 다음 예제에서는 각 스레드가 호출는 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> 뮤텍스를 획득 하는 메서드. 메서드가 반환 하는 경우 시간 제한 간격이 지나면 `false`, 스레드가 뮤텍스를 획득 아니고 뮤텍스의 보호 리소스에 액세스 하 고 있습니다. <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드만 뮤텍스를 획득 하는 스레드에 의해 호출 됩니다.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>기본 속성을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자 오버 로드는이 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자 오버 로드를 지정 하 고 `false` 뮤텍스의 초기 소유권에 대 한 합니다. 즉, 호출 스레드가 뮤텍스를 소유 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제는 로컬 방법을 <xref:System.Threading.Mutex> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다. 뮤텍스를 만드는 스레드는를 소유 하지 않습니다 처음 합니다.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          호출한 스레드에 뮤텍스의 초기 소유권을 부여하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>호출한 스레드가 뮤텍스의 초기 소유권을 가져야 할지를 나타내는 부울 값을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제는 로컬 방법을 <xref:System.Threading.Mutex> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다. 만드는 스레드는는 <xref:System.Threading.Mutex> 처음 소유 합니다.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          이 호출의 결과로 명명된 시스템 뮤텍스가 만들어지는 경우 호출한 스레드에 명명된 시스템 뮤텍스의 초기 소유권을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="name">
          <see cref="T:System.Threading.Mutex" />의 이름입니다. 값이 <see langword="null" />이면 <see cref="T:System.Threading.Mutex" />이(가) 명명되지 않습니다.</param>
        <summary>호출 스레드가 뮤텍스의 초기 소유권을 가져야 할지를 나타내는 부울 값과 뮤텍스 이름인 문자열을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `name` 않습니다 `null` 및 `initiallyOwned` 은 `true`,이 호출의 결과로 명명 된 시스템 뮤텍스가 만들어진 경우에 호출 스레드가 뮤텍스를 소유 합니다. 지정 하는 것이 좋습니다 명명 된 시스템 뮤텍스가 만들어졌는지 여부를 결정 하기 위한 메커니즘이 없으므로 `false` 에 대 한 `initiallyOwned` 이 생성자 오버 로드를 호출할 때입니다. 사용할 수는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> 시스템 뮤텍스의 초기 소유권을 확인 해야 하는 경우에 생성자입니다.  
  
 이 생성자는 <xref:System.Threading.Mutex> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 여러 개 만들 수 있습니다 <xref:System.Threading.Mutex> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.  
  
 명명된 된 뮤텍스에 액세스 제어 보안을 이미 만들어졌습니다 하 고 호출자에 게 없는 경우 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, 예외가 throw 됩니다. 기존 스레드 작업을 동기화 하는 데 필요한 이러한 권한이 포함 된 명명 된 뮤텍스를 열려면 참조는 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드.  
  
 지정 하는 경우 `null` 또는 빈 문자열을 `name`를 호출한 것 처럼 로컬 뮤텍스가 만들어지는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자입니다. 이 경우 `createdNew` 항상 `true`합니다.  
  
 시스템 수준 되기 때문에 명명 된 뮤텍스 프로세스 경계를 넘어 리소스 사용을 조정 하 사용할 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다. 이름이 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 이름이 접두사로 시작 하는 경우 "로컬\\", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서. 즉, 접두사 이름은 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 다음 예제에서는 명명된 된 뮤텍스 두 개의 별도 프로세스에서 실행 되는 스레드 간에 신호 하는 방법을 보여 줍니다.  
  
 두 개 이상의 명령 창에서이 프로그램을 실행 합니다. 각 프로세스는 한 <xref:System.Threading.Mutex> 명명 된 뮤텍스를 나타내는 `MyMutex`합니다. 명명 된 뮤텍스는 수명이의 수명을으로 제한 된 시스템 개체는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 개체입니다. 명명 된 뮤텍스는 첫 번째 프로세스 때 만들어집니다 해당 <xref:System.Threading.Mutex> 개체; 프로그램을 실행 하는 첫 번째 프로세스가이 예제에서는 명명 된 뮤텍스가 소유 합니다. 명명 된 뮤텍스 소멸 될 때 모든는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 릴리스 되었습니다.  
  
 이 예제에서 사용 하는 생성자 오버 로드 호출 스레드 명명된 뮤텍스의 초기 소유권을 부여 되었는지 여부를 알 수 없습니다. 스레드 명명 된 뮤텍스 만든다고 제어할 수 있습니다 하지 않는 한 시스템 뮤텍스의 초기 소유권을 요청 하려면이 생성자를 사용 하지 해야 합니다.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />이 없는 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 뮤텍스를 만들 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 260자 보다 긴 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          이 호출의 결과로 명명된 시스템 뮤텍스가 만들어지는 경우 호출한 스레드에 명명된 시스템 뮤텍스의 초기 소유권을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="name">
          <see cref="T:System.Threading.Mutex" />의 이름입니다. 값이 <see langword="null" />이면 <see cref="T:System.Threading.Mutex" />이(가) 명명되지 않습니다.</param>
        <param name="createdNew">이 메서드가 반환될 때 로컬 뮤텍스가 만들어진 경우(즉, <c>이름</c>이 <see langword="null" />이거나 빈 문자열인 경우)나 지정된 명명된 시스템 뮤텍스가 만들어진 경우에는 <see langword="true" />인 부울이 포함되고, 지정된 명명된 시스템 뮤텍스가 이미 있는 경우에는 <see langword="false" />가 포함됩니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <summary>호출한 스레드가 뮤텍스의 초기 소유권을 가져야 할지를 나타내는 부울 값, 뮤텍스의 이름인 문자열 및 메서드에서 반환할 때 호출한 스레드에 뮤텍스의 초기 소유권이 부여되었는지를 나타내는 부울 값을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `name` 않습니다 `null` 및 `initiallyOwned` 은 `true`, 경우에만 명명 된 뮤텍스를 소유 하는 호출 스레드에서 `createdNew` 은 `true` 호출 후 합니다. 그렇지 않으면 스레드가 않으면 호출 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드.  
  
 이 생성자는 <xref:System.Threading.Mutex> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 여러 개 만들 수 있습니다 <xref:System.Threading.Mutex> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.  
  
 명명된 된 뮤텍스에 액세스 제어 보안을 이미 만들어졌습니다 하 고 호출자에 게 없는 경우 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> 권한, 예외가 throw 됩니다. 기존 스레드 작업을 동기화 하는 데 필요한 이러한 권한이 포함 된 명명 된 뮤텍스를 열려면 참조는 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드.  
  
 지정 하는 경우 `null` 또는 빈 문자열을 `name`를 호출한 것 처럼 로컬 뮤텍스가 만들어지는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자입니다. 이 경우 `createdNew` 항상 `true`합니다.  
  
 시스템 수준 되기 때문에 명명 된 뮤텍스 프로세스 경계를 넘어 리소스 사용을 조정 하 사용할 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다. 이름이 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 이름이 접두사로 시작 하는 경우 "로컬\\", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서. 즉, 접두사 이름은 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 다음 코드 예제에서는 명명된 된 뮤텍스 프로세스 또는 스레드 간에 신호 하는 방법을 보여 줍니다. 두 개 이상의 명령 창에서이 프로그램을 실행 합니다. 각 프로세스는 한 <xref:System.Threading.Mutex> "인 MyMutex" 명명 된 뮤텍스를 나타내는 개체입니다. 명명 된 뮤텍스는 시스템 개체입니다. 이 예제에서는 그 수명은의 수명에 의해 제한 됩니다는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 개체입니다. 첫 번째 프로세스는 로컬에서 명명 된 뮤텍스 생성 됩니다 <xref:System.Threading.Mutex> 개체를 소멸 될 때 모든는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 릴리스 되었습니다. 명명 된 뮤텍스는 처음 첫 번째 프로세스에 의해 소유 됩니다. 두 번째 프로세스 및 모든 후속 프로세스 이전 프로세스 명명 된 뮤텍스를 해제 될 때까지 기다립니다.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />이 없는 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 뮤텍스를 만들 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 260자 보다 긴 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          이 호출의 결과로 명명된 시스템 뮤텍스가 만들어지는 경우 호출한 스레드에 명명된 시스템 뮤텍스의 초기 소유권을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="name">시스템 뮤텍스의 이름입니다. 값이 <see langword="null" />이면 <see cref="T:System.Threading.Mutex" />이(가) 명명되지 않습니다.</param>
        <param name="createdNew">이 메서드가 반환될 때 로컬 뮤텍스가 만들어진 경우(즉, <c>이름</c>이 <see langword="null" />이거나 빈 문자열인 경우)나 지정된 명명된 시스템 뮤텍스가 만들어진 경우에는 <see langword="true" />인 부울이 포함되고, 지정된 명명된 시스템 뮤텍스가 이미 있는 경우에는 <see langword="false" />가 포함됩니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <param name="mutexSecurity">명명된 시스템 뮤텍스에 적용할 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 개체입니다.</param>
        <summary>호출한 스레드가 뮤텍스의 초기 소유권을 가져야 할지를 나타내는 부울 값, 뮤텍스의 이름인 문자열 및 메서드에서 반환할 때 호출한 스레드에 뮤텍스의 초기 소유권이 부여되었는지와 명명된 뮤텍스에 적용할 액세스 제어 보안을 나타내는 부울 변수를 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `name` 않습니다 `null` 및 `initiallyOwned` 은 `true`, 경우에만 명명 된 뮤텍스를 소유 하는 호출 스레드에서 `createdNew` 은 `true` 호출 후 합니다. 그렇지 않으면 스레드가 않으면 호출 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드.  
  
 이 생성자를 사용 하 여 인해 다른 코드에서 뮤텍스의 제어권을 만들 때 명명 된 시스템 뮤텍스에 액세스 제어 보안을 적용 합니다.  
  
 이 생성자는 <xref:System.Threading.Mutex> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 여러 개 만들 수 있습니다 <xref:System.Threading.Mutex> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.  
  
 명명된 된 시스템 뮤텍스가 존재 하지 않는 경우 지정 된 액세스 제어 보안으로 생성 됩니다. 명명 된 뮤텍스가 존재 하는 경우 지정 된 액세스 제어 보안 무시 됩니다.  
  
> [!NOTE]
>  새로 만든에 대 한 모든 권한을 호출자에 게 <xref:System.Threading.Mutex> 경우에도 개체 `mutexSecurity` 거부 없거나 현재 사용자에 게 일부 액세스 권한을 부여에 실패 합니다. 그러나 현재 사용자가 다른 <xref:System.Threading.Mutex> 개체를 나타내는 동일한 명명 된 뮤텍스를 사용 하 여 생성자 또는 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드를 Windows 액세스 제어 보안 적용 됩니다.  
  
 명명된 된 뮤텍스에 액세스 제어 보안을 이미 만들어졌습니다 하 고 호출자에 게 없는 경우 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, 예외가 throw 됩니다. 기존 스레드 작업을 동기화 하는 데 필요한 이러한 권한이 포함 된 명명 된 뮤텍스를 열려면 참조는 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드.  
  
 지정 하는 경우 `null` 또는 빈 문자열을 `name`를 호출한 것 처럼 로컬 뮤텍스가 만들어지는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자입니다. 이 경우 `createdNew` 항상 `true`합니다.  
  
 시스템 수준 되기 때문에 명명 된 뮤텍스 프로세스 경계를 넘어 리소스 사용을 조정 하 사용할 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다. 이름이 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 이름이 접두사로 시작 하는 경우 "로컬\\", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서. 즉, 접두사 이름은 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.  
  
 두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외가 발견 되 고 사용 하 여는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 뮤텍스를 엽니다.  
  
 권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />이 없는 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 뮤텍스를 만들 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 260자 보다 긴 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>명명된 뮤텍스에 대한 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 개체를 가져옵니다.</summary>
        <returns>명명된 뮤텍스에 대한 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A> 메서드 플래그 (비트 OR 연산을 사용 하 여 결합)는 다음과 같은 조합을 사용 하 여 사용 권한을 검색할: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, 및 <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>합니다.  
  
 사용자에 게 있어야 <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> 이 메서드를 호출 하는 뮤텍스를 열려 있어야와 <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.  
  
 두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외가 발견 되 고 사용 하 여는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 하 여 사용 권한을 변경 하는 데 필요한 권한을 뮤텍스를 여는 <xref:System.Threading.Mutex.GetAccessControl%2A> 및 <xref:System.Threading.Mutex.SetAccessControl%2A> 메서드.  
  
 권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">현재 <see cref="T:System.Threading.Mutex" /> 개체가 명명된 시스템 뮤텍스를 나타내지만 사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />가 없는 경우  
  
 또는  
  
 현재 <see cref="T:System.Threading.Mutex" /> 개체가 명명된 시스템 뮤텍스를 나타내지만 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />를 사용하여 열리지 않은 경우</exception>
        <exception cref="T:System.NotSupportedException">Windows 98 또는 Windows Millennium Edition에서 지원되지 않는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이미 있는 경우 지정한 명명된 뮤텍스를 엽니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 뮤텍스의 이름입니다.</param>
        <summary>이미 있는 경우 지정한 명명된 뮤텍스를 엽니다.</summary>
        <returns>명명된 시스템 뮤텍스를 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A> 명명 된 시스템 뮤텍스가 메서드는 지정 된 열려고 시도 합니다. 된 시스템 뮤텍스가 존재 하지 않는 경우이 메서드는 시스템 개체를 만들지 않고 예외를 throw 합니다. 이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <xref:System.Threading.Mutex.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.  
  
 이 메서드 오버 로드 하는 것은 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 지정 하 고 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.  
  
 지정 하는 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 플래그에 뮤텍스를 대기 하는 스레드를 사용 하 고 지정 하는 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 플래그를 호출 하는 스레드를 사용할 수 있습니다는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.  
  
 두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외가 발견 되 고 사용 하 여는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 뮤텍스를 엽니다.  
  
 권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 빈 문자열인 경우  
  
 또는  
  
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">명명된 뮤텍스가 없는 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 뮤텍스의 이름입니다.</param>
        <param name="rights">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</param>
        <summary>이미 있는 경우 지정한 명명된 뮤텍스를 원하는 보안 액세스로 엽니다.</summary>
        <returns>명명된 시스템 뮤텍스를 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` 매개 변수를 포함 해야 합니다는 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 뮤텍스를 대기 하는 스레드를 허용 하도록 플래그 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 호출 하는 스레드를 허용 하도록 플래그는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드는 기존의 명명 된 뮤텍스를 열려고 합니다. 된 시스템 뮤텍스가 존재 하지 않는 경우이 메서드는 시스템 개체를 만들지 않고 예외를 throw 합니다. 이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <xref:System.Threading.Mutex.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.  
  
 이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.  
  
 두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외가 발견 되 고 사용 하 여는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 뮤텍스를 엽니다.  
  
 권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 빈 문자열인 경우  
  
 또는  
  
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">명명된 뮤텍스가 없는 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 있지만 사용자에게 필요한 보안 액세스가 없습니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Threading.Mutex" />을(를) 한 번 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드가 뮤텍스를 획득 될 때마다 (예를 들어 호출 하 여 해당 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드), 이후에 호출 해야 <xref:System.Threading.Mutex.ReleaseMutex%2A> 뮤텍스의 소유권을 사용 하지 못하고 뮤텍스의 소유권을 얻으려고 시도 하는 다른 스레드를 차단 해제를 합니다. 뮤텍스의 소유권을 가져오려는 시도가 실패 하는 경우 (예를 들어 경우에 대 한 호출은 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드는 `millisecondsTimeout` 또는 `timeout` 매개 변수를 반환 `false` 요청 시간이 초과 하기 때문에), 스레드 호출 해서는 안 <xref:System.Threading.Mutex.ReleaseMutex%2A>,이 대/소문자는 스레드도 하지 수 있어야 뮤텍스의 다음 예제와 같이 보호를 받는 리소스에 액세스할 수 있습니다.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 뮤텍스를 소유 하는 스레드 실행을 차단 하지 않고 반복 된 대기 함수 호출에 같은 뮤텍스를 지정할 수 있습니다. 공용 언어 런타임에 의해 호출 수가 유지 됩니다. 스레드에서 <xref:System.Threading.Mutex.ReleaseMutex%2A> 뮤텍스의 소유권을 해제 하려면 동일한 횟수입니다.  
  
 스레드가 뮤텍스를 소유 하는 동안 종료 되 면 뮤텍스가 중단 됩니다. 뮤텍스 상태 신호 설정 되 고 대기 중인 다음 스레드가 소유권을 가져옵니다. 뮤텍스를 소유 아무도 뮤텍스의 상태 신호입니다. .NET Framework 버전 2.0 부터는 <xref:System.Threading.AbandonedMutexException> 뮤텍스를 획득 하는 다음 스레드에서 throw 됩니다. .NET Framework 버전 2.0 이전 예외가 throw 되었습니다.  
  
> [!CAUTION]
>  중단 된 뮤텍스는 코드의 심각한 오류를 나타내는 경우가 많습니다. 스레드가 뮤텍스를 해제 하지 않고 종료 되 면 뮤텍스의 보호를 받는 데이터 구조 일관성 있는 상태가 아닐 수 있습니다. 뮤텍스의 소유권을 요청 하는 다음 스레드에서이 예외를 처리 하 고 데이터 구조의 무결성을 확인할 수 있으면 계속 수 있습니다.  
  
 시스템 차원 뮤텍스의 경우 중단된 뮤텍스는 응용 프로그램이 갑자기 종료되었음을 나타낼 수 있습니다(예: Windows 작업 관리자를 사용하여).  
  
   
  
## Examples  
 다음 예제에서는 로컬 방법을 <xref:System.Threading.Mutex> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다. 뮤텍스를 만드는 스레드는를 소유 하지 않습니다 처음 합니다. <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드는 더 이상 필요 없는 뮤텍스를 해제 하는 데 사용 됩니다.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">호출 스레드가 뮤텍스를 소유하지 않습니다.</exception>
        <exception cref="T:System.ObjectDisposedException">현재 인스턴스가 이미 삭제된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">명명된 시스템 뮤텍스에 적용할 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 개체입니다.</param>
        <summary>명명된 시스템 뮤텍스에 액세스 제어 보안을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자에 게 있어야 <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> 뮤텍스 및이 메서드를 호출 하는 권한으로 연 해야 <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.  
  
 두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외가 발견 되 고 사용 하 여는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 하 여 사용 권한을 변경 하는 데 필요한 권한을 뮤텍스를 여는 <xref:System.Threading.Mutex.GetAccessControl%2A> 및 <xref:System.Threading.Mutex.SetAccessControl%2A> 메서드.  
  
 권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />가 없는 경우  
  
 또는  
  
 뮤텍스가 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />를 사용하여 열리지 않은 경우</exception>
        <exception cref="T:System.SystemException">현재 <see cref="T:System.Threading.Mutex" /> 개체가 명명된 시스템 뮤텍스를 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 명명된 뮤텍스(이미 존재하는 경우)를 열고 작업이 수행되었는지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 뮤텍스의 이름입니다.</param>
        <param name="result">이 메서드가 반환될 때 호출이 성공적으로 실행된 경우 이름이 지정된 뮤텍스를 나타내는 <see cref="T:System.Threading.Mutex" /> 개체를 포함하고 호출에 실패한 경우는 <see langword="null" />을(를) 포함해야 합니다. 이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</param>
        <summary>지정한 명명된 뮤텍스(이미 존재하는 경우)를 열고 작업이 수행되었는지를 나타내는 값을 반환합니다.</summary>
        <returns>
          명명된 뮤텍스를 열었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명 된 뮤텍스가 존재 하지 않는 경우이 메서드가 만드는 것은 아닙니다. 이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <xref:System.Threading.Mutex.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 대신이 메서드 오버 로드를 사용 하 여 명명된 된 뮤텍스 있는지 잘 모르는 경우는 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 뮤텍스가 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.  
  
 에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.  
  
 이 메서드 오버 로드 하는 것은 <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> 메서드 오버 로드를 지정 하 고 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 권한, 비트 OR 연산을 사용 하 여 결합 합니다. 지정 하는 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 플래그에 뮤텍스를 대기 하는 스레드를 사용 하 고 지정 하는 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 플래그를 호출 하는 스레드를 사용할 수 있습니다는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 빈 문자열인 경우  
  
 또는  
  
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 뮤텍스의 이름입니다.</param>
        <param name="rights">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</param>
        <param name="result">이 메서드가 반환될 때 호출이 성공적으로 실행된 경우 이름이 지정된 뮤텍스를 나타내는 <see cref="T:System.Threading.Mutex" /> 개체를 포함하고 호출에 실패한 경우는 <see langword="null" />을(를) 포함해야 합니다. 이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</param>
        <summary>지정된 명명된 뮤텍스를 원하는 보안 액세스 상태에서 열고 작업이 수행되었는지를 나타내는 값을 반환합니다.</summary>
        <returns>
          명명된 뮤텍스를 열었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명 된 뮤텍스가 존재 하지 않는 경우이 메서드가 만드는 것은 아닙니다. 이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <xref:System.Threading.Mutex.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 대신이 메서드 오버 로드를 사용 하 여 명명된 된 뮤텍스 있는지 잘 모르는 경우는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 뮤텍스가 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.  
  
 `rights` 매개 변수를 포함 해야 합니다는 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 뮤텍스를 대기 하는 스레드를 허용 하도록 플래그 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 호출 하는 스레드를 허용 하도록 플래그는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.  
  
 이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 빈 문자열인 경우  
  
 또는  
  
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
  </Members>
</Type>