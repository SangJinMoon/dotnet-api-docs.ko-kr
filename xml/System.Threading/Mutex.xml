<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="092df8a132c6280f7c2111bcb3ab0226334bc0f4" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407056" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A synchronization primitive that can also be used for interprocess synchronization.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 둘 이상의 스레드를 동시에 공유 리소스에 액세스 해야 할 때 시스템에는 동기화 메커니즘을 한 번에 한 스레드만 리소스를 사용 해야 합니다. <xref:System.Threading.Mutex> 하나의 스레드를 공유 리소스에 대 한 단독 액세스를 부여 하는 기본 동기화 합니다. 뮤텍스를 획득 하는 스레드를 첫 번째 스레드가 뮤텍스를 해제 하기 전까지 해당 뮤텍스를 획득 하려고 하는 두 번째 스레드가 일시 중단 됩니다.  
  
> [!IMPORTANT]
>  이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다. 직접 형식의 dispose를 호출 해당 <xref:System.IDisposable.Dispose%2A> 에서 메서드는 `try` / `catch` 블록입니다. 작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다. 자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
 사용할 수는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 뮤텍스의 소유권을 요청 하는 메서드. 호출 스레드가 차단 다음 중 하나가 발생할 때까지:  
  
-   뮤텍스를 소유 하지 않은 나타내는 신호를 받는 합니다. 이런 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드 반환 `true`, 호출 스레드가 뮤텍스의 소유권을 가정 하 고는 뮤텍스로 보호 된 리소스에 액세스 하 고 있습니다. 스레드 호출 해야 리소스에 액세스 완료 될 때는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 뮤텍스의 소유권을 해제 하려면 메서드. "예" 섹션의 첫 번째 예제에서는이 패턴을 보여 줍니다.  
  
-   에 대 한 호출에 지정 된 시간 제한 간격은 <xref:System.Threading.WaitHandle.WaitOne%2A> 변수가 있는 메서드는 `millisecondsTimeout` 또는 `timeout` 경과 된 매개 변수입니다. 이런 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드 반환 `false`, 호출 스레드가 뮤텍스의 소유권을 획득 하려는 추가 시도 하지으로 만듭니다. 이 경우 호출 스레드에 뮤텍스의 보호 되는 리소스에 대 한 액세스 거부 되었습니다 되도록 코드를 구성 해야 합니다. 호출 하지 않아야 스레드가 되지 뮤텍스의 소유권을 획득 하기 때문에 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드. "예" 섹션의 두 번째 예제에서는이 패턴을 보여 줍니다.  
  
 <xref:System.Threading.Mutex> 뮤텍스를 가져온 스레드에서만 해제 될 수 있으므로 클래스는 스레드 id를 적용 합니다. 반면,는 <xref:System.Threading.Semaphore> 클래스 스레드 id를 적용 하지 않습니다. 뮤텍스 응용 프로그램 도메인 경계를 넘어 전달할 수도 있습니다.  
  
 뮤텍스를 소유 하는 스레드는 같은 뮤텍스를 반복적으로 호출을 요청할 수 <xref:System.Threading.WaitHandle.WaitOne%2A> 실행을 차단 하지 않고 있습니다. 그러나 스레드 호출 해야 합니다는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드 뮤텍스의 소유권을 해제 하려면 동일한 횟수입니다.  
  
 때문에 <xref:System.Threading.Mutex> 클래스에서 상속 <xref:System.Threading.WaitHandle>, 정적을 호출할 수도 있습니다 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> 및 <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> 보호 된 리소스에 대 한 액세스를 동기화 하는 메서드.  
  
 스레드가 뮤텍스를 소유 하는 동안 종료 되 면 뮤텍스가 중단 됩니다. 뮤텍스 상태 신호 받음으로 설정 되어 다음 대기 스레드가 소유권을 가져옵니다. .NET Framework 버전 2.0 부터는 <xref:System.Threading.AbandonedMutexException> 중단 된 뮤텍스를 획득 하는 다음 스레드에서 throw 됩니다. .NET Framework 버전 2.0 이전 예외가 throw 되었습니다.  
  
> [!CAUTION]
>  중단 된 뮤텍스는 코드의 심각한 오류를 나타내는 경우가 많습니다. 스레드가 뮤텍스를 해제 하지 않고 종료 되 면 뮤텍스의 보호를 받는 데이터 구조 일관성 있는 상태가 아닐 수 있습니다. 뮤텍스의 소유권을 요청 하는 다음 스레드에서이 예외를 처리 하 고 데이터 구조의 무결성을 확인할 수 있으면 계속 수 있습니다.  
  
 시스템 차원 뮤텍스의 경우 중단된 뮤텍스는 응용 프로그램이 갑자기 종료되었음을 나타낼 수 있습니다(예: Windows 작업 관리자를 사용하여).  
  
 뮤텍스는 다음 두 가지 유형: 이며 명명 되지 않은 시스템 뮤텍스를 명명 된 로컬 뮤텍스 합니다. 로컬 뮤텍스는 프로세스 내에만 존재합니다. 에 대 한 참조 프로세스의 모든 스레드에서 사용할 수는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 개체입니다. 명명 되지 않은 각 <xref:System.Threading.Mutex> 개체는 별도 로컬 뮤텍스를 나타냅니다.  
  
 명명 된 시스템 뮤텍스는 운영 체제 전체에 표시 되 고 프로세스 작업을 동기화 할 수 있습니다. 만들 수는 <xref:System.Threading.Mutex> 이름을 허용 하는 생성자를 사용 하 여 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 같은 시간에 운영 체제 개체를 만들 수 있고 만들기 전에 <xref:System.Threading.Mutex> 개체입니다. 동일한 명명된 시스템 뮤텍스를 나타내는 여러 <xref:System.Threading.Mutex> 개체를 만들 수 있으며 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드를 사용하여 기존 명명된 시스템 뮤텍스를 열 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다. 이름이 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 이름이 접두사로 시작 하는 경우 "로컬\\", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서. 즉, 접두사 이름은 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 이 예제에서는 로컬 방법을 <xref:System.Threading.Mutex> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다. 호출 해야 하므로 각 호출 스레드가 뮤텍스의 소유권을 가져올 때까지 차단 되는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 스레드가 소유권을 해제 하려면 메서드.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 다음 예제에서는 각 스레드가 호출는 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> 뮤텍스를 획득 하는 메서드. 메서드가 반환 하는 경우 시간 제한 간격이 지나면 `false`, 스레드가 뮤텍스를 획득 아니고 뮤텍스의 보호 리소스에 액세스 하 고 있습니다. <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드만 뮤텍스를 획득 하는 스레드에 의해 호출 됩니다.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자 오버 로드는이 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자 오버 로드를 지정 하 고 `false` 뮤텍스의 초기 소유권에 대 한 합니다. 즉, 호출 스레드가 뮤텍스를 소유 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제는 로컬 방법을 <xref:System.Threading.Mutex> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다. 뮤텍스를 만드는 스레드는를 소유 하지 않습니다 처음 합니다.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제는 로컬 방법을 <xref:System.Threading.Mutex> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다. 만드는 스레드는는 <xref:System.Threading.Mutex> 처음 소유 합니다.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the <see cref="T:System.Threading.Mutex" />. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `name` 않습니다 `null` 및 `initiallyOwned` 은 `true`,이 호출의 결과로 명명 된 시스템 뮤텍스가 만들어진 경우에 호출 스레드가 뮤텍스를 소유 합니다. 지정 하는 것이 좋습니다 명명 된 시스템 뮤텍스가 만들어졌는지 여부를 결정 하기 위한 메커니즘이 없으므로 `false` 에 대 한 `initiallyOwned` 이 생성자 오버 로드를 호출할 때입니다. 사용할 수는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> 시스템 뮤텍스의 초기 소유권을 확인 해야 하는 경우에 생성자입니다.  
  
 이 생성자는 <xref:System.Threading.Mutex> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 여러 개 만들 수 있습니다 <xref:System.Threading.Mutex> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.  
  
 명명된 된 뮤텍스에 액세스 제어 보안을 이미 만들어졌습니다 하 고 호출자에 게 없는 경우 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, 예외가 throw 됩니다. 기존 스레드 작업을 동기화 하는 데 필요한 이러한 권한이 포함 된 명명 된 뮤텍스를 열려면 참조는 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드.  
  
 지정 하는 경우 `null` 또는 빈 문자열을 `name`를 호출한 것 처럼 로컬 뮤텍스가 만들어지는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자입니다. 이 경우 `createdNew` 항상 `true`합니다.  
  
 시스템 수준 되기 때문에 명명 된 뮤텍스 프로세스 경계를 넘어 리소스 사용을 조정 하 사용할 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다. 이름이 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 이름이 접두사로 시작 하는 경우 "로컬\\", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서. 즉, 접두사 이름은 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 다음 예제에서는 명명된 된 뮤텍스 두 개의 별도 프로세스에서 실행 되는 스레드 간에 신호 하는 방법을 보여 줍니다.  
  
 두 개 이상의 명령 창에서이 프로그램을 실행 합니다. 각 프로세스는 한 <xref:System.Threading.Mutex> 명명 된 뮤텍스를 나타내는 `MyMutex`합니다. 명명 된 뮤텍스는 수명이의 수명을으로 제한 된 시스템 개체는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 개체입니다. 명명 된 뮤텍스는 첫 번째 프로세스 때 만들어집니다 해당 <xref:System.Threading.Mutex> 개체; 프로그램을 실행 하는 첫 번째 프로세스가이 예제에서는 명명 된 뮤텍스가 소유 합니다. 명명 된 뮤텍스 소멸 될 때 모든는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 릴리스 되었습니다.  
  
 이 예제에서 사용 하는 생성자 오버 로드 호출 스레드 명명된 뮤텍스의 초기 소유권을 부여 되었는지 여부를 알 수 없습니다. 스레드 명명 된 뮤텍스 만든다고 제어할 수 있습니다 하지 않는 한 시스템 뮤텍스의 초기 소유권을 요청 하려면이 생성자를 사용 하지 해야 합니다.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the <see cref="T:System.Threading.Mutex" />. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <param name="createdNew">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed. This parameter is passed uninitialized.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `name` 않습니다 `null` 및 `initiallyOwned` 은 `true`, 경우에만 명명 된 뮤텍스를 소유 하는 호출 스레드에서 `createdNew` 은 `true` 호출 후 합니다. 그렇지 않으면 스레드가 않으면 호출 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드.  
  
 이 생성자는 <xref:System.Threading.Mutex> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 여러 개 만들 수 있습니다 <xref:System.Threading.Mutex> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.  
  
 명명된 된 뮤텍스에 액세스 제어 보안을 이미 만들어졌습니다 하 고 호출자에 게 없는 경우 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> 권한, 예외가 throw 됩니다. 기존 스레드 작업을 동기화 하는 데 필요한 이러한 권한이 포함 된 명명 된 뮤텍스를 열려면 참조는 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드.  
  
 지정 하는 경우 `null` 또는 빈 문자열을 `name`를 호출한 것 처럼 로컬 뮤텍스가 만들어지는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자입니다. 이 경우 `createdNew` 항상 `true`합니다.  
  
 시스템 수준 되기 때문에 명명 된 뮤텍스 프로세스 경계를 넘어 리소스 사용을 조정 하 사용할 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다. 이름이 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 이름이 접두사로 시작 하는 경우 "로컬\\", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서. 즉, 접두사 이름은 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 다음 코드 예제에서는 명명된 된 뮤텍스 프로세스 또는 스레드 간에 신호 하는 방법을 보여 줍니다. 두 개 이상의 명령 창에서이 프로그램을 실행 합니다. 각 프로세스는 한 <xref:System.Threading.Mutex> "인 MyMutex" 명명 된 뮤텍스를 나타내는 개체입니다. 명명 된 뮤텍스는 시스템 개체입니다. 이 예제에서는 그 수명은의 수명에 의해 제한 됩니다는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 개체입니다. 첫 번째 프로세스는 로컬에서 명명 된 뮤텍스 생성 됩니다 <xref:System.Threading.Mutex> 개체를 소멸 될 때 모든는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 릴리스 되었습니다. 명명 된 뮤텍스는 처음 첫 번째 프로세스에 의해 소유 됩니다. 두 번째 프로세스 및 모든 후속 프로세스 이전 프로세스 명명 된 뮤텍스를 해제 될 때까지 기다립니다.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the system mutex. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <param name="createdNew">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed. This parameter is passed uninitialized.</param>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `name` 않습니다 `null` 및 `initiallyOwned` 은 `true`, 경우에만 명명 된 뮤텍스를 소유 하는 호출 스레드에서 `createdNew` 은 `true` 호출 후 합니다. 그렇지 않으면 스레드가 않으면 호출 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드.  
  
 이 생성자를 사용 하 여 인해 다른 코드에서 뮤텍스의 제어권을 만들 때 명명 된 시스템 뮤텍스에 액세스 제어 보안을 적용 합니다.  
  
 이 생성자는 <xref:System.Threading.Mutex> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 여러 개 만들 수 있습니다 <xref:System.Threading.Mutex> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.  
  
 명명된 된 시스템 뮤텍스가 존재 하지 않는 경우 지정 된 액세스 제어 보안으로 생성 됩니다. 명명 된 뮤텍스가 존재 하는 경우 지정 된 액세스 제어 보안 무시 됩니다.  
  
> [!NOTE]
>  새로 만든에 대 한 모든 권한을 호출자에 게 <xref:System.Threading.Mutex> 경우에도 개체 `mutexSecurity` 거부 없거나 현재 사용자에 게 일부 액세스 권한을 부여에 실패 합니다. 그러나 현재 사용자가 다른 <xref:System.Threading.Mutex> 개체를 나타내는 동일한 명명 된 뮤텍스를 사용 하 여 생성자 또는 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드를 Windows 액세스 제어 보안 적용 됩니다.  
  
 명명된 된 뮤텍스에 액세스 제어 보안을 이미 만들어졌습니다 하 고 호출자에 게 없는 경우 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, 예외가 throw 됩니다. 기존 스레드 작업을 동기화 하는 데 필요한 이러한 권한이 포함 된 명명 된 뮤텍스를 열려면 참조는 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드.  
  
 지정 하는 경우 `null` 또는 빈 문자열을 `name`를 호출한 것 처럼 로컬 뮤텍스가 만들어지는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자입니다. 이 경우 `createdNew` 항상 `true`합니다.  
  
 시스템 수준 되기 때문에 명명 된 뮤텍스 프로세스 경계를 넘어 리소스 사용을 조정 하 사용할 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 개뿐입니다. 이름이 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 이름이 접두사로 시작 하는 경우 "로컬\\", 뮤텍스가 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션 내에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 되며 둘 다 볼 수는 모든 프로세스에 터미널 서버 세션에서. 즉, 접두사 이름은 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 않은 뮤텍스 이름의 범위에 설명 합니다.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.  
  
 두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외가 발견 되 고 사용 하 여는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 뮤텍스를 엽니다.  
  
 권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A> 메서드 플래그 (비트 OR 연산을 사용 하 여 결합)는 다음과 같은 조합을 사용 하 여 사용 권한을 검색할: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, 및 <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>합니다.  
  
 사용자에 게 있어야 <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> 이 메서드를 호출 하는 뮤텍스를 열려 있어야와 <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.  
  
 두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외가 발견 되 고 사용 하 여는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 하 여 사용 권한을 변경 하는 데 필요한 권한을 뮤텍스를 여는 <xref:System.Threading.Mutex.GetAccessControl%2A> 및 <xref:System.Threading.Mutex.SetAccessControl%2A> 메서드.  
  
 권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  -or-  The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Not supported for Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named mutex, if it already exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <summary>Opens the specified named mutex, if it already exists.</summary>
        <returns>An object that represents the named system mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A> 명명 된 시스템 뮤텍스가 메서드는 지정 된 열려고 시도 합니다. 된 시스템 뮤텍스가 존재 하지 않는 경우이 메서드는 시스템 개체를 만들지 않고 예외를 throw 합니다. 이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <xref:System.Threading.Mutex.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.  
  
 이 메서드 오버 로드 하는 것은 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 지정 하 고 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.  
  
 지정 하는 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 플래그에 뮤텍스를 대기 하는 스레드를 사용 하 고 지정 하는 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 플래그를 호출 하는 스레드를 사용할 수 있습니다는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.  
  
 두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외가 발견 되 고 사용 하 여는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 뮤텍스를 엽니다.  
  
 권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <summary>Opens the specified named mutex, if it already exists, with the desired security access.</summary>
        <returns>An object that represents the named system mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` 매개 변수를 포함 해야 합니다는 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 뮤텍스를 대기 하는 스레드를 허용 하도록 플래그 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 호출 하는 스레드를 허용 하도록 플래그는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드는 기존의 명명 된 뮤텍스를 열려고 합니다. 된 시스템 뮤텍스가 존재 하지 않는 경우이 메서드는 시스템 개체를 만들지 않고 예외를 throw 합니다. 이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <xref:System.Threading.Mutex.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.  
  
 이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.  
  
 두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외가 발견 되 고 사용 하 여는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 가진 뮤텍스를 엽니다.  
  
 권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the <see cref="T:System.Threading.Mutex" /> once.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드가 뮤텍스를 획득 될 때마다 (예를 들어 호출 하 여 해당 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드), 이후에 호출 해야 <xref:System.Threading.Mutex.ReleaseMutex%2A> 뮤텍스의 소유권을 사용 하지 못하고 뮤텍스의 소유권을 얻으려고 시도 하는 다른 스레드를 차단 해제를 합니다. 뮤텍스의 소유권을 가져오려는 시도가 실패 하는 경우 (예를 들어 경우에 대 한 호출은 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드는 `millisecondsTimeout` 또는 `timeout` 매개 변수를 반환 `false` 요청 시간이 초과 하기 때문에), 스레드 호출 해서는 안 <xref:System.Threading.Mutex.ReleaseMutex%2A>,이 대/소문자는 스레드도 하지 수 있어야 뮤텍스의 다음 예제와 같이 보호를 받는 리소스에 액세스할 수 있습니다.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 뮤텍스를 소유 하는 스레드 실행을 차단 하지 않고 반복 된 대기 함수 호출에 같은 뮤텍스를 지정할 수 있습니다. 공용 언어 런타임에 의해 호출 수가 유지 됩니다. 스레드에서 <xref:System.Threading.Mutex.ReleaseMutex%2A> 뮤텍스의 소유권을 해제 하려면 동일한 횟수입니다.  
  
 스레드가 뮤텍스를 소유 하는 동안 종료 되 면 뮤텍스가 중단 됩니다. 뮤텍스 상태 신호 설정 되 고 대기 중인 다음 스레드가 소유권을 가져옵니다. 뮤텍스를 소유 아무도 뮤텍스의 상태 신호입니다. .NET Framework 버전 2.0 부터는 <xref:System.Threading.AbandonedMutexException> 뮤텍스를 획득 하는 다음 스레드에서 throw 됩니다. .NET Framework 버전 2.0 이전 예외가 throw 되었습니다.  
  
> [!CAUTION]
>  중단 된 뮤텍스는 코드의 심각한 오류를 나타내는 경우가 많습니다. 스레드가 뮤텍스를 해제 하지 않고 종료 되 면 뮤텍스의 보호를 받는 데이터 구조 일관성 있는 상태가 아닐 수 있습니다. 뮤텍스의 소유권을 요청 하는 다음 스레드에서이 예외를 처리 하 고 데이터 구조의 무결성을 확인할 수 있으면 계속 수 있습니다.  
  
 시스템 차원 뮤텍스의 경우 중단된 뮤텍스는 응용 프로그램이 갑자기 종료되었음을 나타낼 수 있습니다(예: Windows 작업 관리자를 사용하여).  
  
   
  
## Examples  
 다음 예제에서는 로컬 방법을 <xref:System.Threading.Mutex> 개체를 사용 하 여 보호 된 리소스에 대 한 액세스를 동기화 하 합니다. 뮤텍스를 만드는 스레드는를 소유 하지 않습니다 처음 합니다. <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드는 더 이상 필요 없는 뮤텍스를 해제 하는 데 사용 됩니다.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">The calling thread does not own the mutex.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</param>
        <summary>Sets the access control security for a named system mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자에 게 있어야 <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> 뮤텍스 및이 메서드를 호출 하는 권한으로 연 해야 <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 명명된 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드 된 명명 된 뮤텍스의 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스에 대 한 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안 만들어집니다.  
  
 두 번째 복사본에 대 한 호출에 대 한 액세스 위반 예외가 throw 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하면 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외가 발견 되 고 사용 하 여는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 하 여 사용 권한을 변경 하는 데 필요한 권한을 뮤텍스를 여는 <xref:System.Threading.Mutex.GetAccessControl%2A> 및 <xref:System.Threading.Mutex.SetAccessControl%2A> 메서드.  
  
 권한이 변경 된 후 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 사용 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  -or-  The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명 된 뮤텍스가 존재 하지 않는 경우이 메서드가 만드는 것은 아닙니다. 이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <xref:System.Threading.Mutex.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 대신이 메서드 오버 로드를 사용 하 여 명명된 된 뮤텍스 있는지 잘 모르는 경우는 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 뮤텍스가 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.  
  
 에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.  
  
 이 메서드 오버 로드 하는 것은 <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> 메서드 오버 로드를 지정 하 고 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 권한, 비트 OR 연산을 사용 하 여 결합 합니다. 지정 하는 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 플래그에 뮤텍스를 대기 하는 스레드를 사용 하 고 지정 하는 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 플래그를 호출 하는 스레드를 사용할 수 있습니다는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명 된 뮤텍스가 존재 하지 않는 경우이 메서드가 만드는 것은 아닙니다. 이미 존재 하지 않을 때 시스템 뮤텍스의 만들려는 중 하나를 사용는 <xref:System.Threading.Mutex.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 대신이 메서드 오버 로드를 사용 하 여 명명된 된 뮤텍스 있는지 잘 모르는 경우는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 뮤텍스가 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.  
  
 `rights` 매개 변수를 포함 해야 합니다는 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 뮤텍스를 대기 하는 스레드를 허용 하도록 플래그 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 호출 하는 스레드를 허용 하도록 플래그는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 에 대 한 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 반환 되는 개체는 같은 명명 된 시스템 뮤텍스를 나타낼 경우에 개체입니다.  
  
 이 메서드는 뮤텍스의 소유권을 요청 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
  </Members>
</Type>