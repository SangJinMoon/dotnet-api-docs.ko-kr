<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="04c73d8d6d8c0205db70235fd1bb85ce866c6212" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36606691" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>개체에 대한 액세스를 동기화하는 메커니즘을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Monitor> 클래스를 사용 하면 가져오고를 호출 하 여 특정 개체에 대 한 잠금을 해제 하 여 코드 영역에 대 한 액세스를 동기화 하는 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, 및 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 메서드. 개체 잠금 블록 일반적으로 임계 영역을 라고 하는 코드에 대 한 액세스를 제한 하는 기능을 제공 합니다. 개체에 대 한 잠금을 소유 하는 스레드를 하는 동안 다른 스레드가 잠금을 획득할 수 있습니다. 사용할 수도 있습니다는 <xref:System.Threading.Monitor> 다른 스레드에서 응용 프로그램의 한 섹션에 액세스할 수 있도록 클래스 잠금 소유자가 실행 중인 다른 스레드가 잠겨 있는 다른 개체를 사용 하 여 코드를 실행 하지 않는 한 코드입니다.  
  
 이 문서의 내용  
  
 [Monitor 클래스: 개요](#Overview)   
 [잠금 개체](#Lock)   
 [임계 영역](#CriticalSection)   
 [펄스, PulseAll, 및 대기](#Pulse)   
 [모니터 및 대기 핸들](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Monitor 클래스: 개요  
 <xref:System.Threading.Monitor> 에 다음과 같은 기능이 있습니다.  
  
-   필요에 따라 개체와 연결 됩니다.  
  
-   바인딩 해제 되어 있으므로 모든 컨텍스트에서 직접 호출할 수 있습니다.  
  
-   인스턴스는 <xref:System.Threading.Monitor> 클래스를 만들 수 없습니다;의 메서드는 <xref:System.Threading.Monitor> 클래스는 모두 정적입니다. 각 메서드에 대 한 액세스를 제어 하는 동기화 된 개체를 전달 되는 임계 영역에 있습니다.  
  
> [!NOTE]
>  사용 하 여는 <xref:System.Threading.Monitor> 문자열 이외의 잠금 개체에 대 한 클래스 (참조, 즉 이외의 형식 <xref:System.String>), 값 형식이 아닙니다. 자세한 내용은 참조의 오버 로드는 <xref:System.Threading.Monitor.Enter%2A> 메서드 및 [잠금 개체](#Lock) 이 문서의 뒷부분에 나오는 섹션.  
  
 다음 표에서 동기화 된 개체에 액세스 하는 스레드에서 수행할 수 있는 동작을 설명 합니다.  
  
|작업|설명|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|개체에 대 한 잠금을 획득합니다. 임계 영역의 시작 부분을 표시합니다. 잠겨 있는 다른 개체를 사용 하 여 중요 한 섹션의 지침에 실행 되는 경우가 아니면 다른 스레드에서 임계 영역을 입력할 수 있습니다.|  
|<xref:System.Threading.Monitor.Wait%2A>|다른 스레드를 잠그고 개체에 액세스할 수 있도록 개체에 대 한 잠금을 해제 합니다. 호출 스레드가 다른 스레드에서 개체에 액세스 하는 동안 대기 합니다. 펄스 신호 변경 개체의 상태에 대 한 대기 중인 스레드를 알리는 데 사용 됩니다.|  
|<xref:System.Threading.Monitor.Pulse%2A> (신호) <xref:System.Threading.Monitor.PulseAll%2A>|하나 이상의 대기 중인 스레드에 신호를 보냅니다. 신호 알립니다 잠긴된 개체의 상태가 변경 되어 대기 중인 스레드에 하 고 잠금의 소유자는 잠금을 해제할 수 있습니다. 개체에 대 한 잠금을 받을 수 있도록 개체의 준비 된 큐에 대기 중인 스레드에 배치 됩니다. 스레드가 잠금을 되 면 필요한 상태에 도달 하는 경우 개체의 새 상태를 검사할 수 있습니다.|  
|<xref:System.Threading.Monitor.Exit%2A>|개체에 대 한 잠금을 해제합니다. 잠겨 있는 개체에 의해 보호 되는 중요 한 섹션의 끝을 표시 합니다.|  
  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에 대 한 오버 로드 중에 두 가지는 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.TryEnter%2A> 메서드. 하나의 오버 로드 집합에는 `ref` (C#에서) 또는 `ByRef` (Visual Basic)에서는 <xref:System.Boolean> 로 자동 설정 하는 매개 변수 `true` 경우 잠금을 획득, 잠금을 획득할 때 예외가 발생 하는 경우에 합니다. 잠금을 해제 하는 모든 경우에는 리소스 잠금을 보호 일관 된 상태에 없을 수도 있는 경우에 중요 한 경우 이러한 오버 로드를 사용 합니다.  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>잠금 개체  
 Monitor 클래스 이루어져 `static` (C#에서) 또는 `Shared` (Visual Basic)에서는 임계 영역에 액세스를 제어 하는 개체에 작동 하는 메서드.  다음 정보는 각 동기화 된 개체에 대 한 유지 관리 됩니다.  
  
-   현재 잠금을 보유 하는 스레드에 대 한 참조입니다.  
  
-   잠금을 가져올 수 있는 스레드가 포함 된 준비 된 큐에 대 한 참조입니다.  
  
-   잠긴된 개체의 상태 변경에 대 한 알림을 대기 중인 스레드를 포함 하는 대기 중인 큐에 대 한 참조입니다.  
  
 <xref:System.Threading.Monitor>는 값 형식이 아니라 개체(즉, 참조 형식)를 잠급니다. <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A>에 값 형식을 전달할 수 있지만 각 호출에 대해 개별적으로 boxing됩니다. 호출마다 별도 개체를 만들기 때문에 <xref:System.Threading.Monitor.Enter%2A>가 차단되지 않으며, 보호하는 코드가 동기화되지 않습니다. 또한 <xref:System.Threading.Monitor.Exit%2A>에 전달되는 개체는 <xref:System.Threading.Monitor.Enter%2A>에 전달되는 개체와 다르므로 <xref:System.Threading.Monitor>에서 <xref:System.Threading.SynchronizationLockException> 예외가 발생하고 "비동기화된 코드 블록에서 개체 동기화 메서드를 호출했습니다." 메시지가 표시됩니다.  
  
 다음 예제에서는 이 문제를 보여 줍니다. 각각 250밀리초 동안 대기하는 10개 작업을 시작합니다. 각 작업은 실제로 시작 및 실행된 작업 수를 계산하기 위한 카운터 변수 `nTasks`를 업데이트합니다. `nTasks`는 동시에 여러 작업에서 업데이트될 수 있는 전역 변수이기 때문에 모니터를 사용하여 여러 작업에서 동시에 수정되지 않도록 보호합니다. 그러나 예제의 출력과 같이 각 작업에서 <xref:System.Threading.SynchronizationLockException> 예외가 발생합니다.  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 각 작업의 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 메서드 호출 전에 `nTasks` 변수가 boxing되므로 각 작업에서 <xref:System.Threading.SynchronizationLockException> 예외가 발생합니다. 즉, 각 메서드 호출에 서로 독립적인 개별 변수가 전달됩니다. `nTasks`는 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 메서드 호출에서 다시 boxing됩니다. 이렇게 하면 다시 서로 독립적인 새 boxed 변수 10개, `nTasks` 및 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 메서드 호출에서 생성되는 boxed 변수 10개가 생성됩니다. 코드에서 이전에 잠기지 않은 새로 만든 변수에 대한 잠금을 해제하려고 하기 때문에 예외가 발생합니다.  
  
 다음 예제와 같이 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A>를 호출하기 전에 값 형식 변수를 boxing하고 boxing된 동일한 개체를 두 메서드에 모두 전달할 수 있지만 아무 이점이 없습니다. boxing되지 않은 변수의 변경 내용은 boxing된 복사본에 반영되지 않으며, boxing된 복사본의 값을 변경할 수 없습니다.  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 동기화 할 개체를 선택할 때 전용 또는 내부 개체에 대해서만 잠가야 합니다. 외부 개체에 대 한 잠금을 관련 되지 않은 코드에 대 한 다양 한 용도 대 한 잠금에 동일한 개체를 선택할 수 있으므로 교착 상태를 발생할 수 있습니다.  
  
 잠금에 사용 되는 개체에서 파생 된 경우 여러 응용 프로그램 도메인에 있는 개체는 동기화 할 수 있는 참고 <xref:System.MarshalByRefObject>합니다.  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>임계 영역  
 사용 하 여는 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A> 임계 영역 시작과 끝을 표시 하는 방법입니다.  
  
> [!NOTE]
>  제공 하는 기능은 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A> 메서드는 제공 하는 동일는 [잠금](~/docs/csharp/language-reference/keywords/lock-statement.md) C# 문 및 [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) 점을 제외 하 고 Visual Basic의 문에 언어 구문이 도입 되면서 래핑은 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> 메서드 오버 로드와 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 에서 메서드는 `try`...`finally` 모니터가 해제 되도록 하는 블록입니다.  
  
 임계 영역에서 가져온 잠금을 인접 한 명령의의 집합이 면이 <xref:System.Threading.Monitor.Enter%2A> 메서드를 사용 하면 단일 스레드만 잠겨 있는 개체와 함께 포함된 코드를 실행할 수 있습니다. 이 경우 좋습니다에서 해당 코드를 배치 하는 `try` 차단에 대 한 호출을 배치 합니다는 <xref:System.Threading.Monitor.Exit%2A> 에서 메서드는 `finally` 블록입니다. 이렇게 하면 예외가 발생해도 잠금이 해제됩니다. 다음 코드에서는이 패턴을 보여 줍니다.  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 이 기능은 클래스의 인스턴스 메서드 또는 정적에 대 한 액세스를 동기화 하려면 일반적으로 사용 됩니다.  
  
 배치 하 여 잠금 기능을 수행할 수는 임계 영역 메서드 전체에 걸쳐 있는 경우는 <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> 방법에 지정 하는 <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> 값의 생성자에서 <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>합니다. 이 특성을 사용 하는 경우는 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A> 메서드 호출은 필요 하지 않습니다. 다음 코드 조각에서는이 패턴을 보여 줍니다.  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 현재 스레드를; 메서드는 반환 될 때까지 잠금을 보유 하 고이 특성으로 인해 있는지 참고 잠금이 더 빨리 해제 될 경우 사용 하 여는 <xref:System.Threading.Monitor> 클래스를 C# [잠금](~/docs/csharp/language-reference/keywords/lock-statement.md) 문 또는 Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) 특성 대신 메서드 내에서 문의 합니다.  
  
 에 대 한 수도 있지만 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A> 잠금 및 멤버 또는 클래스 경계를 교차 하는 지정 된 개체를 해제 하는 문을,이 방법은 권장 되지 않습니다.  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>펄스, PulseAll, 및 대기  
 스레드 잠금을 소유 하 고 잠금을 보호 하는 임계 영역 않았으면을 호출할 수는 <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, 및 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Threading.Monitor.Wait%2A> 잠금을 해제 하 고 경우 커서가 사용 하면 대기 중인 스레드 또는 스레드 잠금을 얻고 임계 영역을 입력 하 고를 호출 하 여 알림을 받을 때까지 대기는 <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> 또는 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 메서드. <xref:System.Threading.Monitor.Wait%2A> 알림을 받으면 반환되고 다시 잠금을 얻습니다.  
  
 <xref:System.Threading.Monitor.Pulse%2A> 및 <xref:System.Threading.Monitor.PulseAll%2A>은 둘 다 대기 큐에 있는 다음 스레드를 계속하도록 신호를 보냅니다.  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>모니터 및 대기 핸들  
 사용 간의 차이점을 확인 해야는 <xref:System.Threading.Monitor> 클래스 및 <xref:System.Threading.WaitHandle> 개체입니다.  
  
-   <xref:System.Threading.Monitor> 클래스는 순수 하 게 관리 되 고, 완전히 이식 가능 하 고 운영 체제 리소스 요구 사항 측면에서 더 효율적일 수 있습니다.  
  
-   <xref:System.Threading.WaitHandle> 개체는 운영 체제 대기 가능 개체를 나타내며, 관리 코드와 비관리 코드 간의 동기화에 유용하고, 동시에 많은 개체를 처리하는 기능과 같은 일부 고급 운영 체제 기능을 노출합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Threading.Monitor> 가 나타내는 난수 생성기의 단일 인스턴스에 대 한 액세스를 동기화 하는 클래스는 <xref:System.Random> 클래스입니다. 이 예에서는 10 작업을 스레드 풀 스레드에서 비동기적으로 실행 하며 각를 만듭니다. 각 작업 10000 난수를 생성 하 고의 평균을 계산, 난수 생성 된 수의 합계와 합계를 유지 관리 하는 두 개의 프로시저 수준 변수를 업데이트 합니다. 모든 작업 실행 한 후 이러한 두 값은 전반적인 평균을 계산 하 사용 됩니다.  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 스레드 풀 스레드에서 실행 중인 모든 작업에서 액세스할 수 있습니다, 때문에 변수를 액세스 `total` 및 `n` 도 동기화 되어야 합니다. <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> 이 목적을 위해 메서드를 사용 합니다.  
  
 다음 예제에는 함께 사용 하는 방법을 보여 줍니다.는 <xref:System.Threading.Monitor> 클래스 (사용 하 여 구현 된 `lock` 또는 `SyncLock` 언어 구문), <xref:System.Threading.Interlocked> 클래스 및 <xref:System.Threading.AutoResetEvent> 클래스. 두 개의 정의 `internal` (C#에서) 또는 `Friend` (Visual Basic)에서는 클래스, `SyncResource` 및 `UnSyncResource`, 각각 리소스에 대 한 동기화 되거나 동기화 되지 않은 액세스를 제공 하는 합니다. 이 예제에서는 동기화 되거나 동기화 되지 않은 액세스 (각 메서드 호출이 신속히 완료 되는 경우 수) 있음 차이점을 보여 줍니다. 위해이 메서드에 임의 지연이 포함 되어 있습니다: 짝수인 스레드에 대해 <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> 속성은,는 메서드 호출 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 2, 000 밀리초의 지연을 소개 합니다. 때문에 `SyncResource` 클래스는 공용이 동기화 된 리소스에서 잠금을 사용 하는 클라이언트 코드의 없음; 내부 클래스가 자체적으로 잠금을 합니다. 이를 통해 악성 코드가 공용 개체에서 잠금을 가져오는 것을 방지할 수 있습니다.  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 이 예제에서는 변수를 정의 `numOps`, 리소스에 액세스 하려고 하는 스레드 수를 정의 하는 합니다. 응용 프로그램 스레드 호출에서 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 메서드 동기화와 동기화 되지 않은 액세스 액세스에 대해 5 번 각각. <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 메서드에 단일 매개 변수, 매개 변수 없이 허용 하 고 값을 반환 하는 대리자입니다. 동기화 된 액세스에 대 한 호출의 `SyncUpdateResource` 메서드; 동기화 되지 않은 액세스에 대 한 호출에서 `UnSyncUpdateResource` 메서드. 응용 프로그램 스레드 호출 메서드 호출의 각 집합에는 [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) 때까지 차단 해당 메서드는 <xref:System.Threading.AutoResetEvent> 인스턴스가 신호입니다.  
  
 호출할 때마다는 `SyncUpdateResource` 메서드 호출 내부 `SyncResource.Access` 메서드 및 호출은 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 감소 시키기 위해 메서드는 `numOps` 카운터입니다. <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 메서드를 사용 하는 카운터를 감소 시키기 위해, 그렇지 않으면 있습니다 수 없기 때문에 두 번째 스레드가 액세스 하는지 값 전에 첫 번째 스레드의 감소 된 값이 변수에 저장 되기도 합니다. 마지막으로 동기화 된 작업자 스레드가 감소 카운터를 0으로, 동기화 된 모든 스레드가 완료 했음을 리소스 액세스는 `SyncUpdateResource` 메서드 호출에서 <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> 주 스레드가 계속 되도록 신호를 보냅니다 메서드 실행 합니다.  
  
 호출할 때마다는 `UnSyncUpdateResource` 메서드 호출 내부 `UnSyncResource.Access` 메서드 및 호출은 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 감소 시키기 위해 메서드는 `numOps` 카운터입니다. 다시 한 번의 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 두 번째 스레드가 첫 번째 스레드의 감소 된 값이 변수에 할당 되기 전에 값 액세스 하지 않도록 하는 카운터를 감소 시키기 위해 메서드를 사용 합니다. 마지막으로 동기화 된 작업자 스레드가 감소 카운터를 0으로 때 리소스에 액세스 해야 동기화 되지 않은 스레드가 더 이상 있는지를 나타내는 `UnSyncUpdateResource` 메서드 호출에서 <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> 주 스레드가 계속 실행 되도록 신호를 보냅니다 메서드 .  
  
 예제의 출력에 나타난 것처럼, 동기화된 액세스는 호출한 스레드가 보호된 리소스를 종료한 다음 다른 스레드가 액세스할 수 있도록 하기 때문에 각 스레드는 선행 작업에서 대기합니다. 반면에 잠금 없이 `UnSyncResource.Access` 메서드는 스레드가 도달 하는 순서로 호출 됩니다.  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 개체의 단독 잠금을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">모니터 잠금을 가져올 개체입니다.</param>
        <summary>지정된 개체의 단독 잠금을 가져옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 `Enter` 얻으려고는 <xref:System.Threading.Monitor> 매개 변수로 전달 된 개체입니다. 다른 스레드가 실행 하는 경우는 `Enter` 개체에 해당 아직 실행 되지 않았으면 있지만 <xref:System.Threading.Monitor.Exit%2A>, 현재 스레드가 다른 스레드에서 개체를 해제할 때까지 차단 됩니다. 에 동일한 스레드에서 호출 하는 `Enter` 차단 하지 않고 두 번 이상 이지만 동일한 수의 `Exit` 호출 개체에서 대기 하는 다른 스레드는 차단 해제 되기 전에 호출 되어야 합니다.  
  
 사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 아닙니다. 값 형식 변수를 전달 하는 경우 `Enter`, 개체로 boxed 형식이 됩니다. 같은 변수를 전달 하는 경우 `Enter` 다시 별개의 개체로 boxed 및 스레드를 차단 하지 않습니다. 이 경우 코드는 `Monitor` 은 보호 중인 보호 되지 않습니다. 또한 전달 하는 경우 변수를 `Exit`, 별도 다른 개체가 만들어집니다. 에 전달 된 개체가 `Exit` 에 전달 된 개체와에서 다른 `Enter`, `Monitor` throw <xref:System.Threading.SynchronizationLockException>합니다. 자세한 내용은 해당 개념 항목을 참조 하십시오. [모니터](xref:System.Threading.Monitor)합니다.  
  
 <xref:System.Threading.Thread.Interrupt%2A> 입력 대기 중인 스레드를 중단할 수는 `Monitor` 개체에 있습니다. A <xref:System.Threading.ThreadInterruptedException> throw 됩니다.  
  
 C#을 사용 하 여 `try`...`finally` 블록 (`Try`...`Finally` Visual Basic) 하 고 모니터를 해제 하거나 C#을 사용 해야 `lock` 문 (`SyncLock` Visual Basic의 문)를 래핑하고 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A> 의 메서드는 `try`...`finally` 블록입니다.  
  
   
  
## Examples  
 다음 예제에서는 `Enter` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <param name="lockTaken">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.  예외가 발생하지 않는 경우 이 메서드의 출력은 항상 <see langword="true" />입니다.</param>
        <summary>지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 `Enter` 얻으려고는 <xref:System.Threading.Monitor> 변수로 전달 된 개체에는 `obj` 매개 변수입니다. 다른 스레드가 실행 하는 경우는 `Enter` 개체에 해당 아직 실행 되지 않았으면 있지만 <xref:System.Threading.Monitor.Exit%2A>, 현재 스레드가 다른 스레드에서 개체를 해제할 때까지 차단 됩니다. 에 동일한 스레드에서 호출 하는 `Enter` 차단 하지 않고 두 번 이상 이지만 동일한 수의 `Exit` 호출 개체에서 대기 하는 다른 스레드는 차단 해제 되기 전에 호출 되어야 합니다.  
  
 예외가 throw 되었기 때문에 잠금이 수행 하지, 경우에 대 한 지정 된 변수는 `lockTaken` 매개 변수는 `false` 이 메서드 종료 된 후입니다. 이렇게 하면 모든 경우에는 잠금을 해제 하는 데 필요한 인지를 확인 하려면 프로그램. 이 메서드가 예외를 throw 하지 않고 반환 하는 경우에 대 한 지정 된 변수는 `lockTaken` 매개 변수는 항상 `true`, 및 테스트할 필요가 없습니다.  
  
 사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 아닙니다. 값 형식 변수를 전달 하는 경우 `Enter`, 개체로 boxed 형식이 됩니다. 같은 변수를 전달 하는 경우 `Enter` 다시 별개의 개체로 boxed 및 스레드를 차단 하지 않습니다. 이 경우 코드는 `Monitor` 은 보호 중인 보호 되지 않습니다. 또한 전달 하는 경우 변수를 `Exit`, 별도 다른 개체가 만들어집니다. 에 전달 된 개체가 `Exit` 에 전달 된 개체와에서 다른 `Enter`, `Monitor` throw <xref:System.Threading.SynchronizationLockException>합니다. 자세한 내용은 해당 개념 항목을 참조 하십시오. [모니터](xref:System.Threading.Monitor)합니다.  
  
 <xref:System.Threading.Thread.Interrupt%2A> 입력 대기 중인 스레드를 중단할 수는 `Monitor` 개체에 있습니다. A <xref:System.Threading.ThreadInterruptedException> throw 됩니다.  
  
   
  
## Examples  
 다음 코드와의 기본적인 패턴을 사용 하 여 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> 메서드 오버 로드 합니다. 이 오버 로드에 전달 되는 변수의 값을 항상 설정 된 `ref` 매개 변수 (`ByRef` Visual basic에서) `lockTaken`메서드가 변수의 값은 되도록 잠금을 있는지 여부를 테스트 하는 신뢰할 수 있는 방법은 예외를 throw 하는 경우에 릴리스 했습니다.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 해제할 개체입니다.</param>
        <summary>지정된 개체의 단독 잠금을 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 스레드가에 잠금을 소유 해야는 `obj` 매개 변수입니다. 호출 스레드가 지정된 된 개체에서 잠금을 소유 하 고 동일한 수의가 변경한 경우 `Exit` 및 <xref:System.Threading.Monitor.Enter%2A> 다음 잠금이 해제 되는 개체에 대 한 호출입니다. 호출 스레드가 호출 하지 않으면 `Exit` 같은 횟수 만큼 `Enter`, 잠금이 해제 되지 않습니다.  
  
 잠금이 해제 되는 개체에 대 한 준비 큐의 다른 스레드를 하는 경우 스레드 중 하나가 잠금을 가져옵니다. 다른 스레드가 잠금을 획득 하려고 대기 하 고 대기 중인 큐에 있는 경우 이동 하지 않습니다 자동으로 준비 된 큐에 있는 잠금의 소유자를 호출할 때 `Exit`합니다. 준비 큐에 하나 이상의 대기 중인 스레드를 이동 하려면 호출 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 호출 하기 전에 `Exit`합니다.  
  
   
  
## Examples  
 다음 예제에서는 `Exit` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">현재 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">테스트할 개체입니다.</param>
        <summary>현재 스레드에 지정된 개체에 대한 잠금이 있는지 여부를 확인합니다.</summary>
        <returns>현재 스레드에 <paramref name="obj" />에 대한 잠금이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 사용 하 여 획득 된 잠금에에 대해서만 사용할 수 있는이 방법의 <xref:System.Threading.Monitor> 클래스를 사용 하 여 C# 또는 `lock` 문 또는 Visual Basic `SyncLock` 사용 하 여 구현 하는 문에 <xref:System.Threading.Monitor>합니다.  
  
 와 같은 진단 도구로이 메서드를 사용 하는 <xref:System.Diagnostics.Debug.Assert%2A> 메서드 및 <xref:System.Diagnostics.Contracts.Contract> 클래스를 포함 하는 잠금 문제를 디버깅 하는 <xref:System.Threading.Monitor> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">스레드에서 기다리는 개체입니다.</param>
        <summary>대기 중인 큐에 포함된 스레드에 잠겨 있는 개체의 상태 변경을 알립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 잠금의 현재 소유자 사용 하 여 대기 중인 개체를 표시할 수만 `Pulse`합니다.  
  
 현재 지정된 된 개체에 대 한 잠금을 소유 하는 스레드 잠금에 대 한 줄에 있는 다음 스레드를 알리기 위해이 메서드를 호출 합니다. 펄스를 수신 하면 대기 스레드가 준비 된 큐로 이동 합니다. 호출한 스레드에서 `Pulse` 의 잠금을 해제 (필요가 없는 펄스 된 스레드가) 준비 된 큐에 있는 다음 스레드 잠금을 가져옵니다.  
  
> [!IMPORTANT]
>  <xref:System.Threading.Monitor> 클래스 하는지 여부를 나타내는 상태를 유지 하지 않습니다는 <xref:System.Threading.Monitor.Pulse%2A> 메서드가 호출 되었습니다. 따라서 호출 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 스레드가 대기 중인 경우, 호출 하는 다음 스레드에서 <xref:System.Threading.Monitor.Wait%2A> 블록 처럼 <xref:System.Threading.Monitor.Pulse%2A> 마치 호출 되지 않습니다. 두 개의 스레드를 사용 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 및 <xref:System.Threading.Monitor.Wait%2A> 상호 작용할이 인해 교착 상태가 발생에서 합니다. 이와 반대로의 동작은 <xref:System.Threading.AutoResetEvent> 클래스: 나타낸다고 하는 경우는 <xref:System.Threading.AutoResetEvent> 호출 하 여 해당 <xref:System.Threading.EventWaitHandle.Set%2A> 메서드를 대기 중, 스레드가 없는 및는 <xref:System.Threading.AutoResetEvent> 스레드가 호출 될 때까지 신호를 받은 상태로 남아 있으며 <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, 또는 <xref:System.Threading.WaitHandle.WaitAll%2A>합니다. <xref:System.Threading.AutoResetEvent> 해당 스레드를 해제 하 고 보내지 않은 상태로 돌아갑니다.  
  
 동기화 된 개체가 소유 하 고 현재 잠금, 스레드 잠금을 가져올 준비가 된, 포함 하는 준비 된 큐에 대 한 참조 및 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 개의 참조가 있음을 유의입니다 개체의 상태 변경에 대 한 알림을 대기 중인 스레드를 포함 합니다.  
  
 `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, 및 <xref:System.Threading.Monitor.Wait%2A> 메서드 코드의 동기화 블록 내에서 호출 되어야 합니다.  
  
 여러 스레드를 알리기 위해 사용 하 여는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">펄스를 보내는 개체입니다.</param>
        <summary>대기 중인 모든 스레드에 개체 상태 변경을 알립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 지정된 된 개체에 대 한 잠금을 소유 하는 스레드 개체에 대 한 잠금을 획득 하려고 대기 하는 모든 스레드가 신호를 보내이 메서드를 호출 합니다. 신호를 보낸 후 대기 중인 스레드가 준비 된 큐로 이동 됩니다. 호출한 스레드에서 `PulseAll` 잠금을 해제 하 고, 준비 된 큐에 있는 다음 스레드 잠금을 가져옵니다.  
  
 동기화 된 개체가 소유 하 고 현재 잠금, 스레드 잠금을 가져올 준비가 된, 포함 하는 준비 된 큐에 대 한 참조 및 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 개의 참조가 있음을 유의입니다 개체의 상태 변경에 대 한 알림을 대기 중인 스레드를 포함 합니다.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, 및 <xref:System.Threading.Monitor.Wait%2A> 메서드 코드의 동기화 블록 내에서 호출 되어야 합니다.  
  
 에 대 한 설명의 <xref:System.Threading.Monitor.Pulse%2A> 메서드 수행 되는 작업에 대해 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
 단일 스레드를 알리기 위해 사용 하 여는 `Pulse` 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 개체의 단독 잠금을 가져오려고 했습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <summary>지정된 개체의 단독 잠금을 가져오려고 했습니다.</summary>
        <returns>현재 스레드에서 잠금을 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 성공이 메서드 배타적 잠금을 획득에 `obj` 매개 변수입니다. 이 메서드는 잠금을 사용할 수 있는지 여부를 즉시 반환 합니다.  
  
 이 메서드는 <xref:System.Threading.Monitor.Enter%2A>, 하지만 현재 스레드를 차단 하지는 것입니다. 메서드가 반환 하는 경우 스레드를 차단 하지 않고 입력할 수 없습니다, `false,`합니다.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 아닙니다. 자세한 내용은 참조는 <xref:System.Threading.Monitor> 문서.  
  
 스레드 임계 영역에 들어가지 않습니다을 보장 하려면를 검사 하는 메서드의 반환 값의 반환 값은 경우에 임계 영역에서 코드를 실행할 `true`합니다. 다음 코드에서는이 메서드를 호출 하는 데 사용 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록 호출 스레드에서 예외가 발생 하면 임계 영역에 대 한 잠금을 해제 하도록 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 다음 코드 예제에서는 `TryEnter` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <param name="lockTaken">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.</param>
        <summary>지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정하려고 시도합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 성공이 메서드 배타적 잠금을 획득에 `obj` 매개 변수입니다. 이 메서드는 잠금을 사용할 수 있는지 여부를 즉시 반환 합니다.  
  
 예외가 throw 되었기 때문에 잠금이 수행 하지, 경우에 대 한 지정 된 변수는 `lockTaken` 매개 변수는 `false` 이 메서드 종료 된 후입니다. 이렇게 하면 모든 경우에는 잠금을 해제 하는 데 필요한 인지를 확인 하려면 프로그램.  
  
 이 메서드는 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, 하지만 현재 스레드를 차단 하지는 것입니다. 스레드를 차단 하지 않고 들어갈 수 없는 경우는 `lockTaken` 인수도 설정 되어 `false` 메서드가 반환 합니다.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 아닙니다. 자세한 내용은 <xref:System.Threading.Monitor>를 참조하십시오.  
  
 스레드 임계 영역에 들어가지 않습니다의 값을 검사 해야 하기 위해 `lockTaken` 해당 값이 있는 경우에 임계 영역에서 코드를 실행 하 고 `true`합니다. 다음 코드에서는이 메서드를 호출 하는 데 사용 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록 호출 스레드에서 예외가 발생 하면 임계 영역에 대 한 잠금을 해제 하도록 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 다음 코드와의 기본적인 패턴을 사용 하 여 <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> 메서드 오버 로드 합니다. 이 오버 로드에 전달 되는 변수의 값을 항상 설정 된 `ref` 매개 변수 (`ByRef` Visual basic에서) `lockTaken`메서드가 변수의 값은 되도록 잠금을 있는지 여부를 테스트 하는 신뢰할 수 있는 방법은 예외를 throw 하는 경우에 릴리스 했습니다.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <param name="millisecondsTimeout">잠금을 기다릴 밀리초 수입니다.</param>
        <summary>지정된 시간(밀리초) 동안 지정된 개체의 단독 잠금을 가져오려고 했습니다.</summary>
        <returns>현재 스레드에서 잠금을 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `millisecondsTimeout` 매개 변수와 같으면 <xref:System.Threading.Timeout.Infinite>,이 메서드는 <xref:System.Threading.Monitor.Enter%2A>합니다. 경우 `millisecondsTimeout` 0 이면이 메서드는 <xref:System.Threading.Monitor.TryEnter%2A>합니다.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 아닙니다. 자세한 내용은 참조는 <xref:System.Threading.Monitor> 문서.  
  
 스레드 임계 영역에 들어가지 않습니다을 보장 하려면를 검사 하는 메서드의 반환 값의 반환 값은 경우에 임계 영역에서 코드를 실행할 `true`합니다. 다음 코드에서는이 메서드를 호출 하는 데 사용 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록 호출 스레드에서 예외가 발생 하면 임계 영역에 대 한 잠금을 해제 하도록 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" />가 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />가 아닌 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <param name="timeout">잠금을 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다. -1밀리초 값은 무한 대기를 지정합니다.</param>
        <summary>지정된 시간 동안 지정된 개체의 단독 잠금을 가져오려고 했습니다.</summary>
        <returns>현재 스레드에서 잠금을 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우의 값은 `timeout` 시간 (밀리초)로 변환 하는 매개 변수-1 이면이 메서드는 <xref:System.Threading.Monitor.Enter%2A>합니다. 하는 경우의 값 `timeout` 0 이면이 메서드는 <xref:System.Threading.Monitor.TryEnter%2A>합니다.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 아닙니다. 자세한 내용은 참조는 <xref:System.Threading.Monitor> 클래스 항목입니다.  
  
 스레드 임계 영역에 들어가지 않습니다을 보장 하려면를 검사 하는 메서드의 반환 값의 반환 값은 경우에 임계 영역에서 코드를 실행할 `true`합니다. 다음 코드에서는이 메서드를 호출 하는 데 사용 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록 호출 스레드에서 예외가 발생 하면 임계 영역에 대 한 잠금을 해제 하도록 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 값(밀리초)이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1밀리초)와 같지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <param name="millisecondsTimeout">잠금을 기다릴 밀리초 수입니다.</param>
        <param name="lockTaken">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.</param>
        <summary>지정된 시간(밀리초) 동안 지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정하려고 시도합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `millisecondsTimeout` 매개 변수와 같으면 <xref:System.Threading.Timeout.Infinite>,이 메서드는 <xref:System.Threading.Monitor.Enter%28System.Object%29>합니다. 경우 `millisecondsTimeout` 0 이면이 메서드는 <xref:System.Threading.Monitor.TryEnter%28System.Object%29>합니다.  
  
 예외가 throw 되었기 때문에 잠금이 수행 하지, 경우에 대 한 지정 된 변수는 `lockTaken` 매개 변수는 `false` 이 메서드 종료 된 후입니다. 이렇게 하면 모든 경우에는 잠금을 해제 하는 데 필요한 인지를 확인 하려면 프로그램.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 아닙니다. 자세한 내용은 참조는 <xref:System.Threading.Monitor> 클래스 항목입니다.  
  
 스레드 임계 영역에 들어가지 않습니다의 값을 검사 해야 하기 위해 `lockTaken` 해당 값이 있는 경우에 임계 영역에서 코드를 실행 하 고 `true`합니다. 다음 코드에서는이 메서드를 호출 하는 데 사용 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록 호출 스레드에서 예외가 발생 하면 임계 영역에 대 한 잠금을 해제 하도록 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 다음 코드와의 기본적인 패턴을 사용 하 여 <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> 메서드 오버 로드 합니다. 이 오버 로드에 전달 되는 변수의 값을 항상 설정 된 `ref` 매개 변수 (`ByRef` Visual basic에서) `lockTaken`메서드가 변수의 값은 되도록 잠금을 있는지 여부를 테스트 하는 신뢰할 수 있는 방법은 예외를 throw 하는 경우에 릴리스 했습니다.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" />가 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />가 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <param name="timeout">잠금을 대기할 시간입니다. -1밀리초 값은 무한 대기를 지정합니다.</param>
        <param name="lockTaken">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.</param>
        <summary>지정된 시간 동안 지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정하려고 시도합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우의 값은 `timeout` 시간 (밀리초)로 변환 하는 매개 변수-1 이면이 메서드는 <xref:System.Threading.Monitor.Enter%28System.Object%29>합니다. 하는 경우의 값 `timeout` 0 이면이 메서드는 <xref:System.Threading.Monitor.TryEnter%28System.Object%29>합니다.  
  
 예외가 throw 되었기 때문에 잠금이 수행 하지, 경우에 대 한 지정 된 변수는 `lockTaken` 매개 변수는 `false` 이 메서드 종료 된 후입니다. 이렇게 하면 모든 경우에는 잠금을 해제 하는 데 필요한 인지를 확인 하려면 프로그램.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 아닙니다. 자세한 내용은 참조는 <xref:System.Threading.Monitor> 클래스 항목입니다.  
  
 스레드 임계 영역에 들어가지 않습니다의 값을 검사 해야 하기 위해 `lockTaken` 해당 값이 있는 경우에 임계 영역에서 코드를 실행 하 고 `true`합니다. 다음 코드에서는이 메서드를 호출 하는 데 사용 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록 호출 스레드에서 예외가 발생 하면 임계 영역에 대 한 잠금을 해제 하도록 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 값(밀리초)이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1밀리초)와 같지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다.</summary>
        <returns>지정된 개체 잠금을 호출자가 다시 가져와 호출이 반환되면 <see langword="true" />입니다. 잠금을 다시 가져오지 않으면 이 메서드는 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 지정된 된 개체에 대 한 잠금을 소유 하 고 스레드가 다른 스레드에서 액세스할 수 있도록 개체를 해제 하기 위해이 메서드를 호출 합니다. 호출자가 잠금을 다시 획득 하기 위해 기다리는 동안 차단 됩니다. 이 메서드는 호출자에 게 다른 스레드 작업의 결과로 발생 하는 상태 변경에 대 한 대기 해야 할 때 호출 됩니다.  
  
 호출 하면 스레드 `Wait`, 개체의 잠금을 해제 하 고 개체의 대기 큐에 들어갑니다. 개체의 준비 된 큐에 있는 다음 스레드 (있는 경우) 잠금을 획득 하는 개체의 단독으로 사용 하 고 있습니다. 호출 하는 모든 스레드가 `Wait` 신호를 받을 때까지 대기 중인 큐에 남아 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A>잠금의 소유자가 보내는 합니다. 경우 `Pulse` 스레드가 대기 큐의 앞 부분에만 영향을 받는 전송 됩니다. 경우 `PulseAll` 영향을 받는 개체에 대 한 대기 중인 모든 스레드가 전송 됩니다. 신호를 받으면 하나 이상의 스레드가 대기 큐를 유지 하 고 준비 된 큐를 입력 합니다. 준비 된 큐에 있는 스레드에서 잠금을 다시 가져올 수 있습니다.  
  
 이 메서드는 호출 스레드에서 개체에 잠금을 다시 가져오면를 반환 합니다. 잠금의 소유자를 호출 하지 않는 경우이 메서드는 무기한으로 차단 참고 `Pulse` 또는 `PulseAll`합니다.  
  
 호출자에 게 실행 `Wait` 횟수에 관계 없이 한 번 <xref:System.Threading.Monitor.Enter%2A> 지정 된 개체를 호출 했습니다. 이론적으로 `Wait` 메서드는 호출자가 호출한 횟수를 저장 `Enter` 개체에 하 고 호출 `Exit` 잠긴된 개체를 완전히 해제 하는 데 필요한 만큼 여러 번입니다. 호출자에 게는 다음 개체를 다시 획득 하기 위해 기다리는 동안 차단 합니다. 시스템에서는 호출 호출자가 잠금을 다시 가져오면 `Enter` 저장 된 복원 하는 데 필요한 만큼 여러 번 `Enter` 호출자에 대 한 수입니다. 호출 `Wait` 잠금을 해제 하 고 지정된 된 개체에 대 한 해당 하며 호출자에 게 다른 개체에 대 한 잠금 소유자 인 경우 이러한 잠금은 해제 되지 않습니다.  
  
 동기화 된 개체가 소유 하 고 현재 잠금, 스레드 잠금을 가져올 준비가 된, 포함 하는 준비 된 큐에 대 한 참조 및 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 개의 참조가 있음을 유의입니다 개체의 상태 변경에 대 한 알림을 대기 중인 스레드를 포함 합니다.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, 및 `Wait` 메서드 코드의 동기화 블록 내에서 호출 되어야 합니다.  
  
 에 대 한 설명의 <xref:System.Threading.Monitor.Pulse%2A> 메서드 수행 되는 작업에 대해 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <param name="millisecondsTimeout">스레드가 준비된 큐에 들어가기 전에 대기할 밀리초 수입니다.</param>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다.</summary>
        <returns>지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배타적 잠금을 다시 가져올 때까지이 메서드를 반환 하지 않습니다는 `obj` 매개 변수입니다.  
  
 현재 지정된 된 개체에 대 한 잠금을 소유 하 고 스레드가 다른 스레드에서 액세스할 수 있도록 개체를 해제 하기 위해이 메서드를 호출 합니다. 호출자가 잠금을 다시 획득 하기 위해 기다리는 동안 차단 됩니다. 이 메서드는 호출자에 게 다른 스레드 작업의 결과로 발생 하는 상태 변경에 대 한 대기 해야 할 때 호출 됩니다.  
  
 제한 시간 다른 스레드가 먼저 호출 하지 않고 잠금을 해제 하는 경우 현재 스레드가 무기한으로 차단 되지 않습니다 보장 된 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드. 또한 스레드가 늦은 대기 큐의 다른 스레드는 잠금을 더 빨리 다시 가져올 수 있도록 바이패스 하 고 준비 된 큐로 이동 합니다. 스레드가의 반환 값을 테스트할 수는 <xref:System.Threading.Monitor.Wait%2A> 잠금 제한 시간 전에 다시 가져왔는지 여부를 결정 하는 메서드. 스레드는 대기를 일으킨 조건을 평가할 수 경우 필요한 호출은 <xref:System.Threading.Monitor.Wait%2A> 메서드를 다시 합니다.  
  
 호출 하면 스레드 `Wait`, 개체의 잠금을 해제 하 고 개체의 대기 큐에 들어갑니다. 개체의 준비 된 큐에 있는 다음 스레드 (있는 경우) 잠금을 획득 하는 개체의 단독으로 사용 하 고 있습니다. 호출한 스레드를 `Wait` 잠금을 보유 하는 스레드는 호출 될 때까지 대기 중인 큐에 남아 있는 <xref:System.Threading.Monitor.PulseAll%2A>, 큐에 있는 다음 순서 및 잠금을 보유 하는 스레드를 호출 하거나 <xref:System.Threading.Monitor.Pulse%2A>합니다. 그러나 경우 `millisecondsTimeout` 다른 스레드가이 개체를 호출 하기 전에 경과 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드를 원래 스레드가 잠금을 다시 가져오기 하려면 준비 된 큐로 이동 됩니다.  
  
> [!NOTE]
>  경우 <xref:System.Threading.Timeout.Infinite> 지정는 `millisecondsTimeout` 매개 변수를이 메서드는 차단 무기한는 잠금의 소유자를 호출 하지 않는 경우 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A>합니다. 경우 `millisecondsTimeout` 0 이면 호출 하는 스레드에서 `Wait` 잠금을 해제 한 다음 잠금을 다시 가져오기 위해 즉시 준비 된 큐에 들어갑니다.  
  
 호출자에 게 실행 `Wait` 횟수에 관계 없이 한 번 <xref:System.Threading.Monitor.Enter%2A> 지정 된 개체를 호출 했습니다. 이론적으로 `Wait` 메서드는 호출자가 호출한 횟수를 저장 <xref:System.Threading.Monitor.Enter%2A> 개체에 하 고 호출 <xref:System.Threading.Monitor.Exit%2A> 잠긴된 개체를 완전히 해제 하는 데 필요한 만큼 여러 번입니다. 호출자에 게는 다음 개체를 다시 획득 하기 위해 기다리는 동안 차단 합니다. 시스템에서는 호출 호출자가 잠금을 다시 가져오면 <xref:System.Threading.Monitor.Enter%2A> 저장 된 복원 하는 데 필요한 만큼 여러 번 <xref:System.Threading.Monitor.Enter%2A> 호출자에 대 한 수입니다. 호출 `Wait` 잠금을 해제 하 고 지정된 된 개체에 대 한 해당 하며 호출자에 게 다른 개체에 대 한 잠금 소유자 인 경우 이러한 잠금은 해제 되지 않습니다.  
  
> [!NOTE]
>  현재 잠금, 스레드 잠금을 가져올 준비가 된, 포함 하는 준비 된 큐에 대 한 참조 및 포함 하는 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 대 한 참조를 보유 하는 동기화 된 개체는 개체의 상태 변경에 대 한 알림을 대기 중인 스레드입니다.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, 및 `Wait` 메서드 코드의 동기화 블록 내에서 호출 되어야 합니다.  
  
 에 대 한 설명의 <xref:System.Threading.Monitor.Pulse%2A> 메서드 수행 되는 작업에 대해 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 매개 변수의 값이 음이고 <see cref="F:System.Threading.Timeout.Infinite" />와 같지 않은 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <param name="timeout">스레드가 준비된 큐에 들어가기 전에 대기할 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다.</summary>
        <returns>지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배타적 잠금을 다시 가져올 때까지이 메서드를 반환 하지 않습니다는 `obj` 매개 변수입니다.  
  
 현재 지정된 된 개체에 대 한 잠금을 소유 하 고 스레드가 다른 스레드에서 액세스할 수 있도록 개체를 해제 하기 위해이 메서드를 호출 합니다. 호출자가 잠금을 다시 획득 하기 위해 기다리는 동안 차단 됩니다. 이 메서드는 호출자에 게 다른 스레드 작업의 결과로 발생 하는 상태 변경에 대 한 대기 해야 할 때 호출 됩니다.  
  
 제한 시간 다른 스레드가 먼저 호출 하지 않고 잠금을 해제 하는 경우 현재 스레드가 무기한으로 차단 되지 않습니다 보장 된 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드. 또한 스레드가 늦은 대기 큐의 다른 스레드는 잠금을 더 빨리 다시 가져올 수 있도록 바이패스 하 고 준비 된 큐로 이동 합니다. 스레드가의 반환 값을 테스트할 수는 <xref:System.Threading.Monitor.Wait%2A> 잠금 제한 시간 전에 다시 가져왔는지 여부를 결정 하는 메서드. 스레드는 대기를 일으킨 조건을 평가할 수 경우 필요한 호출은 <xref:System.Threading.Monitor.Wait%2A> 메서드를 다시 합니다.  
  
 호출 하면 스레드 `Wait`, 개체의 잠금을 해제 하 고 개체의 대기 큐에 들어갑니다. 개체의 준비 된 큐에 있는 다음 스레드 (있는 경우) 잠금을 획득 하는 개체의 단독으로 사용 하 고 있습니다. 호출한 스레드를 `Wait` 잠금을 보유 하는 스레드는 호출 될 때까지 대기 중인 큐에 남아 있는 <xref:System.Threading.Monitor.PulseAll%2A>, 큐에 있는 다음 순서 및 잠금을 보유 하는 스레드를 호출 하거나 <xref:System.Threading.Monitor.Pulse%2A>합니다. 그러나 경우 `timeout` 다른 스레드가이 개체를 호출 하기 전에 경과 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드를 원래 스레드가 잠금을 다시 가져오기 하려면 준비 된 큐로 이동 됩니다.  
  
> [!NOTE]
>  경우는 <xref:System.TimeSpan> 에 대해 지정 된-1 밀리초를 나타내는 `timeout` 매개 변수를이 메서드는 차단 무기한는 잠금의 소유자를 호출 하지 않는 한 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A>합니다. 경우 `timeout` 은 0 밀리초를 호출 하는 스레드에서 `Wait` 잠금을 해제 한 다음 잠금을 다시 가져오기 위해 즉시 준비 된 큐에 들어갑니다.  
  
 호출자에 게 실행 `Wait` 횟수에 관계 없이 한 번 <xref:System.Threading.Monitor.Enter%2A> 지정 된 개체를 호출 했습니다. 이론적으로 `Wait` 메서드는 호출자가 호출한 횟수를 저장 <xref:System.Threading.Monitor.Enter%2A> 개체에 하 고 호출 <xref:System.Threading.Monitor.Exit%2A> 잠긴된 개체를 완전히 해제 하는 데 필요한 만큼 여러 번입니다. 호출자에 게는 다음 개체를 다시 획득 하기 위해 기다리는 동안 차단 합니다. 시스템에서는 호출 호출자가 잠금을 다시 가져오면 <xref:System.Threading.Monitor.Enter%2A> 저장 된 복원 하는 데 필요한 만큼 여러 번 <xref:System.Threading.Monitor.Enter%2A> 호출자에 대 한 수입니다. 호출 `Wait` 잠금을 해제 하 고 지정된 된 개체에 대 한 해당 하며 호출자에 게 다른 개체에 대 한 잠금 소유자 인 경우 이러한 잠금은 해제 되지 않습니다.  
  
> [!NOTE]
>  현재 잠금, 스레드 잠금을 가져올 준비가 된, 포함 하는 준비 된 큐에 대 한 참조 및 포함 하는 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 대 한 참조를 보유 하는 동기화 된 개체는 개체의 상태 변경에 대 한 알림을 대기 중인 스레드입니다.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, 및 `Wait` 메서드 코드의 동기화 블록 내에서 호출 되어야 합니다.  
  
 에 대 한 설명의 <xref:System.Threading.Monitor.Pulse%2A> 메서드 수행 되는 작업에 대해 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 매개 변수의 값(밀리초)이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1밀리초)를 나타내지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <param name="millisecondsTimeout">스레드가 준비된 큐에 들어가기 전에 대기할 밀리초 수입니다.</param>
        <param name="exitContext">대기 전에 컨텍스트의 동기화 도메인(동기화된 컨텍스트에 있는 경우)을 끝내고 다시 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다. 또한 이 메서드는 컨텍스트의 동기화 도메인(동기화된 컨텍스트에 있는 경우)을 대기 전에 종료하고 나중에 다시 가져오는지 여부도 지정합니다.</summary>
        <returns>지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배타적 잠금을 다시 가져올 때까지이 메서드를 반환 하지 않습니다는 `obj` 매개 변수입니다.  
  
 현재 지정된 된 개체에 대 한 잠금을 소유 하 고 스레드가 다른 스레드에서 액세스할 수 있도록 개체를 해제 하기 위해이 메서드를 호출 합니다. 호출자가 잠금을 다시 획득 하기 위해 기다리는 동안 차단 됩니다. 이 메서드는 호출자에 게 다른 스레드 작업의 결과로 발생 하는 상태 변경에 대 한 대기 해야 할 때 호출 됩니다.  
  
 제한 시간 다른 스레드가 먼저 호출 하지 않고 잠금을 해제 하는 경우 현재 스레드가 무기한으로 차단 되지 않습니다 보장 된 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드. 또한 스레드가 늦은 대기 큐의 다른 스레드는 잠금을 더 빨리 다시 가져올 수 있도록 바이패스 하 고 준비 된 큐로 이동 합니다. 스레드가의 반환 값을 테스트할 수는 <xref:System.Threading.Monitor.Wait%2A> 잠금 제한 시간 전에 다시 가져왔는지 여부를 결정 하는 메서드. 스레드는 대기를 일으킨 조건을 평가할 수 경우 필요한 호출은 <xref:System.Threading.Monitor.Wait%2A> 메서드를 다시 합니다.  
  
 호출 하면 스레드 `Wait`, 잠금을 해제 하 고 대기 중인 큐에 들어갑니다. 이 시점에서 준비 된 큐에 있는 다음 스레드 (있는 경우)은 제어할 수 있게 잠금. 호출한 스레드를 `Wait` 잠금을 보유 하는 스레드는 호출 될 때까지 대기 중인 큐에 남아 있는 <xref:System.Threading.Monitor.PulseAll%2A>, 큐에 있는 다음 순서 및 잠금을 보유 하는 스레드를 호출 하거나 <xref:System.Threading.Monitor.Pulse%2A>합니다. 그러나 경우 `millisecondsTimeout` 다른 스레드가이 개체를 호출 하기 전에 경과 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드를 원래 스레드가 잠금을 다시 가져오기 하려면 준비 된 큐로 이동 됩니다.  
  
> [!NOTE]
>  경우 <xref:System.Threading.Timeout.Infinite> 지정는 `millisecondsTimeout` 매개 변수를이 메서드는 차단 무기한는 잠금의 소유자를 호출 하지 않는 경우 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A>합니다. 경우 `millisecondsTimeout` 0 이면 호출 하는 스레드에서 `Wait` 잠금을 해제 한 다음 잠금을 다시 가져오기 위해 즉시 준비 된 큐에 들어갑니다.  
  
 호출자에 게 실행 `Wait` 횟수에 관계 없이 한 번 <xref:System.Threading.Monitor.Enter%2A> 지정 된 개체를 호출 했습니다. 이론적으로 `Wait` 메서드는 호출자가 호출한 횟수를 저장 <xref:System.Threading.Monitor.Enter%2A> 개체에 하 고 호출 <xref:System.Threading.Monitor.Exit%2A> 잠긴된 개체를 완전히 해제 하는 데 필요한 만큼 여러 번입니다. 호출자에 게는 다음 개체를 다시 획득 하기 위해 기다리는 동안 차단 합니다. 시스템에서는 호출 호출자가 잠금을 다시 가져오면 <xref:System.Threading.Monitor.Enter%2A> 저장 된 복원 하는 데 필요한 만큼 여러 번 <xref:System.Threading.Monitor.Enter%2A> 호출자에 대 한 수입니다. 호출 `Wait` 잠금을 해제 하 고 지정된 된 개체에 대 한 해당 하며 호출자에 게 다른 개체에 대 한 잠금 소유자 인 경우 이러한 잠금은 해제 되지 않습니다.  
  
> [!NOTE]
>  현재 잠금, 스레드 잠금을 가져올 준비가 된, 포함 하는 준비 된 큐에 대 한 참조 및 포함 하는 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 대 한 참조를 보유 하는 동기화 된 개체는 개체의 상태 변경에 대 한 알림을 대기 중인 스레드입니다.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, 및 `Wait` 메서드 코드의 동기화 블록 내에서 호출 되어야 합니다.  
  
 에 대 한 설명의 <xref:System.Threading.Monitor.Pulse%2A> 메서드 수행 되는 작업에 대해 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
## <a name="notes-on-exiting-the-context"></a>컨텍스트 종료에 대 한 메모  
 `exitContext` 매개 변수 효과가 <xref:System.Threading.Monitor.Wait%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스에 대 한 호출 안에 스레드에 있으면 이러한 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에서 메서드를 현재 실행 되는 경우에 <xref:System.ContextBoundObject>처럼 <xref:System.String>, 기본이 아닌 컨텍스트에서 수 하는 경우는 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 코드는 기본 디렉터리가 아닌 다른 컨텍스트에서 실행 되는 경우 지정 하 `true` 에 대 한 `exitContext` 스레드가 기본이 아닌 관리 되는 컨텍스트를 종료 합니다 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.Monitor.Wait%2A> 메서드. 호출 후 원래 컨텍스트로 돌아갑니다는 <xref:System.Threading.Monitor.Wait%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다는 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 특성이 적용 합니다. 이 경우 클래스의 멤버에 대 한 모든 호출은 자동으로 동기화 및 동기화 도메인은 클래스에 대 한 코드의 본문 전체. 호출 스택에 있는 멤버의 코드를 호출 하는 경우는 <xref:System.Threading.Monitor.Wait%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`는 스레드가 계속 하려면는 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드가 동기화 도메인을 종료 합니다. 경우는 <xref:System.Threading.Monitor.Wait%2A> 컨텍스트의 동기화 도메인을 다시 입력 하는 호출한 스레드가 기다려야 메서드가 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" />가 동기화된 코드 블록 내에서 호출되지 않는 경우</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 매개 변수의 값이 음이고 <see cref="F:System.Threading.Timeout.Infinite" />와 같지 않은 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <param name="timeout">스레드가 준비된 큐에 들어가기 전에 대기할 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="exitContext">대기 전에 컨텍스트의 동기화 도메인(동기화된 컨텍스트에 있는 경우)을 끝내고 다시 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다. 필요에 따라 동기화된 컨텍스트의 동기화 도메인을 대기 전에 종료하고 나중에 해당 도메인을 다시 가져옵니다.</summary>
        <returns>지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배타적 잠금을 다시 가져올 때까지이 메서드를 반환 하지 않습니다는 `obj` 매개 변수입니다.  
  
 현재 지정된 된 개체에 대 한 잠금을 소유 하 고 스레드가 다른 스레드에서 액세스할 수 있도록 개체를 해제 하기 위해이 메서드를 호출 합니다. 호출자가 잠금을 다시 획득 하기 위해 기다리는 동안 차단 됩니다. 이 메서드는 호출자에 게 다른 스레드 작업의 결과로 발생 하는 상태 변경에 대 한 대기 해야 할 때 호출 됩니다.  
  
 제한 시간 다른 스레드가 먼저 호출 하지 않고 잠금을 해제 하는 경우 현재 스레드가 무기한으로 차단 되지 않습니다 보장 된 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드. 또한 스레드가 늦은 대기 큐의 다른 스레드는 잠금을 더 빨리 다시 가져올 수 있도록 바이패스 하 고 준비 된 큐로 이동 합니다. 스레드가의 반환 값을 테스트할 수는 <xref:System.Threading.Monitor.Wait%2A> 잠금 제한 시간 전에 다시 가져왔는지 여부를 결정 하는 메서드. 스레드는 대기를 일으킨 조건을 평가할 수 경우 필요한 호출은 <xref:System.Threading.Monitor.Wait%2A> 메서드를 다시 합니다.  
  
 호출 하면 스레드 `Wait`, 잠금을 해제 하 고 대기 중인 큐에 들어갑니다. 이 시점에서 준비 된 큐에 있는 다음 스레드 (있는 경우)은 제어할 수 있게 잠금. 호출한 스레드를 `Wait` 잠금을 보유 하는 스레드는 호출 될 때까지 대기 중인 큐에 남아 있는 <xref:System.Threading.Monitor.PulseAll%2A>, 큐에 있는 다음 순서 및 잠금을 보유 하는 스레드를 호출 하거나 <xref:System.Threading.Monitor.Pulse%2A>합니다. 그러나 경우 `timeout` 다른 스레드가이 개체를 호출 하기 전에 밀리초가 경과 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드를 원래 스레드가 잠금을 다시 가져오기 하려면 준비 된 큐로 이동 됩니다.  
  
> [!NOTE]
>  경우는 <xref:System.TimeSpan> 에 대해 지정 된-1 밀리초를 나타내는 `timeout` 매개 변수를이 메서드는 차단 무기한는 잠금의 소유자를 호출 하지 않는 한 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A>합니다. 경우 `timeout` 은 0 밀리초를 호출 하는 스레드에서 `Wait` 잠금을 해제 한 다음 잠금을 다시 가져오기 위해 즉시 준비 된 큐에 들어갑니다.  
  
 호출자에 게 실행 `Wait` 횟수에 관계 없이 한 번 <xref:System.Threading.Monitor.Enter%2A> 지정 된 개체를 호출 했습니다. 이론적으로 `Wait` 메서드는 호출자가 호출한 횟수를 저장 <xref:System.Threading.Monitor.Enter%2A> 개체에 하 고 호출 <xref:System.Threading.Monitor.Exit%2A> 잠긴된 개체를 완전히 해제 하는 데 필요한 만큼 여러 번입니다. 호출자에 게는 다음 개체를 다시 획득 하기 위해 기다리는 동안 차단 합니다. 시스템에서는 호출 호출자가 잠금을 다시 가져오면 <xref:System.Threading.Monitor.Enter%2A> 저장 된 복원 하는 데 필요한 만큼 여러 번 <xref:System.Threading.Monitor.Enter%2A> 호출자에 대 한 수입니다. 호출 `Wait` 잠금을 해제 하 고 지정된 된 개체에 대 한 해당 하며 호출자에 게 다른 개체에 대 한 잠금 소유자 인 경우 이러한 잠금은 해제 되지 않습니다.  
  
> [!NOTE]
>  현재 잠금, 스레드 잠금을 가져올 준비가 된, 포함 하는 준비 된 큐에 대 한 참조 및 포함 하는 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 대 한 참조를 보유 하는 동기화 된 개체는 개체의 상태 변경에 대 한 알림을 대기 중인 스레드입니다.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, 및 `Wait` 메서드 코드의 동기화 블록 내에서 호출 되어야 합니다.  
  
 에 대 한 설명의 <xref:System.Threading.Monitor.Pulse%2A> 메서드 수행 되는 작업에 대해 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
## <a name="notes-on-exiting-the-context"></a>컨텍스트 종료에 대 한 메모  
 `exitContext` 매개 변수 효과가 <xref:System.Threading.Monitor.Wait%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스에 대 한 호출 안에 스레드에 있으면 이러한 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에서 메서드를 현재 실행 되는 경우에 <xref:System.ContextBoundObject>처럼 <xref:System.String>, 기본이 아닌 컨텍스트에서 수 하는 경우는 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 코드는 기본 디렉터리가 아닌 다른 컨텍스트에서 실행 되는 경우 지정 하 `true` 에 대 한 `exitContext` 스레드가 기본이 아닌 관리 되는 컨텍스트를 종료 합니다 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.Monitor.Wait%2A> 메서드. 호출 후 원래 컨텍스트로 돌아갑니다는 <xref:System.Threading.Monitor.Wait%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다는 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 특성이 적용 합니다. 이 경우 클래스의 멤버에 대 한 모든 호출은 자동으로 동기화 및 동기화 도메인은 클래스에 대 한 코드의 본문 전체. 호출 스택에 있는 멤버의 코드를 호출 하는 경우는 <xref:System.Threading.Monitor.Wait%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`는 스레드가 계속 하려면는 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드가 동기화 도메인을 종료 합니다. 경우는 <xref:System.Threading.Monitor.Wait%2A> 컨텍스트의 동기화 도메인을 다시 입력 하는 호출한 스레드가 기다려야 메서드가 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" />가 동기화된 코드 블록 내에서 호출되지 않는 경우</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wait를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 매개 변수가 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1 밀리초)를 나타내지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
  </Members>
</Type>