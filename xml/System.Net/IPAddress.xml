<Type Name="IPAddress" FullName="System.Net.IPAddress">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b382b2e424f3335e396090615b29820d1cd62c1d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class IPAddress" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit IPAddress extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.IPAddress" />
  <TypeSignature Language="VB.NET" Value="Public Class IPAddress" />
  <TypeSignature Language="C++ CLI" Value="public ref class IPAddress" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Primitives</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="f9964-101">IP(인터넷 프로토콜) 주소를 제공합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f9964-101">Provides an Internet Protocol (IP) address.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-102"><xref:System.Net.IPAddress> IP 네트워크에 있는 컴퓨터의 주소를 포함 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-102">The <xref:System.Net.IPAddress> class contains the address of a computer on an IP network.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-103">다음 코드 예제에서는 패밀리 주소를 가져올 서버를 쿼리 하는 방법을 보여주며, IP 주소를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-103">The following code example shows how to query a server to obtain the family addresses and the IP addresses it supports.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#1)]
 [!code-csharp[System.Net.IPAddress#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#1)]
 [!code-vb[System.Net.IPAddress#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-104">
            <see cref="T:System.Net.IPAddress" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-104">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="f9964-105">IP 주소의 바이트 배열 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-105">The byte array value of the IP address.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-106">
            <see cref="T:System.Net.IPAddress" /> 배열로 지정된 주소를 사용하여 <see cref="T:System.Byte" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-106">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-107"><xref:System.Net.IPAddress> 사용 하 여 만든는 <xref:System.Net.IPAddress.Address%2A> 속성이로 설정 `address`합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-107">The <xref:System.Net.IPAddress> is created with the <xref:System.Net.IPAddress.Address%2A> property set to `address`.</span></span>  
  
 <span data-ttu-id="f9964-108">경우 길이의 `address` 는 4, <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> IPv4 주소; 생성 0의 범위와 IPv6 주소 생성 되 고, 그러지 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-108">If the length of `address` is 4, <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> constructs an IPv4 address; otherwise, an IPv6 address with a scope of 0 is constructed.</span></span>  
  
 <span data-ttu-id="f9964-109"><xref:System.Byte> 배열 가장 중요 한 바이트가 인덱스 위치 0에 있는 네트워크 바이트 순서에 있는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-109">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f9964-110">
            <paramref name="address" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-110">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f9964-111">
            <paramref name="address" />에 잘못된 IP 주소가 포함되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-111">
              <paramref name="address" /> contains a bad IP address.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (long newAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 newAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (newAddress As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(long newAddress);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="newAddress" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="newAddress">
          <span data-ttu-id="f9964-112">IP 주소의 long 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-112">The long value of the IP address.</span>
          </span>
          <span data-ttu-id="f9964-113">예를 들어, big-endian 형식의 0x2414188f 값은 IP 주소가 "143.24.20.36"입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-113">For example, the value 0x2414188f in big-endian format would be the IP address "143.24.20.36".</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-114">
            <see cref="T:System.Net.IPAddress" />로 지정된 주소를 사용하여 <see cref="T:System.Int64" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-114">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as an <see cref="T:System.Int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-115"><xref:System.Net.IPAddress> 사용 인스턴스를 만듭니다는 <xref:System.Net.IPAddress.Address%2A> 속성이로 설정 `newAddress`합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-115">The <xref:System.Net.IPAddress> instance is created with the <xref:System.Net.IPAddress.Address%2A> property set to `newAddress`.</span></span>  
  
 <span data-ttu-id="f9964-116"><xref:System.Int64> 값 네트워크 바이트 순서에 있는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-116">The <xref:System.Int64> value is assumed to be in network byte order.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f9964-117">
            <paramref name="newAddress" /> &lt; 0 또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-117">
              <paramref name="newAddress" /> &lt; 0 or</span>
          </span>
          <span data-ttu-id="f9964-118">
            <paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-118">
              <paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[],System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte(), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address, long scopeid);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="f9964-119">IP 주소의 바이트 배열 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-119">The byte array value of the IP address.</span>
          </span>
        </param>
        <param name="scopeid">
          <span data-ttu-id="f9964-120">범위 식별자의 long 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-120">The long value of the scope identifier.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-121">
            <see cref="T:System.Net.IPAddress" /> 배열로 지정된 주소와 지정된 범위 식별자를 사용하여 <see cref="T:System.Byte" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-121">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array and the specified scope identifier.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-122">이 생성자는 IPv6 주소를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-122">This constructor instantiates an IPv6 address.</span></span> <span data-ttu-id="f9964-123">`scopeid` 링크-로컬 주소 경우 네트워크 인터페이스를 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-123">The `scopeid` identifies a network interface in the case of a link-local address.</span></span> <span data-ttu-id="f9964-124">범위 링크-로컬 및 사이트-로컬 주소에 대해서만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-124">The scope is valid only for link-local and site-local addresses.</span></span>  
  
 <span data-ttu-id="f9964-125"><xref:System.Byte> 배열 가장 중요 한 바이트가 인덱스 위치 0에 있는 네트워크 바이트 순서에 있는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-125">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f9964-126">
            <paramref name="address" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-126">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f9964-127">
            <paramref name="address" />에 잘못된 IP 주소가 포함되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-127">
              <paramref name="address" /> contains a bad IP address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f9964-128">
            <paramref name="scopeid" /> &lt; 0 또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-128">
              <paramref name="scopeid" /> &lt; 0 or</span>
          </span>
          <span data-ttu-id="f9964-129">
            <paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-129">
              <paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address, long scopeid);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <param name="scopeid">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public long Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Address { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-130">IP(인터넷 프로토콜) 주소입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-130">An Internet Protocol (IP) address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f9964-131">IP 주소의 long 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-131">The long value of the IP address.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-132">이 속성은 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-132">This property is obsolete.</span></span> <span data-ttu-id="f9964-133"><xref:System.Net.IPAddress.GetAddressBytes%2A>을 사용하십시오.</span><span class="sxs-lookup"><span data-stu-id="f9964-133">Use <xref:System.Net.IPAddress.GetAddressBytes%2A>.</span></span>  
  
 <span data-ttu-id="f9964-134">변환할 <xref:System.Net.IPAddress.Address%2A> 점 표기법을 사용 하 여는 <xref:System.Net.IPAddress.ToString%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f9964-134">To convert <xref:System.Net.IPAddress.Address%2A> to dotted-quad notation, use the <xref:System.Net.IPAddress.ToString%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-135">다음 예제에서는 <xref:System.Net.IPAddress.Address%2A> IP 주소를 검색 매개 변수는 <xref:System.Net.IPAddress> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="f9964-135">The following example uses the <xref:System.Net.IPAddress.Address%2A> parameter to retrieve the IP address of the <xref:System.Net.IPAddress> instance.</span></span>  
  
 [!code-cpp[IPAddress_Address_AddressFamily#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Address_AddressFamily/CPP/ipaddress_address_addressfamily.cpp#2)]
 [!code-csharp[IPAddress_Address_AddressFamily#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Address_AddressFamily/CS/ipaddress_address_addressfamily.cs#2)]
 [!code-vb[IPAddress_Address_AddressFamily#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Address_AddressFamily/VB/ipaddress_address_addressfamily.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="f9964-136">주소 패밀리는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-136">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-137">IP 주소의 주소 패밀리를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-137">Gets the address family of the IP address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f9964-138">IPv4에 대한 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 IPv6에 대한 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-138">Returns <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> for IPv4 or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> for IPv6.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f9964-139">예제를 참조는 <xref:System.Net.IPAddress> 클래스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-139">Refer to the example in the <xref:System.Net.IPAddress> class topic.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Any;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-140">서버에서 모든 네트워크 인터페이스의 클라이언트 동작을 수신 대기해야 함을 나타내는 IP 주소를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-140">Provides an IP address that indicates that the server must listen for client activity on all network interfaces.</span>
          </span>
          <span data-ttu-id="f9964-141">이 필드는 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-141">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-142"><xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> 메서드는 <xref:System.Net.IPAddress.Any> 임을 나타내는 필드는 <xref:System.Net.Sockets.Socket> 모든 네트워크 인터페이스에서 클라이언트 활동 인스턴스가 수신 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-142">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.Any> field to indicate that a <xref:System.Net.Sockets.Socket> instance must listen for client activity on all network interfaces.</span></span>  
  
 <span data-ttu-id="f9964-143"><xref:System.Net.IPAddress.Any> 필드는 0.0.0.0 점 표기법에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-143">The <xref:System.Net.IPAddress.Any> field is equivalent to 0.0.0.0 in dotted-quad notation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Broadcast;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Broadcast" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Broadcast" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Broadcast As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Broadcast;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-144">IP 브로드캐스트 주소를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-144">Provides the IP broadcast address.</span>
          </span>
          <span data-ttu-id="f9964-145">이 필드는 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-145">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-146"><xref:System.Net.IPAddress.Broadcast> 필드는 255.255.255.255 점 표기법에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-146">The <xref:System.Net.IPAddress.Broadcast> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-147">다음 예제에서는 인쇄는 <xref:System.Net.IPAddress.Broadcast> 콘솔에는 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-147">The following example prints the <xref:System.Net.IPAddress.Broadcast> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#2)]
 [!code-csharp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#2)]
 [!code-vb[IPAddress_Broadcast_Loopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">
          <span data-ttu-id="f9964-148">현재 인스턴스와 비교할 <see cref="T:System.Net.IPAddress" /> 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-148">An <see cref="T:System.Net.IPAddress" /> instance to compare to the current instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-149">두 개의 IP 주소를 비교합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-149">Compares two IP addresses.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-150">두 개의 주소가 동일하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-150">
              <see langword="true" /> if the two addresses are equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-151"><xref:System.Net.IPAddress.Equals%2A> 메서드 비교 현재 <xref:System.Net.IPAddress> 인스턴스는 `comparand` 매개 변수 및 반환 `true` 두 인스턴스가 동일한 IP 주소를 포함 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="f9964-151">The <xref:System.Net.IPAddress.Equals%2A> method compares the current <xref:System.Net.IPAddress> instance with the `comparand` parameter and returns `true` if the two instances contain the same IP address.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAddressBytes">
      <MemberSignature Language="C#" Value="public byte[] GetAddressBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetAddressBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetAddressBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAddressBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetAddressBytes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9964-152">
            <see cref="T:System.Net.IPAddress" />의 복사본을 바이트 배열로 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-152">Provides a copy of the <see cref="T:System.Net.IPAddress" /> as an array of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-153">
            <see cref="T:System.Byte" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-153">A <see cref="T:System.Byte" /> array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f9964-154">다음 코드 예제에서는 바이트 형식에서으로 서버 IP 주소를 가져오기 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-154">The following code example shows how to get a server IP address in byte format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#2)]
 [!code-csharp[System.Net.IPAddress#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#2)]
 [!code-vb[System.Net.IPAddress#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9964-155">IP 주소에 대한 해시 값을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-155">Returns a hash value for an IP address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-156">정수 해시 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-156">An integer hash value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-157"><xref:System.Net.IPAddress.GetHashCode%2A> 메서드 IP 주소의 해시 코드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-157">The <xref:System.Net.IPAddress.GetHashCode%2A> method returns a hash code of the IP address.</span></span> <span data-ttu-id="f9964-158">이 값은 해시 테이블에서 키로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-158">This value can be used as a key in hash tables.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HostToNetworkOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-159">호스트 바이트 순서에서 네트워크 바이트 순서로 값을 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-159">Converts a value from host byte order to network byte order.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static short HostToNetworkOrder (short host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 HostToNetworkOrder(int16 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short HostToNetworkOrder(short host);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="f9964-160">호스트 바이트 순서로 변환할 숫자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-160">The number to convert, expressed in host byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-161">short 값을 호스트 바이트 순서에서 네트워크 바이트 순서로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-161">Converts a short value from host byte order to network byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-162">네트워크 바이트 순서로 표현된 short 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-162">A short value, expressed in network byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-163">서로 다른 컴퓨터는 멀티 바이트 정수 값 내에서 바이트 순서 지정에 다른 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-163">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f9964-164">일부 컴퓨터에 가장 덜 중요 한 바이트가 먼저 배치 (이 big endian 순서 라고 함) 및 다른 최하위 바이트 먼저 배치 (일명 little endian 순서).</span><span class="sxs-lookup"><span data-stu-id="f9964-164">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f9964-165">네트워크를 통해 전송 되는 모든 정수 값은 서로 다른 바이트 순서를 사용 하는 컴퓨터를 사용 하려면 먼저 가장 중요 한 바이트 있는 네트워크 바이트 순서 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-165">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f9964-166"><xref:System.Net.IPAddress.HostToNetworkOrder%2A> 메서드는 네트워크에서 사용 하는 바이트 순서로 호스트에서 사용 하는 바이트 순서에서 호스트 시스템에 저장 된 멀티 바이트 정수 값을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-166">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static int HostToNetworkOrder (int host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 HostToNetworkOrder(int32 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int HostToNetworkOrder(int host);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="f9964-167">호스트 바이트 순서로 변환할 숫자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-167">The number to convert, expressed in host byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-168">정수 값을 호스트 바이트 순서에서 네트워크 바이트 순서로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-168">Converts an integer value from host byte order to network byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-169">네트워크 바이트 순서로 표현된 정수 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-169">An integer value, expressed in network byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-170">서로 다른 컴퓨터는 멀티 바이트 정수 값 내에서 바이트 순서 지정에 다른 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-170">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f9964-171">일부 컴퓨터에 가장 덜 중요 한 바이트가 먼저 배치 (이 big endian 순서 라고 함) 및 다른 최하위 바이트 먼저 배치 (일명 little endian 순서).</span><span class="sxs-lookup"><span data-stu-id="f9964-171">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f9964-172">네트워크를 통해 전송 되는 모든 정수 값은 서로 다른 바이트 순서를 사용 하는 컴퓨터를 사용 하려면 먼저 가장 중요 한 바이트 있는 네트워크 바이트 순서 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-172">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f9964-173"><xref:System.Net.IPAddress.HostToNetworkOrder%2A> 메서드는 네트워크에서 사용 하는 바이트 순서로 호스트에서 사용 하는 바이트 순서에서 호스트 시스템에 저장 된 멀티 바이트 정수 값을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-173">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static long HostToNetworkOrder (long host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 HostToNetworkOrder(int64 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long HostToNetworkOrder(long host);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="f9964-174">호스트 바이트 순서로 변환할 숫자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-174">The number to convert, expressed in host byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-175">호스트 바이트 순서에서 네트워크 바이트 순서로 long 값을 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-175">Converts a long value from host byte order to network byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-176">네트워크 바이트 순서로 표현된 long 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-176">A long value, expressed in network byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-177">서로 다른 컴퓨터는 멀티 바이트 정수 값 내에서 바이트 순서 지정에 다른 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-177">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f9964-178">일부 컴퓨터에 가장 덜 중요 한 바이트가 먼저 배치 (이 big endian 순서 라고 함) 및 다른 최하위 바이트 먼저 배치 (일명 little endian 순서).</span><span class="sxs-lookup"><span data-stu-id="f9964-178">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f9964-179">네트워크를 통해 전송 되는 모든 정수 값은 서로 다른 바이트 순서를 사용 하는 컴퓨터를 사용 하려면 먼저 가장 중요 한 바이트 있는 네트워크 바이트 순서 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-179">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f9964-180"><xref:System.Net.IPAddress.HostToNetworkOrder%2A> 메서드는 네트워크에서 사용 하는 바이트 순서로 호스트에서 사용 하는 바이트 순서에서 호스트 시스템에 저장 된 멀티 바이트 정수 값을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-180">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="IPv6Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Any;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-181">
            <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 메서드는 <see cref="F:System.Net.IPAddress.IPv6Any" /> 필드를 사용하여 <see cref="T:System.Net.Sockets.Socket" />이 모든 네트워크 인터페이스에서 클라이언트 동작을 수신 대기해야 함을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-181">The <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method uses the <see cref="F:System.Net.IPAddress.IPv6Any" /> field to indicate that a <see cref="T:System.Net.Sockets.Socket" /> must listen for client activity on all network interfaces.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-182"><xref:System.Net.IPAddress.IPv6Any> 해당 또는 콜론 16 진수 표기법으로 나타낸 하는 필드:: 간단한 표기법에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-182">The <xref:System.Net.IPAddress.IPv6Any> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to :: in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-183">다음 코드 예제에서는 현재 값 모든 주소에 호스트의 표준 압축된 형식으로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-183">The following code example displays the value of the current host's Any address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#2)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#2)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Loopback;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-184">IP 루프백 주소를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-184">Provides the IP loopback address.</span>
          </span>
          <span data-ttu-id="f9964-185">이 속성은 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-185">This property is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-186"><xref:System.Net.IPAddress.IPv6Loopback> 해당 0:0:0:0:0:0:0:1 또는 콜론 16 진수 표기법으로 하는 필드:: 간단한 표기법에서 1입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-186">The <xref:System.Net.IPAddress.IPv6Loopback> field is equivalent to 0:0:0:0:0:0:0:1 in colon-hexadecimal notation, or to ::1 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-187">다음 코드 예제에서는 표준 압축 된 형식에서 현재 호스트의 루프백 주소 값을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-187">The following code example displays the value of the current host's loopback address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6None;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-188">네트워크 인터페이스를 사용하지 않아야 함을 나타내는 IP 주소를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-188">Provides an IP address that indicates that no network interface should be used.</span>
          </span>
          <span data-ttu-id="f9964-189">이 속성은 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-189">This property is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-190"><xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> 메서드는 <xref:System.Net.IPAddress.IPv6None> 임을 나타내는 필드는 <xref:System.Net.Sockets.Socket> 클라이언트 활동에 대 한 수신 대기 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-190">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.IPv6None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="f9964-191"><xref:System.Net.IPAddress.IPv6None> 해당 또는 콜론 16 진수 표기법으로 나타낸 하는 필드:: 간단한 표기법에서 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-191">The <xref:System.Net.IPAddress.IPv6None> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to ::0 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-192">다음 코드 예제에서는 표준 압축 된 형식에서 현재 호스트의 None 주소 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-192">The following code example displays the value of the current host's None address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#3)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#3)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv4MappedToIPv6">
      <MemberSignature Language="C#" Value="public bool IsIPv4MappedToIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv4MappedToIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv4MappedToIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv4MappedToIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-193">IP 주소가 IPv4-매핑된 IPv6 주소인지 여부를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-193">Gets whether the IP address is an IPv4-mapped IPv6 address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f9964-194">
            <see cref="T:System.Boolean" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-194">Returns <see cref="T:System.Boolean" />.</span>
          </span>
          <span data-ttu-id="f9964-195">IP 주소가 IPv4 매핑된 IPv6 주소이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-195">
              <see langword="true" /> if the IP address is an IPv4-mapped IPv6 address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-196">이중 스택 소켓을 IPv6 주소를 항상 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-196">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="f9964-197">IPv4 주소와 상호 작용 하는 IPv4 매핑 IPv6 주소 형식 사용 하면 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-197">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="f9964-198">모든 IPv4 주소는 IPv4 노드가와 통신할 수는 IPv6 전용 응용 프로그램 수 있도록 하는 IPv4 매핑 IPv6 주소 형식으로 표현 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-198">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="f9964-199">IPv4 매핑 IPv6 주소 형식에는 IPv4 주소를 IPv6 주소로 나타낼 수 있는 IPv4 노드의 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-199">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="f9964-200">IPv6 주소의 하위 32 비트에 IPv4 주소 인코딩되고 상위 96 비트 고정된 접두사 0:0:0:0:0:FFFF 보유 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-200">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="f9964-201">IPv4 매핑 IPv6 주소 형식은 RFC 4291에 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-201">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="f9964-202">자세한 내용은 참조 [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231)합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-202">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6LinkLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6LinkLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6LinkLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6LinkLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6LinkLocal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-203">주소가 IPv6 링크 로컬 주소인지 여부를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-203">Gets whether the address is an IPv6 link local address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f9964-204">IP 주소가 IPv6 링크 로컬 주소이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-204">
              <see langword="true" /> if the IP address is an IPv6 link local address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Multicast">
      <MemberSignature Language="C#" Value="public bool IsIPv6Multicast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Multicast" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Multicast" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Multicast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Multicast { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-205">주소가 IPv6 멀티캐스트 전역 주소인지 여부를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-205">Gets whether the address is an IPv6 multicast global address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f9964-206">IP 주소가 IPv6 멀티캐스트 전역 주소이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-206">
              <see langword="true" /> if the IP address is an IPv6 multicast global address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6SiteLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6SiteLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6SiteLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6SiteLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6SiteLocal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-207">주소가 IPv6 사이트 로컬 주소인지 여부를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-207">Gets whether the address is an IPv6 site local address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f9964-208">IP 주소가 IPv6 사이트 로컬 주소이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-208">
              <see langword="true" /> if the IP address is an IPv6 site local address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Teredo">
      <MemberSignature Language="C#" Value="public bool IsIPv6Teredo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Teredo" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Teredo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Teredo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Teredo { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-209">주소가 IPv6 Teredo 주소인지 여부를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-209">Gets whether the address is an IPv6 Teredo address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f9964-210">IP 주소가 IPv6 Teredo 주소이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-210">
              <see langword="true" /> if the IP address is an IPv6 Teredo address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-211">Teredo 주소는 IPv6 주소 2001 접두사로:: / 32입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-211">A Teredo address is an IPv6 address with the prefix of 2001::/32.</span></span> <span data-ttu-id="f9964-212">Teredo 주소는 일반 DNS 이름 확인을 통해 반환 또는 로컬 인터페이스에 할당 된 IPv6 주소로 열거 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-212">Teredo addresses can be returned through normal DNS name resolution or enumerated as an IPv6 address assigned to a local interface.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.BeginGetUnicastAddresses(System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.EndGetUnicastAddresses(System.IAsyncResult)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.GetUnicastAddresses" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public static bool IsLoopback (System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLoopback(class System.Net.IPAddress address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.IsLoopback(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLoopback (address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLoopback(System::Net::IPAddress ^ address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="f9964-213">IP 주소입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-213">An IP address.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-214">지정된 IP 주소가 루프백 주소인지 여부를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-214">Indicates whether the specified IP address is the loopback address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-215">
            <paramref name="address" />가 루프백 주소이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-215">
              <see langword="true" /> if <paramref name="address" /> is the loopback address; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-216"><xref:System.Net.IPAddress.IsLoopback%2A> 메서드 비교 `address` 를 <xref:System.Net.IPAddress.Loopback> 반환 `true` 두 개의 IP 주소는 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-216">The <xref:System.Net.IPAddress.IsLoopback%2A> method compares `address` to <xref:System.Net.IPAddress.Loopback> and returns `true` if the two IP addresses are the same.</span></span>  
  
 <span data-ttu-id="f9964-217">4의 경우는 <xref:System.Net.IPAddress.IsLoopback%2A> 메서드 반환 `true` 폼의 모든 IP 주소에 대 한 127.X.Y.Z (여기서 X, Y 및 Z는 0-255 범위에), 뿐만 아니라 <xref:System.Net.IPAddress.Loopback> (127.0.0.1).</span><span class="sxs-lookup"><span data-stu-id="f9964-217">In the case of IPv4, that the <xref:System.Net.IPAddress.IsLoopback%2A> method returns `true` for any IP address of the form 127.X.Y.Z (where X, Y, and Z are in the range 0-255), not just <xref:System.Net.IPAddress.Loopback> (127.0.0.1).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-218">다음 코드 예제에서는 <xref:System.Net.IPAddress.IsLoopback%2A> 메서드를 지정된 된 주소는 루프백 주소 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-218">The following code example uses the <xref:System.Net.IPAddress.IsLoopback%2A> method to determine whether the specified address is a loopback address.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CPP/isloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CS/isloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/VB/isloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Loopback;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-219">IP 루프백 주소를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-219">Provides the IP loopback address.</span>
          </span>
          <span data-ttu-id="f9964-220">이 필드는 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-220">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-221"><xref:System.Net.IPAddress.Loopback> 필드는 127.0.0.1 점 표기법에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-221">The <xref:System.Net.IPAddress.Loopback> field is equivalent to 127.0.0.1 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-222">다음 예제에서는 인쇄는 <xref:System.Net.IPAddress.Loopback> 콘솔에는 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-222">The following example prints the <xref:System.Net.IPAddress.Loopback> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#1)]
 [!code-csharp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#1)]
 [!code-vb[IPAddress_Broadcast_Loopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv4">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv4 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv4() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv4 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv4();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9964-223">
            <see cref="T:System.Net.IPAddress" /> 개체를 IPv4 주소로 매핑합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-223">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv4 address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-224">
            <see cref="T:System.Net.IPAddress" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-224">Returns <see cref="T:System.Net.IPAddress" />.</span>
          </span>
          <span data-ttu-id="f9964-225">IPv4 주소입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-225">An IPv4 address.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-226">이중 스택 소켓을 IPv6 주소를 항상 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-226">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="f9964-227">IPv4 주소와 상호 작용 하는 IPv4 매핑 IPv6 주소 형식 사용 하면 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-227">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="f9964-228">모든 IPv4 주소는 IPv4 노드가와 통신할 수는 IPv6 전용 응용 프로그램 수 있도록 하는 IPv4 매핑 IPv6 주소 형식으로 표현 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-228">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="f9964-229">IPv4 매핑 IPv6 주소 형식에는 IPv4 주소를 IPv6 주소로 나타낼 수 있는 IPv4 노드의 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-229">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="f9964-230">IPv6 주소의 하위 32 비트에 IPv4 주소 인코딩되고 상위 96 비트 고정된 접두사 0:0:0:0:0:FFFF 보유 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-230">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="f9964-231">IPv4 매핑 IPv6 주소 형식은 RFC 4291에 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-231">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="f9964-232">자세한 내용은 참조 [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231)합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-232">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 <span data-ttu-id="f9964-233">사용 하려는 경우 <xref:System.Net.IPAddress.MapToIPv4%2A> IPv4 주소는 IPv6 형식이에서 IPv4 형식으로 변환 하려면 먼저 확인 해야 인지는 IPv4 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-233">If you want to use <xref:System.Net.IPAddress.MapToIPv4%2A> to convert an IPv4 address from IPv6 format to IPv4 format, you must first ensure that you've got an IPv4 address.</span></span> <span data-ttu-id="f9964-234">호출 <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>를 반환 합니다 `true` IP 주소는 원래 IPv4, IPv6로 작성 하는 경우 또는 `false` 그렇지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="f9964-234">Call <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>, which will return `true` if the IP address is originally IPv4 written as IPv6, or `false` otherwise.</span></span> <span data-ttu-id="f9964-235">경우 <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> 반환 `true`를 사용 하 여 <xref:System.Net.IPAddress.MapToIPv4%2A> 를 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-235">If <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> returns `true`, use <xref:System.Net.IPAddress.MapToIPv4%2A> to make the conversion.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv6">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv6 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv6() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv6 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv6();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9964-236">
            <see cref="T:System.Net.IPAddress" /> 개체를 IPv6 주소로 매핑합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-236">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv6 address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-237">
            <see cref="T:System.Net.IPAddress" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-237">Returns <see cref="T:System.Net.IPAddress" />.</span>
          </span>
          <span data-ttu-id="f9964-238">IPv6 주소입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-238">An IPv6 address.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-239">이중 스택 소켓을 IPv6 주소를 항상 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-239">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="f9964-240">IPv4 주소와 상호 작용 하는 IPv4 매핑 IPv6 주소 형식 사용 하면 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-240">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="f9964-241">모든 IPv4 주소는 IPv4 노드가와 통신할 수는 IPv6 전용 응용 프로그램 수 있도록 하는 IPv4 매핑 IPv6 주소 형식으로 표현 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-241">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="f9964-242">IPv4 매핑 IPv6 주소 형식에는 IPv4 주소를 IPv6 주소로 나타낼 수 있는 IPv4 노드의 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-242">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="f9964-243">IPv6 주소의 하위 32 비트에 IPv4 주소 인코딩되고 상위 96 비트 고정된 접두사 0:0:0:0:0:FFFF 보유 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-243">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="f9964-244">IPv4 매핑 IPv6 주소 형식은 RFC 4291에 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-244">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="f9964-245">자세한 내용은 참조 [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231)합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-245">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="NetworkToHostOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-246">네트워크 바이트 순서에서 호스트 바이트 순서로 숫자를 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-246">Converts a number from network byte order to host byte order.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static short NetworkToHostOrder (short network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 NetworkToHostOrder(int16 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short NetworkToHostOrder(short network);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="network">
          <span data-ttu-id="f9964-247">네트워크 바이트 순서로 변환할 숫자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-247">The number to convert, expressed in network byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-248">short 값을 네트워크 바이트 순서에서 호스트 바이트 순서로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-248">Converts a short value from network byte order to host byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-249">호스트 바이트 순서로 표현된 short 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-249">A short value, expressed in host byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-250">서로 다른 컴퓨터는 멀티 바이트 정수 값 내에서 바이트 순서 지정에 다른 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-250">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f9964-251">일부 컴퓨터에 가장 덜 중요 한 바이트가 먼저 배치 (이 big endian 순서 라고 함) 및 다른 최하위 바이트 먼저 배치 (일명 little endian 순서).</span><span class="sxs-lookup"><span data-stu-id="f9964-251">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f9964-252">네트워크를 통해 전송 되는 모든 정수 값은 서로 다른 바이트 순서를 사용 하는 컴퓨터를 사용 하려면 먼저 가장 중요 한 바이트 있는 네트워크 바이트 순서 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-252">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f9964-253"><xref:System.Net.IPAddress.NetworkToHostOrder%2A> 메서드 호스트에서 사용 하 여 바이트 순서를 네트워크에서 사용 하는 바이트 순서에서 호스트 시스템에 저장 된 멀티 바이트 정수 값을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-253">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-254">다음 예제에서는 <xref:System.Net.IPAddress.NetworkToHostOrder%2A> 호스트 바이트 순서로 네트워크 바이트 순서에서 짧은 값을 변환 하는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-254">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a short value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#1)]
 [!code-csharp[IPAddress_NetworkToHost#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#1)]
 [!code-vb[IPAddress_NetworkToHost#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static int NetworkToHostOrder (int network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NetworkToHostOrder(int32 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NetworkToHostOrder(int network);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="network">
          <span data-ttu-id="f9964-255">네트워크 바이트 순서로 변환할 숫자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-255">The number to convert, expressed in network byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-256">정수 값을 네트워크 바이트 순서에서 호스트 바이트 순서로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-256">Converts an integer value from network byte order to host byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-257">호스트 바이트 순서로 표현된 정수 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-257">An integer value, expressed in host byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-258">서로 다른 컴퓨터는 멀티 바이트 정수 값 내에서 바이트 순서 지정에 다른 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-258">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f9964-259">일부 컴퓨터에 가장 덜 중요 한 바이트가 먼저 배치 (이 big endian 순서 라고 함) 및 다른 최하위 바이트 먼저 배치 (일명 little endian 순서).</span><span class="sxs-lookup"><span data-stu-id="f9964-259">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f9964-260">네트워크를 통해 전송 되는 모든 정수 값은 서로 다른 바이트 순서를 사용 하는 컴퓨터를 사용 하려면 먼저 가장 중요 한 바이트 있는 네트워크 바이트 순서 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-260">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f9964-261"><xref:System.Net.IPAddress.NetworkToHostOrder%2A> 메서드 호스트에서 사용 하 여 바이트 순서를 네트워크에서 사용 하는 바이트 순서에서 호스트 시스템에 저장 된 멀티 바이트 정수 값을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-261">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-262">다음 예제에서는 <xref:System.Net.IPAddress.NetworkToHostOrder%2A> 호스트 바이트 순서로 네트워크 바이트 순서에서 정수 값을 변환 하는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-262">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert an integer value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#2)]
 [!code-csharp[IPAddress_NetworkToHost#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#2)]
 [!code-vb[IPAddress_NetworkToHost#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static long NetworkToHostOrder (long network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 NetworkToHostOrder(int64 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long NetworkToHostOrder(long network);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="network">
          <span data-ttu-id="f9964-263">네트워크 바이트 순서로 변환할 숫자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-263">The number to convert, expressed in network byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-264">long 값을 네트워크 바이트 순서에서 호스트 바이트 순서로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-264">Converts a long value from network byte order to host byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-265">호스트 바이트 순서로 표현된 long 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-265">A long value, expressed in host byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-266">서로 다른 컴퓨터는 멀티 바이트 정수 값 내에서 바이트 순서 지정에 다른 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-266">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f9964-267">일부 컴퓨터에 가장 덜 중요 한 바이트가 먼저 배치 (이 big endian 순서 라고 함) 및 다른 최하위 바이트 먼저 배치 (일명 little endian 순서).</span><span class="sxs-lookup"><span data-stu-id="f9964-267">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f9964-268">네트워크를 통해 전송 되는 모든 정수 값은 서로 다른 바이트 순서를 사용 하는 컴퓨터를 사용 하려면 먼저 가장 중요 한 바이트 있는 네트워크 바이트 순서 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-268">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f9964-269"><xref:System.Net.IPAddress.NetworkToHostOrder%2A> 메서드 호스트에서 사용 하 여 바이트 순서를 네트워크에서 사용 하는 바이트 순서에서 호스트 시스템에 저장 된 멀티 바이트 정수 값을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-269">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-270">다음 예제에서는 <xref:System.Net.IPAddress.NetworkToHostOrder%2A> 호스트 바이트 순서로 네트워크 바이트 순서에서 long 값을 변환 하는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-270">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a long value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#3](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#3)]
 [!code-csharp[IPAddress_NetworkToHost#3](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#3)]
 [!code-vb[IPAddress_NetworkToHost#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ None;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-271">네트워크 인터페이스를 사용하지 않아야 함을 나타내는 IP 주소를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-271">Provides an IP address that indicates that no network interface should be used.</span>
          </span>
          <span data-ttu-id="f9964-272">이 필드는 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-272">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-273"><xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> 메서드는 <xref:System.Net.IPAddress.None> 임을 나타내는 필드는 <xref:System.Net.Sockets.Socket> 클라이언트 활동에 대 한 수신 대기 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-273">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="f9964-274"><xref:System.Net.IPAddress.None> 필드는 255.255.255.255 점 표기법에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-274">The <xref:System.Net.IPAddress.None> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9964-275">사용 하 여 다음 예제는 <xref:System.Net.IPAddress.None> 네트워크 인터페이스가 없는 사용 해야 함을 나타내는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-275">The following example uses the <xref:System.Net.IPAddress.None> property to indicate that no network interface should be used.</span></span>  
  
 [!code-cpp[IPAddress_None#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_None/CPP/ipaddress_none.cpp#1)]
 [!code-csharp[IPAddress_None#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_None/CS/ipaddress_none.cs#1)]
 [!code-vb[IPAddress_None#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_None/VB/ipaddress_none.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As ReadOnlySpan(Of Char)) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (string ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(string ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As String) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(System::String ^ ipString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ipString">
          <span data-ttu-id="f9964-276">IPv4의 경우 점 구분 네 자리 표기법으로 표현된 IP 주소를 포함하는 문자열이고, IPv6의 경우 콜론과 16진수 표기법으로 표현된 IP 주소를 포함하는 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-276">A string that contains an IP address in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-277">IP 주소 문자열을 <see cref="T:System.Net.IPAddress" /> 인스턴스로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-277">Converts an IP address string to an <see cref="T:System.Net.IPAddress" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-278">
            <see cref="T:System.Net.IPAddress" /> 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-278">An <see cref="T:System.Net.IPAddress" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-279">정적 <xref:System.Net.IPAddress.Parse%2A> 메서드 만듭니다는 <xref:System.Net.IPAddress> 점 표기법 i p v 4와 i p v 6에 대 한 콜론 16 진수 표기법을 표현 하는 IP 주소에서 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="f9964-279">The static <xref:System.Net.IPAddress.Parse%2A> method creates an <xref:System.Net.IPAddress> instance from an IP address expressed in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span></span>  
  
 <span data-ttu-id="f9964-280">(각 부분에 마침표 구분 됨)의 파트 수가 `ipString` IP 주소가 생성 되는 방식을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-280">The number of parts (each part is separated by a period) in `ipString` determines how the IP address is constructed.</span></span> <span data-ttu-id="f9964-281">한 부분으로 된 주소는 네트워크 주소에 직접 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-281">A one part address is stored directly in the network address.</span></span> <span data-ttu-id="f9964-282">두 부분으로 구성 주소 클래스 주소를 지정 하는 데 유용 하며, 첫 번째 바이트 및 후행 가장 오른쪽 3 바이트에서 부분의 네트워크 주소 부분은 넣습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-282">A two part address, convenient for specifying a class A address, puts the leading part in the first byte and the trailing part in the right-most three bytes of the network address.</span></span> <span data-ttu-id="f9964-283">세 부분 주소, 클래스 B 주소를 지정 하는 데 유용 하며, 첫 번째 바이트, 두 번째 바이트의 두 번째 부분 및 네트워크 주소의 가장 오른쪽 2 바이트에 마지막 부분에서 첫 번째 부분을 넣습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-283">A three part address, convenient for specifying a class B address, puts the first part in the first byte, the second part in the second byte, and the final part in the right-most two bytes of the network address.</span></span> <span data-ttu-id="f9964-284">예:</span><span class="sxs-lookup"><span data-stu-id="f9964-284">For example:</span></span>  
  
|<span data-ttu-id="f9964-285">파트 수와 예제 `ipString`</span><span class="sxs-lookup"><span data-stu-id="f9964-285">Number of parts and example `ipString`</span></span>|<span data-ttu-id="f9964-286">Ip 주소에 대 한 IPv4 주소</span><span class="sxs-lookup"><span data-stu-id="f9964-286">IPv4 address for IPAddress</span></span>|  
|--------------------------------------------|--------------------------------|  
|<span data-ttu-id="f9964-287">1 -- "65535"</span><span class="sxs-lookup"><span data-stu-id="f9964-287">1 -- "65535"</span></span>|<span data-ttu-id="f9964-288">0.0.255.255</span><span class="sxs-lookup"><span data-stu-id="f9964-288">0.0.255.255</span></span>|  
|<span data-ttu-id="f9964-289">2 -- "20.2"</span><span class="sxs-lookup"><span data-stu-id="f9964-289">2 -- "20.2"</span></span>|<span data-ttu-id="f9964-290">20.0.0.2</span><span class="sxs-lookup"><span data-stu-id="f9964-290">20.0.0.2</span></span>|  
|<span data-ttu-id="f9964-291">2 -- "20.65535"</span><span class="sxs-lookup"><span data-stu-id="f9964-291">2 -- "20.65535"</span></span>|<span data-ttu-id="f9964-292">20.0.255.255</span><span class="sxs-lookup"><span data-stu-id="f9964-292">20.0.255.255</span></span>|  
|<span data-ttu-id="f9964-293">3 -- "128.1.2"</span><span class="sxs-lookup"><span data-stu-id="f9964-293">3 -- "128.1.2"</span></span>|<span data-ttu-id="f9964-294">128.1.0.2</span><span class="sxs-lookup"><span data-stu-id="f9964-294">128.1.0.2</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f9964-295">다음 코드는 IP 주소, i p v 4에 대 한 점 표기법의 또는의 인스턴스로 i p v 6을 콜론 16 진수 표기법을 포함 하는 문자열을 변환의 <xref:System.Net.IPAddress> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-295">The following code converts a string that contains an IP address, in dotted-quad notation for IPv4 or in colon-hexadecimal notation for IPv6, into an instance of the <xref:System.Net.IPAddress> class.</span></span> <span data-ttu-id="f9964-296">그런 다음 오버 로드 된 <xref:System.Net.IPAddress.ToString%2A> 표준 표기법에서 주소를 표시 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="f9964-296">Then it uses the overloaded <xref:System.Net.IPAddress.ToString%2A> method to display the address in standard notation.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.Parse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CPP/parse.cpp#1)]
 [!code-csharp[System.Net.IPAddress.Parse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CS/parse.cs#1)]
 [!code-vb[System.Net.IPAddress.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f9964-297">
            <paramref name="ipString" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-297">
              <paramref name="ipString" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="f9964-298">
            <paramref name="ipString" />이 유효한 IP 주소가 아닌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-298">
              <paramref name="ipString" /> is not a valid IP address.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeId">
      <MemberSignature Language="C#" Value="public long ScopeId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ScopeId" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.ScopeId" />
      <MemberSignature Language="VB.NET" Value="Public Property ScopeId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ScopeId { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9964-299">IPv6 주소 범위 식별자를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-299">Gets or sets the IPv6 address scope identifier.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f9964-300">주소의 범위를 지정하는 정수(Long)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-300">A long integer that specifies the scope of the address.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-301">의미 <xref:System.Net.IPAddress.ScopeId%2A> 사용 되는 컨텍스트에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-301">The meaning of <xref:System.Net.IPAddress.ScopeId%2A> changes depending on the context in which it is used.</span></span>  
  
-   <span data-ttu-id="f9964-302">링크-로컬 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-302">Link-local address.</span></span> <span data-ttu-id="f9964-303">개별 링크에 연결 하는 여러 인터페이스를 가진 호스트에서 여러 인터페이스에 동일한 링크-로컬 주소를 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-303">On a host with multiple interfaces connected to separate links, the same link-local address can be assigned to multiple interfaces.</span></span> <span data-ttu-id="f9964-304">이 모호성을 피하려면 매길 메시지가 교환 되는 인터페이스를 지정 하려면 범위 식별자 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-304">To eliminate this ambiguity, a scope identifier is used to specify the interface over which messages are exchanged.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f9964-305">형식 접두사 (FP) FE80로 식별 되는 링크-로컬 주소를 동일한 링크에 인접 한 노드와 통신할 때 노드에 의해 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-305">Link-local addresses, identified by the Format Prefix (FP) FE80, are used by nodes when communicating with neighboring nodes on the same link.</span></span>  
  
-   <span data-ttu-id="f9964-306">사이트-로컬 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-306">Site-local addresses.</span></span> <span data-ttu-id="f9964-307">호스트는 여러 사이트에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-307">A host can be connected to multiple sites.</span></span> <span data-ttu-id="f9964-308">이 경우 범위 식별자는 특정 사이트와 통신할 수를 나타내는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-308">In this case, a scope identifier is used to indicate a specific site to communicate with.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f9964-309">형식 접두사 (FP) 되어 있으며 FEC0로 식별 되는 사이트-로컬 주소를 개인 인트라넷에서 통신 하는 경우 노드에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-309">Site-local addresses, identified by the Format Prefix (FP) FEC0, are used by nodes when communicating on private intranets.</span></span>  
  
 <span data-ttu-id="f9964-310">지정 하는 데 사용 되는 표기법의 `ScopeId` 주소와는 `Address%ScopeId`합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-310">The notation that is used to specify the `ScopeId` with an address is `Address%ScopeId`.</span></span> <span data-ttu-id="f9964-311">예를 들면 `FE80::5EFE:192.168.41.30%2.`과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-311">For example, `FE80::5EFE:192.168.41.30%2.`</span></span>  
  
   
  
## Examples  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="f9964-312">
            <see langword="AddressFamily" /> = <see langword="InterNetwork" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-312">
              <see langword="AddressFamily" /> = <see langword="InterNetwork" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f9964-313">
            <paramref name="scopeId" /> &lt; 0</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-313">
              <paramref name="scopeId" /> &lt; 0</span>
          </span>
          <span data-ttu-id="f9964-314">\- 또는 -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-314">\- or -</span>
          </span>  
  
-   <span data-ttu-id="f9964-315"><paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="f9964-315"><paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9964-316">인터넷 주소를 표준 표기법으로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-316">Converts an Internet address to its standard notation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-317">IPv4의 경우 점 구분 네 자리 표기법으로 표현된 IP 주소를 포함하는 문자열이고, IPv6의 경우 콜론과 16진수 표기법으로 표현된 IP 주소를 포함하는 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-317">A string that contains the IP address in either IPv4 dotted-quad or in IPv6 colon-hexadecimal notation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-318"><xref:System.Net.IPAddress.ToString%2A> 메서드 변환에 저장 되어 있는 IP 주소는 <xref:System.Net.IPAddress.Address%2A> 속성 쿼드-점으로 구분 된 IPv4 또는 IPv6 콜론 16 진수 표기법을 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-318">The <xref:System.Net.IPAddress.ToString%2A> method converts the IP address that is stored in the <xref:System.Net.IPAddress.Address%2A> property to either IPv4 dotted-quad or IPv6 colon-hexadecimal notation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="f9964-319">주소 패밀리는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />이며 주소가 잘못되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-319">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> and the address is bad.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryFormat(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryFormat(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.ReadOnlySpan{System.Char},System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As ReadOnlySpan(Of Char), ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="address" Type="System.Net.IPAddress&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.String,System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As String, ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
        <Parameter Name="address" Type="System.Net.IPAddress&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ipString">
          <span data-ttu-id="f9964-320">유효성을 검사할 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-320">The string to validate.</span>
          </span>
        </param>
        <param name="address">
          <span data-ttu-id="f9964-321">문자열의 <see cref="T:System.Net.IPAddress" /> 버전입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-321">The <see cref="T:System.Net.IPAddress" /> version of the string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9964-322">문자열이 유효한 IP 주소인지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-322">Determines whether a string is a valid IP address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9964-323">
            <paramref name="ipString" />이 IP 주소로 구문 분석되는 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9964-323">
              <see langword="true" /> if <paramref name="ipString" /> was able to be parsed as an IP address; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9964-324">이 메서드가로 구문 분석할 수 하는 유효한 것으로 ipString 값을 허용 하도록 주의 <xref:System.Int64>, 다음 해당 Int64 하는 방식과 비슷하게 네트워크 바이트 순서에서 IP 주소의 long 값으로 처리 하는 <xref:System.Net.IPAddress.%23ctor%2A> 생성자가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-324">Note that this method accepts as valid an ipString value that can be parsed as an <xref:System.Int64>, and then treats that Int64 as the long value of an IP address in network byte order, similar to the way that the <xref:System.Net.IPAddress.%23ctor%2A> constructor does.</span></span> <span data-ttu-id="f9964-325">이 주소는 올바른 IP 주소를 나타내는 경우에이 메서드는 Int64 성공적으로 구문 분석 되 면 true 반환을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-325">This means that this method returns true if the Int64 is parsed successfully, even if it represents an address that's not a valid IP address.</span></span> <span data-ttu-id="f9964-326">예를 들어 ipString "1" 인 경우이 메서드가 true를 반환 false를 반환 하도록이 메서드를 예상 하 고 "1" (또는 0.0.0.1)은 올바른 IP 주소가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-326">For example, if ipString is "1", this method returns true even though "1" (or 0.0.0.1) is not a valid IP address and you might expect this method to return false.</span></span> <span data-ttu-id="f9964-327">이 버그 수정 기존 앱 작동 하지 않으므로 하므로 현재 동작이 변경 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-327">Fixing this bug would break existing apps, so the current behavior will not be changed.</span></span> <span data-ttu-id="f9964-328">코드를 소수점 형식에서 IP 주소를 구문 분석만이 방법을 사용 하 여 있는지 확인 하 여이 문제를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9964-328">Your code can avoid this behavior by ensuring that it only uses this method to parse IP addresses in dotted-decimal format.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryWriteBytes(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteBytes(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>