<Type Name="ServicePointManager" FullName="System.Net.ServicePointManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f72344dcdd86e1e2513d198545e7195049d4ea26" />
    <Meta Name="ms.sourcegitcommit" Value="3507e865a3613c00760f25ad1045aaa11bae4dd8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/23/2018" />
    <Meta Name="ms.locfileid" Value="31779849" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServicePointManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ServicePointManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.ServicePointManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ServicePointManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServicePointManager" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.ServicePoint</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.Net.ServicePoint" /> 개체의 컬렉션을 관리합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager> 작성, 유지, 및의 인스턴스를 삭제 하는 데 사용 하는 정적 클래스는 <xref:System.Net.ServicePoint> 클래스입니다.  
  
 응용 프로그램에서 인터넷 리소스 식별자 URI (Uniform Resource)에 대 한 연결을 요청 하는 경우를 통해는 <xref:System.Net.ServicePointManager> 개체는 <xref:System.Net.ServicePointManager> 반환는 <xref:System.Net.ServicePoint> 호스트와 식별 하는 스키마에 대 한 연결 정보를 포함 하는 개체 의해서 입니다에. 기존 경우 <xref:System.Net.ServicePoint> 해당 호스트와 스키마에 대 한 개체는 <xref:System.Net.ServicePointManager> 기존 반환 하는 개체 <xref:System.Net.ServicePoint> 개체 그렇지 않은 경우는 <xref:System.Net.ServicePointManager> 개체를 새로 만듭니다 <xref:System.Net.ServicePoint> 개체입니다.  
  
 .NET Framework 4.6에는 안전 하지 않은 암호화 및 해시 알고리즘에 대 한 연결을 차단 하는 새로운 보안 기능이 포함 되어 있습니다. 응용 프로그램 등의 Api 통해 TLS/SSL을 사용 하 여 <xref:System.Net.Http.HttpClient>, <xref:System.Net.HttpWebRequest>, <xref:System.Net.FtpWebRequest>, <xref:System.Net.Mail.SmtpClient>, <xref:System.Net.Security.SslStream>등 기본적으로는 더 안전한 동작을 얻으려면.NET Framework 4.6을 대상으로 지정 하 고 있습니다.  
  
 개발자가 RC4 서비스를 지 원하는 자신의 기존 SSL3 서비스 또는 TLS와의 상호 운용성을 유지 하기 위해이 동작을 취소 하려고 할 수 있습니다. [이 문서](https://support.microsoft.com/kb/3069494) 를 새 동작을 사용할 수 없습니다. 코드를 수정 하는 방법에 설명 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 한 <xref:System.Net.ServicePoint> URI www.contoso.com에 대 한 연결에 대 한 개체입니다.  
  
 [!code-cpp[Classic ServicePoint Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePoint Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePoint Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePoint Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePoint Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePoint Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.ServicePoint" />
  </Docs>
  <Members>
    <Member MemberName="CertificatePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.ICertificatePolicy CertificatePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.ICertificatePolicy CertificatePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CertificatePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CertificatePolicy As ICertificatePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::ICertificatePolicy ^ CertificatePolicy { System::Net::ICertificatePolicy ^ get(); void set(System::Net::ICertificatePolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use ServerCertificateValidationCallback instead", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICertificatePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 인증서 정책을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Net.ICertificatePolicy" /> 인터페이스를 구현하는 개체</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Net.ServicePointManager.CertificatePolicy%2A> 속성이로 설정 되는 <xref:System.Net.ICertificatePolicy> 인터페이스 개체는 <xref:System.Net.ServicePointManager> 개체는 해당 인스턴스 대신 기본 인증 정책에에서 정의 된 인증 정책을 사용 합니다.  
  
 기본 인증 정책에 유효한 인증서 및 만료 된 유효한 인증서를 허용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용자 지정 인증서 정책에 대 한 인증서 정책 예외를 catch 하는 방법을 보여 줍니다. 인증서 정책 개체에 정의 된의 식별자 URI (Uniform Resource) 웹 리소스에 대 한 변수에 포함 되어 있다고 가정 `myUri`, 그리고 라는 메서드가 인지 `ProcessResponse` 응용 프로그램의 작업을 수행 하는 합니다.  
  
 [!code-cpp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">설정 하 여 <see cref="P:System.Net.ServicePointManager.CertificatePolicy" /> 속성입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="CheckCertificateRevocationList">
      <MemberSignature Language="C#" Value="public static bool CheckCertificateRevocationList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckCertificateRevocationList" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckCertificateRevocationList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckCertificateRevocationList { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("CRL checks not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>인증 기관의 해지 목록을 기준으로 인증서를 검사하는지 여부를 나타내는 <see cref="T:System.Boolean" /> 값을 가져오거나 설정합니다.</summary>
        <value>
          인증서 해지 목록을 검사하면 <see langword="true" />이고, 검사하지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Net.ServicePointManager.CheckCertificateRevocationList%2A> 은 `true`, 인증서가 인증서 유효성 검사 프로세스의 일부로 인증 기관의 해지 목록을 검사 합니다. 기본값은 `false`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성을 설정합니다.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">이 속성을 설정 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ClientCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ClientCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ClientCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ClientCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ClientCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultConnectionLimit">
      <MemberSignature Language="C#" Value="public static int DefaultConnectionLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultConnectionLimit" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultConnectionLimit As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultConnectionLimit { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.ServicePoint" /> 개체에서 허용하는 최대 동시 연결 수를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Net.ServicePoint" /> 개체에서 허용하는 최대 동시 연결 수입니다. 기본값은 2입니다. 앱이 ASP.NET 호스트로 실행되고 있는 경우 자동 구성 속성이 <see langword="true" />로 설정되면 구성 파일을 통해 이 속성의 값을 변경할 수 없습니다. 자동 구성 속성이 <see langword="true" />이면 프로그래밍 방식으로 값을 변경할 수 있습니다. AppDomain이 로드되면 원하는 값을 한 번 설정합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> 속성 기본 최대 동시 연결 수는 설정는 <xref:System.Net.ServicePointManager> 개체에 할당 된 <xref:System.Net.ServicePoint.ConnectionLimit%2A> 속성을 만들 때 <xref:System.Net.ServicePoint> 개체.  
  
 변경 된 <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> 속성에 기존에 영향을 주지 <xref:System.Net.ServicePoint> 개체이 고,만 영향을 줍니다 <xref:System.Net.ServicePoint> 변경 후 초기화 하는 개체입니다. 이 속성의 값에 직접 또는 구성을 통해 설정 되지, 기본적으로 값은 상수 <xref:System.Net.ServicePointManager.DefaultPersistentConnectionLimit>합니다.  
  
> [!NOTE]
>  변경 내용이 <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> 속성 HTTP 1.0 및 HTTP 1.1 연결 모두에 영향을 줍니다. 개별적으로 HTTP 1.0 및 HTTP 1.1 프로토콜에 대 한 연결 제한을 변경 하는 것이 불가능 합니다. (ASP.NET) 서버 환경에서 사용할 경우 <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> 더 높은 연결 수를 10 인 기본값으로 설정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성을 설정합니다.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" />가 0보다 작거나 같은 경우</exception>
        <permission cref="T:System.Net.WebPermission">에 대 한 무제한 웹 사용 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="DefaultNonPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultNonPersistentConnectionLimit = (4)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultNonPersistentConnectionLimit As Integer  = 4" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>HTTP/1.0 이상의 서버에 연결된 <see cref="T:System.Net.ServicePoint" /> 개체에서 허용되는 기본 비영구적 연결 수(4)입니다. 이 필드는 상수이지만 .NET Framework 2.0에서는 더 이상 사용되지 않습니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultPersistentConnectionLimit = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultPersistentConnectionLimit As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultPersistentConnectionLimit = 2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>HTTP/1.1 이상의 서버에 연결된 <see cref="T:System.Net.ServicePoint" /> 개체에서 허용되는 기본 영구적 연결 수(2)입니다. <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> 속성 값이 직접 또는 구성을 통해 설정되지 않은 경우 이 필드는 상수이며 <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> 속성을 초기화하는 데 사용됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> 이 필드를 사용 하 여 속성입니다.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DnsRefreshTimeout">
      <MemberSignature Language="C#" Value="public static int DnsRefreshTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DnsRefreshTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DnsRefreshTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DnsRefreshTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>DNS(도메인 이름 서비스) 확인이 유효한 것으로 간주되는 기간을 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>시간 제한 값(밀리초)입니다. 값 -1은 시간 제한이 없음을 나타냅니다. 기본값은 120,000밀리초(2분)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는이 속성을 설정합니다.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EnableDnsRoundRobin">
      <MemberSignature Language="C#" Value="public static bool EnableDnsRoundRobin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableDnsRoundRobin" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableDnsRoundRobin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableDnsRoundRobin { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>DNS(Domain Name Service) 확인이 적절한 IP(인터넷 프로토콜) 주소 사이에서 순환되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          DNS 확인 시 항상 특정 호스트의 첫 번째 IP 주소가 반환되면 <see langword="false" />이고, 반환되지 않으면 <see langword="true" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 여러 개의 IP 주소가 호스트 이름과 관련 된 경우 DNS 확인 시 일반적으로 첫 번째 IP 주소만을 반환 합니다. 이 속성을 설정 하는 경우 `true`, 후속 DNS 확인은 특정 호스트에 대 한 모든 사용 가능한 IP 주소가 순환 합니다. 이 옵션은 서비스 DNS를 사용 하 여 부하 분산 서버 또는 서버 클러스터 간의 메커니즘으로 하는 경우에 유용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성을 설정합니다.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionPolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Security.EncryptionPolicy EncryptionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.Security.EncryptionPolicy EncryptionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EncryptionPolicy As EncryptionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::EncryptionPolicy EncryptionPolicy { System::Net::Security::EncryptionPolicy get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Always returns EncryptionPolicy.RequireEncryption.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.EncryptionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Net.ServicePointManager" /> 인스턴스에 대한 <see cref="T:System.Net.Security.EncryptionPolicy" />를 가져옵니다.</summary>
        <value>이 <see cref="T:System.Net.ServicePointManager" /> 인스턴스에 사용할 암호화 정책입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구성 파일에는 값을 지정 하지 않으면는 <xref:System.Net.ServicePointManager.EncryptionPolicy%2A> 속성의 기본값은 <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>합니다. 이 SSL/TLS 세션에 적용 되는이 <xref:System.Net.ServicePointManager> 인스턴스.  
  
 암호화 정책으로 설정 된 경우 Null 암호화 사용이 필수 <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="P:System.Net.Configuration.ServicePointManagerElement.EncryptionPolicy" />
        <altmember cref="T:System.Net.Security.EncryptionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="Expect100Continue">
      <MemberSignature Language="C#" Value="public static bool Expect100Continue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Expect100Continue" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.Expect100Continue" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Expect100Continue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Expect100Continue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>100-Continue 동작을 사용할지 여부를 결정하는 <see cref="T:System.Boolean" /> 값을 가져오거나 설정합니다.</summary>
        <value>
          100-Continue 동작을 설정하는 경우 <see langword="true" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성이로 설정 된 경우 `true`, 100-계속 동작이 사용 됩니다. 클라이언트에서 사용 하는 요청에서 `PUT` 및 `POST` 메서드는 Expect 헤더를에 추가 요청은 <xref:System.Net.ServicePointManager.Expect100Continue%2A> 속성은 `true` 및 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성은 0 보다 큰 또는 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성은 true입니다. 클라이언트는을 받게 것을 예상-클라이언트를 게시 데이터를 전송 하도록 나타내려면 서버 로부터 응답을 계속 합니다. 이 메커니즘은 요청 헤더에 따라 서버에서 요청을 거부 하려고 할 때 네트워크를 통해 많은 양의 데이터를 보내지 못하게 하는 클라이언트 수 있습니다.  
  
 예를 들어는 <xref:System.Net.ServicePointManager.Expect100Continue%2A> 속성은 `false`합니다. 서버에 요청을 보내면 데이터를 포함 합니다. 요청 헤더를 읽은 후 서버 인증이 필요 하 고 401 응답을 보내야 합니다, 하는 경우 클라이언트가 적절 한 인증 헤더를 사용 하 여 데이터 다시 보내야 합니다.  
  
 이 속성이 `true`, 요청 헤더에는 서버에 보내집니다. 서버가 요청을 거부 했습니다, 100 보냅니다-계속 응답 신호를 보내는 데이터를 전송할 수 있습니다. 앞의 예제에서와 같이 서버 인증이 필요한 경우 401 응답을 보냅니다 및 클라이언트에 데이터를 불필요 하 게 전송 되지 않습니다.  
  
 이 속성의 값을 변경 해도 기존 <xref:System.Net.ServicePoint> 개체입니다. 새로운만 <xref:System.Net.ServicePoint> 변경 이후 생성 되는 개체에 영향을 합니다.  
  
 100-동작이 속성을 설정 하는 경우에 하지 HTTP 1.0 요청에 사용 되므로 계속 `true`합니다.  
  
 Expect 100-계속 동작을 완전히 10.1.1 IETF RFC 2616 섹션에서 설명 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성을 설정합니다.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindServicePoint">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>기존의 <see cref="T:System.Net.ServicePoint" /> 개체를 찾거나 새 <see cref="T:System.Net.ServicePoint" /> 개체를 만들어 이 요청에 대한 통신을 관리합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="address">연결할 인터넷 리소스의 <see cref="T:System.Uri" /> 개체입니다.</param>
        <summary>기존의 <see cref="T:System.Net.ServicePoint" /> 개체를 찾거나 새 <see cref="T:System.Net.ServicePoint" /> 개체를 만들어 지정된 <see cref="T:System.Uri" /> 개체와의 통신을 관리합니다.</summary>
        <returns>요청에 대한 통신을 관리하는 <see cref="T:System.Net.ServicePoint" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> 메서드가 반환 되는 <xref:System.Net.ServicePoint> 지정 된 인터넷 호스트 이름과 관련 된 개체입니다. 없는 경우 <xref:System.Net.ServicePoint> 개체가 해당 호스트에 대해는 <xref:System.Net.ServicePointManager> 개체 하나를 만듭니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.ServicePoint" />에 정의된 <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> 개체의 최대 개수에 도달한 경우</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (string uriString, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(string uriString, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.String,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (uriString As String, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(System::String ^ uriString, System::Net::IWebProxy ^ proxy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="uriString">연결할 인터넷 리소스의 URI입니다.</param>
        <param name="proxy">이 요청에 대한 프록시 데이터입니다.</param>
        <summary>기존의 <see cref="T:System.Net.ServicePoint" /> 개체를 찾거나 새 <see cref="T:System.Net.ServicePoint" /> 개체를 만들어 지정된 URI(Uniform Resource Identifier)와의 통신을 관리합니다.</summary>
        <returns>요청에 대한 통신을 관리하는 <see cref="T:System.Net.ServicePoint" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> 메서드가 반환 되는 <xref:System.Net.ServicePoint> 지정 된 인터넷 호스트 이름과 관련 된 개체입니다. 없는 경우 <xref:System.Net.ServicePoint> 개체가 해당 호스트에 대해는 <xref:System.Net.ServicePointManager> 개체 하나를 만듭니다.  
  
   
  
## Examples  
 다음 코드 예제에 액세스 하려면이 메서드를 호출 하는 방법을 보여 줍니다는 <xref:System.Net.ServicePoint> 개체입니다.  
  
 [!code-cpp[System.Net.ServicePoint#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#7)]
 [!code-csharp[System.Net.ServicePoint#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#7)]
 [!code-vb[System.Net.ServicePoint#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">
          <paramref name="uriString" />에서 지정된 URI가 유효하지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.ServicePoint" />에 정의된 <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> 개체의 최대 개수에 도달한 경우</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address, System::Net::IWebProxy ^ proxy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="address">연결할 인터넷 리소스 주소가 들어 있는 <see cref="T:System.Uri" /> 개체입니다.</param>
        <param name="proxy">이 요청에 대한 프록시 데이터입니다.</param>
        <summary>기존의 <see cref="T:System.Net.ServicePoint" /> 개체를 찾거나 새 <see cref="T:System.Net.ServicePoint" /> 개체를 만들어 지정된 <see cref="T:System.Uri" /> 개체와의 통신을 관리합니다.</summary>
        <returns>요청에 대한 통신을 관리하는 <see cref="T:System.Net.ServicePoint" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> 메서드가 반환 되는 <xref:System.Net.ServicePoint> 지정 된 인터넷 호스트 이름과 관련 된 개체입니다. 없는 경우 <xref:System.Net.ServicePoint> 개체가 해당 호스트에 대해는 <xref:System.Net.ServicePointManager> 개체 하나를 만듭니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.ServicePoint" />에 정의된 <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> 개체의 최대 개수에 도달한 경우</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePointIdleTime">
      <MemberSignature Language="C#" Value="public static int MaxServicePointIdleTime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePointIdleTime" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePointIdleTime As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePointIdleTime { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.ServicePoint" /> 개체의 최대 유휴 시간을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Net.ServicePoint" /> 개체의 최대 유휴 시간(밀리초)입니다. 기본값은 100,000밀리초(100초)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.MaxServicePointIdleTime%2A> 속성 집합의 최대 유휴 시간은 <xref:System.Net.ServicePointManager> 개체에 할당 된 <xref:System.Net.ServicePoint.MaxIdleTime%2A> 속성을 만들 때 <xref:System.Net.ServicePoint> 개체입니다. 이 값에 대 한 변경에만 영향을 <xref:System.Net.ServicePoint> 값이 변경 후 초기화 하는 개체입니다.  
  
 후는 <xref:System.Net.ServicePoint> 개체에 지정 된 시간 동안 유휴 상태가 되었습니다 <xref:System.Net.ServicePoint.MaxIdleTime%2A>, 가비지 수집의 대상이 됩니다. A <xref:System.Net.ServicePoint> 개체는 유휴 연결 목록에 연결 된 경우는 <xref:System.Net.ServicePoint> 개체가 비어 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성을 설정합니다.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.MaxServicePointIdleTime" />가 <see cref="F:System.Threading.Timeout.Infinite" />보다 작거나 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
        <permission cref="T:System.Net.WebPermission">에 대 한 무제한 웹 사용 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePoints">
      <MemberSignature Language="C#" Value="public static int MaxServicePoints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePoints" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePoints" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePoints As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePoints { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>언제나 유지해야 할 최대 <see cref="T:System.Net.ServicePoint" /> 개체 수를 가져오거나 설정합니다.</summary>
        <value>유지해야 할 최대 <see cref="T:System.Net.ServicePoint" /> 개체 수입니다. 기본값은 0이며, 이는 <see cref="T:System.Net.ServicePoint" /> 개체 수에 제한이 없음을 의미합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 줄일 수는 <xref:System.Net.ServicePointManager.MaxServicePoints%2A> 속성 수가 아래 <xref:System.Net.ServicePoint> 의 현재 개체는 <xref:System.Net.ServicePointManager> 삭제는 <xref:System.Net.ServicePoint> 유휴 시간이 가장 긴를 사용 하 여 개체입니다. 경우 수가 <xref:System.Net.ServicePoint> 활성 연결을 사용 하 여 개체의 값 보다 크면 <xref:System.Net.ServicePointManager.MaxServicePoints%2A>, <xref:System.Net.ServicePointManager> 삭제 개체의 <xref:System.Net.ServicePoint> 유휴 상태가 될 때 개체입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성을 설정합니다.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.MaxServicePoints" />가 0보다 작거나 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
        <permission cref="T:System.Net.WebPermission">에 대 한 무제한 웹 사용 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="ReusePort">
      <MemberSignature Language="C#" Value="public static bool ReusePort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ReusePort" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ReusePort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ReusePort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ReusePort { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성 값을 <see langword="true" />로 설정하면 HttpWebRequest의 모든 아웃바운드 TCP 연결에서 소켓에 네이티브 소켓 옵션 SO_REUSE_UNICASTPORT를 사용합니다. 이렇게 하면 기본 송신 포트를 공유할 수 있습니다. 짧은 기간에 많은 수의 나가는 연결이 설정되어 앱이 포트 없이 실행될 위험이 있는 시나리오에 유용합니다.</summary>
        <value>
          <see cref="T:System.Boolean" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본값은 `false`입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityProtocol">
      <MemberSignature Language="C#" Value="public static System.Net.SecurityProtocolType SecurityProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.SecurityProtocolType SecurityProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.SecurityProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityProtocol As SecurityProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::SecurityProtocolType SecurityProtocol { System::Net::SecurityProtocolType get(); void set(System::Net::SecurityProtocolType value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.SecurityProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.ServicePointManager" /> 개체에서 관리하는 <see cref="T:System.Net.ServicePoint" /> 개체에 사용되는 보안 프로토콜을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Net.SecurityProtocolType" /> 열거형에 정의된 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
이 속성에 새 연결;에 사용 하려면 Secure Sockets Layer (SSL) 또는 보안 TLS (전송 계층) 프로토콜의 버전을 선택 기존 연결 변경 되지 않습니다.  
  
이 속성의 기본값은.NET Framework 4.7 부터는 <xref:System.Net.SecurityProtocolType.SystemDefault?displayProperty=nameWithType>합니다. 이렇게 하면.NET Framework Api에 따라 네트워킹 <xref:System.Net.Security.SslStream> (FTP, HTTP, SMTP 등) 또는 시스템 관리자에 의해 수행 된 모든 사용자 지정 구성은 운영 체제에서 기본 보안 프로토콜을 상속 하도록 합니다. 각 버전의 Windows 운영 체제에서 기본적으로 프로토콜이 설정 되어 있는 SSL/TLS에 대 한 정보를 참조 하십시오. [TLS/SSL (Schannel SSP)의 프로토콜](https://msdn.microsoft.com/library/windows/desktop/mt808159.aspx)합니다.
 
버전의.NET Framework 4.6.2 통해.NET Framework에서는이 속성에 대 한 기본값을 갖지 나열 됩니다. 보안 계획 지속적으로 변경 하 고 기본 프로토콜 및 보호 수준이 알려진된 약점을 방지 하기 위해 시간이 지남에 따라 변경 됩니다. 기본값은 개별 컴퓨터 구성, 설치 된 소프트웨어 및 패치 적용 된에 따라 달라 집니다.  
  
 코드 또는 특정 보호 수준을 사용 하 여 보안 수준을 기본적으로 사용 되는 가정에 종속 되지 암시적으로 되어야 합니다. 특정 보안 수준 사용할에 종속 되는 앱에 해당 수준을 명시적으로 지정 하 고에 설정 된 연결에서 사용 중인 실제로 인지 있는지 확인 해야 합니다. 또한 프로토콜은 지원 되는 변경에 관계 없이 강력해 하도록 코드를 디자인 해야, 따라서 자주 변경 거의 미리 확인할 수 있는 새로운 위협 완화 하기 위해.  
  
 .NET Framework 4.6에는 안전 하지 않은 암호화 및 해시 알고리즘에 대 한 연결을 차단 하는 새로운 보안 기능이 포함 되어 있습니다. .NET Framework 4.6을 대상으로 지정 및 HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream 등의 Api 통해 TLS/SSL을 사용 하 여 응용 프로그램 기본적으로 보안 수준이 높은 동작을 가져옵니다.  
  
 개발자가 RC4 서비스를 지 원하는 기존 SSL3 서비스 또는 TLS와의 상호 운용성을 유지 하기 위해이 동작을 취소 하려고 할 수 있습니다. [이 문서](https://support.microsoft.com/kb/3069494) 를 새 동작을 사용할 수 없습니다. 코드를 수정 하는 방법에 설명 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">속성을 설정하기 위해 지정된 값이 유효한 <see cref="T:System.Net.SecurityProtocolType" /> 열거형 값이 아닌 경우</exception>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.SecurityProtocolType" />
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public static System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 인증서의 유효성을 검사할 콜백을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
응용 프로그램을 설정할 수는 <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A> 서버 인증서의 클라이언트에서 사용자 지정 유효성 검사를 사용 하는 메서드에 속성입니다. 사용자 지정 유효성 검사를 수행 하는 경우는 `sender` 에 전달 된 매개 변수는 <xref:System.Net.Security.RemoteCertificateValidationCallback> 호스트 문자열 이름이 될 수 있습니다 또는 개체에서 파생 된 <xref:System.Net.WebRequest> (<xref:System.Net.HttpWebRequest>예를 들면)에 따라는 <xref:System.Net.ServicePointManager.CertificatePolicy%2A> 속성입니다.  
  
사용자 지정 유효성 검사를 사용 하지 않으면 인증서 이름 요청을 만드는 데는 호스트 이름으로 비교 됩니다. 예를 들어 경우 <xref:System.Net.WebRequest.Create%28System.String%29> 의 매개 변수를 전달 된 "https://www.contoso.com/default.html", 기본 동작은 www.contoso.com에 대 한 인증서를 확인 하기 위해 클라이언트에 대 한 합니다.  

불구 하 고 멀티 캐스트 대리자 되 고, 마지막 실행 이벤트 처리기에서 반환 되는 값만 신뢰할 수 있는 간주 됩니다. 즉, 여러 대리자를 연결할 수 있으며 모든 러 워에서 콜백 <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A>합니다. 없습니다; 인증서가 허용 하는지 여부를 나타내는 값을 반환 하는 각 콜백 그러나 마지막 대리자의 값에만 적용 됩니다.
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">설정 하 여 <see cref="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" /> 속성입니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ServerCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ServerCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ServerCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ServerCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTcpKeepAlive">
      <MemberSignature Language="C#" Value="public static void SetTcpKeepAlive (bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTcpKeepAlive(bool enabled, int32 keepAliveTime, int32 keepAliveInterval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.SetTcpKeepAlive(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTcpKeepAlive (enabled As Boolean, keepAliveTime As Integer, keepAliveInterval As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" />
        <Parameter Name="keepAliveTime" Type="System.Int32" />
        <Parameter Name="keepAliveInterval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="enabled">true로 설정하면 지정된 <c>keepAliveTime</c> 및 <c>keepAliveInterval</c> 값을 사용하여 TCP 연결에서 TCP 연결 유지 옵션을 사용하도록 설정합니다.  
  
 false로 설정하면 TCP 연결 유지 옵션을 사용하지 않도록 설정하고 나머지 매개 변수를 무시합니다.  
  
 기본값은 false입니다.</param>
        <param name="keepAliveTime">첫 번째 연결 유지 패킷이 전송될 때까지 아무런 작업도 수행하지 않는 시간 제한(밀리초)을 지정합니다.  
  
 이 값은 0보다 커야 합니다.  0보다 작거나 같은 값이 전달되면 <see cref="T:System.ArgumentOutOfRangeException" />이 throw됩니다.</param>
        <param name="keepAliveInterval">승인을 받지 못할 경우 다음 연결 유지 패킷이 전송되는 간격(밀리초)을 지정합니다.  
  
 이 값은 0보다 커야 합니다.  0보다 작거나 같은 값이 전달되면 <see cref="T:System.ArgumentOutOfRangeException" />이 throw됩니다.</param>
        <summary>TCP 연결에서 연결 유지 옵션을 사용하거나 사용하지 않습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP/IP 공급자 TCP 연결에서 연결 유지 패킷이을 사용할 수 있도록 하는 응용 프로그램 요청할 수 있습니다. 기본값은 TCP 연결에서 연결 유지 패킷이 사용 불가능 합니다.  
  
 TCP 소켓을 경우의 기본 설정은 2 시간 설정에서 연결 유지 시간 제한 및 연결 유지 간격을 1 초로 초기화 합니다. `keepAliveTime` 매개 변수는 첫 번째 연결 유지 패킷이 전송 될 때까지 아무런 작업도 밀리초 단위로 제한 시간을 지정 합니다. `keepAliveInterval` 매개 변수는 간격을 밀리초 단위로 지정 사이 승인을 받지 못할 경우 연속 연결 유지 패킷이 전송 됩니다. 연결 유지 프로브 수를 변경할 수 없습니다 및 10으로 설정 됩니다.  
  
 연결 유지의 결과로 TCP 연결이 끊어진 경우는 <xref:System.Net.Sockets.SocketError> 의 <xref:System.Net.Sockets.SocketError.NetworkReset> 에서 반환 되는 진행 중인 모든 호출에는 소켓 이후의 호출이 실패 하 고는 <xref:System.Net.Sockets.SocketError> 의 <xref:System.Net.Sockets.SocketError.NotConnected>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="keepAliveTime" /> 또는 <paramref name="keepAliveInterval" /> 매개 변수에 지정된 값이 0보다 작거나 같습니다.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="UseNagleAlgorithm">
      <MemberSignature Language="C#" Value="public static bool UseNagleAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseNagleAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseNagleAlgorithm As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseNagleAlgorithm { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Net.ServicePointManager" /> 개체에서 관리하는 서비스 지점에 Nagle 알고리즘을 사용할지 여부를 결정합니다.</summary>
        <value>
          Nagle 알고리즘을 사용하려면 <see langword="true" />이고, 사용하지 않으려면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle 알고리즘은 작은 데이터 패킷을 버퍼링 하 고 단일 패킷으로 전송 하 여 네트워크 트래픽을 줄이기 위해 사용 됩니다. 이 과정을 "nagling"; "이 라고도 전송 된 패킷 수가 감소 하므로 널리 사용 됩니다 하 고 패킷 당 오버 헤드를 낮춥니다.  
  
 이 속성의 값을 변경 해도 기존 <xref:System.Net.ServicePoint> 개체입니다. 새 서비스 지점만 변경 이후 생성에 영향을 받습니다.  
  
 Nagle 알고리즘 IETF RFC 896 완벽 하 게 설명 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성을 설정합니다.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
  </Members>
</Type>