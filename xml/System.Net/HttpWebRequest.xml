<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e375cff6d3f3621aa35b61963b8d8aa09e4f97b6" />
    <Meta Name="ms.sourcegitcommit" Value="b3480b6208c3cad466469e76294a96f5ab1ef04c" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/16/2018" />
    <Meta Name="ms.locfileid" Value="35691822" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides an HTTP-specific implementation of the <see cref="T:System.Net.WebRequest" /> class.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest> 에 정의 된 메서드 및 속성에 대 한 클래스는 지원 <xref:System.Net.WebRequest> 및 추가 속성 및 HTTP를 사용 하 여 서버와 직접 상호 작용할 수 있도록 하는 방법에 대 한 합니다.  
  
 사용 하지 않는 <xref:System.Net.HttpWebRequest.%23ctor%2A> 생성자입니다. 사용 하 여는 <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> 새로운 초기화 하려면 메서드 <xref:System.Net.HttpWebRequest> 개체입니다. 에 식별자 URI (Uniform Resource) 구성표는 경우 `http://` 또는 `https://`, <xref:System.Net.WebRequest.Create%2A> 반환는 <xref:System.Net.HttpWebRequest> 개체입니다.  
  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드에 지정 된 리소스 동기 요청 하는 <xref:System.Net.HttpWebRequest.RequestUri%2A> 속성과 반환은 <xref:System.Net.HttpWebResponse> 응답 개체를 포함 하 합니다. 반환 된 스트림을 사용 하 여 응답 데이터를 받을 수 <xref:System.Net.HttpWebResponse.GetResponseStream%2A>합니다. 응답 개체 또는 응답 스트림에 닫혀 있는 경우 데이터 남은 몰수 됩니다. 나머지 데이터는 비워지기 및 다음과 잡지 응답 개체 또는 스트림을 닫을 때 소켓 후속 요청에 다시 사용 됩니다: keep-alive 또는 파이프라인 요청, 적은 양의 데이터를 받을 수 해야 합니다. 또는 작은 시간 간격에서 남아 있는 데이터를 수신 합니다. 언급 한 조건이 하나도 없는 보유 하거나 드레이닝 시간 임계값을 초과 하는 경우 소켓을 닫습니다. 연결 유지 또는 파이프라인 된 연결에 대 한 응용 프로그램 EOF까지 스트림을 읽는 것이 좋습니다. 이렇게 하면 소켓 덜 사용 되는 리소스 및 성능이 향상으로 인해 발생 하는 후속 요청에 다시 사용 됩니다.  
  
 리소스에 데이터를 전송 하려는 경우는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드가 반환 되는 <xref:System.IO.Stream> 데이터를 보내는 데 사용할 개체입니다. <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 및 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 메서드 송신 데이터 스트림에 대 한 비동기 액세스를 제공 합니다.  
  
 사용한 클라이언트 인증에 대 한 <xref:System.Net.HttpWebRequest>, 클라이언트 인증서를 설치 해야는 현재 사용자의 개인 인증서 저장소입니다.  
  
 <xref:System.Net.HttpWebRequest> throw 클래스는 <xref:System.Net.WebException> 리소스에 액세스 하는 동안 오류가 발생 한 경우. <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> 속성을 포함 한 <xref:System.Net.WebExceptionStatus> 오류의 출처를 나타내는 값입니다. 때 <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> 은 <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, <xref:System.Net.WebException.Response%2A> 속성에 포함 된 <xref:System.Net.HttpWebResponse> 는 리소스에서 받은 합니다.  
  
 <xref:System.Net.HttpWebRequest> 메서드를 설정 하거나; 시스템에서 설정한 속성으로 인터넷 리소스에 보낸, 일반적인 HTTP 헤더 값을 노출 합니다. 다음 표에서 전체 목록을 보여 줍니다. 다른 헤더를 설정할 수는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성 이름/값 쌍으로 합니다. 서버와 캐시가 변경 될 수 있습니다 또는 헤더를 요청 하는 동안 추가 참고 합니다.  
  
 다음 표에서 속성, 메서드 또는 시스템에 의해 설정 된 HTTP 헤더를 보여 줍니다.  
  
|헤더|으로 설정|  
|------------|------------|  
|허용|설정한는 <xref:System.Net.HttpWebRequest.Accept%2A> 속성입니다.|  
|연결|설정한는 <xref:System.Net.HttpWebRequest.Connection%2A> 속성 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성입니다.|  
|Content-Length|설정한는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성입니다.|  
|콘텐츠-유형|설정한는 <xref:System.Net.HttpWebRequest.ContentType%2A> 속성입니다.|  
|예상|설정한는 <xref:System.Net.HttpWebRequest.Expect%2A> 속성입니다.|  
|Date|현재 날짜를 시스템으로 설정 합니다.|  
|호스트|현재 호스트 정보를 시스템으로 설정 합니다.|  
|If-수정-이후|설정한는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성입니다.|  
|범위|으로 설정 된 <xref:System.Net.HttpWebRequest.AddRange%2A> 메서드.|  
|참조 페이지|설정한는 <xref:System.Net.HttpWebRequest.Referer%2A> 속성입니다.|  
|전송 인코딩|설정한는 <xref:System.Net.HttpWebRequest.TransferEncoding%2A> 속성 (의 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성 이어야 `true`).|  
|사용자 에이전트|설정한는 <xref:System.Net.HttpWebRequest.UserAgent%2A> 속성입니다.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> 자동으로 등록 됩니다. 호출할 필요가 없습니다는 <xref:System.Net.WebRequest.RegisterPrefix%2A> 등록 <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> Uri를 사용 하기 전에 부터는 `http://` 또는 `https://`합니다.  
  
 로컬 컴퓨터 또는 응용 프로그램 구성 파일에서 기본 프록시 사용할 지정할 수 있습니다. 경우는 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성이 지정 된 프록시 설정에서는 <xref:System.Net.HttpWebRequest.Proxy%2A> 로컬 컴퓨터 또는 응용 프로그램 구성 파일을 재정의 하는 속성 및 <xref:System.Net.HttpWebRequest> 인스턴스에서 지정 된 프록시 설정을 사용 하 여 합니다. 구성 파일에 없는 프록시를 지정 하는 경우 및 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성이 지정 되어 있지는 <xref:System.Net.HttpWebRequest> 클래스에서에서 상속 되며, Internet Explorer 로컬 컴퓨터에 프록시 설정을 사용 합니다. Internet Explorer의 프록시 설정이 없는 경우에 서버에 직접 요청이 보내집니다.  
  
 <xref:System.Net.HttpWebRequest> 클래스에서에서 상속 되며, Internet Explorer 다르게 무시 목록은 Internet Explorer에서 직접 구문 분석 하는 보다 와일드 카드 문자를 사용한 프록시 바이패스 목록이 구문 분석 합니다. 예를 들어는 <xref:System.Net.HttpWebRequest> 클래스는 ह ु ण फ 바이패스 목록이 "nt *" Internet Explorer에서 정규식의 "nt. $"입니다. 이 기본 동작의 Internet Explorer에서 다릅니다. 따라서의 URL "`http://intxxxxx`"를 사용 하 여 프록시를 무시는 <xref:System.Net.HttpWebRequest> 클래스 같지만 Internet Explorer를 사용 하 여 프록시를 무시 하지 않습니다.  
  
> [!NOTE]
>  프레임 워크 만들어질 때 SSL 세션을 캐시 하 고 가능한 경우 새 요청에 대 한 캐시 된 세션을 사용 하려고 합니다. 프레임 워크의 첫 번째 요소를 사용 하 여 SSL 세션을 다시 사용을 시도할 때 <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (있는지 하나), 하는 경우 익명 세션을 다시 사용 하려고 <xref:System.Net.HttpWebRequest.ClientCertificates%2A> 비어 있습니다.  
  
> [!NOTE]
>  쿠키는 보안상의 이유로 기본적으로 비활성화 됩니다. 사용 하 여 쿠키를 사용 하려는 경우는 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 속성을 사용 하는 쿠키입니다.  
  
 .NET Framework 4.6에는 안전 하지 않은 암호화 및 해시 알고리즘에 대 한 연결을 차단 하는 새로운 보안 기능이 포함 되어 있습니다. .NET Framework 4.6을 대상으로 지정 및 HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream 등의 Api 통해 TLS/SSL을 사용 하 여 응용 프로그램 기본적으로 보안 수준이 높은 동작을 가져옵니다.  
  
 개발자가 RC4 서비스를 지 원하는 기존 SSL3 서비스 또는 TLS와의 상호 운용성을 유지 하기 위해이 동작을 취소 하려고 할 수 있습니다. [이 문서](https://support.microsoft.com/kb/3069494) 를 새 동작을 사용할 수 없습니다. 코드를 수정 하는 방법에 설명 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Net.HttpWebRequest> uri http://www.contoso.com/합니다.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">요청된 된 URI 또는 URI에는 요청을 리디렉션합니다 액세스 하려면. 연결 된 열거형의 경우: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. These constructors are obsolete; see the Remarks section for details.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

둘 다 <xref:System.Net.HttpWebRequest> 생성자 사용 되지 않으며 사용 하지 않아야 합니다. 호출 된 <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> 새로운 초기화 하려면 메서드 <xref:System.Net.HttpWebRequest> 개체입니다.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. This constructor is obsolete.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains the source and destination of the serialized stream associated with the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class from the specified instances of the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and <see cref="T:System.Runtime.Serialization.StreamingContext" /> classes. This constructor is obsolete.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serialization을 사용 하는 경우 응용 프로그램은 완전 신뢰 모드에서 실행 해야 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">네트워크 리소스에 대 한 무제한 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels a request to an Internet resource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Abort%2A> 메서드는 리소스에 대 한 요청을 취소 합니다. 요청이 취소 된 후 호출 된 <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, 또는 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 메서드를 사용 하면은 <xref:System.Net.WebException> 와 <xref:System.Net.WebException.Status%2A> 속성이로 설정 <xref:System.Net.WebExceptionStatus.RequestCanceled>합니다.  
  
 <xref:System.Net.HttpWebRequest.Abort%2A> 메서드는 지정 된 콜백을 동기적으로 실행 합니다는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 또는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드 경우는 <xref:System.Net.HttpWebRequest.Abort%2A> 메서드는 이러한 작업 중 하나라도 완료 되지 않은 동안에 호출 됩니다. 잠재적인 교착 상태 문제가 발생할 수 있습니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 참조 [네트워크 추적](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804)합니다.  
  
   
  
## Examples  
 비동기 요청의 경우 것은 제한 시간 메커니즘을 구현 하는 클라이언트 응용 프로그램의 책임입니다. 다음 코드 예제에서는이 작업을 수행 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Accept" /> HTTP header.</summary>
        <value>HTTP <see langword="Accept" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지우려면는 `Accept` HTTP 헤더를 설정할는 <xref:System.Net.HttpWebRequest.Accept%2A> 속성을 `null`합니다.  
  
> [!NOTE]
>  이 속성에 대 한 값에 저장 됩니다 <xref:System.Net.WebHeaderCollection>합니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Accept%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds a range header to the request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 있으므로 바이트 범위의 개념은 모든 HTTP 엔터티에 대 한 의미 있는 합니다. 그러나 일부 클라이언트 및 서버 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더를 요청 하려고 한다는 것만 HTTP 엔터티에서 지정 된 범위의 바이트의 특정 부분을 받을 클라이언트가 수 있습니다. 서버 범위 헤더 요청을 지 원하는 데 필요는 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 바이트 범위 헤더를 추가 합니다.  
  
 경우 `range` 가 양수 이면는 `range` 매개 변수는 범위의 시작 지점을 지정 합니다. 서버에서 데이터를 보내기 시작 해야는 `range` HTTP 엔터티에서 데이터의 끝에 지정 된 매개 변수입니다.  
  
 경우 `range` 가 음수 이면는 `range` 매개 변수는 끝점의 범위를 지정 합니다. 서버에는 HTTP 엔터티에 있는 데이터의 시작 부분부터 데이터를 보내기 시작 해야는 `range` 매개 변수를 지정 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 있으므로 바이트 범위의 개념은 모든 HTTP 엔터티에 대 한 의미 있는 합니다. 그러나 일부 클라이언트 및 서버 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더를 요청 하려고 한다는 것만 HTTP 엔터티에서 지정 된 범위의 바이트의 특정 부분을 받을 클라이언트가 수 있습니다. 서버 범위 헤더 요청을 지 원하는 데 필요는 없습니다.  
  
 서버 송신 (99 바이트 위치로 시작)에서 처음 100 바이트가 다음 것을 요청 하는 HTTP 프로토콜 요청에 범위 헤더의 예:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 이 예는 `range` 매개 변수-99 것입니다.  
  
 HTTP 서버 범위 Accept 헤더로 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지원 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 서버에서 응답의 헤더에 적용 범위 헤더를 받지 못한 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 적용 범위 헤더를 인식 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고의 속성을 통해 사용할 수 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위에 연결 된 헤더는 응답에 반환 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 요청에 범위 헤더를 추가 합니다.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 바이트 범위 헤더를 추가 합니다.  
  
 경우 `range` 가 양수 이면는 `range` 매개 변수는 범위의 시작 지점을 지정 합니다. 서버에서 데이터를 보내기 시작 해야는 `range` HTTP 엔터티에서 데이터의 끝에 지정 된 매개 변수입니다.  
  
 경우 `range` 가 음수 이면는 `range` 매개 변수는 끝점의 범위를 지정 합니다. 서버에는 HTTP 엔터티에 있는 데이터의 시작 부분부터 데이터를 보내기 시작 해야는 `range` 매개 변수를 지정 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 있으므로 바이트 범위의 개념은 모든 HTTP 엔터티에 대 한 의미 있는 합니다. 그러나 일부 클라이언트 및 서버 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더를 요청 하려고 한다는 것만 HTTP 엔터티에서 지정 된 범위의 바이트의 특정 부분을 받을 클라이언트가 수 있습니다. 서버 범위 헤더 요청을 지 원하는 데 필요는 없습니다.  
  
 서버 송신 (99 바이트 위치로 시작)에서 처음 100 바이트가 다음 것을 요청 하는 HTTP 프로토콜 요청에 범위 헤더의 예:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 이 예는 `range` 매개 변수-99 것입니다.  
  
 HTTP 서버 범위 Accept 헤더로 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지원 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 서버에서 응답의 헤더에 적용 범위 헤더를 받지 못한 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 적용 범위 헤더를 인식 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고의 속성을 통해 사용할 수 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위에 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 바이트 범위 헤더를 추가 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 있으므로 바이트 범위의 개념은 모든 HTTP 엔터티에 대 한 의미 있는 합니다. 그러나 일부 클라이언트 및 서버 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더를 요청 하려고 한다는 것만 HTTP 엔터티에서 지정 된 범위의 바이트의 특정 부분을 받을 클라이언트가 수 있습니다. 서버 범위 헤더 요청을 지 원하는 데 필요는 없습니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 이 예는 `from` 매개 변수는 0으로 지정 및 `to` 매개 변수는 99로 지정 합니다. 범위 지정 자가이 메서드에서 "바이트"로 자동 설정 됩니다.  
  
 HTTP 서버 범위 Accept 헤더로 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지원 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 서버에서 응답의 헤더에 적용 범위 헤더를 받지 못한 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 적용 범위 헤더를 인식 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고의 속성을 통해 사용할 수 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위에 연결 된 헤더는 응답에 반환 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 요청에 범위 헤더를 추가 합니다.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 바이트 범위 헤더를 추가 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 있으므로 바이트 범위의 개념은 모든 HTTP 엔터티에 대 한 의미 있는 합니다. 그러나 일부 클라이언트 및 서버 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더를 요청 하려고 한다는 것만 HTTP 엔터티에서 지정 된 범위의 바이트의 특정 부분을 받을 클라이언트가 수 있습니다. 서버 범위 헤더 요청을 지 원하는 데 필요는 없습니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 이 예는 `from` 매개 변수는 0으로 지정 및 `to` 매개 변수는 99로 지정 합니다. 범위 지정 자가이 메서드에서 "바이트"로 자동 설정 됩니다.  
  
 HTTP 서버 범위 Accept 헤더로 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지원 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 서버에서 응답의 헤더에 적용 범위 헤더를 받지 못한 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 적용 범위 헤더를 인식 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고의 속성을 통해 사용할 수 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위에 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 범위 헤더를 추가 합니다.  
  
 경우 `range` 가 양수 이면는 `range` 매개 변수는 범위의 시작 지점을 지정 합니다. 서버에서 데이터를 보내기 시작 해야는 `range` HTTP 엔터티에서 데이터의 끝에 지정 된 매개 변수입니다.  
  
 경우 `range` 가 음수 이면는 `range` 매개 변수는 끝점의 범위를 지정 합니다. 서버에는 HTTP 엔터티에 있는 데이터의 시작 부분부터 데이터를 보내기 시작 해야는 `range` 매개 변수를 지정 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 있으므로 바이트 범위의 개념은 모든 HTTP 엔터티에 대 한 의미 있는 합니다. 그러나 일부 클라이언트 및 서버 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더를 요청 하려고 한다는 것만 HTTP 엔터티에서 지정 된 범위의 바이트의 특정 부분을 받을 클라이언트가 수 있습니다. 서버 범위 헤더 요청을 지 원하는 데 필요는 없습니다.  
  
 `rangeSpecifier` 매개 변수는 일반적으로로 지정 되며 "바이트",이 대부분의 HTTP 서버에서 인식 하는 유일한 범위 지정자입니다. 설정의 `rangeSpecifier` 바이트 (ietf RFC 2616에 정의 된 바이트 범위 지정자) 이외의 다른 사용자 지정 범위 지정자에 대 한 매개 변수를 다른 문자열로 지원할 수 있게 합니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=-99\r\n\r\n`  
  
 이 예는 `rangeSpecifier` 매개 변수는 "바이트"로 지정 및 `range` 매개 변수-99 것입니다.  
  
 HTTP 서버 응답에 적용 범위 헤더와 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지원 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 서버에서 응답의 헤더에 적용 범위 헤더를 받지 못한 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 적용 범위 헤더를 인식 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고의 속성을 통해 사용할 수 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위에 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 범위 헤더를 추가 합니다.  
  
 경우 `range` 가 양수 이면는 `range` 매개 변수는 범위의 시작 지점을 지정 합니다. 서버에서 데이터를 보내기 시작 해야는 `range` HTTP 엔터티에서 데이터의 끝에 지정 된 매개 변수입니다.  
  
 경우 `range` 가 음수 이면는 `range` 매개 변수는 끝점의 범위를 지정 합니다. 서버에는 HTTP 엔터티에 있는 데이터의 시작 부분부터 데이터를 보내기 시작 해야는 `range` 매개 변수를 지정 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 있으므로 바이트 범위의 개념은 모든 HTTP 엔터티에 대 한 의미 있는 합니다. 그러나 일부 클라이언트 및 서버 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더를 요청 하려고 한다는 것만 HTTP 엔터티에서 지정 된 범위의 바이트의 특정 부분을 받을 클라이언트가 수 있습니다. 서버 범위 헤더 요청을 지 원하는 데 필요는 없습니다.  
  
 `rangeSpecifier` 매개 변수는 일반적으로로 지정 되며 "바이트",이 대부분의 HTTP 서버에서 인식 하는 유일한 범위 지정자입니다. 설정의 `rangeSpecifier` 바이트 (ietf RFC 2616에 정의 된 바이트 범위 지정자) 이외의 다른 사용자 지정 범위 지정자에 대 한 매개 변수를 다른 문자열로 지원할 수 있게 합니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=-99\r\n\r\n`  
  
 이 예는 `rangeSpecifier` 매개 변수는 "바이트"로 지정 및 `range` 매개 변수-99 것입니다.  
  
 HTTP 서버 응답에 적용 범위 헤더와 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지원 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 서버에서 응답의 헤더에 적용 범위 헤더를 받지 못한 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 적용 범위 헤더를 인식 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고의 속성을 통해 사용할 수 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위에 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 범위 헤더를 추가 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 있으므로 바이트 범위의 개념은 모든 HTTP 엔터티에 대 한 의미 있는 합니다. 그러나 일부 클라이언트 및 서버 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더를 요청 하려고 한다는 것만 HTTP 엔터티에서 지정 된 범위의 바이트의 특정 부분을 받을 클라이언트가 수 있습니다. 서버 범위 헤더 요청을 지 원하는 데 필요는 없습니다.  
  
 `rangeSpecifier` 매개 변수는 일반적으로로 지정 되며 "바이트",이 대부분의 HTTP 서버에서 인식 하는 유일한 범위 지정자입니다. 설정의 `rangeSpecifier` 바이트 (ietf RFC 2616에 정의 된 바이트 범위 지정자) 이외의 다른 사용자 지정 범위 지정자에 대 한 매개 변수를 다른 문자열로 지원할 수 있게 합니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 이 예는 `rangeSpecifier` 매개 변수는 "바이트"로 지정 되는 `from` 매개 변수를 0으로 지정할 및 `to` 매개 변수를 지정할 99 합니다.  
  
 HTTP 서버 응답에 적용 범위 헤더와 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지원 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 적용 범위 헤더에 지정 된 문자열은에 의해 지정 되는 범위 지정자는 `rangeSpecifier` 이 메서드에 대 한 매개 변수입니다.  
  
 서버에서 응답의 헤더에 적용 범위 헤더를 받지 못한 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 적용 범위 헤더를 인식 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고의 속성을 통해 사용할 수 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위에 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 범위 헤더를 추가 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 있으므로 바이트 범위의 개념은 모든 HTTP 엔터티에 대 한 의미 있는 합니다. 그러나 일부 클라이언트 및 서버 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더를 요청 하려고 한다는 것만 HTTP 엔터티에서 지정 된 범위의 바이트의 특정 부분을 받을 클라이언트가 수 있습니다. 서버 범위 헤더 요청을 지 원하는 데 필요는 없습니다.  
  
 `rangeSpecifier` 매개 변수는 일반적으로로 지정 되며 "바이트",이 대부분의 HTTP 서버에서 인식 하는 유일한 범위 지정자입니다. 설정의 `rangeSpecifier` 바이트 (ietf RFC 2616에 정의 된 바이트 범위 지정자) 이외의 다른 사용자 지정 범위 지정자에 대 한 매개 변수를 다른 문자열로 지원할 수 있게 합니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 이 예는 `rangeSpecifier` 매개 변수는 "바이트"로 지정 되는 `from` 매개 변수를 0으로 지정할 및 `to` 매개 변수를 지정할 99 합니다.  
  
 HTTP 서버 응답에 적용 범위 헤더와 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지원 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 적용 범위 헤더에 지정 된 문자열은에 의해 지정 되는 범위 지정자는 `rangeSpecifier` 이 메서드에 대 한 매개 변수입니다.  
  
 서버에서 응답의 헤더에 적용 범위 헤더를 받지 못한 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 적용 범위 헤더를 인식 하는 서버에서 적용 범위 헤더의 예는 다음과 같이 합니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고의 속성을 통해 사용할 수 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위에 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Uniform Resource Identifier (URI) of the Internet resource that actually responds to the request.</summary>
        <value>요청에 실제로 응답하는 인터넷 리소스를 식별하는 <see cref="T:System.Uri" />입니다. 기본값은 요청을 초기화하기 위해 <see cref="M:System.Net.WebRequest.Create(System.String)" /> 메서드가 사용한 URI입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Address%2A> 속성을 요청 하는 동안 발생 하는 모든 리디렉션이 완료 된 후 URI로 설정 합니다.  
  
 원래 요청의 URI에 유지 되는 <xref:System.Net.HttpWebRequest.RequestUri%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 확인 하는 <xref:System.Net.HttpWebRequest> 개체 `req` 의 값을 설정 하 고 요청을 수행 하려면 다른 위치에 리디렉션된는 `hasChanged` 변수를 `true` 요청이 리디렉션된; 경우 그렇지 않으면 `hasChanged`로 설정 된 `false`합니다.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the request should follow redirection responses.</summary>
        <value>요청이 인터넷 리소스의 리디렉션 응답을 자동으로 따르면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> 를 `true` 리소스의 새 위치에 HTTP 리디렉션 헤더를 자동으로 수행 하려면 요청 하려는 경우. 최대 리디렉션 수 설정한는 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> 속성입니다.  
  
 경우 <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> 로 설정 된 `false`, 399 300의 HTTP 상태 코드와 함께 모든 응답은 응용 프로그램에 반환 됩니다.  
  
 권한 부여 헤더 자동 리디렉션에서 선택 취소 하 고 <xref:System.Net.HttpWebRequest> 자동으로 다시 리디렉션된 위치에 인증 하려고 합니다. 실제로, 즉, 리디렉션이 발생할 수 있는 경우 응용 프로그램가 인증 헤더에 사용자 지정 인증 정보를 넣을 수 없습니다. 대신, 응용 프로그램을 구현 하 고 사용자 지정 인증 모듈을 등록 해야 합니다. <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> 관련된 클래스는 사용자 지정 인증 모듈을 구현 하는 데 사용 됩니다. <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> 메서드는 사용자 지정 인증 모듈을 등록 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> 속성 요청이 리디렉션 응답을 따를 수 있도록 합니다.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the received from the Internet resource.</summary>
        <value>인터넷 리소스에서 받은 데이터를 버퍼링하려면 <see langword="true" />이고, 버퍼링하지 않으려면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the data sent to the Internet resource.</summary>
        <value>인터넷 리소스에 보낸 데이터를 버퍼링할 수 있게 하려면 <see langword="true" />이고, 버퍼링할 수 없게 하려면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> 은 `true`, 데이터는 메모리에 버퍼링 되어 있으면 요청 리디렉션 또는 인증 시 다시 전송 준비가 된 것입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> 속성을 데이터 버퍼링이 사용 하지 않도록 설정 합니다.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>설정 <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 를 <see langword="true" /> 데이터 버퍼의 사용 가능한 메모리를 사용할 수 있으므로 큰 데이터 집합을 업로드 하는 경우 성능 문제가 발생할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of decompression that is used.</summary>
        <value>A <see cref="T:System.Net.DecompressionMethods" /> 사용 되는 압축을 푸는 형식을 나타내는 개체입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">The object's current state does not allow this property to be set.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 에 대 한 데이터를 보내는 데 사용 되는 스트림에 대 한 비동기 요청을 시작 하는 메서드는 <xref:System.Net.HttpWebRequest>합니다. 비동기 콜백 메서드에서 사용 하 여 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 실제 스트림을 반환 하는 메서드.  
  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 메서드에이 메서드가이 비동기 상태가 되기 전에 (DNS 확인, 프록시 검색 및 예를 들어 TCP 소켓 연결)를 완료 하려면 몇 가지 동기 방식으로 설정 작업을 필요 합니다. 결과적으로,이 메서드가 호출 되 면 안 사용자 인터페이스 (UI) 스레드에서 오류가 발생에 대 한 예외가 하기 전에 동기 초기 설치 작업을 완료할 수 (최대 네트워크 설정에 따라 몇 분) 시간이 오래 걸릴 수 있습니다 때문에 또는 메서드가 성공합니다.  
  
 스레드 풀에 대 한 자세한 참조 [관리 되는 스레드 풀](~/docs/standard/threading/the-managed-thread-pool.md)합니다.  
  
> [!NOTE]
>  응용 프로그램 특정 요청에 대 한 동기 및 비동기 메서드를 혼합할 수 없습니다. 호출 하는 경우는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 사용 해야 합니다는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드 응답을 검색 합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 참조 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 를 stream 인스턴스로 대 한 비동기 요청을 만드는 메서드와 알림이 있습니다.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The stream is being used by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request to an Internet resource.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request for a response.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드 인터넷 리소스의 응답에 대 한 비동기 요청을 시작 합니다. 비동기 콜백 메서드에서 사용 하 여 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> 실제 반환 하는 메서드 <xref:System.Net.WebResponse>합니다.  
  
 A <xref:System.Net.ProtocolViolationException> 속성에 설정 하는 경우 여러 경우에 throw 되는 <xref:System.Net.HttpWebRequest> 충돌 하는 클래스입니다. 응용 프로그램에서 설정 하는 경우이 예외가 발생는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성 및 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성을 `true`, HTTP GET 요청을 전송 합니다. 응용 프로그램을 보내려고만 HTTP 1.0 프로토콜을 지 원하는 서버에 청크 분할이 지원 되지 않습니다는이 예외가 발생 합니다. 응용 프로그램 설정 하지 않고 데이터를 보내려고 시도 하는 경우이 예외가 발생는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성 또는 <xref:System.Net.HttpWebRequest.SendChunked%2A> 은 `false` 버퍼링 사용 불가능 한 keepalive 연결 (의 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성은 `true`)`.`  
  
 경우는 <xref:System.Net.WebException> 가 사용 하 여 throw는 <xref:System.Net.WebException.Response%2A> 및 <xref:System.Net.WebException.Status%2A> 속성의 서버에서 응답을 결정 하는 예외입니다.  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드에이 메서드가이 비동기 상태가 되기 전에 (DNS 확인, 프록시 검색 및 예를 들어 TCP 소켓 연결)를 완료 하려면 몇 가지 동기 방식으로 설정 작업을 필요 합니다. 결과적으로,이 메서드가 호출 되 면 안 사용자 인터페이스 (UI) 스레드에서 오류가 발생에 대 한 예외가 하기 전에 동기 초기 설치 작업을 완료할 수 (최대 네트워크 설정에 따라 몇 분) 시간이 오래 걸릴 수 있습니다 때문에 또는 메서드가 성공합니다.  
  
 스레드 풀에 대 한 자세한 참조 [ &#91; \<topic://cpconthreadpooling >&#93;](http://msdn.microsoft.com/library/2be05b06-a42e-4c9d-a739-96c21d673927)합니다.  
  
> [!NOTE]
>  응용 프로그램 특정 요청에 대 한 동기 및 비동기 메서드를 혼합할 수 없습니다. 호출 하는 경우는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 사용 해야 합니다는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드 응답을 검색 합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 참조 [ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 인터넷 리소스에 대 한 비동기 요청을 만드는 메서드와 알림이 있습니다.  
  
> [!NOTE]
>  비동기 요청의 경우 것은 제한 시간 메커니즘을 구현 하는 클라이언트 응용 프로그램의 책임입니다. 다음 코드 예제에서는 작업을 수행 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" /> and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the collection of security certificates that are associated with this request.</summary>
        <value>이 요청과 연결된 보안 인증서를 포함하는 <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 컬렉션에 인증서를 추가할 수 있지만에 액세스 권한이 없을 수 있습니다. 컬렉션에 포함 된 인증서를 사용 하려면 응용 프로그램에 인증서를 발급 한 엔터티로 동일한 액세스 권한이 있어야 합니다.  
  
> [!NOTE]
>  프레임 워크 만들어질 때 SSL 세션을 캐시 하 고 가능한 경우 새 요청에 대 한 캐시 된 세션을 사용 하려고 합니다. 프레임 워크의 첫 번째 요소를 사용 하 여 SSL 세션을 다시 사용을 시도할 때 <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (있는지 하나), 하는 경우 익명 세션을 다시 사용 하려고 <xref:System.Net.HttpWebRequest.ClientCertificates%2A> 비어 있습니다.  
  
> [!NOTE]
>  클라이언트 인증서를 추가 하면 안 성능상의 이유로 <xref:System.Net.HttpWebRequest> 확신할 수 서버 요구 합니다.  
>   
>  클라이언트 인증서 저장소에 인증서를 열거 하는 방법을 보여 주는 코드 예제를 참조 하십시오.는 <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value specified for a set operation is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Connection" /> HTTP header.</summary>
        <value>HTTP <see langword="Connection" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요청을 보냅니다는 <xref:System.Net.HttpWebRequest.Connection%2A> 속성으로 인터넷 리소스에는 `Connection` HTTP 헤더입니다. 하는 경우의 값은 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성은 `true`, "연결 유지" 값의 끝에 추가 됩니다는 `Connection` 헤더입니다.  
  
 지우려면는 `Connection` HTTP 헤더를 설정할는 <xref:System.Net.HttpWebRequest.Connection%2A> 속성을 `null`합니다.  
  
 변경 된 <xref:System.Net.HttpWebRequest.Connection%2A> 호출 하 여 요청이 시작 된 후 속성은 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, 또는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드가 throw는 <xref:System.InvalidOperationException>합니다.  
  
> [!NOTE]
>  이 속성에 대 한 값에 저장 됩니다 <xref:System.Net.WebHeaderCollection>합니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Connection%2A> 속성 연결 HTTP 헤더의 값을 설정 합니다.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value of <see cref="P:System.Net.HttpWebRequest.Connection" /> is set to Keep-alive or Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the connection group for the request.</summary>
        <value>이 요청에 대한 연결 그룹의 이름입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> 속성을 사용 하면 요청 연결 그룹에 연결할 수 있습니다. 응용 프로그램에서는 요청을 한 서버와 데이터베이스 서버에서 고객 정보를 검색 하는 웹 사이트 같은 다른 사용자에 대 한 경우에 유용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 연결 그룹을 가정 하 고 구성 하기 위해 사용자 정보를 사용 하는 방법을 보여 변수 `username`, `password`, 및 `domain` 이 코드를 호출 하기 전에 응용 프로그램에 의해 설정 됩니다.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>연결 그룹에 각 서버에 대 한 추가 연결을 만듭니다. 으로 설정 된 연결 수를 초과이 될 수 있습니다는 <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> 해당 서버에 대 한 속성.</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see langword="Content-length" /> HTTP header.</summary>
        <value>인터넷 리소스에 보낼 데이터의 바이트 수입니다. 기본값은 -1로, 해당 속성이 설정되지 않았으며 보낼 요청 데이터가 없음을 나타냅니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성으로 보낼 값이 포함 된 `Content-length` 요청과 함께 HTTP 헤더입니다.  
  
 에-1이 아닌 모든 값의 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성 요청 데이터를 업로드 하 고 데이터를 업로드 하는 방법에만 설정할 수 있도록 나타냅니다는 <xref:System.Net.HttpWebRequest.Method%2A> 속성입니다.  
  
 후의 <xref:System.Net.HttpWebRequest.ContentLength%2A> 값 속성은 바이트를 써야 합니다를 호출 하 여 반환 되는 요청 스트림에 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드 또는 둘 다는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 및 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 메서드.  
  
> [!NOTE]
>  이 속성에 대 한 값에 저장 됩니다 <xref:System.Net.WebHeaderCollection>합니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 게시 되는 문자열의 길이 속성입니다.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The new <see cref="P:System.Net.HttpWebRequest.ContentLength" /> value is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Content-type" /> HTTP header.</summary>
        <value>HTTP <see langword="Content-type" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentType%2A> 속성 요청의 미디어 형식을 포함 합니다. 에 할당 된 값은 <xref:System.Net.HttpWebRequest.ContentType%2A> 속성 요청을 보낼 때 기존의 모든 콘텐츠를 대체는 `Content-type` HTTP 헤더입니다.  
  
 지우려면는 `Content-type` HTTP 헤더를 설정할는 <xref:System.Net.HttpWebRequest.ContentType%2A> 속성을 `null`합니다.  
  
> [!NOTE]
>  이 속성에 대 한 값에 저장 됩니다 <xref:System.Net.WebHeaderCollection> 합니다. 경우 <xref:System.Net.WebHeaderCollection> 설정 속성 값이 손실 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.ContentType%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the delegate method called when an HTTP 100-continue response is received from the Internet resource.</summary>
        <value>인터넷 리소스에서 HTTP 계속 응답이 반환될 때 실행하는 콜백 메서드를 구현하는 대리자입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> 클라이언트가 받을 때 호출할 콜백 메서드를 지정 하는 속성-응답을 계속 합니다.  
  
 때는 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> 속성이 설정 되어 있으면 클라이언트가 호출할 대리자 형식의 응답 때마다 프로토콜 <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) 수신 됩니다. 클라이언트는 인터넷 리소스에서 수신 중인 데이터의 상태를 표시 하려는 경우에 유용 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a timeout, in milliseconds, to wait until the 100-Continue is received from the server.</summary>
        <value>100-Continue가 수신될 때까지 기다릴 제한 시간(밀리초)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 100-계속 응답 엔터티 본문을 보낼 수 있습니다, 제한 시간이 만료 되기 전에 수신 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the cookies associated with the request.</summary>
        <value>이 요청과 관련된 쿠키가 들어 있는 A <see cref="T:System.Net.CookieContainer" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 의 인스턴스를 제공 하는 속성은 <xref:System.Net.CookieContainer> 이 요청과 관련 된 쿠키를 포함 하는 클래스입니다.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> `null` 기본적으로 합니다. 할당 해야는 <xref:System.Net.CookieContainer> 에 쿠키가 반환 되는 속성에는 개체는 <xref:System.Net.HttpWebResponse.Cookies%2A> 속성은 <xref:System.Net.HttpWebResponse> 에서 반환 되는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드.  
  
> [!NOTE]
>  쿠키는 보안상의 이유로 기본적으로 비활성화 됩니다. 사용 하 여 쿠키를 사용 하려는 경우는 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 속성을 사용 하는 쿠키입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 URL로 요청을 보내고 응답에서 반환 된 쿠키가 표시 됩니다.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets authentication information for the request.</summary>
        <value>요청과 관련된 인증 자격 증명이 들어 있는 <see cref="T:System.Net.ICredentials" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Credentials%2A> 속성 작성자에 요청을 식별 하는 인증 정보를 포함 합니다. <xref:System.Net.HttpWebRequest.Credentials%2A> 속성 일 수 있습니다는 <xref:System.Net.NetworkCredential>,이 경우 사용자, 암호에 포함 된 도메인 정보는 <xref:System.Net.NetworkCredential> 개체를 사용 하 여 요청을 인증 하는 것이 또는 <xref:System.Net.CredentialCache>있으며이 경우 Uniform Resource 요청의 식별자 (URI)는 요청을 인증 하는 데 사용자, 암호 및 도메인 정보를 확인 하는 데 사용 됩니다.  
  
 대부분의 클라이언트 시나리오에서 사용 해야는 <xref:System.Net.CredentialCache.DefaultCredentials%2A> 현재 로그온된 한 사용자의 자격 증명을 포함 하는 속성입니다. 이 위해 설정 된 <xref:System.Net.WebClient.UseDefaultCredentials%2A> 속성을 `true` 이 속성을 설정 하는 대신 합니다.  
  
 경우는 <xref:System.Net.HttpWebRequest> 클래스는 ASP.NET 응용 프로그램에서 자격 증명 같은 중간 계층 응용 프로그램에서 사용 되는 <xref:System.Net.CredentialCache.DefaultCredentials%2A> 속성이 ASP 페이지 (서버 쪽 자격 증명)를 실행 하는 계정에 속해야 합니다. 일반적으로이 속성을 설정한 자격 증명의 클라이언트 요청이 수행 됩니다.  
  
> [!NOTE]
>  다른 사용자로 가장할 NTLM 인증 체계를 사용할 수 없습니다. Kerberos는 가장을 지원 하기 위해 특별 하 게 구성 되어야 합니다.  
  
 하나 이상의 인증 방법에 HttpWebRequest를 제한 하려면 사용 된 <xref:System.Net.CredentialCache> 클래스 및 자격 증명 하나 이상의 인증 스키마에 바인딩  
  
 지원 되는 인증 체계는 다이제스트, Negotiate, Kerberos, NTLM, 및 Basic 포함 됩니다.  
  
 보안상의 이유로 리디렉션을 자동으로 수행할 때에서 리디렉션에 포함 하려는 자격 증명을 저장 한 <xref:System.Net.CredentialCache> 이 속성에 할당 합니다. 이 속성 자동으로 설정 됩니다 `null` 리디렉션 제외 하 고 포함 된 경우에 <xref:System.Net.CredentialCache>합니다. 이 속성 값을 갖는 자동 설정 `null` 이러한 조건에서 자격 증명을 의도 하지 않은 임의의 대상에 보낼 수 없습니다.
  
## Examples  
 다음 코드 예제에서는 요청에 대 한 자격 증명을 설정 합니다.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the <see langword="Date" /> HTTP header value to use in an HTTP request.</summary>
        <value>HTTP 요청의 Date 헤더 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Date 헤더 이면 `null`, 반환 값을으로 설정 됩니다 <xref:System.DateTime.MinValue?displayProperty=nameWithType>합니다.  
  
 <xref:System.Net.HttpWebRequest.Date%2A> 속성은 표준 <xref:System.DateTime?displayProperty=nameWithType> 개체를 포함할 수는 <xref:System.DateTimeKind?displayProperty=nameWithType> 필드 <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, 또는 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>합니다. 사용 하는 경우 여러 종류의 시간을 설정할 수 있습니다는 <xref:System.Net.HttpWebRequest.Date%2A> 속성입니다. 경우 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> 를 설정 하거나 검색 된 <xref:System.Net.HttpWebRequest.Date%2A> 속성으로 간주 됩니다 <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (현지 시간).  
  
 클래스는 <xref:System.Net> 네임 스페이스 항상 //microsoft.samples.biztalk.wcf.basichttpsendadapter.basichttpwcfserviceconsuming는 <xref:System.Net.HttpWebRequest.Date%2A> GMT (Utc) 형식을 사용 하 여 표준 형태로 전송 하는 동안 통신 중에 속성입니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.Date%2A> 속성이 <xref:System.DateTime.MinValue?displayProperty=nameWithType>, 하면 `Date` HTTP 헤더에서 제거 되는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성 및 <xref:System.Net.WebHeaderCollection>합니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.Date%2A> 속성은 <xref:System.DateTime.MinValue?displayProperty=nameWithType>, 나타냅니다는 `Date` HTTP 헤더에 포함 되지 않습니다는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성 및 <xref:System.Net.WebHeaderCollection>합니다.  
  
> [!NOTE]
>  이 속성에 대 한 값에 저장 됩니다 <xref:System.Net.WebHeaderCollection>합니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.Date%2A> 설정 되어 전송 하려고 시도 하 고는 <xref:System.Net.HttpWebRequest> 본문이 없는 경우 <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> 의해 throw 됩니다는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, 및 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default cache policy for this request.</summary>
        <value>다른 정책을 적용할 수 없을 때 이 요청에 대해 적용할 캐시 정책을 지정하는 <see cref="T:System.Net.Cache.HttpRequestCachePolicy" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTTP 및 HTTPS 스키마에 대 한 지정 된 정책을 등록이 속성을 설정 합니다. 이 정책은 경우이 요청에 사용 됩니다.  
  
 없는 <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> 이 요청에 대해 지정 된 속성입니다.  
  
 \- 또는 -  
  
 시스템 및 응용 프로그램 구성 파일을이 요청을 만드는 데 사용 하는 식별자 URI (Uniform Resource) 적용할 수 있는 캐시 정책을 지정 하지 마십시오.  
  
 캐시 정책을 리소스 호스트 컴퓨터에 요청을 보내는 대신 캐시에서 요청 된 리소스를 가져올 수 있는지 여부를 결정 합니다.  
  
 리소스에 대 한 응답 스트림을 검색 하는 스트림의 끝에 대 한 읽기 경우에 리소스의 복사본을 캐시에 추가 됩니다. 이므로 동일한 리소스에 대 한 다른 요청에는이 요청에 대 한 캐시 정책 수준에 따라 캐시 된 복사본을 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">네트워크 리소스에 대 한 무제한 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default maximum length of an HTTP error response.</summary>
        <value>HTTP 오류 응답의 기본 최대 길이입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default for the <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> property.</summary>
        <value>받은 응답 헤더의 기본 최대 길이이며 킬로바이트(1024바이트) 단위입니다. 기본 구성 파일에서는 이 값을 64KB로 설정합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응답 상태 표시줄 및 모든 추가 제어 문자가 HTTP 프로토콜의 일부로 받은 응답 헤더의 길이 받았습니다. 값이-1 이면; 받은 응답 헤더에 제한 되지 않습니다 0은 모든 요청에 실패 하는 값입니다.  
  
 구성 파일에서이 값을 변경할 수도 있습니다. 이 속성의 영향을 설정 하 여 재정의할 수 있습니다는 <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> 의 인스턴스에 대 한 속성은 <xref:System.Net.HttpWebRequest> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is not equal to -1 and is less than zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 의해 시작 된 스트림에 대 한 비동기 요청을 완료 하는 메서드는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 메서드. 이후에 <xref:System.IO.Stream> 반환 되었습니다. 개체를 사용 하 여 데이터를 보낼 수 있습니다는 <xref:System.Net.HttpWebRequest> 를 사용 하 여는 <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> 메서드.  
  
> [!NOTE]
>  값을 설정 해야 합니다는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 스트림에 데이터를 쓰기 전에 속성입니다.  
  
> [!CAUTION]
>  호출 해야 합니다는 <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> 메서드 스트림을 닫고 다시 사용에 대 한 연결을 해제 합니다. 스트림이 닫기에 실패 하면 연결 되지 않을 수 있는 응용 프로그램.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 참조 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 메서드를 stream 인스턴스로 대 한 비동기 요청을 끝냅니다.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <param name="context">To be added.</param>
        <param name="transportContext">To be added.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 의해 시작 된 스트림에 대 한 비동기 요청을 완료 하는 메서드는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 메서드 및 출력의 <xref:System.Net.TransportContext> 스트림과 연결 된입니다. 이후에 <xref:System.IO.Stream> 반환 되었습니다. 개체를 사용 하 여 데이터를 보낼 수 있습니다는 <xref:System.Net.HttpWebRequest> 를 사용 하 여는 <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> 메서드.  
  
 확장된 보호와 함께 Windows 통합된 인증을 사용 하는 일부 응용 프로그램에서 사용 하는 전송 계층을 쿼리할 수 해야 <xref:System.Net.HttpWebRequest> 기본 TLS 채널의 (CBT)의 채널 바인딩 토큰을 검색 하기 위해. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드 요청 본문을 포함 하는 HTTP 메서드에 대 한이 정보에 대 한 액세스 제공 (`POST` 및 `PUT` 요청)입니다. 응용 프로그램 자체 인증을 구현 하는 CBT에 액세스 해야 하는 경우에이 과정이 필요만.  
  
> [!NOTE]
>  응용 프로그램의 값을 설정 해야 하는 경우는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성을 다음이 스트림을 검색 하 고 데이터를 쓰려면 하기 전에 수행 해야 합니다.  
  
> [!CAUTION]
>  호출 해야 합니다는 <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> 메서드 스트림을 닫고 다시 사용에 대 한 연결을 해제 합니다. 스트림이 닫기에 실패 하면 연결 되지 않을 수 있는 응용 프로그램.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 참조 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a response.</param>
        <summary>Ends an asynchronous request to an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> 메서드를 호출 하 여 시작 된 인터넷 리소스에 대 한 비동기 요청을 완료 된 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드.  
  
> [!CAUTION]
>  호출 해야 합니다는 <xref:System.Net.HttpWebResponse.Close%2A> 메서드를 스트림을 닫고 연결을 해제 합니다. 이렇게 하지 않으면 연결 되지 않을 수 있는 응용 프로그램을 발생할 수 있습니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 참조 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> 메서드 인터넷 리소스에 대 한 비동기 요청을 끝냅니다.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult." />  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> property is greater than 0 but the data has not been written to the request stream.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Expect" /> HTTP header.</summary>
        <value>콘텐츠는 <see langword="Expect" /> HTTP 헤더입니다. 기본값은 <see langword="null" />입니다.  
  
 <block subset="none" type="note"><para> 이 속성에 대 한 값에 저장 됩니다 <see cref="T:System.Net.WebHeaderCollection" />합니다. WebHeaderCollection이 설정 되 면 속성 값이 손실 됩니다.  </para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> is set to a string that contains "100-continue" as a substring.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data required to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 포함 된 모든 개체는 <xref:System.Runtime.Serialization.SerializationInfo> 자동으로 추적 되 고 포맷터에 의해 serialize 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드에 대 한 데이터를 보내는 데 사용할 스트림을 반환는 <xref:System.Net.HttpWebRequest>합니다. 이후에 <xref:System.IO.Stream> 반환 되었습니다. 개체를 사용 하 여 데이터를 보낼 수 있습니다는 <xref:System.Net.HttpWebRequest> 를 사용 하 여는 <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> 메서드.  
  
 응용 프로그램의 값을 설정 해야 하는 경우는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성을 다음이 스트림을 검색 하기 전에 수행 해야 합니다.  
  
 호출 해야 합니다는 <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> 메서드 스트림을 닫고 다시 사용에 대 한 연결을 해제 합니다. 스트림이 닫기에 실패 하면 연결 되지 않을 수 있는 응용 프로그램.  
  
> [!NOTE]
>  응용 프로그램 특정 요청에 대 한 동기 및 비동기 메서드를 혼합할 수 없습니다. 호출 하는 경우는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 사용 해야 합니다는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드 응답을 검색 합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 참조 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드 스트림 인스턴스를 반환 합니다.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">The <see cref="T:System.Net.TransportContext" /> for the <see cref="T:System.IO.Stream" />.</param>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드에 대 한 데이터를 보내는 데 사용할 스트림을 반환는 <xref:System.Net.HttpWebRequest> 하 고 출력은 <xref:System.Net.TransportContext> 스트림과 연결 된입니다. 이후에 <xref:System.IO.Stream> 반환 되었습니다. 개체를 사용 하 여 데이터를 보낼 수 있습니다는 <xref:System.Net.HttpWebRequest> 를 사용 하 여는 <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> 메서드.  
  
 확장된 보호와 함께 Windows 통합된 인증을 사용 하는 일부 응용 프로그램에서 사용 하는 전송 계층을 쿼리할 수 해야 <xref:System.Net.HttpWebRequest> 기본 TLS 채널의 (CBT)의 채널 바인딩 토큰을 검색 하기 위해. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드 요청 본문을 포함 하는 HTTP 메서드에 대 한이 정보에 대 한 액세스 제공 (`POST` 및 `PUT` 요청)입니다. 응용 프로그램 자체 인증을 구현 하는 CBT에 액세스 해야 하는 경우에이 과정이 필요만.  
  
 응용 프로그램의 값을 설정 해야 하는 경우는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성을 다음이 스트림을 검색 하기 전에 수행 해야 합니다.  
  
 호출 해야 합니다는 <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> 메서드 스트림을 닫고 다시 사용에 대 한 연결을 해제 합니다. 스트림이 닫기에 실패 하면 연결 되지 않을 수 있는 응용 프로그램.  
  
> [!NOTE]
>  응용 프로그램 특정 요청에 대 한 동기 및 비동기 메서드를 혼합할 수 없습니다. 호출 하는 경우는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 사용 해야 합니다는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드 응답을 검색 합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 참조 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method was unable to obtain the <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a response from an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드가 반환 되는 <xref:System.Net.WebResponse> 인터넷 리소스 로부터의 응답이 들어 있는 개체입니다. 반환 되는 실제 인스턴스는 <xref:System.Net.HttpWebResponse>, 및 속성에 액세스 HTTP 관련 해당 클래스에 형식 캐스팅 될 수 있습니다.  
  
 A <xref:System.Net.ProtocolViolationException> 속성에 설정 하는 경우 여러 경우에 throw 되는 <xref:System.Net.HttpWebRequest> 충돌 하는 클래스입니다. 응용 프로그램에서 설정 하는 경우이 예외가 발생는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성 및 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성을 `true`, HTTP GET 요청을 전송 합니다. 응용 프로그램을 보내려고만 HTTP 1.0 프로토콜을 지 원하는 서버에 청크 분할이 지원 되지 않습니다는이 예외가 발생 합니다. 응용 프로그램 설정 하지 않고 데이터를 보내려고 시도 하는 경우이 예외가 발생는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성 또는 <xref:System.Net.HttpWebRequest.SendChunked%2A> 은 `false` 버퍼링 사용 불가능 한 keepalive 연결 (의 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성은 `true`)`.`  
  
> [!CAUTION]
>  호출 해야 합니다는 <xref:System.Net.HttpWebResponse.Close%2A> 메서드를 스트림을 닫고 연결을 해제 합니다. 이렇게 하지 않으면 연결 되지 않을 수 있는 응용 프로그램을 발생할 수 있습니다.  
  
 POST 메서드를 사용 하면 요청 스트림을 가져올, 게시 될 데이터를 작성 하며 스트림을 닫습니다. 이 메서드는 대기 중인; 게시 하는 콘텐츠에 대 한 차단 제한 시간 집합이 있는 경우 콘텐츠, 호출 스레드가 차단 무기한으로 제공 하지 않으면 합니다.  
  
> [!NOTE]
>  여러 번 호출 <xref:System.Net.HttpWebRequest.GetResponse%2A> ; 동일한 응답 개체를 반환 합니다. 요청을 다시 발행 되지 않습니다.  
  
> [!NOTE]
>  응용 프로그램 특정 요청에 대 한 동기 및 비동기 메서드를 혼합할 수 없습니다. 호출 하는 경우는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 사용 해야 합니다는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드 응답을 검색 합니다.  
  
> [!NOTE]
>  경우는 <xref:System.Net.WebException> 가 사용 하 여 throw는 <xref:System.Net.WebException.Response%2A> 및 <xref:System.Net.WebException.Status%2A> 속성의 서버에서 응답을 결정 하는 예외입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 참조 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  쿠키는 보안상의 이유로 기본적으로 비활성화 됩니다. 사용 하 여 쿠키를 사용 하려는 경우는 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 속성을 사용 하는 쿠키입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 요청에 대 한 응답을 가져옵니다.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater or equal to zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, this request includes data to be sent to the server. Requests that send data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether a response has been received from an Internet resource.</summary>
        <value>응답을 받았으면 <see langword="true" />이고, 받지 않았으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.HaveResponse%2A> 속성을 인터넷 리소스 로부터 응답을 받지 못했습니다.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a collection of the name/value pairs that make up the HTTP headers.</summary>
        <value>HTTP 요청의 헤더를 구성하는 이름/값 쌍이 들어 있는 <see cref="T:System.Net.WebHeaderCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Headers%2A> 컬렉션 요청과 관련 된 프로토콜 헤더가 들어 있습니다. 다음 표에 나와 있는에 저장 되지 않은 HTTP 헤더는 <xref:System.Net.HttpWebRequest.Headers%2A> 컬렉션 하지만 시스템에서 설정 하거나 설정 속성 또는 메서드.  
  
|헤더|으로 설정|  
|------------|------------|  
|허용|설정한는 <xref:System.Net.HttpWebRequest.Accept%2A> 속성입니다.|  
|연결|으로 설정 된 <xref:System.Net.HttpWebRequest.Connection%2A> 속성 및 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성입니다.|  
|Content-Length|설정한는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성입니다.|  
|콘텐츠-유형|설정한는 <xref:System.Net.HttpWebRequest.ContentType%2A> 속성입니다.|  
|예상|설정한는 <xref:System.Net.HttpWebRequest.Expect%2A> 속성입니다.|  
|날짜|설정한는 <xref:System.Net.HttpWebRequest.Date%2A> 속성입니다.|  
|호스트|설정한는 <xref:System.Net.HttpWebRequest.Host%2A> 속성입니다.|  
|If-수정-이후|설정한는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성입니다.|  
|범위|으로 설정 된 <xref:System.Net.HttpWebRequest.AddRange%2A> 메서드.|  
|참조 페이지|설정한는 <xref:System.Net.HttpWebRequest.Referer%2A> 속성입니다.|  
|전송 인코딩|설정한는 <xref:System.Net.HttpWebRequest.TransferEncoding%2A> 속성 (의 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성이 true 여야 합니다).|  
|사용자 에이전트|설정한는 <xref:System.Net.HttpWebRequest.UserAgent%2A> 속성입니다.|  
  
 <xref:System.Net.WebHeaderCollection.Add%2A> 메서드가 throw는 <xref:System.ArgumentException> 이러한 보호 된 헤더 중 하나를 설정 하려고 합니다.  
  
 변경 된 <xref:System.Net.HttpWebRequest.Headers%2A> 호출 하 여 요청이 시작 된 후 속성 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, 또는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드가 throw는 <xref:System.InvalidOperationException>합니다.  
  
 웹 서버와 캐시 변경 될 수 있습니다 또는 웹 요청에 헤더를 추가 하기 때문에 헤더 값 변경 되지 가정 하지 않아야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성을 콘솔에 HTTP 헤더 이름/값 쌍을 인쇄 합니다.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the Host header value to use in an HTTP request independent from the request URI.</summary>
        <value>HTTP 요청의 호스트 헤더 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Host%2A> 호스트 헤더 값은 요청 URI와에서 독립적인 HTTP 요청에 사용 하도록 설정 하려면 속성을 사용할 수 있습니다. <xref:System.Net.HttpWebRequest.Host%2A> 속성은 호스트 이름 및 선택적 포트 번호를 구성할 수 있습니다. 포트 정보 없이 호스트 헤더는 요청 된 서비스 (포트 80에 대 한 HTTP URL 예:)에 대 한 기본 포트를 의미합니다.  
  
 호스트 및 포트를 지정 하는 형식은 14.23 IETF 게시 된 RFC2616의 규칙을 따라야 합니다. 이러한 요구 사항을 준수 포트 8080 지정 하는 예를 들어 수에 대해 다음 값은 <xref:System.Net.HttpWebRequest.Host%2A> 속성:  
  
 `www.contoso.com:8080`  
  
 사용 하 여 <xref:System.Net.HttpWebRequest.Host%2A> 속성을 통해 사용자 지정 호스트 헤더 값을 명시적으로 지정도 영향을 줍니다 캐싱 영역, 쿠키 및 인증 합니다. 특정 URI 접두사에 대 한 자격 증명을 제공 하는 응용 프로그램, 응용 프로그램에서 URI에 있는 대상 서버가 아닌 호스트 헤더의 값이 포함 된 URI를 사용 하 고 있는지 확인 해야 합니다. 리소스를 캐싱할 때 사용 되는 키 요청 URI가 아닌 호스트 헤더 값을 사용 합니다. 쿠키에 저장 되는 <xref:System.Net.CookieContainer> 서버 도메인 이름으로 논리적으로 그룹화 합니다. 응용 프로그램의 호스트 헤더를 지정 하는 경우이 값이 도메인으로 사용 됩니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.Host%2A> 속성을 설정 하지 않으면 다음 HTTP 요청에 사용할 호스트 헤더 값은 요청 URI에 기반 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The Host header cannot be set to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The Host header cannot be set to an invalid value.</exception>
        <exception cref="T:System.InvalidOperationException">The Host header cannot be set after the <see cref="T:System.Net.HttpWebRequest" /> has already started to be sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="If-Modified-Since" /> HTTP header.</summary>
        <value>A <see cref="T:System.DateTime" /> 의 콘텐츠를 포함 하는 <see langword="If-Modified-Since" /> HTTP 헤더입니다. 기본값이 현재 날짜와 시간입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성은 표준 <xref:System.DateTime?displayProperty=nameWithType> 개체를 포함할 수는 <xref:System.DateTimeKind?displayProperty=nameWithType> 필드 <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, 또는 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>합니다. 사용 하는 경우 여러 종류의 시간을 설정할 수 있습니다는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성입니다. 경우 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> 를 설정 하거나 검색 된 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성으로 간주 됩니다 <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (현지 시간).  
  
 클래스는 <xref:System.Net> 네임 스페이스 항상 //microsoft.samples.biztalk.wcf.basichttpsendadapter.basichttpwcfserviceconsuming는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> GMT (Utc) 형식을 사용 하 여 표준 형태로 전송 하는 동안 통신 중에 속성입니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성이 <xref:System.DateTime.MinValue?displayProperty=nameWithType>, 하면 `If-Modified-Since` HTTP 헤더에서 제거 되는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성 및 <xref:System.Net.WebHeaderCollection>합니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성은 <xref:System.DateTime.MinValue?displayProperty=nameWithType>, 나타냅니다는 `If-Modified-Since` HTTP 헤더에 포함 되지 않습니다는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성 및 <xref:System.Net.WebHeaderCollection>합니다.  
  
> [!NOTE]
>  이 속성에 대 한 값에 저장 됩니다 <xref:System.Net.WebHeaderCollection>합니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to make a persistent connection to the Internet resource.</summary>
        <value>
          <see langword="true" /> 인터넷 리소스에 대 한 요청에 포함 되어야 하는 경우는 <see langword="Connection" /> HTTP 헤더 값 고, 그렇지 않으면 연결 유지 <see langword="false" />합니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정 `true` 보내려고는 `Connection` HTTP 헤더의 값을 유지 합니다. 응용 프로그램에서 사용 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 영구 연결에 대 한 기본 설정을 나타냅니다. 경우는 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성은 `true`, 응용 프로그램을 지 원하는 서버에 대 한 영구 연결을 만듭니다.  
  
> [!NOTE]
>  HTTP/1.1을 사용할 경우 연결 유지는 기본적으로 설정 합니다. 설정 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 를 `false` 전송 될 수 있습니다는 `Connection: Close` 서버에 헤더입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성을 `false` 인터넷 리소스와의 영구 연결을 설정 하지 않으려면입니다.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of redirects that the request follows.</summary>
        <value>요청이 따르는 최대 리디렉션 응답 수입니다. 기본값은 50입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> 리디렉션 요청을 수행 하는 경우에 대 한 최대 수를 설정 하는 속성은 <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> 속성은 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성의 값을 설정 합니다.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value is set to 0 or less.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum allowed length of the response headers.</summary>
        <value>응답 헤더의 킬로바이트(1024바이트) 단위 길이입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응답 헤더의 길이가 응답 상태 표시줄 및 HTTP 프로토콜의 일부로 수신 된 모든 추가 제어 문자가 포함 되어 있습니다. 값이-1 이면 응답 헤더;에 제한 되지 않습니다 0은 모든 요청에 실패 하는 값입니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> 속성이 명시적으로 설정 되지 않은의 값에는 기본적으로 <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> 속성입니다.  
  
 받은 응답 헤더의 길이가의 값을 초과 하는 경우는 <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> 속성에는 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> 또는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드를 발생 시킵니다는 <xref:System.Net.WebException> 와 <xref:System.Net.WebException.Status%2A> 속성이로 설정 <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성의 값을 설정 합니다.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The property is set after the request has already been submitted.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the media type of the request.</summary>
        <value>요청의 미디어 형식입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값은 <xref:System.Net.HttpWebRequest.MediaType%2A> 속성에 영향을 미칩니다는 <xref:System.Net.HttpWebResponse.CharacterSet%2A> 속성입니다. 설정 하는 경우는 <xref:System.Net.HttpWebRequest.MediaType%2A> 요청에는 해당 미디어 형식은 응답에서 반환 하는 문자 집합의 목록에서 선택 됩니다 `Content-type` HTTP 헤더입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the method for the request.</summary>
        <value>인터넷 리소스에 접속하는 데 사용할 요청 메서드입니다. 기본값은 GET입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Method%2A> HTTP 1.1 프로토콜 동사 중 하나에 속성을 설정할 수 있습니다: GET, HEAD, POST, PUT, DELETE, TRACE 또는 옵션입니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성이-1 이외의 값으로 설정 되어는 <xref:System.Net.HttpWebRequest.Method%2A> 속성 데이터를 업로드 하는 프로토콜 속성으로 설정 되어 있어야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Method%2A> 속성을 게시 합니다.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No method is supplied.  -or-  The method string contains invalid characters.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to pipeline the request to the Internet resource.</summary>
        <value>요청을 파이프라인해야 하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램에서 사용 된 <xref:System.Net.HttpWebRequest.Pipelined%2A> 파이프라인된 연결에 대 한 기본 설정을 나타내는 속성을 합니다. 때 <xref:System.Net.HttpWebRequest.Pipelined%2A> 은 `true`는 응용 프로그램은 파이프라인된 연결을 지 원하는 서버에 있습니다.  
  
 파이프라인 된 연결 된 경우에만 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성도 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 값을 인쇄는 <xref:System.Net.HttpWebRequest.Pipelined%2A> 콘솔에는 속성입니다.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send an Authorization header with the request.</summary>
        <value>
          <see langword="true" /> 인증을 수행한 후 요청과 함께 HTTP 권한 부여 헤더를 보낼 것인지 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클라이언트 요청을 특정 후 <xref:System.Uri> 가 성공적으로 인증 하는 경우 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> 은 `true` 자격 증명을 제공 하 고, 권한 부여 헤더에 각 요청과 함께 전송 되 <xref:System.Uri> 와 일치 하는 특정 <xref:System.Uri>마지막 슬래시까지 합니다. 따라서 클라이언트 요청을 특정 성공적으로 인증 하는 경우 <xref:System.Uri> 다음을 포함 하 합니다.  
  
 `http://www.contoso.com/firstpath/`  
  
 사전 인증에 대 한 권한 부여 헤더에는 다음 각 요청과 함께 보내집니다 <xref:System.Uri> 인스턴스:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 그러나 권한 부여 헤더는 하지 요청과 함께 전송에 다음 <xref:System.Uri> 인스턴스:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 클라이언트 요청을 특정 하는 경우 <xref:System.Uri> 은 표준 인증 절차를 사용 하 여 요청이 인증 되지 않았습니다.  
  
 첫 번째 요청을 제외 하 고는 <xref:System.Net.WebRequest.PreAuthenticate%2A> 속성 이후 요청에 대 한 인증 정보를 보낼 것인지 나타냅니다는 <xref:System.Uri> 와 일치 하는 특정 <xref:System.Uri> 되도록 대기 하지 않고 마지막 슬래시까지 서버에서 요구할 합니다.  
  
 이 속성의 효과 설명 하는 클라이언트와 서버 간에 다음과 같은 대화 상자가 있습니다. 대화 상자에서는 해당 기본 인증을 사용 하 여 가정 합니다.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> `false`:  
  
 GET someUrl 클라이언트:  
  
 서버: 401 Www-authenticate Basic  
  
 권한 부여 헤더도 얻을 수 있는 클라이언트:  
  
 서버: 200 확인  
  
 GET someUrl 클라이언트:  
  
 서버: 401 Www-authenticate Basic  
  
 권한 부여 헤더도 얻을 수 있는 클라이언트:  
  
 서버: 200 확인  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> `true`:  
  
 GET someUrl 클라이언트:  
  
 서버: 401 Www-authenticate Basic  
  
 권한 부여 헤더도 얻을 수 있는 클라이언트:  
  
 서버: 200 확인  
  
 클라이언트: 권한 부여 헤더와 함께 someUrl 가져오기  
  
 인증 체계 사전 인증을 지원 하지 않는 경우이 속성의 값은 무시 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the version of HTTP to use for the request.</summary>
        <value>요청에 사용할 HTTP 버전입니다. 기본값은 <see cref="F:System.Net.HttpVersion.Version11" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest> 클래스 버전 1.0 및 1.1 http만 지원 합니다. 설정 <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> 를 다른 버전으로 예외를 throw 합니다.  
  
> [!NOTE]
>  현재 요청의 HTTP 버전을 설정 하려면는 <xref:System.Net.HttpVersion.Version10> 및 <xref:System.Net.HttpVersion.Version11> 의 필드는 <xref:System.Net.HttpVersion> 클래스입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The HTTP version is set to a value other than 1.0 or 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets proxy information for the request.</summary>
        <value>
          <see cref="T:System.Net.IWebProxy" /> 요청이 프록시를 사용 하는 개체입니다. 호출 하 여 기본 값이 설정 된 <see cref="P:System.Net.GlobalProxySelection.Select" /> 속성입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성을 식별 하는 <xref:System.Net.WebProxy> 인터넷 리소스에 대 한 요청을 처리 하는 데 사용할 개체입니다. 프록시가 사용 되어야 함을 지정 하려면는 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성에서 반환 되는 프록시 인스턴스에 <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> 메서드.  
  
 로컬 컴퓨터 또는 응용 프로그램 구성 파일에서 기본 프록시 사용할 지정할 수 있습니다. 경우는 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성이 지정 된 프록시 설정에서는 <xref:System.Net.HttpWebRequest.Proxy%2A> 로컬 컴퓨터 또는 응용 프로그램 구성 파일을 재정의 하는 속성 및 <xref:System.Net.HttpWebRequest> 인스턴스에서 지정 된 프록시 설정을 사용 하 여 합니다. 구성 파일에 없는 프록시를 지정 하는 경우 및 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성이 지정 되어 있지는 <xref:System.Net.HttpWebRequest> 클래스에서에서 상속 되며, Internet Explorer 로컬 컴퓨터에 프록시 설정을 사용 합니다. Internet Explorer의 프록시 설정이 없는 경우에 서버에 직접 요청이 보내집니다.  
  
 <xref:System.Net.HttpWebRequest> 클래스 구문 분석 하 여 와일드 카드 문자를 사용한 프록시 바이패스 목록이 Internet Explorer에서 동일한 상태로 상속 무시 목록 Internet Explorer에서 직접 구문 분석 됩니다. 예를 들어는 <xref:System.Net.HttpWebRequest> 클래스는 ह ु ण फ 바이패스 목록이 "nt *" Internet Explorer에서 정규식의 "nt.\*"입니다. 따라서의 URL "`http://nt.com`"를 사용 하 여 프록시를 무시는 <xref:System.Net.HttpWebRequest> 클래스 및 Internet Explorer를 사용 합니다.  
  
 <xref:System.Net.HttpWebRequest> 클래스는 로컬 프록시 바이패스를 지원 합니다. 클래스에는 다음 조건 중 하나라도 충족 되 면 로컬로 대상을 고려 합니다.  
  
-   대상 플랫 이름 (URL에서 점 없음)를 포함합니다.  
  
-   루프백 주소를 포함 하는 대상 (<xref:System.Net.IPAddress.Loopback> 또는 <xref:System.Net.IPAddress.IPv6Loopback>)는 대상에 포함 하거나는 <xref:System.Net.IPAddress> 로컬 컴퓨터에 할당 합니다.  
  
-   로컬 컴퓨터의 도메인 접미사를 일치 하는 대상의 도메인 접미사 (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 변경 된 <xref:System.Net.HttpWebRequest.Proxy%2A> 호출 하 여 요청이 시작 된 후 속성은 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, 또는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드가 throw는 <xref:System.InvalidOperationException>합니다. Proxy 요소에 대 한 내용은 [ \&lt; defaultProxy\&gt; 요소 (네트워크 설정)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Proxy%2A> 메서드는 요청에 대 한 프록시 정보를 얻을 수 있습니다.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> is set to <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have permission for the requested operation.</exception>
        <permission cref="T:System.Net.WebPermission">가져오거나 설정할는 <see cref="P:System.Net.HttpWebRequest.Proxy" /> 속성입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a time-out in milliseconds when writing to or reading from a stream.</summary>
        <value>쓰기 또는 읽기가 가능한 제한 시간(밀리초)입니다. 기본값은 300,000밀리초(5분)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 속성에서 반환 된 스트림에 쓸 때 사용 되는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드나에서 반환 된 스트림에서 읽기는 <xref:System.Net.HttpWebResponse.GetResponseStream%2A> 메서드.  
  
 특히,는 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 속성에 대 한 제한 시간을 제어는 <xref:System.IO.Stream.Read%2A> 반환한 스트림을 읽는 데 사용 되는 메서드는 <xref:System.Net.HttpWebResponse.GetResponseStream%2A> 메서드, 및에 대 한는 <xref:System.IO.Stream.Write%2A> 는 에서반환된스트림에쓰기위해사용되는메서드를<xref:System.Net.HttpWebRequest.GetRequestStream%2A>메서드.  
  
 요청이 완료 될 때까지 대기 하는 시간을 지정 하려면 사용 된 <xref:System.Net.HttpWebRequest.Timeout%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 속성을 설정하는 방법을 보여 줍니다.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has already been sent.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than or equal to zero and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Referer" /> HTTP header.</summary>
        <value>HTTP <see langword="Referer" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> 속성은 `true`, <xref:System.Net.HttpWebRequest.Referer%2A> 속성은 다른 사이트에 요청을 리디렉션할 때 자동으로 설정 됩니다.  
  
 지우려면는 `Referer` HTTP 헤더를 설정할는 <xref:System.Net.HttpWebRequest.Referer%2A> 속성을 `null`합니다.  
  
> [!NOTE]
>  이 속성에 대 한 값에 저장 됩니다 <xref:System.Net.WebHeaderCollection>합니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Referer%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the original Uniform Resource Identifier (URI) of the request.</summary>
        <value>A <see cref="T:System.Uri" /> 에 전달 된 인터넷 리소스의 URI를 포함 하는 <see cref="M:System.Net.WebRequest.Create(System.String)" /> 메서드.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri> 에 전달 된 개체 <xref:System.Net.HttpWebRequest> 호출 하 여 <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>합니다.  
  
 리디렉션 후 헤더 변경 되지 않습니다는 <xref:System.Net.HttpWebRequest.RequestUri%2A> 속성입니다. 요청에 응답 하는 실제 URI를 가져오려면 검사는 <xref:System.Net.HttpWebRequest.Address%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 확인 하 고 <xref:System.Net.HttpWebRequest> 개체 `req` 의 값을 설정 하 고 요청을 수행 하려면 다른 위치에 리디렉션된는 `hasChanged` 변수를 `true` 요청이 고, 그렇지 않으면 리디렉션된 경우 `hasChanged` 로 설정 된 `false`합니다.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send data in segments to the Internet resource.</summary>
        <value>
          <see langword="true" /> 데이터를 인터넷 리소스에 분할 된 형태로 보내려면 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Net.HttpWebRequest.SendChunked%2A> 은 `true`, 요청 세그먼트에 인터넷 리소스에 데이터를 보냅니다. 인터넷 리소스는 청크 분할 된 데이터를 받는 지원 해야 합니다.  
  
 변경 된 <xref:System.Net.HttpWebRequest.SendChunked%2A> 호출 하 여 요청이 시작 된 후 속성은 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, 또는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드가 throw는 <xref:System.InvalidOperationException>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성을 `true` 인터넷 리소스에는 세그먼트에 데이터를 보낼 수 있도록 합니다.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a callback function to validate the server certificate.</summary>
        <value>서버 인증서의 유효성을 검사할 콜백 함수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본값은 콜백 함수가 설정 되어 있는지와 <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> 속성은 `null`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the service point to use for the request.</summary>
        <value>A <see cref="T:System.Net.ServicePoint" /> 인터넷 리소스에 네트워크 연결을 나타내는입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> 속성이 다를 수 있습니다 <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> 요청을 리디렉션할 경우.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the request provides support for a <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" /> 요청에 대 한 지원을 제공 하는 경우는 <see cref="T:System.Net.CookieContainer" />, 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 포함 된 모든 개체는 <xref:System.Runtime.Serialization.SerializationInfo> 자동으로 추적 되 고 포맷터에 의해 serialize 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the time-out value in milliseconds for the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> and <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> methods.</summary>
        <value>요청이 시간 초과하기 전까지 기다리는 시간(밀리초)입니다. 기본값은 100,000밀리초(100초)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> 후속 동기 요청으로 수행 된 시간 (밀리초)의 수는 <xref:System.Net.HttpWebRequest.GetResponse%2A> , 응답을 대기 하는 메서드 및 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드 스트림에 대 한 대기 합니다. <xref:System.Net.HttpWebRequest.Timeout%2A> 전체 요청 및 응답을 개별적으로 되지 적용는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 및 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드를 호출 합니다. 리소스 제한 시간 내에 반환 되지 않으면, 요청이 발생 한 <xref:System.Net.WebException> 와 <xref:System.Net.WebException.Status%2A> 속성이로 설정 <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>합니다.  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A> 하기 전에 속성을 설정 해야는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 또는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드를 호출 합니다. 변경 된 <xref:System.Net.HttpWebRequest.Timeout%2A> 호출한 후 속성은 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 또는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드에서 아무 작업도  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A> 속성 통한 비동기 요청에 영향을 주지는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 또는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 메서드.  
  
> [!CAUTION]
>  비동기 요청의 경우 클라이언트 응용 프로그램에는 제한 시간 메커니즘을 구현합니다. 예제를 참조는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드.  
  
 읽기 또는 쓰기 작업의 제한 시간에 시간을 지정 하려면 사용 된 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 속성입니다.  
  
 DNS 도메인 이름 () 쿼리는 최대 15 초 반환할 또는 제한 시간 걸릴 수 있습니다. 요청이 포함 해상도 필요로 하는 호스트 이름을 설정한 경우 <xref:System.Net.FileWebRequest.Timeout%2A> 값 보다 작거나 15 초 걸릴 수 있습니다 하기 전에 15 초 이상는 <xref:System.Net.WebException> 요청에 대 한 시간을 나타내기 위해 throw 되 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Timeout%2A> 의 속성은 <xref:System.Net.HttpWebRequest> 개체입니다.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Transfer-encoding" /> HTTP header.</summary>
        <value>HTTP <see langword="Transfer-encoding" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 하기 전에 <xref:System.Net.HttpWebRequest.TransferEncoding%2A> 속성을 먼저 설정 해야는 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성을 `true`합니다. 지우기 <xref:System.Net.HttpWebRequest.TransferEncoding%2A> 로 설정 하 여 `null` 의 값에 영향을 주지 <xref:System.Net.HttpWebRequest.SendChunked%2A>합니다.  
  
 에 할당 된 값은 <xref:System.Net.HttpWebRequest.TransferEncoding%2A> 속성에는 모든 기존 내용을 대체 합니다.  
  
> [!NOTE]
>  이 속성에 대 한 값에 저장 됩니다 <xref:System.Net.WebHeaderCollection>합니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set when <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to the value "Chunked".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to allow high-speed NTLM-authenticated connection sharing.</summary>
        <value>
          <see langword="true" /> 인증 된 연결을 열어 유지 하려면 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 대 한 기본값은 `false`, 때문에 현재 연결을 요청을 완료 한 후 닫아야 합니다. 새 요청을 발급 될 때마다 응용 프로그램 인증 시퀀스를 통해 이동 해야 합니다.  
  
 이 속성은로 설정 하는 경우 `true`, 인증이 수행 후 응답을 검색 하는 데 사용 하는 연결이 열려 있습니다. 이 경우 된 다른 요청으로이 속성이 설정 `true` 다시 인증 하지 않고 연결을 사용할 수 있습니다. 즉, 사용자 A에 대 한 연결을 인증 하는 경우 사용자 B 다시 사용할 수 있습니다 A의 연결 1. 사용자의 자격 증명에 따라 B의 사용자 요청이 행은  
  
> [!CAUTION]
>  한지 관리 문제가 시스템에서이 속성을 설정할 때 확인 해야 하는 인증을 거치지 않고 연결을 사용 하도록 응용 프로그램에 대 한 수 있기 때문에 `true`합니다. 응용 프로그램에서 여러 사용자에 게 요청 하는 경우 (가장 하는 여러 사용자 계정) 의존 하 여 리소스를 보호 하는 인증, 않으면이 속성을 설정 하지 `true` 아래 설명 된 대로 연결 그룹을 사용 하지 않는 한 합니다.  
  
 경우이 메커니즘을 사용 하도록 설정 하려는 경우에 성능 문제가 발생 하는 응용 프로그램은 Windows 통합된 인증으로 웹 서버에서 실행 되 고 합니다.  
  
 이 설정을 사용 하면 시스템 보안 위험을 엽니다. 설정 하는 경우는 <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> 속성을 `true` 다음 예방 조치를 수행 하시기 바랍니다.  
  
-   사용 하 여는 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> 속성을 다른 사용자에 대 한 연결을 관리 합니다. 이 인증 되지 않은 응용 프로그램에서 연결의 사용 가능성을 방지합니다. 예를 들어 사용자 A 2. 사용자와에서 다른 고유한 연결 그룹 이름이 있어야 각 사용자 계정에 대 한 격리 계층을 제공합니다.  
  
-   연결이 악용을 방지 하려면 보호 된 환경에서 응용 프로그램을 실행 합니다.  
  
 백 엔드 서버를 제어 하는 경우 대신 해야 할 인증 지 속성을 해제 합니다. 어느 정도 성능이 향상 되지만 더 안전 합니다. 자세한 내용은 MSDN library에서 AuthPersistence 검색 [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library)합니다.  
  
> [!NOTE]
>  두 <xref:System.Net.WebRequest.PreAuthenticate%2A> 및 <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> 로 설정 `true`, 권한 부여 헤더를 사용 하지만 안전 하지 않은 풀에서 연결을 사용 하 여 각 요청이 보내집니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">이 속성을 설정 하려면 제한 되지 않은 웹 권한이 필요 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that controls whether default credentials are sent with requests.</summary>
        <value>기본 자격 증명이 사용되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정 `true` 에서이 요청을 수행 하는 경우 <xref:System.Net.HttpWebRequest> 개체, 서버에 의해 요청 된 경우 인증 해야 현재 로그온된 한 사용자의 자격 증명을 사용 하 여 합니다. 이 클라이언트 응용 프로그램에 대 한 대부분의 시나리오에서 원하는 동작 합니다. 이 속성을 사용 하는 대신 ASP.NET 응용 프로그램 같은 중간 계층 응용 프로그램에 일반적으로 설정한는 <xref:System.Net.HttpWebRequest.Credentials%2A> 속성 대신 요청 클라이언트의 자격 증명을 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You attempted to set this property after the request was sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="User-agent" /> HTTP header.</summary>
        <value>HTTP <see langword="User-agent" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.  
  
 <block subset="none" type="note"><para> 이 속성에 대 한 값에 저장 됩니다 <see cref="T:System.Net.WebHeaderCollection" />합니다. WebHeaderCollection이 설정 되 면 속성 값이 손실 됩니다.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.UserAgent%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>