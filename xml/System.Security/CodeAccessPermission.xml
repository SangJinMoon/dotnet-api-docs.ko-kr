<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CodeAccessPermission.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b497a3cd20cb1d0ae8172ce6caf259ae001ddee0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b497a3cd20cb1d0ae8172ce6caf259ae001ddee0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.CodeAccessPermission">
          <source>Defines the underlying structure of all code access permissions.</source>
          <target state="translated">모든 코드 액세스 권한의 기본 구조를 정의합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</source>
          <target state="translated">코드 액세스 권한 스택 워크를 사용 하 여 사용 권한을 코드의 모든 호출자에 게 부여 되어 있는지 확인 하십시오.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>If a permission object is <ph id="ph1">`null`</ph>, it is handled the same as a permission object with the state <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">사용 권한 개체가 <ph id="ph1">`null`</ph>, 상태와 사용 권한 개체와 동일한 처리 <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">호출 스택의 호출 스택의 상위 메서드를 호출할 낮은 호출 스택에 있도록 하향식으로 일반적으로 표현 됩니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Inheritors of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class must be granted full trust to function correctly as permissions extending the security infrastructure.</source>
          <target state="translated">상속자는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> 클래스 보안 인프라를 확장 하는 권한으로 제대로 작동 하려면 완전 신뢰를 부여 해야 합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>To determine that the inheritors are fully trusted, <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> issues an <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityAction.InheritanceDemand&gt;</ph> for <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence&gt;</ph><ph id="ph4"> = </ph><ph id="ph5">`true`</ph> and <ph id="ph6">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy&gt;</ph><ph id="ph7"> = </ph><ph id="ph8">`true`</ph>.</source>
          <target state="translated">상속 자가 완전히 신뢰할 수 있는지 확인 하려면 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> 문제는 <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityAction.InheritanceDemand&gt;</ph> 에 대 한 <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence&gt;</ph> <ph id="ph4"> = </ph> <ph id="ph5">`true`</ph> 및 <ph id="ph6">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy&gt;</ph> <ph id="ph7"> = </ph> <ph id="ph8">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The following code example shows a permission derived from the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">다음 코드 예제에서는에서 파생 된 사용 권한을 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>for the ability of inheritors to provide evidence and view and modify policy.</source>
          <target state="translated">증명 정보 및 보기를 제공 하 고 정책을 수정 상속자 수 있습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /&gt;</ph>.</source>
          <target state="translated">연관 된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>When you inherit from <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>, you must also implement the <ph id="ph2">&lt;see cref="T:System.Security.Permissions.IUnrestrictedPermission" /&gt;</ph> interface.</source>
          <target state="translated">상속 하는 경우 <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>를 구현 해야는 <ph id="ph2">&lt;see cref="T:System.Security.Permissions.IUnrestrictedPermission" /&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The following <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> members must be overridden: <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Copy" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Security.CodeAccessPermission.ToXml" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" /&gt;</ph>, and <ph id="ph7">&lt;see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" /&gt;</ph>.</source>
          <target state="translated">다음 <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> 멤버를 재정의 해야 합니다: <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Copy" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Security.CodeAccessPermission.ToXml" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" /&gt;</ph>, 및 <ph id="ph7">&lt;see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>You must also define a constructor that takes a <ph id="ph1">&lt;see cref="T:System.Security.Permissions.PermissionState" /&gt;</ph> as its only parameter.</source>
          <target state="translated">사용 하는 생성자도 정의 해야는 <ph id="ph1">&lt;see cref="T:System.Security.Permissions.PermissionState" /&gt;</ph> 유일한 매개 변수로 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>You must apply the <ph id="ph1">&lt;see cref="T:System.SerializableAttribute" /&gt;</ph> attribute to a class that inherits from <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">적용 해야 합니다는 <ph id="ph1">&lt;see cref="T:System.SerializableAttribute" /&gt;</ph> 에서 상속 되는 클래스에 특성 <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>This constructor is called to initialize state in the type whenever an instance of the derived class is created.</source>
          <target state="translated">이 생성자를 호출 하 여 파생된 클래스의 인스턴스를 만들 때마다 형식의 상태를 초기화 하 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</source>
          <target state="translated">파생된 클래스 생성자의 생성자 선언에이 생성자를 명시적으로 호출할 수, 있지만이 대개 필요는 없습니다. 대부분의 컴파일러에서는 사용자에 대 한 호출을 자동으로 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</source>
          <target state="translated">스택의 상위 호출자에게 리소스에 액세스할 수 있는 권한이 부여되지 않더라도 호출 코드가 이 메서드를 호출하는 코드를 통해 사용 권한 요구로 보호되는 리소스에 액세스할 수 있음을 선언합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Using <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> can create security issues.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>를 사용하면 보안 문제가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">호출 스택의 호출 스택의 상위 메서드를 호출할 낮은 호출 스택에 있도록 하향식으로 일반적으로 표현 됩니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Calling <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</source>
          <target state="translated">호출 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 이 메서드를 호출 하는 코드를 넘어 진행에서 호출 스택을에서 더 아래로 발생 스택 워크 수 없습니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</source>
          <target state="translated">따라서 호출 스택의 상위 호출자에 리소스를 액세스할 수 있는 필수 권한이 없는 경우에은 여전히 액세스할 수는 데 필요한 사용 권한을이 메서드를 호출 하는 코드를 통해.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>An assertion is effective only if the code that calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> passes the security check for the permission that it is asserting.</source>
          <target state="translated">어설션을 코드를 호출 하는 경우에 유효 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 어설션하는 사용 권한에 대해 보안 검사를 통과 합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">에 대 한 호출 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 호출 하는 코드는 호출자에 반환 될 때까지 유효 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">하나의 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 프레임에서 활성화 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">호출 하려고 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 때 활성 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 프레임 결과 따라 존재는 <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">호출 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> 활성을 제거 하려면 <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 권한에 대 한 요청이 실패 합니다 부여 되지 않은 사용 권한을 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>However, if code lower on the call stack calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">그러나 코드가 호출 스택에 낮은 호출 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> 권한에 대해는 <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> 스택 워크를 호출 하려고 하는 코드에 도달 하면 throw 되 <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>This happens because the code that called <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> has not been granted the permission, even though it tried to <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> it.</source>
          <target state="translated">코드를 호출 하기 때문에 이런 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 가 부여 되지 권한, 하 려 했지만 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 것입니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Because calling <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</source>
          <target state="translated">호출 하기 때문에 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 호출 체인에 모든 코드가 요구 해야 권한이 제거 지정 된 리소스에 액세스할 수, 메서드를 잘못 사용할 경우 보안 문제가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Therefore, it should be used with great caution.</source>
          <target state="translated">따라서 매우 주의 해 서 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The calling code does not have <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>.</source>
          <target state="translated">호출 코드에 <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>이 없습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame.</source>
          <target state="translated">현재 프레임에 대해 활성 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>가 이미 있습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>for the ability to call <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>.</source>
          <target state="translated">호출 하는 기능에 대 한 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>You cannot override this method.</source>
          <target state="translated">이 메서드를 재정의할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>When implemented by a derived class, creates and returns an identical copy of the current permission object.</source>
          <target state="translated">파생된 클래스에 의해 구현될 때 현재 권한 개체의 동일한 복사본을 만들어서 반환합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>A copy of the current permission object.</source>
          <target state="translated">현재 권한 개체의 복사본입니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>A copy of a permission object represents the same access to resources as the original permission object.</source>
          <target state="translated">사용 권한 개체의 복사본을 원래 권한 개체 리소스에 동일한 액세스를 권한을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Copy%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Copy%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>You must override this method in a derived class.</source>
          <target state="translated">파생된 클래스에서이 메서드를 재정의 해야 합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>Forces a <ph id="ph1">&lt;see cref="T:System.Security.SecurityException" /&gt;</ph> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</source>
          <target state="translated">호출 스택의 상위 호출자에게 현재 인스턴스로 지정된 권한이 없는 경우 런타임에 <ph id="ph1">&lt;see cref="T:System.Security.SecurityException" /&gt;</ph>을 강제 적용합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>This method is typically used by secure libraries to ensure that callers have permission to access a resource.</source>
          <target state="translated">이 메서드는 일반적으로 호출자에 게 리소스에 액세스할 수 있는 권한이 있는지 확인 하려면 보안 라이브러리에서 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>For example, a file class in a secure class library calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for the necessary <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> before performing a file operation requested by the caller.</source>
          <target state="translated">예를 들어 보안 클래스 라이브러리의 파일 클래스 호출 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> 필요한 <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> 는 호출자가 요청한 파일 작업을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</source>
          <target state="translated">이 메서드를 호출 하는 코드의 사용 권한은 검사 하지 않습니다. 검사 해당 코드의 직접 실행 호출자에서 시작 되 고 스택 위로 진행 됩니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">호출 스택의 호출 스택의 상위 메서드를 호출할 낮은 호출 스택에 있도록 하향식으로 일반적으로 표현 됩니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> succeeds only if no <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> 없는 경우에 성공 <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> 발생 합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>A caller higher in the call stack does not have the permission specified by the current instance.</source>
          <target state="translated">호출 스택의 상위에 있는 호출자에게 현재 인스턴스가 지정한 사용 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>A caller higher in the call stack has called <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> on the current permission object.</source>
          <target state="translated">호출 스택의 상위 호출자가 현재 사용 권한 개체에 대해 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph>를 호출했습니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>You cannot override this method.</source>
          <target state="translated">이 메서드를 재정의할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</source>
          <target state="translated">호출 스택의 상위 호출자가 이 메서드를 호출하는 코드를 사용하여 현재 인스턴스에 의해 지정된 리소스에 액세스하지 못하게 합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 완전히 신뢰할 수 있는 코드에서 메서드를 실수로 액세스 로부터 리소스를 보호에 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">하지 신뢰할 수 없는 코드 리소스 의도적인 악용 으로부터 보호 하기 위해 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> for a permission and then calls method <ph id="ph3">`B`</ph>, method <ph id="ph4">`B`</ph> can overtly override the <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> by issuing an <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">예를 들어 경우 메서드 <ph id="ph1">`A`</ph> 문제는 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 사용 권한 및 다음 호출 메서드 <ph id="ph3">`B`</ph>, 메서드 <ph id="ph4">`B`</ph> 명백히 재정의할 수 있습니다는 <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 실행 하 여 프로그램 <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">호출된 된 메서드가 스택의 항상 높습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> lower in the stack.</source>
          <target state="translated">따라서 경우 메서드 <ph id="ph1">`B`</ph> 보안 시스템에서 보호 된 리소스에 액세스 하려고 하기 때문에 여 사용 권한을 확인 하기 시작 메서드 <ph id="ph2">`B`</ph> 직접 실행 호출자 이며 워크 우선이 있는지 확인 하기 위해 스택의 없습니다 <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 또는 <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 스택의 더 낮은 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> method.</source>
          <target state="translated">메서드 <ph id="ph1">`B`</ph>, 리소스에 액세스 하려고 하는 수는 스택 워크 즉시 사용 하 여 중지 된 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>In that case, the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> placed on the stack by method <ph id="ph2">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">이 경우에 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 메서드에서 스택에 배치 <ph id="ph2">`A`</ph> (호출 하는 방법)가 검색 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</source>
          <target state="translated">이 메서드는 호출 스택의 상위 호출자가 해당 호출자가 액세스할 수 있는 권한이 부여 되어 있는 경우에이 메서드를 호출 하는 코드를 통해 보호 된 리소스에 액세스 하지 못하도록 방지 합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">호출 스택의 호출 스택의 상위 메서드를 호출할 낮은 호출 스택에 있도록 하향식으로 일반적으로 표현 됩니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> from being used to access the resource protected by the denied permission.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 프로그래머의 책임을 제한 하거나 호출 하는 메서드를 방지할 수 있으므로 실수로 인 한 보안 문제를 방지할 수 있습니다 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 에서 거부 된 권한으로 보호 되는 리소스에 액세스 하는 데 사용 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>If a method calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> on a permission, and if a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</source>
          <target state="translated">메서드를 호출 하는 경우 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 권한, 경우에 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> 에 도달 하면 해당 보안 검사에서 실패에 해당 권한이 하위 호출 스택의 호출자가 호출 되는 <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">에 대 한 호출 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 호출 하는 코드는 호출자에 반환 될 때까지 유효 합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">하나의 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 프레임에서 활성화 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">호출 하려고 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 때 활성 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 프레임 결과 따라 존재는 <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</source>
          <target state="translated">호출 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> 활성을 제거 하려면 <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 권한에 대 한 요청이 실패 합니다 부여 되지 않은 사용 권한을 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame.</source>
          <target state="translated">현재 프레임에 대해 활성 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph>가 이미 있습니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>You cannot override this method.</source>
          <target state="translated">이 메서드를 재정의할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object to compare with the current <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>와 비교할 <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object is equal to the current <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> 개체가 현재 <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>과 같은지 여부를 확인합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object is equal to the current <ph id="ph3">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">지정한 <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> 개체가 현재  <ph id="ph3">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>와 같으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The XML encoding to use to reconstruct the security object.</source>
          <target state="translated">보안 개체를 다시 생성하는 데 사용할 XML 인코딩입니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</source>
          <target state="translated">파생된 클래스에서 재정의되는 경우, XML 인코딩에서 지정된 상태의 보안 개체를 다시 생성합니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>Custom code that extends security objects needs to implement the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> methods to make the objects security-encodable.</source>
          <target state="translated">보안 개체를 확장 하는 사용자 지정 코드를 구현 해야는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> 보안 인코딩할 수 있는 개체를 만드는 메서드.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elem" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter does not contain the XML encoding for an instance of the same type as the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elem" /&gt;</ph> 매개 변수에 현재 인스턴스와 동일한 형식의 인스턴스에 대한 XML 인코딩이 포함되어 있지 않은 경우</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The version number of the <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elem" /&gt;</ph> 매개 변수의 버전 번호가 지원되지 않는 경우</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">파생된 클래스에서이 메서드를 재정의 해야 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>Gets a hash code for the <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object that is suitable for use in hashing algorithms and data structures such as a hash table.</source>
          <target state="translated">해시 알고리즘과 해시 테이블 같은 데이터 구조에 사용하기 적합한 <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> 개체에 대한 해시 코드를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>A hash code for the current <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> 개체의 해시 코드입니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> objects.</source>
          <target state="translated">두 인스턴스가 같은 권한의 대 한 해시 코드 서로 다를 수 있으므로 해시 코드를 사용 두 개를 비교 하 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>A permission to intersect with the current permission.</source>
          <target state="translated">현재 사용 권한과 공통되는 사용 권한입니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">현재 사용 권한과 동일한 형식이어야 합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</source>
          <target state="translated">파생된 클래스에서 구현되는 경우 현재 사용 권한 및 지정된 사용 권한의 공통 권한을 만들어 반환합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>A new permission that represents the intersection of the current permission and the specified permission.</source>
          <target state="translated">현재 사용 권한 및 지정된 사용 권한의 공통 영역을 나타내는 새 사용 권한입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>This new permission is <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the intersection is empty.</source>
          <target state="translated">교집합이 비어 있으면 새 사용 권한은 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The intersection of two permissions is a permission that describes the set of operations they both describe in common.</source>
          <target state="translated">두 사용 권한의 공통 사항에는 모두 공통으로 설명 하는 작업 집합을 설명 하는 권한입니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>Only a demand that passes both original permissions will pass the intersection.</source>
          <target state="translated">원래 사용 권한을 모두 전달 하는 요구만 교집합에 전달 합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Intersect%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Intersect%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and is not an instance of the same class as the current permission.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 현재 사용 권한과 동일한 클래스의 인스턴스가 아닌 경우</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">파생된 클래스에서이 메서드를 재정의 해야 합니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>A permission that is to be tested for the subset relationship.</source>
          <target state="translated">하위 집합 관계에 대해 테스트할 사용 권한입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>This permission must be of the same type as the current permission.</source>
          <target state="translated">이 사용 권한은 현재 권한과 동일한 형식이어야 합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</source>
          <target state="translated">파생 클래스에 의해 구현될 경우 권한이 지정된 사용 권한의 하위 집합인지를 확인합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current permission is a subset of the specified permission; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 사용 권한이 지정된 사용 권한의 하위 집합이면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission.</source>
          <target state="translated">현재 권한은 현재 사용 권한이 지정된 된 사용 하 여 완전히 포함 된 작업의 집합을 지정 하는 경우 지정된 된 사용 권한의 하위 집합입니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:<ph id="ph1">\\</ph>.</source>
          <target state="translated">예를 들어 c:\example.txt 있는 사용 권한을의 하위 집합인 c: \에 대 한 액세스를 나타내는 사용 권한의<ph id="ph1">\\</ph>합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If this method returns <ph id="ph1">`true`</ph>, the current permission represents no more access to the protected resource than does the specified permission.</source>
          <target state="translated">이 메서드가 반환 하는 경우 <ph id="ph1">`true`</ph>, 현재 사용 권한과 동일한 액세스 보호 된 리소스에 지정된 된 사용은 보다를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The following statements are required to be <ph id="ph1">`true`</ph> for all overrides of the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> method.</source>
          <target state="translated">다음 문은 되어야 하는 데 필요한 <ph id="ph1">`true`</ph> 의 모든 재정의 위한는 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>, <bpt id="p2">*</bpt>Y<ept id="p2">*</ept>, and <bpt id="p3">*</bpt>Z<ept id="p3">*</ept> represent custom code access permission objects that are not null references, <bpt id="p4">*</bpt>U<ept id="p4">*</ept> represents an unrestricted code access permission, and <bpt id="p5">*</bpt>N<ept id="p5">*</ept> represents an empty permission with a <ph id="ph1">&lt;xref:System.Security.Permissions.PermissionState&gt;</ph> of <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>, <bpt id="p2">*</bpt>Y<ept id="p2">*</ept>, 및 <bpt id="p3">*</bpt>Z<ept id="p3">*</ept> null 참조가 아닌 사용자 지정 코드 액세스 권한 개체 나타내는 <bpt id="p4">*</bpt>U<ept id="p4">*</ept> 제한 되지 않은 코드 액세스 권한을 나타내는 및 <bpt id="p5">*</bpt>N<ept id="p5">*</ept> 와 빈 권한을 나타내는 <ph id="ph1">&lt;xref:System.Security.Permissions.PermissionState&gt;</ph> 의 <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>합니다. IsSubsetOf (<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) 반환 <ph id="ph1">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) returns the same value as <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>X<ept id="p4">*</ept>) if and only if <bpt id="p5">*</bpt>X<ept id="p5">*</ept> and <bpt id="p6">*</bpt>Y<ept id="p6">*</ept> represent the same set of permissions.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>합니다. IsSubsetOf (<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>)과 동일한 값을 반환 <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>합니다. IsSubsetOf (<bpt id="p4">*</bpt>X<ept id="p4">*</ept>) 경우에 <bpt id="p5">*</bpt>X<ept id="p5">*</ept> 및 <bpt id="p6">*</bpt>Y<ept id="p6">*</ept> 동일한 사용 권한 집합을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) and <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) both return <ph id="ph1">`true`</ph>, <bpt id="p5">*</bpt>X<ept id="p5">*</ept>.IsSubsetOf(<bpt id="p6">*</bpt>Z<ept id="p6">*</ept>) returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">경우 <bpt id="p1">*</bpt>X<ept id="p1">*</ept>합니다. IsSubsetOf (<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) 및 <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>합니다. IsSubsetOf (<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) 둘 다 반환 <ph id="ph1">`true`</ph>, <bpt id="p5">*</bpt>X<ept id="p5">*</ept>합니다. IsSubsetOf (<bpt id="p6">*</bpt>Z<ept id="p6">*</ept>) 반환 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>U<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>합니다. IsSubsetOf (<bpt id="p2">*</bpt>U<ept id="p2">*</ept>) 반환 <ph id="ph1">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>N<ept id="p2">*</ept>) returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>합니다. IsSubsetOf (<bpt id="p2">*</bpt>N<ept id="p2">*</ept>) 반환 <ph id="ph1">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>N<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>N<ept id="p1">*</ept>합니다. IsSubsetOf (<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) 반환 <ph id="ph1">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>X<ept id="p1">*</ept> and <bpt id="p2">*</bpt>Y<ept id="p2">*</ept> represent custom code access permission objects that are null references, <bpt id="p3">*</bpt>X<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>Y<ept id="p4">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">경우 <bpt id="p1">*</bpt>X<ept id="p1">*</ept> 및 <bpt id="p2">*</bpt>Y<ept id="p2">*</ept> 사용자 지정 코드 액세스 권한 개체가 null 참조를 나타내는 <bpt id="p3">*</bpt>X<ept id="p3">*</ept>합니다. IsSubsetOf (<bpt id="p4">*</bpt>Y<ept id="p4">*</ept>) 반환 <ph id="ph1">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>Z<ept id="p1">*</ept> is also null, the compound set operation <bpt id="p2">*</bpt>X<ept id="p2">*</ept>.Union(<bpt id="p3">*</bpt>Y<ept id="p3">*</ept>).IsSubsetOf(<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) also returns <ph id="ph1">`true`</ph> because the union of two null permissions is a null permission.</source>
          <target state="translated">경우 <bpt id="p1">*</bpt>Z<ept id="p1">*</ept> 도 null, 복합 집합 연산 <bpt id="p2">*</bpt>X<ept id="p2">*</ept>합니다. Union (<bpt id="p3">*</bpt>Y<ept id="p3">*</ept>). IsSubsetOf (<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>)도 반환 <ph id="ph1">`true`</ph> 하므로 두 개의 null 사용 권한의 합집합 null 권한입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and is not of the same type as the current permission.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 현재 사용 권한과 형식이 다른 경우</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">파생된 클래스에서이 메서드를 재정의 해야 합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</source>
          <target state="translated">호출 스택의 상위 호출자가 이 메서드를 호출하는 코드를 사용하여 현재 인스턴스에 의해 지정된 리소스를 제외한 모든 리소스에 액세스하지 못하게 합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 완전히 신뢰할 수 있는 코드에서 메서드를 실수로 액세스 로부터 리소스를 보호에 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">하지 신뢰할 수 없는 코드 리소스 의도적인 악용 으로부터 보호 하기 위해 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for a permission and then calls method <ph id="ph3">`B`</ph>, method <ph id="ph4">`B`</ph> can overtly override the <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> by issuing an <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">예를 들어 경우 메서드 <ph id="ph1">`A`</ph> 문제는 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 사용 권한 및 다음 호출 메서드 <ph id="ph3">`B`</ph>, 메서드 <ph id="ph4">`B`</ph> 명백히 재정의할 수 있습니다는 <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 실행 하 여 프로그램 <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">호출된 된 메서드가 스택의 항상 높습니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> lower in the stack.</source>
          <target state="translated">따라서 경우 메서드 <ph id="ph1">`B`</ph> 보안 시스템에서 보호 된 리소스에 액세스 하려고 하기 때문에 여 사용 권한을 확인 하기 시작 메서드 <ph id="ph2">`B`</ph> 직접 실행 호출자 이며 워크 우선이 있는지 확인 하기 위해 스택의 없습니다 <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 또는 <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 스택의 더 낮은 합니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> method.</source>
          <target state="translated">메서드 <ph id="ph1">`B`</ph>, 리소스에 액세스 하려고 하는 수는 스택 워크 즉시 사용 하 여 중지 된 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>In that case, the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> placed on the stack by method <ph id="ph2">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">이 경우에 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 메서드에서 스택에 배치 <ph id="ph2">`A`</ph> (호출 하는 방법)가 검색 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, in that both cause stack walks to fail when they would otherwise succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 유사한 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>그렇지 않은 경우는 성공 시 작동이 실패 하도록 스택 워크 있는 상황에서, 합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The difference is that <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> specifies permissions that will cause the stack walk to fail, but <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> specifies the only permissions that do not cause the stack walk to fail.</source>
          <target state="translated">차이점은 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 실패 하는 스택 워크를 발생 시키는 사용 권한을 지정 하지만 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 스택 워크 실패 하지 않게 되는 유일한 권한을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Call this method to ensure that your code can be used to access only the specified resources.</source>
          <target state="translated">코드 지정 된 리소스에만 액세스할 수 사용 될 수 있도록 하려면이 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">에 대 한 호출 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 호출 하는 코드는 호출자에 반환 될 때까지 유효 합니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">하나의 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 프레임에서 활성화 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">호출 하려고 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 때 활성 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 프레임 결과 따라 존재는 <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</source>
          <target state="translated">호출 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> 활성을 제거 하려면 <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 권한에 대 한 요청이 실패 합니다 부여 되지 않은 사용 권한을 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>However, if code lower on the call stack later calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</source>
          <target state="translated">그러나 코드에 대 한 호출에 낮은 나중 스택 하는 경우 호출 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> 권한에 대해는 <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> 스택 워크를 호출 하려고 하는 코드에 도달 하면 throw 되 <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>This is because the code that called <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> has not been granted the permission, even though it called <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for that permission.</source>
          <target state="translated">호출한 코드 때문에 이것이 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 에 권한이 부여 되지는 호출 했지만 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 권한에 합니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">호출 스택의 호출 스택의 상위 메서드를 호출할 낮은 호출 스택에 있도록 하향식으로 일반적으로 표현 됩니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">현재 프레임에 대해 활성 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph>가 이미 있습니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>You cannot override this method.</source>
          <target state="translated">이 메서드를 재정의할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>Causes all previous overrides for the current frame to be removed and no longer in effect.</source>
          <target state="translated">현재 프레임에 대한 모든 이전 재정의가 제거되고 더 이상 적용되지 않습니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>If there are no overrides (<ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>) for the current frame, an <ph id="ph4">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">재정의 없는 경우 (<ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, 또는 <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>) 현재 프레임에 대 한는 <ph id="ph4">&lt;xref:System.ExecutionEngineException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph>, or <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">현재 프레임에 대한 이전 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> 또는 <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph>가 없는 경우</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">현재 프레임에 대한 이전의 모든 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>를 제거하여 더 이상 적용되지 않도록 합니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">없는 경우 없는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> 현재 프레임에 대 한는 <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame.</source>
          <target state="translated">현재 프레임에 대한 이전 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>가 없는 경우</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">현재 프레임에 대한 이전의 모든 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph>를 제거하여 더 이상 적용되지 않도록 합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">없는 경우 없는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> 현재 프레임에 대 한는 <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame.</source>
          <target state="translated">현재 프레임에 대한 이전 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph>가 없는 경우</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">현재 프레임에 대한 이전의 모든 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph>를 제거하여 더 이상 적용되지 않도록 합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">없는 경우 없는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> 현재 프레임에 대 한는 <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">현재 프레임에 대한 이전 <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph>가 없는 경우</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>Creates and returns a string representation of the current permission object.</source>
          <target state="translated">현재 사용 권한 개체에 대한 문자열 표현을 만들고 반환합니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>A string representation of the current permission object.</source>
          <target state="translated">현재 사용 권한 개체에 대한 문자열 표현입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>This method is useful in debugging when you need to display the permission as a string.</source>
          <target state="translated">이 메서드는 사용 권한을 문자열로 표시 하기 위해 필요한 경우 디버깅에 유용 합니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>When overridden in a derived class, creates an XML encoding of the security object and its current state.</source>
          <target state="translated">파생된 클래스에서 재정의되면 보안 개체 및 현재 상태의 XML 인코딩을 만듭니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>An XML encoding of the security object, including any state information.</source>
          <target state="translated">모든 상태 정보를 포함하는 보안 개체의 XML 인코딩입니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>Custom code that extends security objects needs to implement the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> methods to make the objects security-encodable.</source>
          <target state="translated">보안 개체를 확장 하는 사용자 지정 코드를 구현 해야는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> 보안 인코딩할 수 있는 개체를 만드는 메서드.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>You must override this method in a derived class.</source>
          <target state="translated">파생된 클래스에서이 메서드를 재정의 해야 합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>A permission to combine with the current permission.</source>
          <target state="translated">현재 사용 권한과 결합할 사용 권한입니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">현재 사용 권한과 동일한 형식이어야 합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</source>
          <target state="translated">파생된 클래스에서 재정의되는 경우 현재 사용 권한 및 지정한 사용 권한을 합한 사용 권한을 만듭니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>A new permission that represents the union of the current permission and the specified permission.</source>
          <target state="translated">현재 사용 권한 및 지정한 사용 권한의 합을 나타내는 새 사용 권한입니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The result of a call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> is a permission that represents all the operations represented by both the current permission and the specified permission.</source>
          <target state="translated">에 대 한 호출의 결과 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> 현재 사용 권한 및 지정한 사용 권한의 둘 다로 나타나는 모든 작업을 나타내는 권한입니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>Any demand that passes either permission passes their union.</source>
          <target state="translated">사용 권한 중 하나를 전달 하는 모든 요청의 합집합을 통과 합니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="other" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph> 매개 변수는 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아닌 경우.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>This method is only supported at this level when passed <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 메서드는 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 전달한 경우 이 수준에서만 지원됩니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">파생된 클래스에서이 메서드를 재정의 해야 합니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>You should return a copy of the permission if the value of the <ph id="ph1">&lt;paramref name="other" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">경우에 사용 권한의 복사본을 반환 해야의 값은 <ph id="ph1">&lt;paramref name="other" /&gt;</ph> 매개 변수는 <ph id="ph2">&lt;see langword="null" /&gt;</ph>합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>