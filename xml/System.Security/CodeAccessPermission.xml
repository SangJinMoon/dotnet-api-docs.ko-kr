<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0ef420f39e78c977752455a048c2a081e234d1c8" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37622512" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeAccessPermission&#xA;Implements IPermission, IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeAccessPermission abstract : System::Security::IPermission, System::Security::IStackWalk" />
  <TypeSignature Language="F#" Value="type CodeAccessPermission = class&#xA;    interface IPermission&#xA;    interface ISecurityEncodable&#xA;    interface IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="fdb0b-101">Defines the underlying structure of all code access permissions.</span>
      <span class="sxs-lookup">
        <span data-stu-id="fdb0b-101">Defines the underlying structure of all code access permissions.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-102">코드 액세스 권한 스택 워크를 사용 하 여 권한을 코드의 모든 호출자에 게 부여 되어 있는지 확인 하십시오.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-102">Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</span></span> <span data-ttu-id="fdb0b-103">사용 권한 개체 이면 `null`, 상태를 사용 하 여 사용 권한 개체와 동일 하 게 처리 됩니다 <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-103">If a permission object is `null`, it is handled the same as a permission object with the state <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="fdb0b-104">호출 스택의 메서드 호출 스택의 상위에 메서드를 호출 낮은 호출 스택의 있도록에 일반적으로 하향식으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-104">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="fdb0b-105">상속자는 <xref:System.Security.CodeAccessPermission> 클래스 보안 인프라를 확장 하는 권한으로 제대로 작동 하려면 완전 신뢰를 부여 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-105">Inheritors of the <xref:System.Security.CodeAccessPermission> class must be granted full trust to function correctly as permissions extending the security infrastructure.</span></span> <span data-ttu-id="fdb0b-106">자가 완전히 신뢰할 수 있는지 확인할 <xref:System.Security.CodeAccessPermission> 문제는 <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> 에 대 한 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence>  =  `true` 하 고 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy>  =  `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-106">To determine that the inheritors are fully trusted, <xref:System.Security.CodeAccessPermission> issues an <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> for <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence> = `true` and <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy> = `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fdb0b-107">다음 코드 예제에서 파생 된 사용 권한을 보여 줍니다는 <xref:System.Security.CodeAccessPermission> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-107">The following code example shows a permission derived from the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="fdb0b-108">증명 정보 및 보기를 제공 하 고 정책을 수정 하려면 상속 자가 수 있습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="fdb0b-108">for the ability of inheritors to provide evidence and view and modify policy.</span>
      </span>
      <span data-ttu-id="fdb0b-109">연관 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="fdb0b-109">Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</span>
      </span>
    </permission>
    <block subset="none" type="overrides">
      <span data-ttu-id="fdb0b-110">
        <para>상속 하는 경우 <see cref="T:System.Security.CodeAccessPermission" />를 구현 해야 합니다 <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> 인터페이스입니다.  다음 <see cref="T:System.Security.CodeAccessPermission" /> 멤버를 재정의 해야 합니다. <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, 및 <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />합니다.  사용 하는 생성자도 정의 해야 합니다는 <see cref="T:System.Security.Permissions.PermissionState" /> 유일한 매개 변수로 합니다.  적용 해야 합니다 <see cref="T:System.SerializableAttribute" /> 에서 상속 되는 클래스에 특성 <see cref="T:System.Security.CodeAccessPermission" />합니다.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="fdb0b-110">
          <para>When you inherit from <see cref="T:System.Security.CodeAccessPermission" />, you must also implement the <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interface.  The following <see cref="T:System.Security.CodeAccessPermission" /> members must be overridden: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, and <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.  You must also define a constructor that takes a <see cref="T:System.Security.Permissions.PermissionState" /> as its only parameter.  You must apply the <see cref="T:System.SerializableAttribute" /> attribute to a class that inherits from <see cref="T:System.Security.CodeAccessPermission" />.</para>
        </span>
      </span>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeAccessPermission();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-111">Initializes a new instance of the <see cref="T:System.Security.CodeAccessPermission" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-111">Initializes a new instance of the <see cref="T:System.Security.CodeAccessPermission" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-112">파생된 클래스의 인스턴스를 만들 때마다 형식의 상태를 초기화 하려면이 생성자를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-112">This constructor is called to initialize state in the type whenever an instance of the derived class is created.</span></span> <span data-ttu-id="fdb0b-113">파생된 클래스 생성자는 생성자 선언에이 생성자를 명시적으로 호출할 수 있습니다, 있지만이 대개 필요는 없습니다. 대부분의 컴파일러를 호출을 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-113">Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit&#xA;override this.Assert : unit -&gt; unit" Usage="codeAccessPermission.Assert " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-114">Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-114">Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</span>
          </span>
          <span data-ttu-id="fdb0b-115">Using <see cref="M:System.Security.CodeAccessPermission.Assert" /> can create security issues.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-115">Using <see cref="M:System.Security.CodeAccessPermission.Assert" /> can create security issues.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-116">호출 스택의 메서드 호출 스택의 상위에 메서드를 호출 낮은 호출 스택의 있도록에 일반적으로 하향식으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-116">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="fdb0b-117">호출 <xref:System.Security.CodeAccessPermission.Assert%2A> 스택 워크에서이 메서드를 호출 하는 코드를 넘어 호출 스택 위로 계속 호출 스택의 낮은 발생을 방지 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-117">Calling <xref:System.Security.CodeAccessPermission.Assert%2A> prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</span></span> <span data-ttu-id="fdb0b-118">따라서 호출 스택의 상위 호출자에 리소스를 액세스 하는 필수 권한이 없는 경우에 액세스할 수 있습니다 계속 하는 데 필요한 사용 권한을이 메서드를 호출 하는 코드를 통해.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-118">Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</span></span> <span data-ttu-id="fdb0b-119">어설션 코드를 호출 하는 경우에 유효 <xref:System.Security.CodeAccessPermission.Assert%2A> 어설션 중인 권한에 대 한 보안 검사를 통과 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-119">An assertion is effective only if the code that calls <xref:System.Security.CodeAccessPermission.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="fdb0b-120">에 대 한 호출 <xref:System.Security.CodeAccessPermission.Assert%2A> 호출 코드에서 호출자로 반환 될 때까지 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-120">The call to <xref:System.Security.CodeAccessPermission.Assert%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="fdb0b-121">하나의 <xref:System.Security.CodeAccessPermission.Assert%2A> 프레임 활성 상태일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-121">Only one <xref:System.Security.CodeAccessPermission.Assert%2A> can be active on a frame.</span></span> <span data-ttu-id="fdb0b-122">호출 하려는 시도가 <xref:System.Security.CodeAccessPermission.Assert%2A> 때 활성 <xref:System.Security.CodeAccessPermission.Assert%2A> 프레임 결과 따라 존재를 <xref:System.Security.SecurityException>입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-122">An attempt to call <xref:System.Security.CodeAccessPermission.Assert%2A> when an active <xref:System.Security.CodeAccessPermission.Assert%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="fdb0b-123">호출 <xref:System.Security.CodeAccessPermission.RevertAssert%2A> 나 <xref:System.Security.CodeAccessPermission.RevertAll%2A> 활성 제거할 <xref:System.Security.CodeAccessPermission.Assert%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-123">Call <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span>  
  
 <span data-ttu-id="fdb0b-124"><xref:System.Security.CodeAccessPermission.Assert%2A> 해당 권한 요청에 실패 합니다 부여 되지 않은 사용 권한을 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-124"><xref:System.Security.CodeAccessPermission.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="fdb0b-125">그러나 호출 스택에 있는 낮은 코드를 호출 하는 경우 <xref:System.Security.CodeAccessPermission.Demand%2A> 해당 사용 권한에 대 한는 <xref:System.Security.SecurityException> 스택 워크를 호출 하려고 하는 코드에 도달할 때 발생 하는 <xref:System.Security.CodeAccessPermission.Assert%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-125">However, if code lower on the call stack calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="fdb0b-126">코드는 호출 되므로 이런 <xref:System.Security.CodeAccessPermission.Assert%2A> 에 권한이 부여 되지는, 하 려 했지만 <xref:System.Security.CodeAccessPermission.Assert%2A> 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-126">This happens because the code that called <xref:System.Security.CodeAccessPermission.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.CodeAccessPermission.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="fdb0b-127">호출 하므로 <xref:System.Security.CodeAccessPermission.Assert%2A> 제거 호출 체인에 모든 코드는 요구 사항을 받아야 지정된 된 리소스를 액세스할 수 있는 권한이, 잘못 되었거나 부적절 하 게 사용 하는 경우 보안 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-127">Because calling <xref:System.Security.CodeAccessPermission.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</span></span> <span data-ttu-id="fdb0b-128">따라서 주의 기울여야를 사용 하 여 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-128">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="fdb0b-129">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-129">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          </span>
          <span data-ttu-id="fdb0b-130">-or-  There is already an active <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-130">-or-  There is already an active <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="fdb0b-131">호출 하는 기능에 대 한 <see cref="M:System.Security.CodeAccessPermission.Assert" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-131">for the ability to call <see cref="M:System.Security.CodeAccessPermission.Assert" />.</span>
          </span>
          <span data-ttu-id="fdb0b-132">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-132">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></span>
          </span>
        </permission>
        <block subset="none" type="overrides">
          <span data-ttu-id="fdb0b-133">
            <para>이 메서드를 재정의할 수 없습니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-133">
              <para>You cannot override this method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission" Usage="codeAccessPermission.Copy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-134">When implemented by a derived class, creates and returns an identical copy of the current permission object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-134">When implemented by a derived class, creates and returns an identical copy of the current permission object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fdb0b-135">A copy of the current permission object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-135">A copy of the current permission object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-136">권한 개체 사본 원래 권한 개체와 리소스에 대 한 동일한 액세스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-136">A copy of a permission object represents the same access to resources as the original permission object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fdb0b-137">다음 코드 예제에서는 <xref:System.Security.CodeAccessPermission.Copy%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-137">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Copy%2A> method.</span></span> <span data-ttu-id="fdb0b-138">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Security.CodeAccessPermission> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-138">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="fdb0b-139">
            <para>파생된 클래스에서이 메서드를 재정의 해야 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-139">
              <para>You must override this method in a derived class.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit&#xA;override this.Demand : unit -&gt; unit" Usage="codeAccessPermission.Demand " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-140">Forces a <see cref="T:System.Security.SecurityException" /> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-140">Forces a <see cref="T:System.Security.SecurityException" /> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-141">이 메서드는 일반적으로 기본 호출자에 게 리소스에 액세스할 수 있는 권한이 있는지 확인 되는 보안 라이브러리에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-141">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="fdb0b-142">보안 클래스 라이브러리에 파일 클래스를 호출 하는 예를 들어 <xref:System.Security.CodeAccessPermission.Demand%2A> 필요한 <xref:System.Security.Permissions.FileIOPermission> 는 호출자가 요청한 파일 작업을 수행 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-142">For example, a file class in a secure class library calls <xref:System.Security.CodeAccessPermission.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="fdb0b-143">이 메서드를 호출 하는 코드의 사용 권한은 검사 하지 않습니다. 확인 코드의 직접 실행 호출자에서 시작 하 고 스택을 나아갑니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-143">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="fdb0b-144">호출 스택의 메서드 호출 스택의 상위에 메서드를 호출 낮은 호출 스택의 있도록에 일반적으로 하향식으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-144">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="fdb0b-145"><xref:System.Security.CodeAccessPermission.Demand%2A> 없는 경우에 성공 <xref:System.Security.SecurityException> 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-145"><xref:System.Security.CodeAccessPermission.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="fdb0b-146">A caller higher in the call stack does not have the permission specified by the current instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-146">A caller higher in the call stack does not have the permission specified by the current instance.</span>
          </span>
          <span data-ttu-id="fdb0b-147">-or-  A caller higher in the call stack has called <see cref="M:System.Security.CodeAccessPermission.Deny" /> on the current permission object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-147">-or-  A caller higher in the call stack has called <see cref="M:System.Security.CodeAccessPermission.Deny" /> on the current permission object.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="fdb0b-148">
            <para>이 메서드를 재정의할 수 없습니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-148">
              <para>You cannot override this method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit&#xA;override this.Deny : unit -&gt; unit" Usage="codeAccessPermission.Deny " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-149">Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-149">Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="fdb0b-150"><xref:System.Security.CodeAccessPermission.Deny%2A> 완전히 신뢰할 수 있는 코드에서 리소스 우발적인 액세스를 보호할 수만 메서드를 사용할 수 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-150">The <xref:System.Security.CodeAccessPermission.Deny%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="fdb0b-151">해당 해서는 안 의도적인 악용 으로부터 리소스를 보호 하기 위해 신뢰할 수 없는 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-151">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="fdb0b-152">예를 들어 경우 메서드 `A` 문제를 <xref:System.Security.CodeAccessPermission.Deny%2A> 사용 권한 및 다음 메서드만 호출 `B`, 메서드 `B` 명백히 재정의할 수 있습니다 합니다 <xref:System.Security.CodeAccessPermission.Deny%2A> 실행 하 여는 <xref:System.Security.CodeAccessPermission.Assert%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-152">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.Deny%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.Deny%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="fdb0b-153">호출된 된 메서드는 스택의 상위에 항상 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-153">The called method is always higher in the stack.</span></span> <span data-ttu-id="fdb0b-154">따라서 경우 메서드 `B` 보안 시스템 보호 된 리소스에 액세스 하려고 하기 때문에를 사용 하 여 권한 검사 시작 메서드 `B` 즉각적인 호출자 이며 다음 단계를 안내 아래쪽이 있는지 확인 하려면 스택 없습니다 <xref:System.Security.CodeAccessPermission.Deny%2A> 또는 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 스택의 낮은 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-154">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="fdb0b-155">메서드 `B`, 리소스에 액세스 하려고 하는 사용 중지할 수는 스택 워크 즉시는 <xref:System.Security.CodeAccessPermission.Assert%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-155">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="fdb0b-156">이런 경우는 <xref:System.Security.CodeAccessPermission.Deny%2A> 메서드에서 스택에 배치 `A` (호출 메서드)가 검색 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-156">In that case, the <xref:System.Security.CodeAccessPermission.Deny%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="fdb0b-157">이 메서드는 호출 스택의 상위 호출자가 해당 호출자가 액세스할 권한이 부여 된 경우에이 메서드를 호출 하는 코드를 통해 보호 되는 리소스에 액세스 하지 못하도록 방지 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-157">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="fdb0b-158">호출 스택의 메서드 호출 스택의 상위에 메서드를 호출 낮은 호출 스택의 있도록에 일반적으로 하향식으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-158">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="fdb0b-159"><xref:System.Security.CodeAccessPermission.Deny%2A> 프로그래머의 책임을 제한 하거나 호출 하는 메서드를 방지할 수 있으므로 실수로 인 한 보안 문제를 방지할 수 있습니다 <xref:System.Security.CodeAccessPermission.Deny%2A> 를 사용 하 여 거부 된 권한으로 보호 되는 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-159"><xref:System.Security.CodeAccessPermission.Deny%2A> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <xref:System.Security.CodeAccessPermission.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="fdb0b-160">메서드를 호출 하는 경우 <xref:System.Security.CodeAccessPermission.Deny%2A> 는 권한에 경우에 <xref:System.Security.CodeAccessPermission.Demand%2A> 에 도달 하면 해당 보안 확인이 실패 한 해당 권한을 하위 호출 스택의 호출자가 호출 되는 <xref:System.Security.CodeAccessPermission.Deny%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-160">If a method calls <xref:System.Security.CodeAccessPermission.Deny%2A> on a permission, and if a <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span>  
  
 <span data-ttu-id="fdb0b-161">에 대 한 호출 <xref:System.Security.CodeAccessPermission.Deny%2A> 호출 코드에서 호출자로 반환 될 때까지 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-161">The call to <xref:System.Security.CodeAccessPermission.Deny%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="fdb0b-162">하나의 <xref:System.Security.CodeAccessPermission.Deny%2A> 프레임 활성 상태일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-162">Only one <xref:System.Security.CodeAccessPermission.Deny%2A> can be active on a frame.</span></span> <span data-ttu-id="fdb0b-163">호출 하려는 시도가 <xref:System.Security.CodeAccessPermission.Deny%2A> 때 활성 <xref:System.Security.CodeAccessPermission.Deny%2A> 프레임 결과 따라 존재를 <xref:System.Security.SecurityException>입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-163">An attempt to call <xref:System.Security.CodeAccessPermission.Deny%2A> when an active <xref:System.Security.CodeAccessPermission.Deny%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="fdb0b-164">호출 <xref:System.Security.CodeAccessPermission.RevertDeny%2A> 나 <xref:System.Security.CodeAccessPermission.RevertAll%2A> 활성 제거할 <xref:System.Security.CodeAccessPermission.Deny%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-164">Call <xref:System.Security.CodeAccessPermission.RevertDeny%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span> <span data-ttu-id="fdb0b-165"><xref:System.Security.CodeAccessPermission.Deny%2A> 해당 권한 요청에 실패 합니다 부여 되지 않은 사용 권한을 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-165"><xref:System.Security.CodeAccessPermission.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="fdb0b-166">There is already an active <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-166">There is already an active <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="fdb0b-167">
            <para>이 메서드를 재정의할 수 없습니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-167">
              <para>You cannot override this method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="codeAccessPermission.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="fdb0b-168">The <see cref="T:System.Security.CodeAccessPermission" /> object to compare with the current <see cref="T:System.Security.CodeAccessPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-168">The <see cref="T:System.Security.CodeAccessPermission" /> object to compare with the current <see cref="T:System.Security.CodeAccessPermission" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fdb0b-169">Determines whether the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-169">Determines whether the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fdb0b-170">
            <see langword="true" /> if the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-170">
              <see langword="true" /> if the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-171">자세한 내용은 <xref:System.Object.Equals%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-171">For more information, see <xref:System.Object.Equals%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FromXml (elem As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void FromXml(System::Security::SecurityElement ^ elem);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit" Usage="codeAccessPermission.FromXml elem" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem">
          <span data-ttu-id="fdb0b-172">The XML encoding to use to reconstruct the security object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-172">The XML encoding to use to reconstruct the security object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fdb0b-173">When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-173">When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-174">보안 개체를 확장 하는 사용자 지정 코드를 구현 해야 합니다 <xref:System.Security.CodeAccessPermission.ToXml%2A> 및 <xref:System.Security.CodeAccessPermission.FromXml%2A> 개체 보안을 인코딩할 수 있도록 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-174">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fdb0b-175">다음 코드 예제에서는 <xref:System.Security.CodeAccessPermission.FromXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-175">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.FromXml%2A> method.</span></span> <span data-ttu-id="fdb0b-176">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Security.CodeAccessPermission> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-176">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="fdb0b-177">The <paramref name="elem" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-177">The <paramref name="elem" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="fdb0b-178">The <paramref name="elem" /> parameter does not contain the XML encoding for an instance of the same type as the current instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-178">The <paramref name="elem" /> parameter does not contain the XML encoding for an instance of the same type as the current instance.</span>
          </span>
          <span data-ttu-id="fdb0b-179">-or-  The version number of the <paramref name="elem" /> parameter is not supported.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-179">-or-  The version number of the <paramref name="elem" /> parameter is not supported.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="fdb0b-180">
            <para>파생된 클래스에서이 메서드를 재정의 해야 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-180">
              <para>You must override this method in a derived class.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="codeAccessPermission.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-181">Gets a hash code for the <see cref="T:System.Security.CodeAccessPermission" /> object that is suitable for use in hashing algorithms and data structures such as a hash table.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-181">Gets a hash code for the <see cref="T:System.Security.CodeAccessPermission" /> object that is suitable for use in hashing algorithms and data structures such as a hash table.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fdb0b-182">A hash code for the current <see cref="T:System.Security.CodeAccessPermission" /> object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-182">A hash code for the current <see cref="T:System.Security.CodeAccessPermission" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-183">동일한 권한에의 두 인스턴스에 대 한 해시 코드를 서로 다를 수 있으므로 해시 코드를 해야 사용 두 비교할 <xref:System.Security.CodeAccessPermission> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-183">The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <xref:System.Security.CodeAccessPermission> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="fdb0b-184">A permission to intersect with the current permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-184">A permission to intersect with the current permission.</span>
          </span>
          <span data-ttu-id="fdb0b-185">It must be of the same type as the current permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-185">It must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fdb0b-186">When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-186">When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fdb0b-187">A new permission that represents the intersection of the current permission and the specified permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-187">A new permission that represents the intersection of the current permission and the specified permission.</span>
          </span>
          <span data-ttu-id="fdb0b-188">This new permission is <see langword="null" /> if the intersection is empty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-188">This new permission is <see langword="null" /> if the intersection is empty.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-189">두 사용 권한의 교집합에는 모두 공통으로 설명 하는 작업 집합을 설명 하는 권한입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-189">The intersection of two permissions is a permission that describes the set of operations they both describe in common.</span></span> <span data-ttu-id="fdb0b-190">원래 사용 권한을 모두 전달 하는 요구만 교집합을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-190">Only a demand that passes both original permissions will pass the intersection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fdb0b-191">다음 코드 예제에서는 <xref:System.Security.CodeAccessPermission.Intersect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-191">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Intersect%2A> method.</span></span> <span data-ttu-id="fdb0b-192">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Security.CodeAccessPermission> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-192">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="fdb0b-193">The <paramref name="target" /> parameter is not <see langword="null" /> and is not an instance of the same class as the current permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-193">The <paramref name="target" /> parameter is not <see langword="null" /> and is not an instance of the same class as the current permission.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="fdb0b-194">
            <para>파생된 클래스에서이 메서드를 재정의 해야 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-194">
              <para>You must override this method in a derived class.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="codeAccessPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="fdb0b-195">A permission that is to be tested for the subset relationship.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-195">A permission that is to be tested for the subset relationship.</span>
          </span>
          <span data-ttu-id="fdb0b-196">This permission must be of the same type as the current permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-196">This permission must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fdb0b-197">When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-197">When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fdb0b-198">
            <see langword="true" /> if the current permission is a subset of the specified permission; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-198">
              <see langword="true" /> if the current permission is a subset of the specified permission; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-199">현재 권한 현재 사용 권한과 지정 된 권한으로 완전히 포함 된 작업의 집합을 지정 하는 경우 지정 된 사용 권한의 하위 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-199">The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission.</span></span> <span data-ttu-id="fdb0b-200">예를 들어 c:\example.txt 있는 사용 권한을 c: \에 대 한 액세스를 나타내는 사용 권한의 하위 집합인\\합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-200">For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:\\.</span></span> <span data-ttu-id="fdb0b-201">이 메서드가 반환 하는 경우 `true`, 현재 사용 권한과 액세스 권한을 보호 되는 리소스의 지정한 사용 권한에 보다를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-201">If this method returns `true`, the current permission represents no more access to the protected resource than does the specified permission.</span></span>  
  
 <span data-ttu-id="fdb0b-202">다음 문은 해야 `true` 의 모든 재정의 위한는 <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-202">The following statements are required to be `true` for all overrides of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="fdb0b-203">*X*, *Y*, 및 *Z* null 참조 되지 않는 사용자 지정 코드 액세스 권한 개체를 나타내는 *U* 무제한 코드 액세스 권한을 나타내는 및 *N* 사용 하 여 빈 권한을 나타내는 <xref:System.Security.Permissions.PermissionState> 의 <xref:System.Security.Permissions.PermissionState.None>합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-203">*X*, *Y*, and *Z* represent custom code access permission objects that are not null references, *U* represents an unrestricted code access permission, and *N* represents an empty permission with a <xref:System.Security.Permissions.PermissionState> of <xref:System.Security.Permissions.PermissionState.None>.</span></span>  
  
-   <span data-ttu-id="fdb0b-204">*X*합니다. IsSubsetOf (*X*)를 반환 합니다 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-204">*X*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
-   <span data-ttu-id="fdb0b-205">*X*합니다. IsSubsetOf (*Y*)와 동일한 값을 반환 *Y*합니다. IsSubsetOf (*X*) 인 경우에 *X* 하 고 *Y* 동일한 사용 권한 집합을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-205">*X*.IsSubsetOf(*Y*) returns the same value as *Y*.IsSubsetOf(*X*) if and only if *X* and *Y* represent the same set of permissions.</span></span>  
  
-   <span data-ttu-id="fdb0b-206">하는 경우 *X*합니다. IsSubsetOf (*Y*) 및 *Y*합니다. IsSubsetOf (*Z*) 둘 다 반환 `true`하십시오 *X*합니다. IsSubsetOf (*Z*)를 반환 합니다 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-206">If *X*.IsSubsetOf(*Y*) and *Y*.IsSubsetOf(*Z*) both return `true`, *X*.IsSubsetOf(*Z*) returns `true`.</span></span>  
  
-   <span data-ttu-id="fdb0b-207">*X*합니다. IsSubsetOf (*U*)를 반환 합니다 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-207">*X*.IsSubsetOf(*U*) returns `true`.</span></span>  
  
-   <span data-ttu-id="fdb0b-208">*X*합니다. IsSubsetOf (*N*)를 반환 합니다 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-208">*X*.IsSubsetOf(*N*) returns `false`.</span></span>  
  
-   <span data-ttu-id="fdb0b-209">*N*합니다. IsSubsetOf (*X*)를 반환 합니다 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-209">*N*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
 <span data-ttu-id="fdb0b-210">하는 경우 *X* 하 고 *Y* 사용자 지정 코드 액세스 권한 개체는 null 참조를 나타내는 *X*합니다. IsSubsetOf (*Y*)를 반환 합니다 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-210">If *X* and *Y* represent custom code access permission objects that are null references, *X*.IsSubsetOf(*Y*) returns `true`.</span></span> <span data-ttu-id="fdb0b-211">하는 경우 *Z* 가 null도 복합 집합 연산 *X*합니다. 공용 구조체 (*Y*). IsSubsetOf (*Z*)도 반환 `true` 두 null 사용 권한의 합집합 null 권한 이므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-211">If *Z* is also null, the compound set operation *X*.Union(*Y*).IsSubsetOf(*Z*) also returns `true` because the union of two null permissions is a null permission.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fdb0b-212">다음 코드 예제에서는 <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-212">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="fdb0b-213">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Security.CodeAccessPermission> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-213">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="fdb0b-214">The <paramref name="target" /> parameter is not <see langword="null" /> and is not of the same type as the current permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-214">The <paramref name="target" /> parameter is not <see langword="null" /> and is not of the same type as the current permission.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="fdb0b-215">
            <para>파생된 클래스에서이 메서드를 재정의 해야 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-215">
              <para>You must override this method in a derived class.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit&#xA;override this.PermitOnly : unit -&gt; unit" Usage="codeAccessPermission.PermitOnly " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-216">Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-216">Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="fdb0b-217"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> 완전히 신뢰할 수 있는 코드에서 리소스 우발적인 액세스를 보호할 수만 메서드를 사용할 수 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-217">The <xref:System.Security.CodeAccessPermission.PermitOnly%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="fdb0b-218">해당 해서는 안 의도적인 악용 으로부터 리소스를 보호 하기 위해 신뢰할 수 없는 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-218">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="fdb0b-219">예를 들어 경우 메서드 `A` 문제를 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 사용 권한 및 다음 메서드만 호출 `B`, 메서드 `B` 명백히 재정의할 수 있습니다 합니다 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 실행 하 여는 <xref:System.Security.CodeAccessPermission.Assert%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-219">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="fdb0b-220">호출된 된 메서드는 스택의 상위에 항상 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-220">The called method is always higher in the stack.</span></span> <span data-ttu-id="fdb0b-221">따라서 경우 메서드 `B` 보안 시스템 보호 된 리소스에 액세스 하려고 하기 때문에를 사용 하 여 권한 검사 시작 메서드 `B` 즉각적인 호출자 이며 다음 단계를 안내 아래쪽이 있는지 확인 하려면 스택 없습니다 <xref:System.Security.CodeAccessPermission.Deny%2A> 또는 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 스택의 낮은 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-221">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="fdb0b-222">메서드 `B`, 리소스에 액세스 하려고 하는 사용 중지할 수는 스택 워크 즉시는 <xref:System.Security.CodeAccessPermission.Assert%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-222">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="fdb0b-223">이런 경우는 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 메서드에서 스택에 배치 `A` (호출 메서드)가 검색 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-223">In that case, the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="fdb0b-224"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> 비슷합니다 <xref:System.Security.CodeAccessPermission.Deny%2A>스택 워크는 성공이 고, 그렇지 때 있는 상황에서, 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-224"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is similar to <xref:System.Security.CodeAccessPermission.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="fdb0b-225">점이 <xref:System.Security.CodeAccessPermission.Deny%2A> 실패는 스택 워크는 사용 권한을 지정 하지만 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 실패 스택 워크가 발생 하지 않는 유일한 사용 권한을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-225">The difference is that <xref:System.Security.CodeAccessPermission.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.CodeAccessPermission.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span>  
  
 <span data-ttu-id="fdb0b-226">지정 된 리소스에 액세스 하려면 코드를 사용할 수 있도록 하려면이 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-226">Call this method to ensure that your code can be used to access only the specified resources.</span></span> <span data-ttu-id="fdb0b-227">에 대 한 호출 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 호출 코드에서 호출자로 반환 될 때까지 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-227">The call to <xref:System.Security.CodeAccessPermission.PermitOnly%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="fdb0b-228">하나의 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 프레임 활성 상태일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-228">Only one <xref:System.Security.CodeAccessPermission.PermitOnly%2A> can be active on a frame.</span></span> <span data-ttu-id="fdb0b-229">호출 하려는 시도가 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 때 활성 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 프레임 결과 따라 존재를 <xref:System.Security.SecurityException>입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-229">An attempt to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A> when an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="fdb0b-230">호출 <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> 나 <xref:System.Security.CodeAccessPermission.RevertAll%2A> 활성 제거할 <xref:System.Security.CodeAccessPermission.PermitOnly%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-230">Call <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span>  
  
 <span data-ttu-id="fdb0b-231"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> 해당 권한 요청에 실패 합니다 부여 되지 않은 사용 권한을 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-231"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="fdb0b-232">그러나 하위 호출에서 나중에 스택 하는 경우 호출 <xref:System.Security.CodeAccessPermission.Demand%2A> 해당 사용 권한에 대 한는 <xref:System.Security.SecurityException> 스택 워크를 호출 하려고 하는 코드에 도달할 때 발생 하는 <xref:System.Security.CodeAccessPermission.PermitOnly%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-232">However, if code lower on the call stack later calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span> <span data-ttu-id="fdb0b-233">코드는 호출 되므로이 작업이 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 에 권한이 부여 되지를 호출 했지만 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 해당 사용 권한에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-233">This is because the code that called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="fdb0b-234">호출 스택의 메서드 호출 스택의 상위에 메서드를 호출 낮은 호출 스택의 있도록에 일반적으로 하향식으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-234">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="fdb0b-235">There is already an active <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-235">There is already an active <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="fdb0b-236">
            <para>이 메서드를 재정의할 수 없습니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-236">
              <para>You cannot override this method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAll();" />
      <MemberSignature Language="F#" Value="static member RevertAll : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-237">Causes all previous overrides for the current frame to be removed and no longer in effect.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-237">Causes all previous overrides for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-238">재정의가 없습니다 경우 (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, 또는 <xref:System.Security.CodeAccessPermission.PermitOnly%2A>)는 현재 프레임에 대 한는 <xref:System.ExecutionEngineException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-238">If there are no overrides (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, or <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="fdb0b-239">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" />, or <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-239">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" />, or <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAssert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAssert();" />
      <MemberSignature Language="F#" Value="static member RevertAssert : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAssert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-240">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame to be removed and no longer in effect.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-240">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-241">없는 경우 없습니다 <xref:System.Security.CodeAccessPermission.Assert%2A> 현재 프레임에 대 한는 <xref:System.ExecutionEngineException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-241">If there is no <xref:System.Security.CodeAccessPermission.Assert%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="fdb0b-242">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-242">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertDeny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertDeny();" />
      <MemberSignature Language="F#" Value="static member RevertDeny : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertDeny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-243">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame to be removed and no longer in effect.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-243">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-244">없는 경우 없습니다 <xref:System.Security.CodeAccessPermission.Deny%2A> 현재 프레임에 대 한는 <xref:System.ExecutionEngineException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-244">If there is no <xref:System.Security.CodeAccessPermission.Deny%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="fdb0b-245">There is no previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-245">There is no previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertPermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertPermitOnly();" />
      <MemberSignature Language="F#" Value="static member RevertPermitOnly : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertPermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-246">Causes any previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame to be removed and no longer in effect.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-246">Causes any previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-247">없는 경우 없습니다 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 현재 프레임에 대 한는 <xref:System.ExecutionEngineException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-247">If there is no <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="fdb0b-248">There is no previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-248">There is no previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IPermission.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IPermission.Demand() = System::Security::IPermission::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberSignature Language="VB.NET" Value="Sub Assert () Implements IStackWalk.Assert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Assert() = System::Security::IStackWalk::Assert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IStackWalk.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Demand() = System::Security::IStackWalk::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberSignature Language="VB.NET" Value="Sub Deny () Implements IStackWalk.Deny" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Deny() = System::Security::IStackWalk::Deny;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Sub PermitOnly () Implements IStackWalk.PermitOnly" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.PermitOnly() = System::Security::IStackWalk::PermitOnly;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="codeAccessPermission.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-249">Creates and returns a string representation of the current permission object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-249">Creates and returns a string representation of the current permission object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fdb0b-250">A string representation of the current permission object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-250">A string representation of the current permission object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-251">이 메서드는 사용 권한을 문자열로 표시 해야 하는 경우 디버깅에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-251">This method is useful in debugging when you need to display the permission as a string.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement" Usage="codeAccessPermission.ToXml " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fdb0b-252">When overridden in a derived class, creates an XML encoding of the security object and its current state.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-252">When overridden in a derived class, creates an XML encoding of the security object and its current state.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fdb0b-253">An XML encoding of the security object, including any state information.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-253">An XML encoding of the security object, including any state information.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-254">보안 개체를 확장 하는 사용자 지정 코드를 구현 해야 합니다 <xref:System.Security.CodeAccessPermission.ToXml%2A> 및 <xref:System.Security.CodeAccessPermission.FromXml%2A> 개체 보안을 인코딩할 수 있도록 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-254">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fdb0b-255">다음 코드 예제에서는 <xref:System.Security.CodeAccessPermission.ToXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-255">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.ToXml%2A> method.</span></span> <span data-ttu-id="fdb0b-256">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Security.CodeAccessPermission> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-256">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="fdb0b-257">
            <para>파생된 클래스에서이 메서드를 재정의 해야 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-257">
              <para>You must override this method in a derived class.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Union (other As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Union other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="fdb0b-258">A permission to combine with the current permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-258">A permission to combine with the current permission.</span>
          </span>
          <span data-ttu-id="fdb0b-259">It must be of the same type as the current permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-259">It must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fdb0b-260">When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-260">When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fdb0b-261">A new permission that represents the union of the current permission and the specified permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-261">A new permission that represents the union of the current permission and the specified permission.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fdb0b-262">에 대 한 호출의 결과 <xref:System.Security.CodeAccessPermission.Union%2A> 현재 사용 권한 및 지정한 사용 권한의 권한 나타나는 모든 작업을 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-262">The result of a call to <xref:System.Security.CodeAccessPermission.Union%2A> is a permission that represents all the operations represented by both the current permission and the specified permission.</span></span> <span data-ttu-id="fdb0b-263">사용 권한 중 하나를 전달 하는 모든 요청 전달 합집합에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-263">Any demand that passes either permission passes their union.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fdb0b-264">다음 코드 예제에서는 <xref:System.Security.CodeAccessPermission.Union%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-264">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Union%2A> method.</span></span> <span data-ttu-id="fdb0b-265">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Security.CodeAccessPermission> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb0b-265">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="fdb0b-266">The <paramref name="other" /> parameter is not <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-266">The <paramref name="other" /> parameter is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="fdb0b-267">This method is only supported at this level when passed <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-267">This method is only supported at this level when passed <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="fdb0b-268">
            <para>파생된 클래스에서이 메서드를 재정의 해야 합니다. 경우에 사용 권한의 복사본을 반환 해야의 값을 <paramref name="other" /> 매개 변수는 <see langword="null" />합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="fdb0b-268">
              <para>You must override this method in a derived class. You should return a copy of the permission if the value of the <paramref name="other" /> parameter is <see langword="null" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>