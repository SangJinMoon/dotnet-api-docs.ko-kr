<Type Name="SecurityManager" FullName="System.Security.SecurityManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="51b52be500a5be1b9b263e9528638a7f09b2cb2a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500687" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class SecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed SecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.SecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class SecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityManager abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>보안 시스템과 상호 작용하는 클래스에 대한 주 액세스 지점을 제공합니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 보안 액세스 하 고 보안 정책 구성을 처리 하는 메서드를 제공 합니다. 인스턴스를 만들 수 <xref:System.Security.SecurityManager>합니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CheckExecutionRights">
      <MemberSignature Language="C#" Value="public static bool CheckExecutionRights { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckExecutionRights" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.CheckExecutionRights" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckExecutionRights As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckExecutionRights { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>코드에 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" />이 있어야 실행할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          코드에 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" />이 있어야 실행할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성이 `false`, 없이 코드에도 <xref:System.Security.Permissions.SecurityPermissionFlag.Execution> 실행할 수 있습니다. 실행 검사 상당히 소모 되며 지연 정책 결정의 장점의 제거할 수 있습니다. 필요한 경우 실행 검사 하지 않으려면이 속성은 제공 합니다.  
  
 이 속성에 대 한 변경 될 때까지 지속 되지 않는 <xref:System.Security.SecurityManager.SavePolicy%2A> 호출 됩니다. 레지스트리에 유지 될 때까지 새 프로세스 변경의 적용 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">이 메서드를 호출하는 코드에 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />가 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">정책을 수정할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThreadRequiresSecurityContextCapture">
      <MemberSignature Language="C#" Value="public static bool CurrentThreadRequiresSecurityContextCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CurrentThreadRequiresSecurityContextCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CurrentThreadRequiresSecurityContextCapture () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CurrentThreadRequiresSecurityContextCapture();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>나중 시점에 현재 스레드의 보안 상태를 다시 만들어야 하는 경우 현재 스레드에서 보안 컨텍스트 캡처를 요구할지 여부를 결정합니다.</summary>
        <returns>
          스택에 부분적으로 신뢰할 수 있는 응용 프로그램 도메인, 부분적으로 신뢰할 수 있는 어셈블리 및 현재 활성인 <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> 또는 <see cref="M:System.Security.CodeAccessPermission.Deny" /> 한정자가 포함되어 있으면 <see langword="false" />이고, 공용 언어 런타임에서 스택에 이러한 한정자가 포함되어 있지 않음을 보장할 수 없으면 <see langword="true" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> 성공적인 보안 요구 후에 얻은 중요 한 데이터를 캐시 하기 전에 메서드.  
  
 경우는 <xref:System.Security.CodeAccessPermission.Assert%2A> 메서드를 호출한 더 높은 스택에, 해당 보안 컨텍스트를 캡처하지 않고 데이터를 캐시 하지 않아야 합니다. 그렇지 않으면 중요 한 데이터에서 가져온는 <xref:System.Security.CodeAccessPermission.Assert%2A> 코드에 사용할 수 있게와 더 이상 실행 되지 <xref:System.Security.CodeAccessPermission.Assert%2A> 위치에 없습니다.  
  
> [!IMPORTANT]
>  반환 값은 신뢰할 수 있는 경우에 `false`, 스레드가 필요한 보안 컨텍스트 캡처 수 없도록 보장을 의미 합니다. 보안 컨텍스트 캡처 보안 취약성을 방지 하기 위해 필요 하지 않은 경우 메서드가 true 반환할 수 있습니다.  
  
 <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> 보안에 중요 한 이므로 주 용도 불필요 한 보안 컨텍스트를 방지 하기 위해 캡처를 사용 하는 코드 보안에 중요 하 고 감사 해야 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStandardSandbox">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet GetStandardSandbox (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet GetStandardSandbox(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ GetStandardSandbox(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">권한 집합에 일치시킬 호스트 증명 정보입니다.</param>
        <summary>제공된 증명 정보가 있는 응용 프로그램에 부여하는 데 안전한 권한 집합을 가져옵니다.</summary>
        <returns>제공된 증명 정보가 있는 응용 프로그램에 대한 권한 부여 설정으로 사용 가능한 권한 집합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  에 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 증명 정보에 호스트 `evidence` 포함 해야 합니다 <xref:System.Security.Policy.Zone?displayProperty=nameWithType> 증명 정보입니다.  
>   
>  다음 표에서 각 영역에 대해 반환 되는 사용 권한 집합을 보여 줍니다.  
  
|영역|권한 집합|  
|----------|--------------------|  
|<xref:System.Security.SecurityZone.MyComputer>|`FullTrust`|  
|<xref:System.Security.SecurityZone.Intranet>|`LocalIntranet`|  
|<xref:System.Security.SecurityZone.Trusted>|`Internet`|  
|<xref:System.Security.SecurityZone.Internet>|`Internet`|  
|<xref:System.Security.SecurityZone.Untrusted>|없음|  
|<xref:System.Security.SecurityZone.NoZone>|없음|  
  
 다른 증명 정보 같은 <xref:System.Security.Policy.Url> 또는 <xref:System.Security.Policy.Site>, 간주 될 수 있습니다.  
  
 반환 된 권한 집합 응용 프로그램을 실행 하는 샌드박스에서 사용할 수 있습니다. 참고가이 방법의 정책을 지정 하지 않습니다 되지만 호스트 응용 프로그램에서 요청한 권한 집합이 합리적인 인지 확인 하는 데 도움이 됩니다. 샌드박스에 영역을 매핑할이 메서드를 사용할 수 있습니다.  
  
   
  
## Examples  
 사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Security.SecurityManager.GetStandardSandbox%2A> 샌드 박싱된 응용 프로그램에 대 한 사용 권한을 얻는 메서드를 설정 합니다. 샌드박스에서 응용 프로그램을 실행 하는 방법에 대 한 자세한 내용은 참조 [하는 방법: 부분적으로 신뢰할 수 있는 코드 실행 샌드박스에서](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)합니다.  
  
 [!code-csharp[sandboxingApis#1](~/samples/snippets/csharp/VS_Snippets_CLR/SandboxingAPIs/CS/program.cs#1)]
 [!code-vb[sandboxingApis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SandboxingAPIs/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetZoneAndOrigin">
      <MemberSignature Language="C#" Value="public static void GetZoneAndOrigin (out System.Collections.ArrayList zone, out System.Collections.ArrayList origin);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetZoneAndOrigin([out] class System.Collections.ArrayList&amp; zone, [out] class System.Collections.ArrayList&amp; origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetZoneAndOrigin (ByRef zone As ArrayList, ByRef origin As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetZoneAndOrigin([Runtime::InteropServices::Out] System::Collections::ArrayList ^ % zone, [Runtime::InteropServices::Out] System::Collections::ArrayList ^ % origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="zone" Type="System.Collections.ArrayList&amp;" RefType="out" />
        <Parameter Name="origin" Type="System.Collections.ArrayList&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="zone">부여된 <see cref="T:System.Collections.ArrayList" /> 개체의 <see cref="P:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone" />가 들어 있는 출력 매개 변수입니다.</param>
        <param name="origin">부여된 <see cref="T:System.Collections.ArrayList" /> 개체의 <see cref="T:System.Security.Permissions.UrlIdentityPermission" />가 들어 있는 출력 매개 변수입니다.</param>
        <summary>현재 어셈블리에 부여된 영역 ID 및 URL ID 권한 집합을 가져옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 대신이이 메서드를 호출 하는 실행 중인 어셈블리에 대 한 URL 및 영역 증명 정보를 사용 하는 것 <xref:System.Security.SecurityManager.ResolvePolicy%2A> 각 증거 형식에 대 한 합니다. 반환 된 사용 권한 집합은 <xref:System.Security.SecurityManager.ResolvePolicy%2A> 호출 영역 및 원본 URL에 따라 실행 중인 어셈블리에 부여 된 권한을 식별 합니다.  
  
> [!NOTE]
>  이 멤버에는 올바른 암호화 키가 아니라 의사 키 있는 ECMA 공개 키에 대 한 링크 요청을 만듭니다. .NET Framework 내에서 링크 요청 ECMA 의사 키에 대 한 자동으로 Microsoft 공개 키에 대 한 링크 요청으로 변환 됩니다. 보안 예외가 ECMA 의사 키가 아니라 Microsoft 공개 키를 기반으로 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" />에 대한 요청이 실패한 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsGranted">
      <MemberSignature Language="C#" Value="public static bool IsGranted (System.Security.IPermission perm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsGranted(class System.Security.IPermission perm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.IsGranted(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsGranted (perm As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsGranted(System::Security::IPermission ^ perm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="perm" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="perm">호출자 부여에 대하여 검사할 사용 권한입니다.</param>
        <summary>호출자에 사용 권한을 부여했는지 여부를 확인합니다.</summary>
        <returns>
          <paramref name="perm" /> 권한 등의 사용 권한이 호출자에게 부여되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 권한 부여 정책에 따라 결정 및는 어설션과 같은 재정의 하기 쉬운 요청과와에서 다릅니다. 또한 <xref:System.Security.SecurityManager.IsGranted%2A> 부여 스택의 다른 호출자에 게 독립적 호출 코드 어셈블리를 검사 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromFile">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile (string path, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile(string path, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromFile (path As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromFile(System::String ^ path, System::Security::PolicyLevelType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="path">보안 정책 정보를 포함하는 파일에 대한 실제 파일 경로입니다.</param>
        <param name="type">로드할 정책 수준 유형을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 파일에서 <see cref="T:System.Security.Policy.PolicyLevel" />을 로드합니다.</summary>
        <returns>로드된 정책 수준입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 매개 변수가 나타내는 파일이 없습니다.</exception>
        <exception cref="T:System.Security.SecurityException">이 메서드를 호출하는 코드에 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />가 없는 경우  
  
 또는  
  
 이 메서드를 호출하는 코드에 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />가 없는 경우  
  
 또는  
  
 이 메서드를 호출하는 코드에 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />가 없는 경우  
  
 또는  
  
 이 메서드를 호출하는 코드에 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />가 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">이 메서드는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 더 이상 사용되지 않는 CAS(코드 액세스 보안) 정책을 사용합니다. 이전 버전의 .NET Framework와의 호환성에 대한 CAS 정책을 사용하도록 설정하려면 [&lt;legacyCasPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)를 사용합니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">보고 하 여 정책을 수정할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromString">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromString (string str, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromString(string str, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromString (str As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromString(System::String ^ str, System::Security::PolicyLevelType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="str">구성 파일에 나타나는 것과 같은 형식으로 된 보안 정책 수준의 XML 표현입니다.</param>
        <param name="type">로드할 정책 수준 유형을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 문자열에서 <see cref="T:System.Security.Policy.PolicyLevel" />을 로드합니다.</summary>
        <returns>로드된 정책 수준입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> 매개 변수가 잘못된 경우</exception>
        <exception cref="T:System.Security.SecurityException">이 메서드를 호출하는 코드에 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />가 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">보고 하 여 정책을 수정할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PolicyHierarchy">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator PolicyHierarchy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator PolicyHierarchy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.PolicyHierarchy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PolicyHierarchy () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ PolicyHierarchy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컴퓨터 정책 및 사용자 정책과 같은 보안 정책 계층 구조에 수준별로 액세스하기 위한 열거자를 제공합니다.</summary>
        <returns>보안 정책 계층 구조를 구성하는 <see cref="T:System.Security.Policy.PolicyLevel" /> 개체에 대한 열거자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 열거자를 제공 연속 <xref:System.Security.Policy.PolicyLevel> 해당 정책을 나타내는 개체 (컴퓨터, 사용자, 엔터프라이즈, 응용 프로그램 도메인) 계층의 수준입니다. 이러한 개체는 정책 라이브 개체입니다. 이러한 개체를 변경 하면 예기치 않은 결과가 있을 수 있습니다.  
  
 최소 정책 계층 구조의 컴퓨터 수준, 엔터프라이즈 수준 및 사용자 수준 구성 됩니다. 그러나 계층 수준을 포함할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 더 이상 사용되지 않는 CAS(코드 액세스 보안) 정책을 사용합니다. 이전 버전의 .NET Framework와의 호환성에 대한 CAS 정책을 사용하도록 설정하려면 [&lt;legacyCasPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)를 사용합니다.</exception>
        <exception cref="T:System.Security.SecurityException">이 메서드를 호출하는 코드에 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />가 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">보고 하 여 정책을 수정할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolvePolicy">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>코드에 부여할 사용 권한을 결정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">정책을 평가하는 데 사용되는 증명 정보 집합입니다.</param>
        <summary>지정한 증명 정보에 따라 코드에 부여할 권한을 결정합니다.</summary>
        <returns>보안 시스템에서 부여할 수 있는 사용 권한 집합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 호출 코드의 id의 증명 정보를 제공 하는 보안 정책 엔진을 호출 합니다. 결과 보안 정책에 의해 결정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 더 이상 사용되지 않는 CAS(코드 액세스 보안) 정책을 사용합니다. 이전 버전의 .NET Framework와의 호환성에 대한 CAS 정책을 사용하도록 설정하려면 [&lt;legacyCasPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)를 사용합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence[] evidences);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence[] evidences) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ResolvePolicy (evidences As Evidence()) As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(cli::array &lt;System::Security::Policy::Evidence ^&gt; ^ evidences);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidences" Type="System.Security.Policy.Evidence[]" />
      </Parameters>
      <Docs>
        <param name="evidences">정책을 평가하는 데 사용되는 증명 정보 개체의 배열입니다.</param>
        <summary>지정한 증명 정보에 따라 코드에 부여할 권한을 결정합니다.</summary>
        <returns>제공된 모든 증명 정보에 적합한 사용 권한 집합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 호출의 배열을 사용 하 여 제공 하는 보안 정책 엔진 <xref:System.Security.Policy.Evidence> 개체입니다. 반환 된 권한 집합에는 배열에 있는 모든 증명 정보에 적용 되는 권한을만 나타냅니다. 이러한 권한은 동일 하거나 하위 집합 정책 각 개별 증거에 부여한 사용 권한을 적용 합니다. 이 메서드는 각에서 정책을 확인의 결과에 교차를 수행 하는 경우에 따라 동작는 <xref:System.Security.Policy.Evidence> 배열의 개체에에서 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 더 이상 사용되지 않는 CAS(코드 액세스 보안) 정책을 사용합니다. 이전 버전의 .NET Framework와의 호환성에 대한 CAS 정책을 사용하도록 설정하려면 [&lt;legacyCasPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)를 사용합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence, System.Security.PermissionSet reqdPset, System.Security.PermissionSet optPset, System.Security.PermissionSet denyPset, out System.Security.PermissionSet denied);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet reqdPset, class System.Security.PermissionSet optPset, class System.Security.PermissionSet denyPset, [out] class System.Security.PermissionSet&amp; denied) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ reqdPset, System::Security::PermissionSet ^ optPset, System::Security::PermissionSet ^ denyPset, [Runtime::InteropServices::Out] System::Security::PermissionSet ^ % denied);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="reqdPset" Type="System.Security.PermissionSet" />
        <Parameter Name="optPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denyPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denied" Type="System.Security.PermissionSet&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="evidence">정책을 평가하는 데 사용되는 증명 정보 집합입니다.</param>
        <param name="reqdPset">코드를 실행하는 데 필요한 권한입니다.</param>
        <param name="optPset">부여될 경우에 사용되지만 코드가 실행되는 데 필요하지는 않은 선택적 권한입니다.</param>
        <param name="denyPset">정책에서 허용하는 경우에도 코드에 절대 부여되지 않아야 하는 거부된 권한입니다.</param>
        <param name="denied">부여되지 않은 사용 권한 집합을 포함하는 출력 매개 변수입니다.</param>
        <summary>지정한 증명 정보 및 요청에 따라 코드에 부여할 권한을 결정합니다.</summary>
        <returns>보안 시스템에서 부여하는 사용 권한 집합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 호출의 코드 호출 코드의 id 및 사용 권한 집합에 제공 하는 보안 정책 엔진 요청 합니다. 결과 보안 정책에 의해 결정 됩니다. 이 메서드는 보안 시스템에서 부여 될 사용 권한 집합을 반환 하 고 출력 매개 변수로 거부 될 수 있는 사용 권한 집합을 반환 합니다. 유효 이전에 부여한 사용 권한을의 거부 집합에 없는 부여 된 권한 집합입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 더 이상 사용되지 않는 CAS(코드 액세스 보안) 정책을 사용합니다. 이전 버전의 .NET Framework와의 호환성에 대한 CAS 정책을 사용하도록 설정하려면 [&lt;legacyCasPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)를 사용합니다.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">정책이 <paramref name="reqdPset" /> 매개 변수로 지정된 최소 필수 권한을 부여하지 못하는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicyGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator ResolvePolicyGroups (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator ResolvePolicyGroups(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ ResolvePolicyGroups(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">정책이 평가되는 증명 정보 집합입니다.</param>
        <summary>지정한 증명 정보와 일치하는 코드 그룹의 컬렉션을 가져옵니다.</summary>
        <returns>증명 정보와 일치하는 코드 그룹 집합의 열거형입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 지정 된 정책 구성이 어떤 방식으로 특정 종류의 증명 정보를 분석에 유용 합니다.  
  
 코드 그룹 정책 계층 구조 비교의 적용 가능한 모든 수준에서 반환 됩니다는 `evidence` 매개 변수입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 더 이상 사용되지 않는 CAS(코드 액세스 보안) 정책을 사용합니다. 이전 버전의 .NET Framework와의 호환성에 대한 CAS 정책을 사용하도록 설정하려면 [&lt;legacyCasPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)를 사용합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSystemPolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolveSystemPolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolveSystemPolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolveSystemPolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">정책을 평가하는 데 사용되는 증명 정보 집합입니다.</param>
        <summary>
          <see cref="T:System.AppDomain" /> 수준의 정책을 제외하고 지정한 증명 정보에 따라 코드에 부여할 권한을 결정합니다.</summary>
        <returns>보안 시스템에서 부여할 수 있는 사용 권한 집합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 보안 정책 엔진을 호출 하 고 호출 코드의 id의 증명 정보를 제공 합니다. 결과 제외한 모든 시스템 보안 정책에 의해 결정 <xref:System.AppDomain> 정책입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 더 이상 사용되지 않는 CAS(코드 액세스 보안) 정책을 사용합니다. 이전 버전의 .NET Framework와의 호환성에 대한 CAS 정책을 사용하도록 설정하려면 [&lt;legacyCasPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)를 사용합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SavePolicy">
      <MemberSignature Language="C#" Value="public static void SavePolicy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicy ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>수정된 보안 정책 상태를 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는로 노출 정책을 저장 <xref:System.Security.SecurityManager.PolicyHierarchy%2A>, <xref:System.Security.Policy.PolicyLevel>, 및 기타 보안 정책의 구성을 나타내는 클래스입니다. 이 메서드를 호출 하지 않으면 정책 개체에 대 한 변경 내용이 저장 되지 않습니다 및 후속 응용 프로그램 실행에 영향을 주지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 더 이상 사용되지 않는 CAS(코드 액세스 보안) 정책을 사용합니다. 이전 버전의 .NET Framework와의 호환성에 대한 CAS 정책을 사용하도록 설정하려면 [&lt;legacyCasPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)를 사용합니다.</exception>
        <exception cref="T:System.Security.SecurityException">이 메서드를 호출하는 코드에 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />가 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">정책을 수정할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SavePolicyLevel">
      <MemberSignature Language="C#" Value="public static void SavePolicyLevel (System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicyLevel(class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicyLevel (level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicyLevel(System::Security::Policy::PolicyLevel ^ level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="level">저장할 정책 수준 개체입니다.</param>
        <summary>
          <see cref="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" />을 사용하여 로드된 수정된 보안 정책 수준을 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Policy.PolicyLevel> 로드 된 같은 위치에 저장 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">이 메서드를 호출하는 코드에 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />가 없는 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 더 이상 사용되지 않는 CAS(코드 액세스 보안) 정책을 사용합니다. 이전 버전의 .NET Framework와의 호환성에 대한 CAS 정책을 사용하도록 설정하려면 [&lt;legacyCasPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)를 사용합니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">정책을 수정할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityEnabled">
      <MemberSignature Language="C#" Value="public static bool SecurityEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SecurityEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.SecurityEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SecurityEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The security manager cannot be turned off on MS runtime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>보안의 활성화 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          보안이 활성화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 사용 되는 [Caspol.exe (코드 액세스 보안 정책 도구)](~/docs/framework/tools/caspol-exe-code-access-security-policy-tool.md)  
  
 `-security` (`-s`) 코드 기반 보안을 해제 하는 옵션입니다.  
  
 <xref:System.Security.SecurityManager.SecurityEnabled%2A> 관리자가 코드 액세스 보안을 사용 하지 않도록 설정할 수 있는 방법을 제공 합니다. 코드 액세스 보안을 해제하면 모든 코드 액세스 요청이 성공합니다. 모든 코드 부여 효과적으로 `FullTrust`합니다. 코드를 수행할 수 있도록 보안 시스템을 무시 코드 액세스 보안을 해제 하면 해당 하는 보안 정책 부여 보다 조금 더 나은 `FullTrust` 모든 코드입니다. 이 속성은 역할 기반 보안을 비활성화 하지 않습니다. 따라서 <xref:System.Security.Permissions.PrincipalPermission> 수요에 영향을 받지 않습니다.  
  
> [!CAUTION]
>  그러나 코드 액세스 보안을 해제하면 시스템이 바이러스나 웜과 같은 악의적 코드를 사용한 공격에 취약해집니다. 코드 액세스 보안을 해제 하면 관리 되는 코드의 어떤 방식으로 실행이 자동으로 차단 되지 않습니다. It 부서에서 유일한 원인은 관리 코드가 코드 액세스 보안 시스템에서 제한 없이 실행 및 가장 극단적인 주의 해 서 수행 해야 합니다. 보안 성능을 추가로 얻을을 해제 해야 경우에 수행할 시스템 보안 보호를 위해 수행 된 다른 보안 조치입니다. 다른 보안 예방 조치의 예로 공용 네트워크에서 연결을 끊거나 컴퓨터를 물리적으로 보호하는 경우를 들 수 있습니다.  
  
 이 속성에 대 한 변경 될 때까지 레지스트리 지속 되지 않으므로 <xref:System.Security.SecurityManager.SavePolicy%2A> 호출 됩니다. 레지스트리에 유지 될 때까지 새 프로세스 변경의 적용 되지 않습니다. 실행 중인 프로세스에서이 속성의 값을 변경 반드시 바뀌지 않습니다 상태 정상적으로. 호출 해야 변경 사항이 적용 되도록 <xref:System.Security.SecurityManager.SavePolicy%2A> 새 프로세스를 시작 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">이 메서드를 호출하는 코드에 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />가 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">정책을 수정할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>