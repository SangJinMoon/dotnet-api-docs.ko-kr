<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d374acbfa59bece9a23ff4841ba74263d0c6fa42" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30630717" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.Windows.Documents.FlowDocument" /> 또는 <see cref="T:System.Windows.Controls.TextBlock" /> 내의 위치를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer> 클래스에서는 다음 용어를 소개 합니다.  
  
-   위치-기본적으로, 한 <xref:System.Windows.Documents.TextPointer> 항상 가리키는 *위치* 콘텐츠에 합니다.  이러한 위치 또는 흐름의 콘텐츠를 문자 간에 콘텐츠 요소 태그를 삽입 하는 콘텐츠에 대 한 구조를 정의 합니다.  
  
-   때문에 현재 위치-는 <xref:System.Windows.Documents.TextPointer> 항상 한 위치를 나타내고 않기 때문에 여러 작업을 통해 수행할 수 있는 <xref:System.Windows.Documents.TextPointer> 에서 가리키는 현재 위치를 기준으로는 <xref:System.Windows.Documents.TextPointer>로 참조 하는 의미가 으로 지정 된 위치는 <xref:System.Windows.Documents.TextPointer> 로 *현재 위치*합니다.  
  
-   삽입 위치-는 *삽입 위치* 연결된 콘텐츠에 대 한 의미 체계 규칙을 위반 하지 않고 새 콘텐츠를 추가할 수 있는 위치입니다.  실제로, 삽입 위치는 콘텐츠 내에 캐럿 위치 지정할 수 있습니다.  유효한의 예로 <xref:System.Windows.Documents.TextPointer> 삽입 위치 하지 않은 위치는 인접 한 두 사이의 위치 <xref:System.Windows.Documents.Paragraph> 태그 (즉, 이전 단락의 닫는 태그와 여는 태그 다음 단락의 사이).  
  
-   목적에 대 한 기호- <xref:System.Windows.Documents.TextPointer> 것으로 간주 됩니다 기호를 포함 하는 작업을 다음 중 하나는 *기호*:  
  
    -   여는 태그 또는 닫는 태그가 <xref:System.Windows.Documents.TextElement> 요소입니다.  
  
    -   A <xref:System.Windows.UIElement> 내에 포함 된 요소는 <xref:System.Windows.Documents.InlineUIContainer> 또는 <xref:System.Windows.Documents.BlockUIContainer>합니다.  이러한은 <xref:System.Windows.UIElement> 항상 정확히 하나의 기호; 추가 내용 또는 요소에 포함 된 것으로 간주 됩니다는 <xref:System.Windows.UIElement> 기호로 계산 되지 않습니다.  
  
    -   각각 16 비트 [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] 텍스트 내부에서 문자 <xref:System.Windows.Documents.Run> 요소입니다.  
  
-   텍스트 컨테이너-A *텍스트 컨테이너* 최종 테두리에 유동 콘텐츠를 구성 하는 요소 않으면 나타내는 위치는 <xref:System.Windows.Documents.TextPointer> 항상 텍스트 컨테이너 내에 속합니다.  현재 텍스트 컨테이너 중 하나 여야 합니다는 <xref:System.Windows.Documents.FlowDocument> 또는 <xref:System.Windows.Controls.TextBlock>합니다.  일반적으로 사이의 연산은 <xref:System.Windows.Documents.TextPointer> 인스턴스가 다양 한 텍스트 컨테이너에서 지원 되지 않습니다.  
  
-   문서-텍스트 컨테이너의 콘텐츠 라고는 *문서*에서 같이 <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> 메서드 및 <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> 및 <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> 속성입니다.  
  
 <xref:System.Windows.Documents.TextPointer> 클래스 쉽게 탐색 하 고 막대로 콘텐츠의 조작 하기 위한 용도가 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 유동 콘텐츠 요소; 등의 요소에서 파생 되는 일반적으로 <xref:System.Windows.Documents.TextElement>합니다.  일부 작업 하는 <xref:System.Windows.Documents.TextPointer> 용이 하 게는 다음과 같습니다.  
  
-   두 번째 지정 된 위치와 현재 위치 하는 서 수 비교를 수행 합니다.  참조는 <xref:System.Windows.Documents.TextPointer.CompareTo%2A> 메서드.  
  
-   지정 된 방향으로 현재 위치에 인접 한 콘텐츠의 형식을 결정 합니다.  참조는 <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> 메서드 및 <xref:System.Windows.Documents.TextPointerContext> 열거 합니다.  
  
-   가져오기는 <xref:System.Windows.Documents.TextElement> 범위를 지정 하거나 현재 위치에 인접 한입니다.  참조 <xref:System.Windows.Documents.Paragraph> 및 <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> 메서드.  
  
-   현재 문서의 범위를 지정 하는 텍스트 컨테이너를 가져옵니다.  <xref:System.Windows.Documents.TextPointer.Parent%2A> 속성을 참조하세요.  
  
-   지정된 된 수를의 문자 앞 또는 뒤의 현재 위치를 가져옵니다.  참조는 <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> 메서드.  
  
-   현재 위치에 문자열을 삽입 합니다.  참조는 <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> 메서드.  
  
-   줄 경계를 콘텐츠를 찾습니다.  참조는 <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> 메서드 및 <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> 속성입니다.  
  
-   사이 변환 <xref:System.Windows.Documents.TextPointer> 콘텐츠로 위치와 기호 오프셋 합니다.  참조는 <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> 및 <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> 메서드.  
  
-   간에 변환 하 여 시각적 적중 테스트 수행을 <xref:System.Windows.Documents.TextPointer> 위치 및 <xref:System.Windows.Point> 상대 좌표를 나타내는입니다.  
  
-   근접 한 삽입 위치를 찾거나 삽입 위치 현재 위치 인지 확인 하십시오.  참조는 <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> 및 <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> 메서드 및 <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> 속성입니다.  
  
 위치 및 <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> 가리키는 <xref:System.Windows.Documents.TextPointer> 개체는 변경할 수 없습니다.  콘텐츠 편집 하거나 수정 하 여 지정 된 위치는 <xref:System.Windows.Documents.TextPointer> ; 주변 텍스트를 기준으로 바뀌지 않으면 대신 콘텐츠의 시작 부분에서 해당 위치의 오프셋 새 상대 위치를 반영 하도록 알맞게 조정 됩니다 콘텐츠입니다.  예를 들어 한 <xref:System.Windows.Documents.TextPointer> 나타내는 콘텐츠를 삽입 하거나 앞 이나 뒤 단락을 삭제할 경우에 해당 단락 시작 부분을 가리키도록 지정 단락 시작 부분에 위치를 계속 합니다.  
  
 <xref:System.Windows.Documents.TextPointer> 클래스는 공용 생성자를 제공 하지 않습니다.  인스턴스 <xref:System.Windows.Documents.TextPointer> 속성이 나 다른 개체의 메서드를 사용 하 여 생성 됩니다 (다른를 포함 하 여 <xref:System.Windows.Documents.TextPointer> 개체). 다음 목록에서는 메서드 및 속성 만들고 반환 하는 몇 가지 예는 <xref:System.Windows.Documents.TextPointer>합니다.  이 목록은 완벽 하지는:  
  
-   <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> 및 <xref:System.Windows.Documents.TextRange.End%2A>합니다.  
  
-   <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, 및 <xref:System.Windows.Documents.TextElement.ElementEnd%2A>합니다.  
  
-   <xref:System.Windows.Controls.TextBlock> (텍스트 컨테이너): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, 및 <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>합니다.  
  
-   <xref:System.Windows.Documents.FlowDocument> (텍스트 컨테이너): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, 및 <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   기존 <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, 및 <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Documents.TextPointer> 첫 번째 내부 위치 찾으려면 <xref:System.Windows.Documents.Run> 된 지정 된 텍스트 컨테이너의에서 요소입니다.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 다음 예제에서는 사용 하 여 단순한 찾기 알고리즘 구현 <xref:System.Windows.Documents.TextPointer> 시설을 운영 합니다.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">현재 위치와 비교할 위치를 지정하는 <see cref="T:System.Windows.Documents.TextPointer" />입니다.</param>
        <summary>현재 <see cref="T:System.Windows.Documents.TextPointer" />와 지정된 두 번째 <see cref="T:System.Windows.Documents.TextPointer" />에 지정된 위치 사이에 서수 비교를 수행합니다.</summary>
        <returns>현재 <see cref="T:System.Windows.Documents.TextPointer" />가 <paramref name="position" /> 앞에 오면 –1이고, 위치가 동일하면 0이고, 현재 <see cref="T:System.Windows.Documents.TextPointer" />가 <paramref name="position" /> 뒤에 오면 +1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 -1 값을 현재 지정 된 위치가 <xref:System.Windows.Documents.TextPointer> 로 지정 된 위치를 앞에 오는 `position`합니다.  0 값 표시 되는 위치가 같음을 나타냅니다.  값이 양의 + 1 이면 현재 지정 된 위치가 <xref:System.Windows.Documents.TextPointer> 로 지정 된 위치 뒤에 오는 `position`합니다.  
  
   
  
## Examples  
 다음 예제에서는이 메서드에 대 한 사용을 보여 줍니다.  예제에서는 <xref:System.Windows.Documents.TextPointer.CompareTo%2A> 함께에서 메서드를 사용는 <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> 메서드는 지정 된 있는지 여부를 테스트 <xref:System.Windows.Documents.TextElement> 비어 있습니다.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" />이 현재 위치와 연결된 텍스트 컨테이너의 외부 위치를 지정하는 경우</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">현재 위치에서 시작하는 삭제할 문자 수입니다. 현재 위치 뒤에 오는 문자를 삭제하려면 양수 값을 지정하고, 현재 위치 앞에 오는 문자를 삭제하려면 음수 값을 지정합니다.</param>
        <summary>현재 <see cref="T:System.Windows.Documents.TextPointer" />로 표시되는 위치에서 지정된 수의 문자를 삭제합니다.</summary>
        <returns>실제로 삭제할 문자의 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 위치 뒤에 있는 문자를 삭제 하려면 양수 값을 지정 (에서 같이 <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); 문자 앞에 현재 위치를 삭제 하려면 음수 값을 지정 (에서 같이 <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 실제로 삭제 되는 문자 수로 지정 된 수보다 작을 수도 있습니다 `count`합니다.  경우에 이런 여기서 `count` 삭제할 존재 하는 보다 많은 문자를 지정 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">텍스트를 사용할 수 없는 위치에서 메서드가 호출됩니다.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치와 연결된 텍스트 컨테이너의 콘텐츠 끝 부분에서 <see cref="T:System.Windows.Documents.TextPointer" />를 가져옵니다.</summary>
        <value>현재 위치와 연결된 텍스트 컨테이너의 콘텐츠 끝 부분에 있는 <see cref="T:System.Windows.Documents.TextPointer" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> 반환 된 작업에 대 한 <xref:System.Windows.Documents.TextPointer> 은 항상 텍스트 컨테이너 (<xref:System.Windows.Controls.TextBlock> 또는 <xref:System.Windows.Documents.FlowDocument>), 아닌 <xref:System.Windows.Documents.TextElement>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치와 연결된 텍스트 컨테이너의 콘텐츠 시작 부분에서 <see cref="T:System.Windows.Documents.TextPointer" />를 가져옵니다.</summary>
        <value>현재 위치와 연결된 텍스트 컨테이너의 콘텐츠 시작 부분에 있는 <see cref="T:System.Windows.Documents.TextPointer" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다른 위치에 상대적인 오프셋으로를 기본 위치로이 속성에서 반환 되는 위치를 사용 합니다.  <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> 및 <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> 메서드는 위치와 위치 사이 변환 하는 방법을 제공 만큼 오프셋 합니다.  
  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> 반환 된 작업에 대 한 <xref:System.Windows.Documents.TextPointer> 은 항상 텍스트 컨테이너 (<xref:System.Windows.Controls.TextBlock> 또는 <xref:System.Windows.Documents.FlowDocument>), 아닌 <xref:System.Windows.Documents.TextElement>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">인접한 요소를 검색할 논리 방향을 지정하는 <see cref="T:System.Windows.Documents.LogicalDirection" /> 값 중 하나입니다.</param>
        <summary>지정된 논리 방향으로 현재 <see cref="T:System.Windows.Documents.TextPointer" />에 인접한 요소가 있으면 반환합니다.</summary>
        <returns>지정된 <paramref name="direction" />으로 인접한 요소입니다. 인접한 요소가 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 요소는 일반적으로 <xref:System.Windows.Documents.TextElement>합니다.  A <xref:System.Windows.UIElement> 반환 될 수는 <xref:System.Windows.Documents.TextPointer> 내부 위치를 나타내는 <xref:System.Windows.Documents.BlockUIContainer> 요소 또는 <xref:System.Windows.Documents.InlineUIContainer> 요소입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">콘텐츠 경계 상자를 찾을 논리 방향을 지정하는 <see cref="T:System.Windows.Documents.LogicalDirection" /> 값 중 하나입니다.</param>
        <summary>지정된 논리 방향으로 현재 <see cref="T:System.Windows.Rect" />에 인접한 콘텐츠의 경계 상자(<see cref="T:System.Windows.Documents.TextPointer" />)를 반환합니다.</summary>
        <returns>지정된 논리 방향으로 현재 <see cref="T:System.Windows.Documents.TextPointer" />에 인접한 콘텐츠의 경계 상자입니다. 현재 올바른 레이아웃 정보를 사용할 수 없는 경우 <see cref="P:System.Windows.Rect.Empty" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> 가장자리는이 방법의 목적에 대 한 콘텐츠를 고려 하지 않습니다.  경우는 <xref:System.Windows.Documents.TextPointer> 앞에 배치 되는 <xref:System.Windows.Documents.TextElement> 경계 면 반환 값은 다음에 대 한 경계 상자 비-<xref:System.Windows.Documents.TextElement> 지정된 된 방향으로 콘텐츠입니다.  너비가 0 인 지정된 된 방향으로 콘텐츠가 없는 경우 <xref:System.Windows.Rect> 높이 이전 콘텐츠를 일치 하는 높이 함께 반환 됩니다.  
  
 이 메서드에 의해 수행 되는 작업은 올바른 레이아웃에 따라 달라 집니다.  필요한 경우이 메서드는 작업을 진행 하기 전에 유효한 레이아웃을 자동으로 다시 생성 하려고 합니다.  레이아웃을 다시 생성 하는 작업 상대적으로 비용이 많이 들 수 있습니다.  사용 하 여는 <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> 레이아웃을 다시 생성 될 수도 있는 작업을 수행 하기 전에 유효한 레이아웃에 대해 확인할 속성입니다.  자세한 내용은 참조 [레이아웃](~/docs/framework/wpf/advanced/layout.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">가장 가까운 삽입 위치를 검색할 논리 방향을 지정하는 <see cref="T:System.Windows.Documents.LogicalDirection" /> 값 중 하나입니다.</param>
        <summary>지정된 논리 방향으로 가장 가까운 삽입 위치에 대한 <see cref="T:System.Windows.Documents.TextPointer" />를 반환합니다.</summary>
        <returns>지정된 방향으로 가장 가까운 삽입 위치에 대한 <see cref="T:System.Windows.Documents.TextPointer" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 삽입 위치는 연결된 된 콘텐츠에 대 한 의미 체계 규칙을 위반 하지 않고 새 콘텐츠를 추가할 수 있는 위치입니다.  실제로, 삽입 위치는 콘텐츠 내에 캐럿 위치 지정할 수 있습니다.  유효한의 예로 <xref:System.Windows.Documents.TextPointer> 삽입 위치 하지 않은 위치는 인접 한 두 사이의 위치 <xref:System.Windows.Documents.Paragraph> 태그 (즉, 이전 단락의 닫는 태그와 여는 태그 다음 단락의 사이).  
  
 경우는 <xref:System.Windows.Documents.TextPointer> 이미 비어 있지 않은 서식 시퀀스에 지정된 된 방향으로의 해당 위치 바로 뒤에 대 한 올바른 삽입 위치를 있지만 닫는 태그를 가리키는 경우 <xref:System.Windows.Documents.TextPointer> 이 속성에서 반환 메서드는 삽입을 가리키도록 조정 됩니다 서식 지정 시퀀스 닫기 바로 다음 위치를 지정 합니다. 예를 들어 태그 시퀀스 `<Bold>a</Bold>b`합니다. 문자 간 두 개의 삽입 위치는 `a` 및 `b` -뒤에 닫는 하나 `Bold` 태그 및 닫는 바로 뒤 하나 `Bold` 태그입니다. 경우 <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> 라고 하는 <xref:System.Windows.Documents.TextPointer> 문자 바로 뒤의 위치로 `a` 하기 전에 닫기를 `Bold` 태그를 가진는 `direction` 의 <xref:System.Windows.Documents.LogicalDirection.Forward>, 반환 된 <xref:System.Windows.Documents.TextPointer> 가리키도록 조정는 문자 바로 앞의 위치 `b`를 닫은 후 `Bold` 태그입니다. 논리적 반대 방향으로 작업 하는 경우 서식 지정 태그를 열기 위한는 비슷한 조정이 이루어집니다. 이 메서드는 비슷한 경우의 삽입 위치 간에 명확성 수단을 제공 하는 데 사용 됩니다.  
  
 이 메서드는 구조적 태그 시퀀스 관련 된 경우 삽입 지점을 선택 되도록 데도 사용할 수 있습니다. 예를 들어 때에 결산 잔액과 개시 단락 태그 사이의 위치, 방향 매개 변수 수 데 사용 될 다음 단락 시작 부분에 가장 가까운 삽입 지점을 선택 (지정 하 여 <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) 또는 이전 단락 (의 끝에 지정 하 여 <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 포인터가 삽입 위치에 이미 있고 인접 한 서식 지정 태그 없음에 지정 된 경우 `direction`, 반환 된 <xref:System.Windows.Documents.TextPointer> 호출 하는 동일한 위치를 가리키는 <xref:System.Windows.Documents.TextPointer>합니다.  
  
 올바른 삽입 지점이 없을가 가리키는 위치를 기준으로 존재 하는지 수는 <xref:System.Windows.Documents.TextPointer>합니다.  참조 된 콘텐츠가 빈 테이블 또는 목록에서와 같이 구조적으로 완료 되지 않은 경우 발생할 수 있습니다.  이러한 경우이 메서드가 반환 된 <xref:System.Windows.Documents.TextPointer> 와 같은 위치에는 <xref:System.Windows.Documents.TextPointer> 이 메서드가 호출 된에서 합니다.  이 메서드는 항상 유효한 반환 <xref:System.Windows.Documents.TextPointer>합니다.  
  
   
  
## Examples  
 사용 하는 방법을 보여 주는이 예제는 <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> 지정 된 있는지 여부를 확인 하는 메서드 <xref:System.Windows.Documents.TextElement> 인쇄 가능한 콘텐츠가 비어 있습니다.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Windows.Documents.TextPointer" />에 상대적으로 지정된 줄의 시작 부분에 대한 <see cref="T:System.Windows.Documents.TextPointer" />를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">시작 위치를 반환할 줄을 결정할 때 건너뛸 줄 시작 마커 수입니다. 음수 값은 이전 줄을 지정하고, 0은 현재 줄을 지정하고, 양수 값은 다음 줄을 지정합니다.</param>
        <summary>현재 <see cref="T:System.Windows.Documents.TextPointer" />에 상대적으로 지정된 줄의 시작 부분에 대한 <see cref="T:System.Windows.Documents.TextPointer" />를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" />이 <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />로 설정된 지정된 줄의 시작 부분을 가리키는 <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />입니다. 지정된 줄이 범위를 벗어나거나 해당 줄을 찾을 수 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Documents.TextPointer> 는 모호한 위치를 가리키는 예를 들어 두 줄 사이 지정 된 방향의 함수의 줄 <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> 상대 시작 줄으로 선택 합니다.  
  
 이 메서드에 의해 수행 되는 작업은 올바른 레이아웃에 따라 달라 집니다.  필요한 경우이 메서드는 작업을 진행 하기 전에 유효한 레이아웃을 자동으로 다시 생성 하려고 합니다.  레이아웃을 다시 생성 하는 작업 상대적으로 비용이 많이 들 수 있습니다.  사용 하 여 <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> 레이아웃을 다시 생성 될 수도 있는 작업을 수행 하기 전에 유효한 레이아웃에 대 한 확인 하도록 합니다.  자세한 내용은 참조 [레이아웃](~/docs/framework/wpf/advanced/layout.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">시작 위치를 반환할 줄을 결정할 때 건너뛸 줄 시작 마커 수입니다. 음수 값은 이전 줄을 지정하고, 0은 현재 줄을 지정하고, 양수 값은 다음 줄을 지정합니다.</param>
        <param name="actualCount">이 메서드는 반환될 때 시작 위치를 반환할 줄을 결정할 때 건너뛴 실제 줄 시작 마커 수를 포함합니다.  지정된 수의 줄을 건너뛰기 전에 콘텐츠 시작 또는 끝 부분이 있는 경우 이 값은 <c>count</c>보다 작을 수 있습니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <summary>현재 <see cref="T:System.Windows.Documents.TextPointer" />에 상대적으로 지정된 줄의 시작 부분에 대한 <see cref="T:System.Windows.Documents.TextPointer" />를 반환하고 건너뛴 줄 수를 보고합니다.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" />이 <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />로 설정된 지정된 줄의 시작 부분을 가리키거나 지정된 줄에 가장 가까운 줄의 시작 부분(지정된 줄이 범위를 벗어난 경우)을 가리키는 <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Documents.TextPointer> 는 모호한 위치를 가리키는 예를 들어 두 줄 사이의 줄에 지정 된 방향의 <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> 상대 시작 줄으로 속성을 선택 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">다음 기호를 검색할 논리 방향을 지정하는 <see cref="T:System.Windows.Documents.LogicalDirection" /> 값 중 하나입니다.</param>
        <summary>지정된 논리 방향의 다음 기호에 대한 포인터를 반환합니다.</summary>
        <returns>요청한 방향의 다음 기호에 대한 <see cref="T:System.Windows.Documents.TextPointer" />입니다. 현재 <see cref="T:System.Windows.Documents.TextPointer" />가 콘텐츠 시작 또는 끝 부분에 인접한 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 항목은 기호 간주 됩니다.  
  
-   여는 태그 또는 닫는 태그가 <xref:System.Windows.Documents.TextElement> 요소입니다.  
  
-   A <xref:System.Windows.UIElement> 에 포함 된 요소는 <xref:System.Windows.Documents.InlineUIContainer> 또는 <xref:System.Windows.Documents.BlockUIContainer>합니다.  이러한은 <xref:System.Windows.UIElement> 항상 정확히 하나의 기호; 추가 내용 또는 요소에 포함 된 것으로 간주 됩니다는 <xref:System.Windows.UIElement> 기호로 계산 되지 않습니다.  
  
-   16 비트 [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] 텍스트 내부에서 문자 <xref:System.Windows.Documents.Run> 요소입니다.  
  
 다음 기호 분류 되는지 경우 <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, 또는 <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (으로 식별 되는 <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> 메서드), 그런 다음 <xref:System.Windows.Documents.TextPointer> 이 속성에서 반환 메서드는 현재 위치에서 정확히 하나의 기호가 앞입니다.  
  
 다음 기호 분류 되는지 경우 <xref:System.Windows.Documents.TextPointerContext.Text>, 하면 <xref:System.Windows.Documents.TextPointer> 이 속성에서 반환 메서드에서 텍스트 뒤로 다음 텍스트가 아닌 기호 (즉, 다음 위치의 <xref:System.Windows.Documents.TextPointerContext> 않습니다 <xref:System.Windows.Documents.TextPointerContext.Text>).  호출 하 여 교차 기호 정확한 개수를 미리 계산할 수 있습니다는 <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는이 메서드에 대 한 사용을 보여 줍니다.  이 예제에서는 사용 된 <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> 메서드와 함께 <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> 메서드를 트래버스하 고 지정 된 기호를 추출할 <xref:System.Windows.Documents.TextElement>합니다.  
  
 추출 하는 예제를 사용할 수 있지만 한 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 의 내용에 대 한 구조는 주어진 <xref:System.Windows.Documents.TextElement>, 설명 목적 으로만 사용 하 고 프로덕션 코드에서는 사용할 수 없습니다.  참조는 <xref:System.Xml> 다양 한 작업 및 XML을 처리 하기 위한 형식에 대 한 네임 스페이스입니다.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">다음 삽입 위치를 검색할 논리 방향을 지정하는 <see cref="T:System.Windows.Documents.LogicalDirection" /> 값 중 하나입니다.</param>
        <summary>지정된 논리 방향의 다음 삽입 위치에 대한 <see cref="T:System.Windows.Documents.TextPointer" />를 반환합니다.</summary>
        <returns>요청한 방향의 다음 삽입 위치를 식별하는 <see cref="T:System.Windows.Documents.TextPointer" />입니다. 다음 삽입 위치를 찾을 수 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *삽입 위치* 연결된 콘텐츠에 대 한 의미 체계 규칙을 위반 하지 않고 새 콘텐츠를 추가할 수 있는 위치입니다.  실제로, 삽입 위치는 콘텐츠 내에 캐럿 위치 지정할 수 있습니다.  유효한의 예로 <xref:System.Windows.Documents.TextPointer> 삽입 위치 하지 않은 위치는 인접 한 두 사이의 위치 <xref:System.Windows.Documents.Paragraph> 태그 (즉, 이전 단락의 닫는 태그와 여는 태그 다음 단락의 사이).  
  
   
  
## Examples  
 다음 예제에서는이 메서드에 대 한 사용을 보여 줍니다. 이 예제에서는 사용는 <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> 의 수를 계산 하기 위해 콘텐츠 요소 경계를 트래버스해야 하는 메서드 <xref:System.Windows.Documents.Paragraph> 간에 지정 된 두 요소가 제공 <xref:System.Windows.Documents.TextPointer> 인스턴스.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">거리(기호)를 찾을 위치를 지정하는 <see cref="T:System.Windows.Documents.TextPointer" />입니다.</param>
        <summary>현재 <see cref="T:System.Windows.Documents.TextPointer" />와 지정된 두 번째 <see cref="T:System.Windows.Documents.TextPointer" /> 사이의 기호 수를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Windows.Documents.TextPointer" />와 <paramref name="position" /> 사이의 상대적 기호 수입니다.  음수 값은 현재 <see cref="T:System.Windows.Documents.TextPointer" />가 <paramref name="position" />에 지정된 위치 뒤에 옴을 나타내고, 0은 위치가 동일함을 나타내고, 양수 값은 현재 <see cref="T:System.Windows.Documents.TextPointer" />가 <paramref name="position" />에 지정된 위치 앞에 옴을 나타냅니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 항목은 기호 간주 됩니다.  
  
-   여는 태그 또는 닫는 태그가 <xref:System.Windows.Documents.TextElement> 요소입니다.  
  
-   A <xref:System.Windows.UIElement> 에 포함 된 요소는 <xref:System.Windows.Documents.InlineUIContainer> 또는 <xref:System.Windows.Documents.BlockUIContainer>합니다.  이러한은 <xref:System.Windows.UIElement> 항상 정확히 하나의 기호; 추가 내용 또는 요소에 포함 된 것으로 간주 됩니다는 <xref:System.Windows.UIElement> 기호로 계산 되지 않습니다.  
  
-   16 비트 [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] 텍스트 내부에서 문자 <xref:System.Windows.Documents.Run> 요소입니다.  
  
   
  
## Examples  
 다음 예제에서는이 메서드에 대 한 사용을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> 두에 대 한 오프셋을 확인 하려면 <xref:System.Windows.Documents.TextPointer> 인스턴스와 다음이 정보를 사용 하 여 저장 하 고 선택 영역 복원는 <xref:System.Windows.Controls.RichTextBox>합니다.  이 예에서는 가정 하는의 내용을 <xref:System.Windows.Controls.RichTextBox> 저장 선택 및 선택 영역 복원 간에 변경 되지 않았습니다.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" />이 현재 위치와 연결된 텍스트 컨테이너의 외부 위치를 지정하는 경우</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">인접한 콘텐츠의 범주를 결정할 논리 방향을 지정하는 <see cref="T:System.Windows.Documents.LogicalDirection" /> 값 중 하나입니다.</param>
        <summary>지정된 논리 방향으로 현재 <see cref="T:System.Windows.Documents.TextPointer" />에 인접한 콘텐츠의 범주 표시기를 반환합니다.</summary>
        <returns>지정된 논리 방향으로 인접한 콘텐츠의 범주를 나타내는 <see cref="T:System.Windows.Documents.TextPointerContext" /> 값 중 하나입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는이 메서드에 대 한 사용을 보여 줍니다. 이 예제에서는 사용 된 <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> 수 간의 균형점을 열고 닫는 요소 태그가 지정 된 두 사이 계산 하기 위한 알고리즘을 구현 하는 메서드 <xref:System.Windows.Documents.TextPointer> 위치 합니다.  각 + 1로 이동 하 고 각 계산 되는 여는 요소 태그-1로 계산 되는 닫는 요소 태그가 있습니다.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>콘텐츠 시작 부분에서 지정된 오프셋(기호)으로 표시되는 위치에 대한 <see cref="T:System.Windows.Documents.TextPointer" />를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">위치를 계산하고 반환할 오프셋(기호)입니다.  오프셋이 음수이면 위치는 <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> 속성으로 표시되는 방향과 반대 논리 방향으로 계산됩니다.</param>
        <summary>현재 <see cref="T:System.Windows.Documents.TextPointer" /> 시작 부분에서 지정된 오프셋(기호)으로 표시되는 위치에 대한 <see cref="T:System.Windows.Documents.TextPointer" />를 반환합니다.</summary>
        <returns>지정된 오프셋으로 표시되는 위치에 대한 <see cref="T:System.Windows.Documents.TextPointer" />입니다. 해당 위치를 찾을 수 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 항목은 기호 간주 됩니다.  
  
-   여는 태그 또는 닫는 태그가 <xref:System.Windows.Documents.TextElement> 요소입니다.  
  
-   A <xref:System.Windows.UIElement> 에 포함 된 요소는 <xref:System.Windows.Documents.InlineUIContainer> 또는 <xref:System.Windows.Documents.BlockUIContainer>합니다.  이러한은 <xref:System.Windows.UIElement> 항상 정확히 하나의 기호; 추가 내용 또는 요소에 포함 된 것으로 간주 됩니다는 <xref:System.Windows.UIElement> 기호로 계산 되지 않습니다.  
  
-   16 비트 [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] 텍스트 내부에서 문자 <xref:System.Windows.Documents.Run> 요소입니다.  
  
   
  
## Examples  
 다음 예제에서는이 메서드에 대 한 사용을 보여 줍니다. 이 예제에서는 사용는 <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> 하나 모든 호스팅 단락 및 반환 하 고 다른 기준으로 지정된 된 위치에 대 한 오프셋을 계산 하는 메서드 쌍을 구현 하려면 메서드는 <xref:System.Windows.Documents.TextPointer> 지정된 단락에 지정된 된 오프셋에 있습니다.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">위치를 계산하고 반환할 오프셋(기호)입니다.  오프셋이 음수이면 반환되는 <see cref="T:System.Windows.Documents.TextPointer" />는 현재 <see cref="T:System.Windows.Documents.TextPointer" /> 앞에 오고, 그렇지 않으면 뒤에 옵니다.</param>
        <param name="direction">반환되는 <see cref="T:System.Windows.Documents.LogicalDirection" />의 논리 방향을 지정하는 <see cref="T:System.Windows.Documents.TextPointer" /> 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.Windows.Documents.TextPointer" />의 시작 부분에서 지정된 방향으로 지정된 오프셋(기호)으로 표시되는 위치에 대한 <see cref="T:System.Windows.Documents.TextPointer" />를 반환합니다.</summary>
        <returns>지정된 오프셋으로 표시되는 위치에 대한 <see cref="T:System.Windows.Documents.TextPointer" />입니다. 오프셋이 콘텐츠 끝을 지나 확장되는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 항목은 기호 간주 됩니다.  
  
-   여는 태그 또는 닫는 태그가 <xref:System.Windows.Documents.TextElement> 요소입니다.  
  
-   A <xref:System.Windows.UIElement> 에 포함 된 요소는 <xref:System.Windows.Documents.InlineUIContainer> 또는 <xref:System.Windows.Documents.BlockUIContainer>합니다.  이러한은 <xref:System.Windows.UIElement> 항상 정확히 하나의 기호; 추가 내용 또는 요소에 포함 된 것으로 간주 됩니다는 <xref:System.Windows.UIElement> 기호로 계산 되지 않습니다.  
  
-   16 비트 [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] 텍스트 내부에서 문자 <xref:System.Windows.Documents.Run> 요소입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Windows.Documents.TextPointer" />에 인접한 텍스트를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">인접한 텍스트를 찾아 반환할 논리 방향을 지정하는 <see cref="T:System.Windows.Documents.LogicalDirection" /> 값 중 하나입니다.</param>
        <summary>지정된 논리 방향으로 현재 <see cref="T:System.Windows.Documents.TextPointer" />에 인접한 텍스트를 포함하는 문자열을 반환합니다.</summary>
        <returns>지정된 논리 방향으로 인접한 텍스트를 포함하는 문자열입니다. 인접한 텍스트를 찾을 수 없는 경우 <see cref="F:System.String.Empty" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 텍스트의 중단 없이 실행만을 반환합니다.  아무 것도 반환 이외의 모든 기호 형식을 경우 <xref:System.Windows.Documents.TextPointerContext.Text> 현재에 인접 한 <xref:System.Windows.Documents.TextPointer> 지정된 된 방향으로 합니다.  마찬가지로, 다음 텍스트가 아닌 기호 까지만 텍스트가 반환 됩니다.  
  
   
  
## Examples  
 다음 예제에서는이 메서드에 대 한 사용을 보여 줍니다. 이 예제에서는 사용 된 <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> 간단한 텍스트 extractor 구현 하려면 메서드.  메서드는 지정 된 두 까지의 모든 텍스트의 문자열 연결을 반환 <xref:System.Windows.Documents.TextPointer> 인스턴스.  
  
 이 예제에서는 두 텍스트를 추출할 사용할 수 있지만 <xref:System.Windows.Documents.TextPointer> 인스턴스 것 설명 목적 으로만, 용도가 및 프로덕션 코드에서는 사용할 수 없습니다.  대신 <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType> 속성을 사용하세요.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">인접한 텍스트를 찾아 복사할 논리 방향을 지정하는 <see cref="T:System.Windows.Documents.LogicalDirection" /> 값 중 하나입니다.</param>
        <param name="textBuffer">텍스트를 복사할 버퍼입니다.</param>
        <param name="startIndex">복사된 텍스트를 쓰기 시작할 <c>textBuffer</c>에 대한 인덱스입니다.</param>
        <param name="count">복사할 최대 문자 수입니다.</param>
        <summary>지정된 방향으로 인접한 텍스트에서 지정된 최대 수의 문자를 호출자가 제공한 문자 배열에 복사합니다.</summary>
        <returns>
          <paramref name="textBuffer" />에 실제로 복사되는 문자 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 텍스트의 중단 없이 실행만을 반환합니다.  아무 것도 반환 이외의 모든 기호 형식을 경우 <xref:System.Windows.Documents.TextPointerContext.Text> 현재에 인접 한 <xref:System.Windows.Documents.TextPointer> 지정된 된 방향으로 합니다.  마찬가지로, 다음 텍스트가 아닌 기호 까지만 텍스트가 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" />가 0보다 작거나 <paramref name="textBuffer" />의 <see cref="P:System.Array.Length" /> 속성보다 큰 경우.  
  
 또는  
  
 <paramref name="count" />가 0보다 작거나 <paramref name="textBuffer" />의 남은 공간 보다 큰 경우(<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> 빼기 <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">문자 수를 계산할 논리 방향을 지정하는 <see cref="T:System.Windows.Documents.LogicalDirection" /> 값 중 하나입니다.</param>
        <summary>지정된 방향으로 현재 <see cref="T:System.Windows.Documents.TextPointer" />와 텍스트가 아닌 다음 기호 사이의 유니코드 문자 수를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Windows.Documents.TextPointer" />와 텍스트가 아닌 다음 기호 사이의 유니코드 문자 수입니다.  인접한 텍스트가 없는 경우 이 숫자는 0일 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 항목은 기호 간주 됩니다.  
  
-   여는 태그 또는 닫는 태그가 <xref:System.Windows.Documents.TextElement> 요소입니다.  
  
-   A <xref:System.Windows.UIElement> 에 포함 된 요소는 <xref:System.Windows.Documents.InlineUIContainer> 또는 <xref:System.Windows.Documents.BlockUIContainer>합니다.  이러한은 <xref:System.Windows.UIElement> 항상 정확히 하나의 기호; 추가 내용 또는 요소에 포함 된 것으로 간주 됩니다는 <xref:System.Windows.UIElement> 기호로 계산 되지 않습니다.  
  
-   16 비트 [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] 텍스트 내부에서 문자 <xref:System.Windows.Documents.Run> 요소입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치와 연결된 텍스트 컨테이너의 레이아웃이 올바른지(최신인지) 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          레이아웃이 최신 상태이면서 올바르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요한 경우 올바른 레이아웃에 종속 된 작업 (같은 <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> 메서드를 <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> 메서드를 및 <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> 속성) 작업을 진행 하기 전에 유효한 레이아웃을 자동으로 다시 생성 하려고 합니다.  레이아웃을 다시 생성 하는 작업 상대적으로 비용이 많이 들 수 있습니다.  이 속성을 사용 하 여 레이아웃을 다시 생성 될 수도 있는 작업을 수행 하기 전에 유효한 레이아웃에 대 한 확인 하도록 합니다.  자세한 내용은 참조 [레이아웃](~/docs/framework/wpf/advanced/layout.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 위치에 줄 바꿈을 삽입합니다.</summary>
        <returns>이 메서드에서 <see cref="T:System.Windows.Documents.TextPointer" /> 요소를 삽입한 직후에 배치되는 <see cref="T:System.Windows.Documents.LineBreak" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 위치에 단락 나누기를 삽입합니다.</summary>
        <returns>새 단락의 시작 부분(<see cref="T:System.Windows.Documents.TextPointer" />)에 대한 <see cref="P:System.Windows.Documents.TextElement.ContentStart" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기존의 내부에서 현재 위치 하는 경우이 메서드를 호출 하면 <xref:System.Windows.Documents.Paragraph> 요소, 기존 단락 및 포함 된 콘텐츠는 현재 위치에 두 단락으로 분할 됩니다.  현재 위치를 기존 단락 내에서 없을 때이 메서드가 호출 되는 새로 만든 빈 단락 삽입 됩니다.  이 메서드는 위치에 분할 하거나 단락 삽입 사용할 수 없는 경우 (내에 현재 위치 하는 경우에 예를 들어 한 <xref:System.Windows.Documents.Hyperlink> 요소), 예외가 throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 메서드는 <see cref="T:System.Windows.Documents.Hyperlink" /> 또는 <see cref="T:System.Windows.Documents.InlineUIContainer" /> 범위에서와 같이 새 단락을 수용하도록 분할할 수 없는 위치에서 호출됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">삽입할 텍스트입니다.</param>
        <summary>지정된 텍스트를 현재 위치의 <see cref="T:System.Windows.Documents.Run" /> 텍스트에 삽입합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Documents.TextPointer> 여 범위로 지정 되지 않은 한 <xref:System.Windows.Documents.Run> 요소는 <xref:System.Windows.Documents.Run> 와 함께 삽입 됩니다는 `textData`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 위치가 <see cref="T:System.Windows.Documents.Run" /> 요소 내에 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치가 삽입 위치인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 위치가 삽입 위치이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 삽입 위치는 연결된 된 콘텐츠에 대 한 의미 체계 규칙을 위반 하지 않고 새 콘텐츠를 추가할 수 있는 위치입니다.  실제로, 삽입 위치는 콘텐츠 내에 캐럿 위치 지정할 수 있습니다.  유효한의 예로 <xref:System.Windows.Documents.TextPointer> 삽입 위치 하지 않은 위치는 인접 한 두 사이의 위치 <xref:System.Windows.Documents.Paragraph> 태그 (즉, 이전 단락의 닫는 태그와 여는 태그 다음 단락의 사이).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치가 줄의 시작 부분에 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 위치가 줄의 시작 부분에 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Documents.TextPointer> 는 모호한 위치를 가리키는 예를 들어 두 줄 사이의 줄에 지정 된 방향의 <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> 상대 시작 줄으로 속성을 선택 합니다.  
  
 이 속성에 의해 수행 되는 작업은 올바른 레이아웃에 따라 달라 집니다.  필요한 경우이 메서드는 작업을 진행 하기 전에 유효한 레이아웃을 자동으로 다시 생성 하려고 합니다.  레이아웃을 다시 생성 하는 작업 상대적으로 비용이 많이 들 수 있습니다.  사용 하 여는 <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> 레이아웃을 다시 생성 될 수도 있는 작업을 수행 하기 전에 유효한 레이아웃에 대해 확인할 속성입니다.  자세한 내용은 참조 [레이아웃](~/docs/framework/wpf/advanced/layout.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">현재 위치와 비교할 위치를 지정하는 <see cref="T:System.Windows.Documents.TextPointer" />입니다.</param>
        <summary>지정된 위치가 현재 위치와 동일한 텍스트 컨테이너 내에 있는지 여부를 나타냅니다.</summary>
        <returns>
          <paramref name="textPosition" />이 현재 위치와 동일한 텍스트 컨테이너 내 위치를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 여러 관련 된 대부분의 작업 <xref:System.Windows.Documents.TextPointer> 문제의 인스턴스는 동일한 텍스트 컨테이너 범위에 있는 위치를 가리킬 경우 인스턴스는만 유효 합니다.  예를 들어는 <xref:System.Windows.Documents.TextPointer.CompareTo%2A> 및 <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> 메서드를 함께 사용할 수 없습니다는 <xref:System.Windows.Documents.TextPointer> 현재 위치와 연결 된 텍스트 컨테이너의 외부 위치에 있습니다.  지정 된 되어 있는지 확인 하려면이 메서드를 사용 <xref:System.Windows.Documents.TextPointer> 등의 작업에 대 한 현재 위치와 호환 됩니다.  
  
   
  
## Examples  
 다음 예제에서는이 메서드에 대 한 사용을 보여 줍니다.  이 예제에서는 사용는 <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> 지정 된 있는지 여부를 확인 하는 메서드 <xref:System.Windows.Documents.TextPointer> 다른 지정 된 두 중간쯤 <xref:System.Windows.Documents.TextPointer> 보장이 없습니다 세 개의 위치가 모두 동일한 텍스트 컨테이너에 속하는 경우 인스턴스.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치와 연결된 콘텐츠를 구분하는 데 사용되는 현재 위치와 연결된 논리 방향을 가져옵니다.</summary>
        <value>현재 위치와 연결된 <see cref="T:System.Windows.Documents.LogicalDirection" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하는 방법의 예로 <xref:System.Windows.Documents.LogicalDirection> 의 <xref:System.Windows.Documents.TextPointer> 반환 된 적중된 테스트에서 메서드는 텍스트의 두 문자 사이 있는 적중 횟수를 제공 합니다. 두 문자 중에 도달한 실제로 논리 방향을 지정-왼쪽 이나 오른쪽입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치의 범위를 지정하는 단락이 있으면 가져옵니다.</summary>
        <value>
          <see cref="T:System.Windows.Documents.Paragraph" /> 범위로 지정 하는 현재 위치 또는 <see langword="null" /> 이러한 단락이 없는 존재 하는 경우.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치의 범위를 지정하는 논리 부모를 가져옵니다.</summary>
        <value>현재 위치의 범위를 지정하는 논리 부모입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 형식 또는 멤버는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 인프라를 지원하며 사용자 코드에서 직접 사용할 수 없습니다.</summary>
        <returns>개체를 나타내는 문자열입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>