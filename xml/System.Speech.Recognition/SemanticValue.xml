<Type Name="SemanticValue" FullName="System.Speech.Recognition.SemanticValue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a671b8ca015f41830e946215a9630d3f776935d5" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39997970" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SemanticValue : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;string,System.Speech.Recognition.SemanticValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit SemanticValue extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.SemanticValue" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SemanticValue&#xA;Implements ICollection(Of KeyValuePair(Of String, SemanticValue)), IDictionary(Of String, SemanticValue), IEnumerable(Of KeyValuePair(Of String, SemanticValue))" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemanticValue sealed : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;, System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type SemanticValue = class&#xA;    interface IDictionary&lt;string, SemanticValue&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;string, SemanticValue&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;string, SemanticValue&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Diagnostics.DebuggerDisplay("'{_keyName}'= {Value}  -  Children = {_dictionary.Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Speech.Recognition.SemanticValue/SemanticValueDebugDisplay))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="18bed-101">인식된 구의 의미 체계 구성을 나타냅니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="18bed-101">Represents the semantic organization of a recognized phrase.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18bed-102"><xref:System.Speech.Recognition.SemanticValue> System.Speech 의미 체계 기술을 구현 하는 기본 개체가입니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-102"><xref:System.Speech.Recognition.SemanticValue> is the primary object that implements the semantic technology in System.Speech.</span></span> <span data-ttu-id="18bed-103">의미 해석 문법을를 올바르게 오디오 입력을 해석할 인식 엔진에 의해 사용에 대 한 규칙을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-103">Semantic interpretation allows grammars to define rules for use by a recognition engine to correctly interpret audio input.</span></span> <span data-ttu-id="18bed-104">의미 해석 인식 엔진을 단어 및 단어의 시퀀스를 인식만 반환 하지 않고 쉽게 처리할 수, 있도록 그 결과 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-104">Semantic interpretation also enables recognition engines to organize their results so that they can be more easily processed, rather than returning only recognized words and sequences of words.</span></span>  
  
 <span data-ttu-id="18bed-105">예를 들어 인식 엔진 구문 분석 하 고 작업이 수행 될 수 전에 응용 프로그램에 의해 해석 해야 "빨강 배경색 변경"을 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-105">For example, the recognition engine output "Change background to red" would have to be parsed and interpreted by an application before it could be acted upon.</span></span> <span data-ttu-id="18bed-106"><xref:System.Speech.Recognition.Grammar> 개체 자식과 구 백그라운드 또는 포그라운드 ("백그라운드" 텍스트로 표시 됨) 및 선택에 대 한 기타 선택에 대 한 두 가지 의미 체계 하위 구조체에 지정 하 여 처리 되도록 의미 해석을 지정할 수 있습니다 색 (텍스트 "red"로 표현 됨).</span><span class="sxs-lookup"><span data-stu-id="18bed-106">A <xref:System.Speech.Recognition.Grammar> object can specify a semantic interpretation to make processing clearer by specifying that the phrase has two semantic substructures, one for selecting background or foreground (represented by the text "background"), and the other for selecting color (represented by the text "red").</span></span>  
  
 <span data-ttu-id="18bed-107">System.Speech 트리에서 인식 작업의 의미 체계를 나타내는 <xref:System.Speech.Recognition.SemanticValue> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-107">System.Speech represents the semantics of a recognition operation in a tree of <xref:System.Speech.Recognition.SemanticValue> objects.</span></span>  
  
 <span data-ttu-id="18bed-108">각 <xref:System.Speech.Recognition.SemanticValue> 인스턴스는 다음이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-108">Each <xref:System.Speech.Recognition.SemanticValue> instance includes the following:</span></span>  
  
-   <span data-ttu-id="18bed-109"><xref:System.Object>이용 하 여 액세스 합니다 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 속성의 인스턴스 키를 사용 합니다 <xref:System.Speech.Recognition.SemanticValue>.</span><span class="sxs-lookup"><span data-stu-id="18bed-109">An <xref:System.Object>, accessed by means of the <xref:System.Speech.Recognition.SemanticValue.Value%2A> property, used to key the instance of the <xref:System.Speech.Recognition.SemanticValue>.</span></span>  
  
-   <span data-ttu-id="18bed-110">반환 된 구문 의미 분석의 정확도 측정값은 <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-110">A measure of the accuracy of semantic parsing, returned by the <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> property.</span></span>  
  
-   <span data-ttu-id="18bed-111">이름/값 쌍의 컬렉션 (<xref:System.Collections.Generic.KeyValuePair%602>)도 자식 개체의 <xref:System.Speech.Recognition.SemanticValue> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="18bed-111">A collection of name/value pairs (<xref:System.Collections.Generic.KeyValuePair%602>) of child objects, which are also <xref:System.Speech.Recognition.SemanticValue> instances.</span></span> <span data-ttu-id="18bed-112">자식 노드를 통해 액세스할 수 합니다 <xref:System.Speech.Recognition.SemanticValue> 구현의 <xref:System.Collections.Generic.IDictionary%602> 문자열 조회 키를 사용 하 여 및 <xref:System.Speech.Recognition.SemanticValue> 다음 예제와 같이 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="18bed-112">Child nodes are accessible through the <xref:System.Speech.Recognition.SemanticValue> implementation of <xref:System.Collections.Generic.IDictionary%602> using a string lookup key and a <xref:System.Speech.Recognition.SemanticValue> instance, as in the following example.</span></span>  
  
    ```csharp  
    foreach (KeyValuePair<String, SemanticValue> child in semantics)   
    {  
      Utils.CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
    }  
    ```  
  
 <span data-ttu-id="18bed-113">System.Speech 기반 인식 엔진의 유효한 인스턴스를 제공 <xref:System.Speech.Recognition.SemanticValue> 인식의 모든 출력에 대 한 구 통해 훨씬 명시적 의미 체계 구조가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-113">Recognition engines based on System.Speech provide valid instances of <xref:System.Speech.Recognition.SemanticValue> for all output from recognition, even for phrases with no explicit semantic structure.</span></span>  
  
 <span data-ttu-id="18bed-114"><xref:System.Speech.Recognition.SemanticValue> 구를 사용 하 여 가져온에 대 한 인스턴스를 <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> 속성을 <xref:System.Speech.Recognition.RecognizedPhrase> 개체 (또는 같은에서 상속 되는 개체 <xref:System.Speech.Recognition.RecognitionResult>).</span><span class="sxs-lookup"><span data-stu-id="18bed-114">The <xref:System.Speech.Recognition.SemanticValue> instance for a phrase is obtained using the <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> property on the <xref:System.Speech.Recognition.RecognizedPhrase> object (or objects that inherit from it, such as <xref:System.Speech.Recognition.RecognitionResult>).</span></span>  
  
 <span data-ttu-id="18bed-115"><xref:System.Speech.Recognition.SemanticValue> 의미 체계 구조 없이 인식할 수 있는 구 가져온 개체에 따라 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-115"><xref:System.Speech.Recognition.SemanticValue> objects obtained for recognized phrases without semantic structure are characterized by:</span></span>  
  
-   <span data-ttu-id="18bed-116">자식의 부족 (<xref:System.Speech.Recognition.SemanticValue.Count%2A> 0).</span><span class="sxs-lookup"><span data-stu-id="18bed-116">The lack of children (<xref:System.Speech.Recognition.SemanticValue.Count%2A> is 0).</span></span>  
  
-   <span data-ttu-id="18bed-117"><xref:System.Speech.Recognition.SemanticValue.Value%2A> 속성은 `null`입니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-117">The <xref:System.Speech.Recognition.SemanticValue.Value%2A> property is `null`.</span></span>  
  
-   <span data-ttu-id="18bed-118">1.0는 인위적인 의미 체계 신뢰도 수준 (반환한 <xref:System.Speech.Recognition.SemanticValue.Confidence%2A>).</span><span class="sxs-lookup"><span data-stu-id="18bed-118">An artificial semantic confidence level of 1.0 (returned by <xref:System.Speech.Recognition.SemanticValue.Confidence%2A>).</span></span>  
  
 <span data-ttu-id="18bed-119">일반적으로 응용 프로그램을 만들어야 <xref:System.Speech.Recognition.SemanticValue> 인스턴스가 없습니다를 직접 추가 하 <xref:System.Speech.Recognition.Grammar> 개체를 사용 하 여 <xref:System.Speech.Recognition.SemanticResultValue> 하 고 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스를 함께 <xref:System.Speech.Recognition.Choices> 및 <xref:System.Speech.Recognition.GrammarBuilder> 개체.</span><span class="sxs-lookup"><span data-stu-id="18bed-119">Typically, applications create <xref:System.Speech.Recognition.SemanticValue> instances indirectly, adding them to <xref:System.Speech.Recognition.Grammar> objects by using <xref:System.Speech.Recognition.SemanticResultValue> and <xref:System.Speech.Recognition.SemanticResultKey> instances,  in conjunction with  <xref:System.Speech.Recognition.Choices> and <xref:System.Speech.Recognition.GrammarBuilder> objects.</span></span>  
  
 <span data-ttu-id="18bed-120">직접 생성 한 <xref:System.Speech.Recognition.SemanticValue> 강력한 형식의 문법 만드는 동안 인스턴스 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-120">Direct construction of a <xref:System.Speech.Recognition.SemanticValue> instance is useful during the creation of strongly-typed grammars.</span></span>  
  
 <span data-ttu-id="18bed-121"><xref:System.Speech.Recognition.SemanticValue> 구현 된 <xref:System.Collections.Generic.IDictionary%602>, <xref:System.Collections.Generic.ICollection%601>, 및 <xref:System.Collections.Generic.IEnumerable%601> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-121"><xref:System.Speech.Recognition.SemanticValue> implements the <xref:System.Collections.Generic.IDictionary%602>, <xref:System.Collections.Generic.ICollection%601>, and <xref:System.Collections.Generic.IEnumerable%601> interfaces.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18bed-122">다음 예제에 대 한 처리기를 <xref:System.Speech.Recognition.Grammar.SpeechRecognized> 이벤트 전경색과 배경색을 변경 하는 명령 처리 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-122">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="18bed-123">처리기에 구조가 없는 기본 의미 체계를 감지 하 여 구가 인식된 하 게 식별 하는 <xref:System.Speech.Recognition.SemanticValue.Count%2A> 0으로 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-123">The handler identifies recognized phrases that have no underlying semantic structure by detecting a <xref:System.Speech.Recognition.SemanticValue.Count%2A> of zero and a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null`.</span></span> <span data-ttu-id="18bed-124">이 인식 출력 원시 텍스트를 구문 분석 하 여 직접 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-124">This recognition output is then processed directly by parsing the raw text.</span></span>  
  
 <span data-ttu-id="18bed-125">다른 경우 처리기는 포그라운드 또는 백그라운드 명령이 바뀝니다 여부를 확인 하거나 올바른 키가 있음을 나타내기 위해 색 이름을 RGB 구성 요소를 가져올 키를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-125">In other cases, the handler uses keys to obtain the RGB components of a color name, to determine whether the command will change the foreground or background, or to indicate that no valid key was found.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        // and search for "background" or "foreground" in the input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
  
      // Make sure that text is readable regardless of the background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="18bed-126">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-126">Initializes a new instance of the <see cref="T:System.Speech.Recognition.SemanticValue" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18bed-127">일반적으로 만들지 않습니다 <xref:System.Speech.Recognition.SemanticValue> 개체를 명시적으로 제외한를 강력한 형식의 문법의 빌드를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-127">Typically, you will not create <xref:System.Speech.Recognition.SemanticValue> objects explicitly, except to support the building of strongly-typed grammars.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemanticValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemanticValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.SemanticValue : obj -&gt; System.Speech.Recognition.SemanticValue" Usage="new System.Speech.Recognition.SemanticValue value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="18bed-128">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> 개체에 저장되는 정보입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-128">The information to be stored in the <see cref="T:System.Speech.Recognition.SemanticValue" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18bed-129">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> 클래스의 새 인스턴스를 초기화하고 의미 값을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-129">Initializes a new instance of the <see cref="T:System.Speech.Recognition.SemanticValue" /> class and specifies a semantic value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18bed-130">형식에 대 한 제한은 없습니다 `value` 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-130">There are no restrictions on the type of `value` to be stored.</span></span>  
  
 <span data-ttu-id="18bed-131">응용 프로그램을 검색할 수 있습니다 `value` 를 사용 하 여 합니다 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 속성을 <xref:System.Speech.Recognition.SemanticValue> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="18bed-131">An application can retrieve `value` by using the <xref:System.Speech.Recognition.SemanticValue.Value%2A> property on a <xref:System.Speech.Recognition.SemanticValue> instance.</span></span>  
  
 <span data-ttu-id="18bed-132">값을 <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> 속성에 대 한는 <xref:System.Speech.Recognition.SemanticValue> 인스턴스-1로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-132">The value of the <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> property for the <xref:System.Speech.Recognition.SemanticValue> instance will be set to -1.</span></span>  
  
 <span data-ttu-id="18bed-133"><xref:System.Speech.Recognition.SemanticValue> 생성이 메서드는 키 이름으로 참조할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-133">A <xref:System.Speech.Recognition.SemanticValue> constructed with this method cannot be referenced by key name.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemanticValue (string keyName, object value, float confidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string keyName, object value, float32 confidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.#ctor(System.String,System.Object,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keyName As String, value As Object, confidence As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemanticValue(System::String ^ keyName, System::Object ^ value, float confidence);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.SemanticValue : string * obj * single -&gt; System.Speech.Recognition.SemanticValue" Usage="new System.Speech.Recognition.SemanticValue (keyName, value, confidence)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="confidence" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="keyName">
          <span data-ttu-id="18bed-134">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> 인스턴스를 참조하는데 사용할 수 있는 키</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-134">A key that can be used to reference this <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="18bed-135">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> 개체에 저장될 정보를 포함하는 개체</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-135">An object containing information to be stored in the <see cref="T:System.Speech.Recognition.SemanticValue" /> object.</span>
          </span>
        </param>
        <param name="confidence">
          <span data-ttu-id="18bed-136">의미 분석의 예상 확신도를 포함하는 <see langword="float" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-136">A <see langword="float" /> containing an estimate of the certainty of semantic analysis.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18bed-137">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> 클래스의 새 인스턴스를 초기화하며 의미 값, 키 이름 및 신뢰 수준을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-137">Initializes a new instance of the <see cref="T:System.Speech.Recognition.SemanticValue" /> class and specifies a semantic value, a key name, and a confidence level.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18bed-138">형식에 대 한 제한은 없습니다 `value` 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-138">There are no restrictions on the type of `value` to be stored.</span></span>  
  
 <span data-ttu-id="18bed-139">응용 프로그램을 검색할 수 있습니다 `value` 를 사용 하 여 합니다 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 속성을 <xref:System.Speech.Recognition.SemanticValue> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="18bed-139">An application can retrieve `value` by using the <xref:System.Speech.Recognition.SemanticValue.Value%2A> property on a <xref:System.Speech.Recognition.SemanticValue> instance.</span></span>  
  
 <span data-ttu-id="18bed-140">`confidence` 매개 변수 (반환한 합니다 <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> 속성을 <xref:System.Speech.Recognition.SemanticValue> 인스턴스), 0.0과 1.0 사이 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-140">The `confidence` parameter (returned by the <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> property on a <xref:System.Speech.Recognition.SemanticValue> instance), should be between 0.0 and 1.0.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Confidence">
      <MemberSignature Language="C#" Value="public float Confidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 Confidence" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Confidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Confidence As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float Confidence { float get(); };" />
      <MemberSignature Language="F#" Value="member this.Confidence : single" Usage="System.Speech.Recognition.SemanticValue.Confidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18bed-141">
            <see cref="T:System.Speech.Recognition.SemanticValue" />의 현재 인스턴스가 반환된 구문 의미 분석의 정확성에 관한 확신도의 상대 측정을 반환합니다</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-141">Returns a relative measure of the certainty as to the correctness of the semantic parsing that returned the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18bed-142">
            <see cref="T:System.Speech.Recognition.SemanticValue" />의 현재 인스턴스가 반환된 구문 의미 분석의 확신도에 대한 상대 측정인 <see langword="float" />을 반환합니다</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-142">Returns a <see langword="float" /> that is a relative measure of the certainty of semantic parsing that returned the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18bed-143">합니다 <xref:System.Speech.Recognition.SemanticValue.Confidence%2A?displayProperty=nameWithType> 구문 의미 분석의 정확성에 대 한 측정값을 반환 하는 속성을 사용 하 여 혼동 하지 마십시오는 <xref:System.Speech.Recognition.RecognizedPhrase.Confidence%2A?displayProperty=nameWithType> 의 음성 인식 정확도 측정값을 반환 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-143">The <xref:System.Speech.Recognition.SemanticValue.Confidence%2A?displayProperty=nameWithType> property, which returns a measure of the correctness of semantic parsing, should not be confused with the <xref:System.Speech.Recognition.RecognizedPhrase.Confidence%2A?displayProperty=nameWithType> property, which returns a measure of the accuracy of speech recognition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18bed-144">다음 예제에서는 재귀적으로 트래버스 되 고 다음 정보 (신뢰도 포함)으로 표시를 <xref:System.Windows.Forms.TreeNodeCollection>, 되거나 노드로 트리 구조의 의미 체계를 구성 하는 데 구를 인식 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-144">The following example is used to recursively traverse and then display information (including confidence) as a <xref:System.Windows.Forms.TreeNodeCollection>, or as the nodes making up the tree structure of the semantics used to recognize a phrase.</span></span>  
  
```csharp  
internal static void CreateSemanticsTreeNodes(  
        TreeNodeCollection nodes,  
        SemanticValue semantics,  
        String name)   
{  
  string semanticsText =   
      String.Format("  {0}  (Confidence {1})", name,semantics.Confidence);  
  
  // Format integers as hexadecimal.  
  if (semantics.Value == null )  
  {  
    semanticsText = semanticsText + " = null";  
  }  
  else if (semantics.Value.GetType() == typeof(int))   
  {  
    semanticsText = String.Format("{0} = {1:X} ", semanticsText, semantics.Value);  
  }   
  else   
  {  
    semanticsText = semanticsText + " = " + semantics.Value.ToString();  
  }  
  
  TreeNode semanticsNode = new TreeNode(semanticsText);  
  foreach (KeyValuePair<String, SemanticValue> child in semantics)   
  {  
    CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
  }  
  nodes.Add(semanticsNode);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As KeyValuePair(Of String, SemanticValue)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : System.Collections.Generic.KeyValuePair&lt;string, System.Speech.Recognition.SemanticValue&gt; -&gt; bool&#xA;override this.Contains : System.Collections.Generic.KeyValuePair&lt;string, System.Speech.Recognition.SemanticValue&gt; -&gt; bool" Usage="semanticValue.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="18bed-145">키 문자열 및 <see cref="T:System.Collections.Generic.KeyValuePair`2" /> 인스턴스의 지정된 값에 대해 인스턴스화된 <see cref="T:System.Speech.Recognition.SemanticValue" />의 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-145">An instance of <see cref="T:System.Collections.Generic.KeyValuePair`2" /> instantiated for a given value of a key string and a <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18bed-146">현재 <see cref="T:System.Speech.Recognition.SemanticValue" /> 인스턴스 컬렉션이 특정 키 및 키/값 쌍으로 표현되는 <see cref="T:System.Speech.Recognition.SemanticValue" />의 특정 인스턴스를 포함하는지 여부를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-146">Indicates whether the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance collection contains a specific key and a specific instance of <see cref="T:System.Speech.Recognition.SemanticValue" /> expressed as a key/value pair.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18bed-147">현재 <see cref="T:System.Speech.Recognition.SemanticValue" />에 키 문자열과 <see cref="T:System.Speech.Recognition.SemanticValue" />의 지정된 값에 대한 <c>KeyValuePair&lt;String, SemanticValue&gt;</c>의 인스턴스가 포함된 경우 <see langword="true" />인 <see langword="bool" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-147">Returns a <see langword="bool" /> which is <see langword="true" /> if the current <see cref="T:System.Speech.Recognition.SemanticValue" /> contains an instance of <c>KeyValuePair&lt;String, SemanticValue&gt;</c> for a specified value of the key string and the <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
          <span data-ttu-id="18bed-148">그렇지 않으면 <see langword="false" />이 반환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-148">Otherwise, <see langword="false" /> is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.ContainsKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::String ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : string -&gt; bool&#xA;override this.ContainsKey : string -&gt; bool" Usage="semanticValue.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="18bed-149">현재 <see cref="T:System.String" />에서 <see cref="T:System.Speech.Recognition.SemanticValue" />의 자식 인스턴스를 식별하는데 사용하는 키 문자열이 포함된 <see cref="T:System.Speech.Recognition.SemanticValue" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-149">
              <see cref="T:System.String" /> containing the key string used to identify a child instance of <see cref="T:System.Speech.Recognition.SemanticValue" /> under the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18bed-150">현재 <see cref="T:System.Speech.Recognition.SemanticValue" /> 인스턴스 컬렉션이 지정된 키 문자열과 함께 자식 <see cref="T:System.Speech.Recognition.SemanticValue" /> 인스턴스를 포함하는지 여부를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-150">Indicates whether the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance collection contains a child <see cref="T:System.Speech.Recognition.SemanticValue" /> instance with a given key string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18bed-151">
            <see langword="bool" />이 반환됩니다. <paramref name="key" />가 발견된 문자열과 태그된 자식 인스턴스 <see cref="T:System.Speech.Recognition.SemanticValue" />인 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" /> 입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-151">Returns a <see langword="bool" />, <see langword="true" /> if a child instance <see cref="T:System.Speech.Recognition.SemanticValue" /> tagged with the string <paramref name="key" /> is found, <see langword="false" /> if not.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18bed-152">예를 확인 하려면 런타임에 키 값으로 데이터를만 액세스할 수 있습니다 *의미 체계 ["myKey"]입니다. 값*,이 예외를 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-152">You can only access data by key value at runtime, for example to check *semantic["myKey"].Value*, and this generates an exception.</span></span> <span data-ttu-id="18bed-153">사용 하 여 개체를 쿼리 하는 것이 좋습니다 <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> 사용 하기 전에 <xref:System.Speech.Recognition.SemanticValue.Item%2A> 의 특정된 인스턴스와 함께 <xref:System.Speech.Recognition.SemanticValue>입니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-153">We recommend that you query the object with <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> before using <xref:System.Speech.Recognition.SemanticValue.Item%2A> with a given instance of <xref:System.Speech.Recognition.SemanticValue>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18bed-154">다음 예제에 대 한 처리기를 <xref:System.Speech.Recognition.Grammar.SpeechRecognized> 이벤트 전경색과 배경색을 변경 하는 명령 처리 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-154">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="18bed-155">구 인식 되는 구조가 없는데 의미 체계를 처리 한 후 처리기를 사용 하 여 적절 한 키의 존재 여부 확인 <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`, `colorRGBValueList`, 또는 `colorStringList)`, 기능적으로 구성 된 데이터를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-155">After handling phrases that are recognized but have no semantic structure, the handler checks for the presence of appropriate keys using <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`, `colorRGBValueList`, or `colorStringList)`,  and then processes the semantically organized data.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        // searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Speech.Recognition.SemanticValue.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18bed-156">하위 <see cref="T:System.Speech.Recognition.SemanticValue" /> 개체(현재 <see cref="T:System.Speech.Recognition.SemanticValue" /> 인스턴스 안에 있음) 개수를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-156">Returns the number of child <see cref="T:System.Speech.Recognition.SemanticValue" /> objects under the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18bed-157">
            <see cref="T:System.Speech.Recognition.SemanticValue" />의 자식 개체 수 현재 <see cref="T:System.Speech.Recognition.SemanticValue" /> 미만입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-157">The number of child <see cref="T:System.Speech.Recognition.SemanticValue" /> objects under the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18bed-158">구문 의미 분석의 사용 하지 않는 인식 결과 항상을 <xref:System.Speech.Recognition.SemanticValue.Count%2A> 값을 0으로 뿐만 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-158">Recognition results that do not make use of semantic parsing always have a <xref:System.Speech.Recognition.SemanticValue.Count%2A> value of zero, as well as a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18bed-159">다음 예제에 대 한 처리기를 <xref:System.Speech.Recognition.Grammar.SpeechRecognized> 이벤트 전경색과 배경색을 변경 하는 명령 처리 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-159">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="18bed-160">처리기에 구조가 없는 기본 의미 체계를 감지 하 여 구가 인식된 하 게 식별 하는 <xref:System.Speech.Recognition.SemanticValue.Count%2A> 0으로 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-160">The handler identifies recognized phrases that have no underlying semantic structure by detecting a <xref:System.Speech.Recognition.SemanticValue.Count%2A> of zero and a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null`.</span></span> <span data-ttu-id="18bed-161">이 인식 출력 원시 텍스트를 구문 분석 하 여 직접 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-161">This recognition output is then processed directly by parsing the raw text.</span></span>  
  
 <span data-ttu-id="18bed-162">다른 경우 처리기는 포그라운드 또는 백그라운드 명령이 바뀝니다 여부를 확인 하거나 올바른 키가 있음을 나타내기 위해 색 이름을 RGB 구성 요소를 가져올 키를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-162">In other cases, the handler uses keys to obtain the RGB components of a color name, to determine whether the command will change the foreground or background, or to indicate that no valid key was found.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        //  searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="semanticValue.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="18bed-163">확인할 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-163">The object to evaluate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18bed-164">지정된 개체가 <c>SemanticValue</c>의 인스턴스이고 <c>SemanticValue</c>의 현재 인스턴스와 같은지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-164">Determines whether a specified object is an instance of <c>SemanticValue</c> and equal to the current instance of <c>SemanticValue</c>.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18bed-165">지정한 개체가 현재 개체와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-165">
              <see langword="true" /> if the specified Object is equal to the current Object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="semanticValue.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18bed-166">
            <c>SemanticValue</c> 개체에 대한 해시 코드를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-166">Provides a hash code for a <c>SemanticValue</c> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18bed-167">현재 <see cref="T:System.Speech.Recognition.SemanticValue" /> 개체의 해시 코드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-167">A hash code for the current <see cref="T:System.Speech.Recognition.SemanticValue" /> object.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Speech.Recognition.SemanticValue this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Speech.Recognition.SemanticValue Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As String) As SemanticValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Speech::Recognition::SemanticValue ^ default[System::String ^] { System::Speech::Recognition::SemanticValue ^ get(System::String ^ key); void set(System::String ^ key, System::Speech::Recognition::SemanticValue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Speech.Recognition.SemanticValue with get, set" Usage="System.Speech.Recognition.SemanticValue.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.SemanticValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="18bed-168">
            <see cref="T:System.Speech.Recognition.SemanticValue" />의 현재 인스턴스에 포함된 <see langword="KeyValuePair&lt;String, SemanticValue&gt;" />의 키입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-168">A key for a <see langword="KeyValuePair&lt;String, SemanticValue&gt;" /> contained in the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="18bed-169">자식 <see cref="T:System.Speech.Recognition.SemanticValue" />에 현재 속한 인스턴스 <see cref="T:System.Speech.Recognition.SemanticValue" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-169">Returns child <see cref="T:System.Speech.Recognition.SemanticValue" /> instances that  belong to the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18bed-170">현재 자식 항목을 반환 <see cref="T:System.Speech.Recognition.SemanticValue" /> 키 값 쌍의 일부로 인덱싱할 수 있는: <c>KeyValuePair&lt;문자열</c><c>SemanticValue&gt;</c>합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-170">Returns a child of the current <see cref="T:System.Speech.Recognition.SemanticValue" /> that can be indexed as part of a key value pair: <c>KeyValuePair&lt;String,</c><c>SemanticValue&gt;</c>.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18bed-171"><xref:System.Speech.Recognition.SemanticValue.Item%2A> 읽기 전용 이며 멤버 수정 되는 경우 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-171">The <xref:System.Speech.Recognition.SemanticValue.Item%2A> is read-only and generates exceptions if members are modified.</span></span>  
  
 <span data-ttu-id="18bed-172">예를 확인 하려면 컴파일 시간에 아닐 실행 시간에 키 값으로 데이터를만 액세스할 수 있습니다 `semantic["myKey"].Value`합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-172">You can only access data by key value at run-time, not at compile-time, for example to check `semantic["myKey"].Value`.</span></span> <span data-ttu-id="18bed-173">존재 하지 않는 키를 지정 하면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-173">Specifying a key that is not present generates an exception.</span></span>  
  
 <span data-ttu-id="18bed-174">지정된 된 키의 존재를 검색 하려면 사용 합니다 <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> 속성에는 <xref:System.Speech.Recognition.SemanticValue> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="18bed-174">To detect the presence of a given key, use the <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> property on an <xref:System.Speech.Recognition.SemanticValue> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18bed-175">다음 예제에 대 한 처리기를 <xref:System.Speech.Recognition.Grammar.SpeechRecognized> 이벤트 전경색과 배경색을 변경 하는 명령 처리 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-175">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="18bed-176">의미 체계 구조가 없는 인식할 수 있는 구 처리 후 처리기를 사용 하 여 적절 한 키의 존재 여부 확인 <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`를 `colorRGBValueList`, 또는 `colorStringList)`를 사용 하 여는 <xref:System.Speech.Recognition.SemanticValue.Item%2A> 속성 노드를 가져오려면 필수 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-176">After handling recognized phrases that have no semantic structure, the handler checks for the presence of appropriate keys using <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`, `colorRGBValueList`, or `colorStringList)`, and then uses the <xref:System.Speech.Recognition.SemanticValue.Item%2A> property to obtain the nodes with needed information.</span></span>  
  
 <span data-ttu-id="18bed-177">사용 <xref:System.Speech.Recognition.SemanticValue.Item%2A> 아래 강조 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-177">The use of <xref:System.Speech.Recognition.SemanticValue.Item%2A> is highlighted below.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        //  searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantic keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of the foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">
          <span data-ttu-id="18bed-178">
            <paramref name="key" /> 매개 변수와 일치하는 키가 있는 <see cref="T:System.Speech.Recognition.SemanticValue" />의 현재 인스턴스의 자식 멤버가 없으면 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-178">Thrown if no child member of the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" /> has the key matching the <paramref name="key" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="18bed-179">지정된 인덱스에서 코드의 <see cref="T:System.Speech.Recognition.SemanticValue" />를 변경하려고 할 경우 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-179">Thrown if code attempts to change the <see cref="T:System.Speech.Recognition.SemanticValue" /> at a given index.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As KeyValuePair(Of String, SemanticValue)) Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; key) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear() = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of String, SemanticValue)(), index As Integer) Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt; ^ array, int index) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String,System::Speech::Recognition::SemanticValue&gt;&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As KeyValuePair(Of String, SemanticValue)) As Boolean Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; key) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add">
      <MemberSignature Language="C#" Value="void IDictionary&lt;string,SemanticValue&gt;.Add (string key, System.Speech.Recognition.SemanticValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add(string key, class System.Speech.Recognition.SemanticValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Add(System.String,System.Speech.Recognition.SemanticValue)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As String, value As SemanticValue) Implements IDictionary(Of String, SemanticValue).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add(System::String ^ key, System::Speech::Recognition::SemanticValue ^ value) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;string&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of String) Implements IDictionary(Of String, SemanticValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ System::Collections::Generic::IDictionary&lt;System::String,System::Speech::Recognition::SemanticValue&gt;::Keys { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;string,SemanticValue&gt;.Remove (string key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As String) As Boolean Implements IDictionary(Of String, SemanticValue).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove(System::String ^ key) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;string,SemanticValue&gt;.TryGetValue (string key, out System.Speech.Recognition.SemanticValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue(string key, [out] class System.Speech.Recognition.SemanticValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#TryGetValue(System.String,System.Speech.Recognition.SemanticValue@)" />
      <MemberSignature Language="VB.NET" Value="Function TryGetValue (key As String, ByRef value As SemanticValue) As Boolean Implements IDictionary(Of String, SemanticValue).TryGetValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue(System::String ^ key, [Runtime::InteropServices::Out] System::Speech::Recognition::SemanticValue ^ % value) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::TryGetValue;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;System.Speech.Recognition.SemanticValue&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.Speech.Recognition.SemanticValue&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of SemanticValue) Implements IDictionary(Of String, SemanticValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;System::Speech::Recognition::SemanticValue ^&gt; ^ System::Collections::Generic::IDictionary&lt;System::String,System::Speech::Recognition::SemanticValue&gt;::Values { System::Collections::Generic::ICollection&lt;System::Speech::Recognition::SemanticValue ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Speech.Recognition.SemanticValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, SemanticValue)) Implements IEnumerable(Of KeyValuePair(Of String, SemanticValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="18bed-180">컬렉션을 반복하는 열거자를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-180">Returns an enumerator that iterates through a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="18bed-181">컬렉션을 반복하는 열거자를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-181">Returns an enumerator that iterates through a collection.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Speech.Recognition.SemanticValue.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="18bed-182">현재 <see cref="T:System.Speech.Recognition.SemanticValue" />에 포함된 정보를 반환하는 읽기 전용 속성</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-182">A read-only property that returns the information contained in the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="18bed-183">
            <see cref="T:System.Object" /> 인스턴스를 반환합니다. 이 인스턴스에는 현재<see cref="T:System.Speech.Recognition.SemanticValue" /> 인스턴스가 저장된 정보가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="18bed-183">Returns an <see cref="T:System.Object" /> instance containing the information stored in the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18bed-184">구문 의미 분석의 사용 되지 않도록 하는 인식 결과 항상을 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 `null` 및 <xref:System.Speech.Recognition.SemanticValue.Count%2A> 0의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-184">Recognition results which do not make use of semantic parsing always have a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null` and a <xref:System.Speech.Recognition.SemanticValue.Count%2A> property of zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18bed-185">다음 예제에서는 재귀적으로 트래버스 되 고 다음 정보 (신뢰도 포함)으로 표시를 <xref:System.Windows.Forms.TreeNodeCollection>, 되거나 노드로 트리 구조의 의미 체계를 구성 하는 데 구를 인식 합니다.</span><span class="sxs-lookup"><span data-stu-id="18bed-185">The following example is used to recursively traverse and then display information (including confidence) as a <xref:System.Windows.Forms.TreeNodeCollection>, or as the nodes making up the tree structure of the semantics used to recognize a phrase.</span></span>  
  
```csharp  
internal static void CreateSemanticsTreeNodes(  
          TreeNodeCollection nodes,  
          SemanticValue semantics,  
          String name)   
{  
  string semanticsText =   
      String.Format("  {0} ( Confidence {1})", name,semantics.Confidence);  
  
  // Format integers as hexadecimal.  
  if (semantics.Value == null )  
  {  
    semanticsText = semanticsText + " = null";  
  }  
  else if (semantics.Value.GetType() == typeof(int))   
  {  
    semanticsText = String.Format("{0} = {1:X} ", semanticsText, semantics.Value);  
  }  
  else   
  {  
    semanticsText = semanticsText + " = " + semantics.Value.ToString();  
  }  
  
  TreeNode semanticsNode = new TreeNode(semanticsText);  
  foreach (KeyValuePair<String, SemanticValue> child in semantics)   
  {  
    CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
  }  
  nodes.Add(semanticsNode);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>