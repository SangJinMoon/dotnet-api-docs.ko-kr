<Type Name="RegistryKey" FullName="Microsoft.Win32.RegistryKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bd1c542732c55e805b838b930fc5df9a58097d3b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36657898" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistryKey : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed RegistryKey extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.RegistryKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistryKey&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistryKey sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type RegistryKey = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a key-level node in the Windows registry. This class is a registry encapsulation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스를 가져오려면 <xref:Microsoft.Win32.RegistryKey>의 정적 멤버 중 하나를 사용 하 여는 <xref:Microsoft.Win32.Registry> 클래스입니다.  
  
 레지스트리는 컴퓨터에 운영 체제 및 응용 프로그램에 대 한 정보의 중앙 저장소로 사용 됩니다. 레지스트리는 저장 된 요소의 논리적 순서에 따라 형식으로 구성 됩니다 (참조 하십시오 <xref:Microsoft.Win32.Registry> 이 계층의 기본 수준 항목에 대 한). 레지스트리에서 정보를 저장할 때 저장 되는 정보의 유형에 따라 적절 한 위치를 선택 합니다. 이러한 응용 프로그램에 예기치 못한 동작이 발생할 수 있습니다이 사용자 고유의 응용 프로그램에 영향을 줄 수도 있으므로 다른 응용 프로그램에서 만든 정보를 삭제 하지 않도록 해야 합니다.  
  
> [!IMPORTANT]
>  이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다. 직접 형식의 dispose를 호출 해당 <xref:System.IDisposable.Dispose%2A> 에서 메서드는 `try` / `catch` 블록입니다. 작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다. 자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
 레지스트리 키는 레지스트리에 조직의 기본 단위로 있으며 파일 탐색기에서 폴더와 비교할 수 있습니다. 특정 키 폴더가 있는 하위 폴더와 마찬가지로, 하위 키를 가질 수 있습니다. 이렇게 하려면 적절 한 권한이 사용자 및 기본 키가 아닌 키 또는 기본 키 바로 아래 수준에서 각 키를 삭제할 수 있습니다. 각 키 정보를 저장 하는 데 사용 되는 것 (값과 비교할 수 파일)와 관련 된 여러 값이 있는-예를 들어 컴퓨터에 설치 된 응용 프로그램에 대 한 정보입니다. 하나의 특정 개수의 검색 하거나 필요할 때 업데이트할 수 있는 정보를 보유 하는 각 값입니다. 예를 들어, 만들 수 있습니다는 <xref:Microsoft.Win32.RegistryKey> 를 HKEY_LOCAL_MACHINE\Software 키 아래에서 회사 및 회사 만드는 각 응용 프로그램에 대 한 하위 키에 대 한 합니다. 각 하위 키 화면 위치와 크기, 색 설정 등 해당 응용 프로그램에 관련 된 정보가 저장 하거나 파일 확장명을 인식 합니다.  
  
 레지스트리에 저장 된 정보는 다른 응용 프로그램 및 사용자를 사용할 수 및 따라서 안되며 보안 데이터 나 중요 한 응용 프로그램 정보를 저장 하기 note 합니다.  
  
> [!CAUTION]
>  노출 하지 마십시오. <xref:Microsoft.Win32.RegistryKey> 방식 악의적인 프로그램 수 무의미 한 하위 수천 만들거나 않은 키/값 쌍 개체입니다. 예를 들어 임의의 키 또는 값을 입력 하는 호출자를 허용 하지 않습니다.  
  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 더 이상 레지스트리 키의 길이 255 자로 제한 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 HKEY_CURRENT_USER 아래에 하위 키를 만들고 해당 콘텐츠를 조작 하 다음 하위 키를 삭제 하는 방법을 보여 줍니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.Registry" />
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="registryKey.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes the key and flushes it to disk if its contents have been modified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 시스템 키에 대해이 메서드를 호출 합니다 되므로 효과가 없습니다, 시스템 키는 절대로 닫히지 않습니다.  
  
 이 메서드는 아무 작업도 수행의 인스턴스에서 호출 하는 경우 `RegistryKey` 이미 닫혀 있는 합니다.  
  
   
  
## Examples  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Flush" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new subkey or opens an existing subkey.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open. This string is not case-sensitive.</param>
        <summary>Creates a new subkey or opens an existing subkey for write access.</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed. If a zero-length string is specified for <paramref name="subkey" />, the current <see cref="T:Microsoft.Win32.RegistryKey" /> object is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 작업을 수행 하기 위해 레지스트리 계층 구조에서이 수준에 해당 하는 권한을 사용자에 게 있어야 합니다.  
  
> [!CAUTION]
>  노출 하지 마십시오. <xref:Microsoft.Win32.RegistryKey> 방식 악의적인 프로그램 수 무의미 한 하위 수천 만들거나 않은 키/값 쌍 개체입니다. 예를 들어 임의의 키 또는 값을 입력 하는 호출자를 허용 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 HKEY_CURRENT_USER 아래에 하위 키를 만들고 해당 콘텐츠를 조작 하 다음 하위 키를 삭제 하는 방법을 보여 줍니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> on which this method is being invoked is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> cannot be written to; for example, it was not opened as a writable key , or the user does not have the necessary access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key, or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">또는 레지스트리 키 if를 만들 수 있는 경우 지정된 된 레지스트리 키를 수정 하는 기능에 대 한 것가 아직 없는 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open. This string is not case-sensitive.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <summary>Creates a new subkey or opens an existing subkey for write access, using the specified permission check option.</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed. If a zero-length string is specified for <paramref name="subkey" />, the current <see cref="T:Microsoft.Win32.RegistryKey" /> object is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 작업을 수행 하기 위해 레지스트리 계층 구조에서이 수준에 해당 하는 권한을 사용자에 게 있어야 합니다.  
  
> [!CAUTION]
>  노출 하지 마십시오. <xref:Microsoft.Win32.RegistryKey> 방식 악의적인 프로그램 수 무의미 한 하위 수천 만들거나 않은 키/값 쌍 개체입니다. 예를 들어 임의의 키 또는 값을 입력 하는 호출자를 허용 하지 않습니다.  
  
 사용 하려면는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 있어야의 인스턴스는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다. 인스턴스를 가져오려면 <xref:Microsoft.Win32.RegistryKey>의 정적 멤버 중 하나를 사용 하 여는 <xref:Microsoft.Win32.Registry> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contains an invalid value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> on which this method is being invoked is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> cannot be written to; for example, it was not opened as a writable key, or the user does not have the necessary access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key, or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">또는 레지스트리 키 if를 만들 수 있는 경우 지정된 된 레지스트리 키를 수정 하는 기능에 대 한 것가 아직 없는 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open. This string is not case-sensitive.</param>
        <param name="writable">
          <see langword="true" /> to indicate the new subkey is writable; otherwise, <see langword="false" />.</param>
        <summary>Creates a new subkey or opens an existing subkey with the specified access.  Available starting in [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed. If a zero-length string is specified for <paramref name="subkey" />, the current <see cref="T:Microsoft.Win32.RegistryKey" /> object is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 작업을 수행 하기 위해 레지스트리 계층 구조에서이 수준에 해당 하는 권한을 사용자에 게 있어야 합니다.  
  
> [!CAUTION]
>  노출 하지 마십시오. <xref:Microsoft.Win32.RegistryKey> 방식 악의적인 프로그램 수 무의미 한 하위 수천 만들거나 않은 키/값 쌍 개체입니다. 예를 들어 임의의 키 또는 값을 입력 하는 호출자를 허용 하지 않습니다.  
  
 사용 하려면는 <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> 메서드를 있어야의 인스턴스는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다. 인스턴스를 가져오려면 <xref:Microsoft.Win32.RegistryKey>의 정적 멤버 중 하나를 사용 하 여는 <xref:Microsoft.Win32.Registry> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> cannot be written to; for example, it was not opened as a writable key, or the user does not have the necessary access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key, or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open. This string is not case-sensitive.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <param name="registrySecurity">The access control security for the new key.</param>
        <summary>Creates a new subkey or opens an existing subkey for write access, using the specified permission check option and registry security.</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed. If a zero-length string is specified for <paramref name="subkey" />, the current <see cref="T:Microsoft.Win32.RegistryKey" /> object is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> 메서드로 지정 된 액세스 제어를가지고 있는 레지스트리 키를 만듭니다.는 `registrySecurity` 매개 변수입니다. <xref:Microsoft.Win32.RegistryKey> 반환 되는 개체는 레지스트리 키를 나타내지 않으며 해당 개체에 지정 된 액세스 제어로 제한 되어 있지는 `registrySecurity` 매개 변수입니다.  
  
 경우 `permissionCheck` 은 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, 읽기/쓰기 액세스에 대 한 키가 열립니다. 경우 `permissionCheck` 은 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>, 읽기 액세스에 대 한 키가 열립니다.  
  
 이전 버전과 호환성에 대 한 키를 읽고 쓰는 경우에 대 한 열 `permissionCheck` 은 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType> 및 부모 키가 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>합니다. 부모 키가 다른 값으로 설정한 경우 읽기/쓰기 상태는 부모 키의 설정에 의해 제어 됩니다.  
  
 이 작업을 수행 하기 위해 사용자 레지스트리 계층 구조에서 사용 권한을이 수준이 하에 있어야 합니다.  
  
> [!CAUTION]
>  노출 하지 마십시오. <xref:Microsoft.Win32.RegistryKey> 방식 악의적인 프로그램 수 무의미 한 하위 수천 만들거나 않은 키/값 쌍 개체입니다. 예를 들어 임의의 키 또는 값을 입력 하는 호출자를 허용 하지 않습니다.  
  
 사용 하려면는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 있어야의 인스턴스는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다. 인스턴스를 가져오려면 <xref:Microsoft.Win32.RegistryKey>의 정적 멤버 중 하나를 사용 하 여는 <xref:Microsoft.Win32.Registry> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contains an invalid value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> on which this method is being invoked is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> cannot be written to; for example, it was not opened as a writable key, or the user does not have the necessary access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key, or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">또는 레지스트리 키 if를 만들 수 있는 경우 지정된 된 레지스트리 키를 수정 하는 기능에 대 한 것가 아직 없는 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable, Microsoft.Win32.RegistryOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable, valuetype Microsoft.Win32.RegistryOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean,Microsoft.Win32.RegistryOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean, options As RegistryOptions) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable, Microsoft::Win32::RegistryOptions options);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open. This string is not case-sensitive.</param>
        <param name="writable">
          <see langword="true" /> to indicate the new subkey is writable; otherwise, <see langword="false" />.</param>
        <param name="options">The registry option to use.</param>
        <summary>Creates a new subkey or opens an existing subkey with the specified access.  Available starting in [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed. If a zero-length string is specified for <paramref name="subkey" />, the current <see cref="T:Microsoft.Win32.RegistryKey" /> object is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 작업을 수행 하기 위해 레지스트리 계층 구조에서이 수준에 해당 하는 권한을 사용자에 게 있어야 합니다.  
  
> [!CAUTION]
>  노출 하지 마십시오. <xref:Microsoft.Win32.RegistryKey> 방식 악의적인 프로그램 수 무의미 한 하위 수천 만들거나 않은 키/값 쌍 개체입니다. 예를 들어 임의의 키 또는 값을 입력 하는 호출자를 허용 하지 않습니다.  
  
 사용 하려면는 <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> 메서드를 있어야의 인스턴스는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다. 인스턴스를 가져오려면 <xref:Microsoft.Win32.RegistryKey>의 정적 멤버 중 하나를 사용 하 여는 <xref:Microsoft.Win32.Registry> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> does not specify a valid Option</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> cannot be written to; for example, it was not opened as a writable key, or the user does not have the necessary access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key, or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions options);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions options) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions options);" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck, options As RegistryOptions) As RegistryKey" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netcore-2.0" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <param name="options">The registry option to use; for example, that creates a volatile key.</param>
        <param name="registryOptions">To be added.</param>
        <summary>Creates a subkey or opens a subkey for write access, using the specified permission check and registry options.</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 가져오려면 <xref:Microsoft.Win32.RegistryKey> 개체, 빈 문자열을 지정 ("")에 대 한 `subkey`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> object is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> object cannot be written to; for example, it was not opened as a writable key, or the user does not have the required access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions registryOptions, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registryOptions, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <param name="registryOptions">The registry option to use.</param>
        <param name="registrySecurity">The access control security for the new subkey.</param>
        <summary>Creates a subkey or opens a subkey for write access, using the specified permission check option, registry option, and registry security.</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 가져오려면 <xref:Microsoft.Win32.RegistryKey> 개체, 빈 문자열을 지정 ("")에 대 한 `subkey`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> object is closed. Closed keys cannot be accessed.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> object cannot be written to; for example, it was not opened as a writable key, or the user does not have the required access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deletes the specified subkey.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string -&gt; unit" Usage="registryKey.DeleteSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">The name of the subkey to delete. This string is not case-sensitive.</param>
        <summary>Deletes the specified subkey.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 자식 하위 키를 삭제 하려면 <xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>합니다.  
  
 레지스트리 키를 삭제 하는 경우에 주의 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 <xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A>합니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source2.cpp#5)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source2.cs#5)]
 [!code-vb[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <paramref name="subkey" /> has child subkeys</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="subkey" /> parameter does not specify a valid registry key</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" /></exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정된 된 레지스트리 키를 수정할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string * bool -&gt; unit" Usage="registryKey.DeleteSubKey (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">The name of the subkey to delete. This string is not case-sensitive.</param>
        <param name="throwOnMissingSubKey">Indicates whether an exception should be raised if the specified subkey cannot be found. If this argument is <see langword="true" /> and the specified subkey does not exist, an exception is raised. If this argument is <see langword="false" /> and the specified subkey does not exist, no action is taken.</param>
        <summary>Deletes the specified subkey, and specifies whether an exception is raised if the subkey is not found.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 자식 하위 키를 삭제 하려면 <xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>합니다.  
  
 레지스트리 키를 삭제 하는 경우에 주의 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="subkey" /> has child subkeys.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="subkey" /> does not specify a valid registry key, and <paramref name="throwOnMissingSubKey" /> is <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정된 된 레지스트리 키를 수정할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKeyTree">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deletes a subkey and any child subkeys recursively, with optional exception handling.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string -&gt; unit" Usage="registryKey.DeleteSubKeyTree subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">The subkey to delete. This string is not case-sensitive.</param>
        <summary>Deletes a subkey and any child subkeys recursively.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하위 키 및 해당 하는 트리를 삭제 하려면 적절 한 권한이 있어야 합니다.  
  
> [!CAUTION]
>  특정 키를 삭제 트리에서 키 아래 항목을 모두 제거 됩니다. 경고 없이 제공 됩니다. 사용 하 여 없는 자식 하위 키가 있는 경우에 하위 키를 삭제 하려는 경우는 <xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A> 메서드.  
  
   
  
## Examples  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Deletion of a root hive is attempted.  -or-  <paramref name="subkey" /> does not specify a valid registry subkey.</exception>
        <exception cref="T:System.IO.IOException">An I/O error has occurred.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정된 된 레지스트리 키를 수정할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string * bool -&gt; unit" Usage="registryKey.DeleteSubKeyTree (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">The name of the subkey to delete. This string is not case-sensitive.</param>
        <param name="throwOnMissingSubKey">Indicates whether an exception should be raised if the specified subkey cannot be found. If this argument is <see langword="true" /> and the specified subkey does not exist, an exception is raised. If this argument is <see langword="false" /> and the specified subkey does not exist, no action is taken.</param>
        <summary>Deletes the specified subkey and any child subkeys recursively, and specifies whether an exception is raised if the subkey is not found.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">An attempt was made to delete the root hive of the tree.  -or-  <paramref name="subkey" /> does not specify a valid registry subkey, and <paramref name="throwOnMissingSubKey" /> is <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the key.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정된 된 레지스트리 키를 수정할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deletes the specified value from this key, and throws an exception if the value is not found.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string -&gt; unit" Usage="registryKey.DeleteValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to delete.</param>
        <summary>Deletes the specified value from this key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 95, Windows 98, Windows 98 Second Edition 및 Windows Millennium Edition에서 빈 문자열을 지정 하는 `name` 매개 변수 기본값 삭제 되지 않습니다.  
  
   
  
## Examples  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#3)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#3)]
 [!code-vb[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is not a valid reference to a value.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is read-only.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정된 된 레지스트리 키를 삭제할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name, bool throwOnMissingValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name, bool throwOnMissingValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String, throwOnMissingValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name, bool throwOnMissingValue);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string * bool -&gt; unit" Usage="registryKey.DeleteValue (name, throwOnMissingValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnMissingValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to delete.</param>
        <param name="throwOnMissingValue">Indicates whether an exception should be raised if the specified value cannot be found. If this argument is <see langword="true" /> and the specified value does not exist, an exception is raised. If this argument is <see langword="false" /> and the specified value does not exist, no action is taken.</param>
        <summary>Deletes the specified value from this key, and specifies whether an exception is raised if the value is not found.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `throwOnMissingValue` 은 `false`, 없는 경우 삭제 성공적으로, 이후에 삭제 된 값에 액세스 하려고 하지 않고 있는지 알 수 없습니다. 따라서 이런이 방식으로 레지스트리에서 값을 삭제할 때는 주의 해야 합니다.  
  
 Windows 95, Windows 98, Windows 98 Second Edition 및 Windows Millennium Edition에서 빈 문자열을 지정 하는 `name` 매개 변수 기본값 삭제 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is not a valid reference to a value and <paramref name="throwOnMissingValue" /> is <see langword="true" />.  -or-  <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is read-only.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정된 된 레지스트리 키를 삭제할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="registryKey.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:Microsoft.Win32.RegistryKey" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dispose` 사용을 마치면 <xref:Microsoft.Win32.RegistryKey>를 호출합니다. `Dispose` 메서드를 사용하면 <xref:Microsoft.Win32.RegistryKey>를 사용할 수 없게 됩니다. 호출한 후 `Dispose`에 대 한 모든 참조를 해제 해야는 <xref:Microsoft.Win32.RegistryKey> 가비지 수집기는 메모리를 회수할 수 있도록 하는 <xref:Microsoft.Win32.RegistryKey> 차지한 합니다.  
  
 자세한 내용은 참조 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md) 및 [Dispose 메서드를 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.  
  
> [!NOTE]
>  `Dispose`에 대한 마지막 참조를 해제하기 전에 반드시 <xref:Microsoft.Win32.RegistryKey>를 호출하십시오. 이렇게 하지 않으면 가비지 수집기가 <xref:Microsoft.Win32.RegistryKey> 개체의 `Finalize` 메서드를 호출할 때까지 사용 중인 리소스가 해제되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="registryKey.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Writes all the attributes of the specified open registry key into the registry.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출할 필요는 없습니다 `Flush` 키에 대 한 변경 내용을 쓸 수 있습니다. 레지스트리 변경 된 경우 디스크에 플러시됩니다 레지스트리 지연 플을 사용 합니다. 지연 플러시하는 시스템에서 지정한 시간 제한 간격 후 자동으로 정기적으로 발생합니다. 레지스트리 변경도 플러시되 디스크에 시스템을 종료 합니다.  
  
 와 달리 <xref:Microsoft.Win32.RegistryKey.Close%2A>, `Flush` 함수는에 모든 데이터가 레지스트리에 기록 된 경우에을 반환 합니다.  
  
 `Flush` 다른 키의 전체 또는 일부의 함수를 작성할 수도 있습니다. 이 함수를 과도 하 게 호출 응용 프로그램의 성능에 부정적인 영향을 미칠 수 있습니다.  
  
 응용 프로그램 호출 해야 합니다. `Flush` 있어야 하는 경우 특정 레지스트리 변경 내용이 기록 되므로 디스크에 있습니다. 일반적으로 `Flush` 드물게 얻어지는 경우 사용 하지 않아도 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHandle">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a registry key from a specified handle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" />
      </Parameters>
      <Docs>
        <param name="handle">The handle to the registry key.</param>
        <summary>Creates a registry key from a specified handle.</summary>
        <returns>A registry key.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to perform this action.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle (handle, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="handle">The handle to the registry key.</param>
        <param name="view">The registry view to use.</param>
        <summary>Creates a registry key from a specified handle and registry view setting.</summary>
        <returns>A registry key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `view` 하위 키를 여는 등의 후속 작업에서이 메서드에 대 한 매개 변수를 사용 합니다.  
  
 경우 `view` 은 <xref:Microsoft.Win32.RegistryView.Registry64> 하지만 컴퓨터가 실행 되는 32 비트 운영 체제, 반환 된 키 ´ ֲ는 <xref:Microsoft.Win32.RegistryView.Registry32> 보기.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="view" /> is invalid.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to perform this action.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the access control security for the current registry key.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the access control security for the current registry key.</summary>
        <returns>An object that describes the access control permissions on the registry key represented by the current <see cref="T:Microsoft.Win32.RegistryKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드 하는 것은 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%28System.Security.AccessControl.AccessControlSections%29> 메서드 오버 로드는 다음 플래그의 비트 조합으로: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, 및 <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>합니다. 오버 로드 하는 다른 사용 권한에 대 한 검색을 사용할 수 있습니다.  
  
 사용자에 게 있어야 <xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType> 권한을이 메서드를 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the necessary permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.InvalidOperationException">The current key has been deleted.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">A bitwise combination of enumeration values that specifies the type of security information to get.</param>
        <summary>Returns the specified sections of the access control security for the current registry key.</summary>
        <returns>An object that describes the access control permissions on the registry key represented by the current <see cref="T:Microsoft.Win32.RegistryKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 사용자에 게 부여 된 액세스 권한을 요청 하는 다음 플래그의 비트 조합 지정: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, 및 <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>합니다. 사용할 수 있습니다는 <xref:Microsoft.Win32.RegistryKey.GetAccessControl> 메서드 오버 로드를 해당 값의 조합을 정확 하 게 지정 합니다.  
  
 사용자에 게 있어야 <xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType> 권한을이 메서드를 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the necessary permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.InvalidOperationException">The current key has been deleted.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSubKeyNames">
      <MemberSignature Language="C#" Value="public string[] GetSubKeyNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetSubKeyNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSubKeyNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetSubKeyNames();" />
      <MemberSignature Language="F#" Value="member this.GetSubKeyNames : unit -&gt; string[]" Usage="registryKey.GetSubKeyNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves an array of strings that contains all the subkey names.</summary>
        <returns>An array of strings that contains the names of the subkeys for the current key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 찾기 이름을 재귀적으로 수행 합니다. 호출 된 기본 수준의 이름을 반환 합니다.  
  
   
  
## Examples  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.IO.IOException">A system error occurred, for example the current key has been deleted.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">레지스트리에서 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves the value associated with the specified name.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string -&gt; obj" Usage="registryKey.GetValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to retrieve. This string is not case-sensitive.</param>
        <summary>Retrieves the value associated with the specified name. Returns <see langword="null" /> if the name/value pair does not exist in the registry.</summary>
        <returns>The value associated with <paramref name="name" />, or <see langword="null" /> if <paramref name="name" /> is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  레지스트리 키 이름과 연결 되지 않은 하나의 값을 가질 수 있습니다. 레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열이 이름 대신 표시 됩니다. 명명 되지 않은 값이를 검색 하려면 `null` 또는 빈 문자열 ("")에 대 한 `name`합니다.  
  
 경우는 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 확장 가능한 문자열 값을 검색 하는 메서드 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), 로컬 환경에서 데이터를 사용 하 여 환경 문자열을 확장 합니다. 원격 컴퓨터의 레지스트리에서 문자열 값을 검색 하려면 사용 된 <xref:Microsoft.Win32.RegistryKey.GetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueOptions%29> 메서드 오버 로드를 확장할 되도록 지정 합니다.  
  
> [!NOTE]
>  환경 변수에 대 한 확장 참조를 포함 하는 값을 문자열로 저장 된 경우 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), 확장 가능한 문자열 대신 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 확장 하지 않습니다. 호출 하 여 검색 한 후 이러한 문자열을 확장할 수 있습니다는 <xref:System.Environment.ExpandEnvironmentVariables%2A> 메서드.  
  
> [!NOTE]
>  데이터를 검색 하는 권장된 방법은 <xref:Microsoft.Win32.Registry.PerformanceData> 키가 사용 하는 <xref:System.Diagnostics.PerformanceCounter> 클래스 보다는 <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> 메서드.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> REG_NONE 또는 REG_LINK 유형의 값을 읽기를 지원 하지 않습니다.  두 경우 모두 기본값 (`null`) 실제 값 대신 반환 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 테스트 키를 만들고 서로 다른 데이터 형식의 값을 키에 추가 합니다. 예제에서는 다음 이름/값 쌍을 읽고 콘솔에 표시를 사용 하는 <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> 해당 레지스트리 데이터 형식을 검색 하는 메서드입니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.IO.IOException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value has been marked for deletion.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">레지스트리에서 읽지 못했습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">REG_EXPAND_SZ 형식의 레지스트리 키를 읽지 못했습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj -&gt; obj" Usage="registryKey.GetValue (name, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to retrieve. This string is not case-sensitive.</param>
        <param name="defaultValue">The value to return if <c>name</c> does not exist.</param>
        <summary>Retrieves the value associated with the specified name. If the name is not found, returns the default value that you provide.</summary>
        <returns>The value associated with <paramref name="name" />, with any embedded environment variables left unexpanded, or <paramref name="defaultValue" /> if <paramref name="name" /> is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 이름을 아직 존재 하지 않는 경우를 처리 하-예를 들어 처음 응용 프로그램을 실행 합니다. 이 오버 로드를 호출할 때마다 사용 하는 `defaultValue` 매개 변수를 지정 하는 경우에 반환할 값입니다 `name` 존재 하지 않습니다.  
  
> [!NOTE]
>  레지스트리 키 이름과 연결 되지 않은 하나의 값을 가질 수 있습니다. 레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열이 이름 대신 표시 됩니다. 명명 되지 않은 값이를 검색 하려면 `null` 또는 빈 문자열 ("")에 대 한 `name`합니다.  
  
 경우는 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 확장 가능한 문자열 값을 검색 하는 메서드 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), 로컬 환경에서 데이터를 사용 하 여 환경 문자열을 확장 합니다. 원격 컴퓨터의 레지스트리에서 문자열 값을 검색 하려면 사용 된 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 오버 로드를 확장할 되도록 지정 합니다.  
  
> [!NOTE]
>  환경 변수에 대 한 확장 참조를 포함 하는 값을 문자열로 저장 된 경우 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), 확장 가능한 문자열 대신 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 메서드 확장 하지 않습니다. 호출 하 여 검색 한 후 이러한 문자열을 확장할 수 있습니다는 <xref:System.Environment.ExpandEnvironmentVariables%2A> 메서드.  
  
> [!NOTE]
>  데이터를 검색 하는 권장된 방법은 <xref:Microsoft.Win32.Registry.PerformanceData> 키가 사용 하는 <xref:System.Diagnostics.PerformanceCounter> 클래스 보다는 <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> 메서드.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> REG_NONE 또는 REG_LINK 유형의 값을 읽기를 지원 하지 않습니다.  두 경우 모두 기본값 (`null`) 실제 값 대신 반환 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 값이 있는 테스트 키를 만들고 해당 값을 검색 합니다. 이 예제에서는 키;에서 존재 하지 않는 값을 검색 하려고 합니다. 이 경우에 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 메서드가 지정 된 기본값을 반환 합니다.  
  
 [!code-cpp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CS/source.cs#1)]
 [!code-vb[Classic RegistryKey.GetValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.IO.IOException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value has been marked for deletion.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">레지스트리에서 읽지 못했습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">REG_EXPAND_SZ 형식의 레지스트리 키를 읽지 못했습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue, Microsoft.Win32.RegistryValueOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue, valuetype Microsoft.Win32.RegistryValueOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object,Microsoft.Win32.RegistryValueOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object, options As RegistryValueOptions) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue, Microsoft::Win32::RegistryValueOptions options);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj * Microsoft.Win32.RegistryValueOptions -&gt; obj" Usage="registryKey.GetValue (name, defaultValue, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryValueOptions" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to retrieve. This string is not case-sensitive.</param>
        <param name="defaultValue">The value to return if <c>name</c> does not exist.</param>
        <param name="options">One of the enumeration values that specifies optional processing of the retrieved value.</param>
        <summary>Retrieves the value associated with the specified name and retrieval options. If the name is not found, returns the default value that you provide.</summary>
        <returns>The value associated with <paramref name="name" />, processed according to the specified <paramref name="options" />, or <paramref name="defaultValue" /> if <paramref name="name" /> is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 검색된 된 값의 특수 처리를 지정 합니다. 지정할 수는 예를 들어 <xref:Microsoft.Win32.RegistryValueOptions.DoNotExpandEnvironmentNames?displayProperty=nameWithType> 형식의 레지스트리 값을 검색할 때 <xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType> 확장 하지 않고 문자열을 검색 하기 위해 환경 변수를 포함 합니다.  
  
 사용 하 여는 `defaultValue` 경우 반환할 값을 지정 하려면 매개 변수 `name` 존재 하지 않습니다.  
  
> [!NOTE]
>  레지스트리 키 이름과 연결 되지 않은 하나의 값을 가질 수 있습니다. 레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열이 이름 대신 표시 됩니다. 명명 되지 않은 값이를 검색 하려면 `null` 또는 빈 문자열 ("")에 대 한 `name`합니다.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> REG_NONE 또는 REG_LINK 유형의 값을 읽기를 지원 하지 않습니다.  두 경우 모두 기본값 (`null`) 실제 값 대신 반환 됩니다.  
  
   
  
## Examples  
 다음 코드 샘플 테스트 키, 포함 된 환경 변수를 가진 값을 추가 및 확장 및 확장 되지 않은 형태로 값을 검색 합니다.  
  
 [!code-cpp[RegistryValueOptions#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryValueOptions/CPP/RegistryValueOptions.cpp#1)]
 [!code-csharp[RegistryValueOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryValueOptions/CS/source.cs#1)]
 [!code-vb[RegistryValueOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryValueOptions/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.IO.IOException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value has been marked for deletion.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> is not a valid <see cref="T:Microsoft.Win32.RegistryValueOptions" /> value; for example, an invalid value is cast to <see cref="T:Microsoft.Win32.RegistryValueOptions" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">레지스트리에서 읽지 못했습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">REG_EXPAND_SZ 형식의 레지스트리 키를 읽지 못했습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryValueOptions" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValueKind">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryValueKind GetValueKind (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.Win32.RegistryValueKind GetValueKind(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueKind (name As String) As RegistryValueKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryValueKind GetValueKind(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValueKind : string -&gt; Microsoft.Win32.RegistryValueKind" Usage="registryKey.GetValueKind name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryValueKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value whose registry data type is to be retrieved. This string is not case-sensitive.</param>
        <summary>Retrieves the registry data type of the value associated with the specified name.</summary>
        <returns>The registry data type of the value associated with <paramref name="name" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  레지스트리 키 이름과 연결 되지 않은 하나의 값을 가질 수 있습니다. 레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열이 이름 대신 표시 됩니다. 를 검색 하기 위해 명명 되지 않은 값이의 레지스트리 데이터 형식을 지정 하거나 `null` 또는 빈 문자열 ("")에 대 한 `name`합니다.  
  
 지원 되는 레지스트리 데이터 형식에 대 한 참조 하십시오는 <xref:Microsoft.Win32.RegistryValueKind> 열거형입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 테스트 키를 만들고 서로 다른 데이터 형식의 값을 키에 추가 합니다. 예제에서는 다음 이름/값 쌍을 읽고 콘솔에 표시를 사용 하는 <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> 해당 레지스트리 데이터 형식을 검색 하는 메서드입니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.IO.IOException">The subkey that contains the specified value does not exist.  -or-  The name/value pair specified by <paramref name="name" /> does not exist.  This exception is not thrown on Windows 95, Windows 98, or Windows Millennium Edition.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">레지스트리에서 읽지 못했습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="GetValueNames">
      <MemberSignature Language="C#" Value="public string[] GetValueNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetValueNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetValueNames();" />
      <MemberSignature Language="F#" Value="member this.GetValueNames : unit -&gt; string[]" Usage="registryKey.GetValueNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves an array of strings that contains all the value names associated with this key.</summary>
        <returns>An array of strings that contains the value names for the current key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 키 값 이름이 없으면 빈 배열이 반환 됩니다.  
  
 레지스트리 키에는 기본값을 가질 수 있습니다-즉,는 이름/값 쌍입니다 이름이 빈 문자열 (""). 레지스트리 키에 대 한 기본값을 설정 하 여 반환 된는 배열은 <xref:Microsoft.Win32.RegistryKey.GetValueNames%2A> 메서드에 빈 문자열이 포함 되어 있습니다.  
  
   
  
## Examples  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.IO.IOException">A system error occurred; for example, the current key has been deleted.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">레지스트리에서 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeRegistryHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeRegistryHandle" Usage="Microsoft.Win32.RegistryKey.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeRegistryHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:Microsoft.Win32.SafeHandles.SafeRegistryHandle" /> object that represents the registry key that the current <see cref="T:Microsoft.Win32.RegistryKey" /> object encapsulates.</summary>
        <value>레지스트리 키에 대한 핸들입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The registry key is closed. Closed keys cannot be accessed.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.IO.IOException">A system error occurred, such as deletion of the current key.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the key.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Microsoft.Win32.RegistryKey.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieves the name of the key.</summary>
        <value>키의 절대(정규화된) 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 키의 이름에는 기본 키에서 시작 된 항상 HKEY_LOCAL_MACHINE 레지스트리에서이 키의 절대 경로가 포함 됩니다.  
  
   
  
## Examples  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <altmember cref="M:Microsoft.Win32.RegistryKey.ToString" />
      </Docs>
    </Member>
    <Member MemberName="OpenBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenBaseKey (Microsoft.Win32.RegistryHive hKey, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenBaseKey (hKey As RegistryHive, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenBaseKey(Microsoft::Win32::RegistryHive hKey, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenBaseKey : Microsoft.Win32.RegistryHive * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenBaseKey (hKey, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="hKey">The HKEY to open.</param>
        <param name="view">The registry view to use.</param>
        <summary>Opens a new <see cref="T:Microsoft.Win32.RegistryKey" /> that represents the requested key on the local machine with the specified view.</summary>
        <returns>The requested registry key.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> or <paramref name="view" /> is invalid.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to perform this action.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenRemoteBaseKey">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a new T:Microsoft.Win32.RegistryKey that represents the requested key on a remote machine, with the option of specified registry view.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hKey">The HKEY to open, from the <see cref="T:Microsoft.Win32.RegistryHive" /> enumeration.</param>
        <param name="machineName">The remote machine.</param>
        <summary>Opens a new <see cref="T:Microsoft.Win32.RegistryKey" /> that represents the requested key on a remote machine.</summary>
        <returns>The requested registry key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로컬 컴퓨터 레지스트리의 경우 열릴 `machineName` 은 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 요청 된 키 원격 컴퓨터에서 루트 키 이어야 하며 적절 한으로 식별 되 <xref:Microsoft.Win32.RegistryHive> 값입니다.  
  
 키를 원격으로 열 수 순서로 서버와 클라이언트 컴퓨터에서 원격 레지스트리 서비스가 실행 하 고 원격 관리를 사용 하도록 설정 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 원격 컴퓨터에서 레지스트리 키 열 및 키의 값을 열거 하는 방법을 보여 줍니다. 원격 컴퓨터에서 원격 레지스트리 서비스가 실행 되어야 합니다. 프로그램을 호출할 때 명령줄 인수로 원격 컴퓨터의 이름을 지정 합니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> is invalid.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="machineName" /> is not found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the proper permissions to perform this operation.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryHive" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="hKey">The HKEY to open from the <see cref="T:Microsoft.Win32.RegistryHive" /> enumeration..</param>
        <param name="machineName">The remote machine.</param>
        <param name="view">The registry view to use.</param>
        <summary>Opens a new registry key that represents the requested key on a remote machine with the specified view.</summary>
        <returns>The requested registry key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로컬 컴퓨터 레지스트리의 경우 열릴 `machineName` 은 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 요청 된 키 원격 컴퓨터에서 루트 키 이어야 하며 적절 한으로 식별 되 <xref:Microsoft.Win32.RegistryHive> 값입니다.  
  
 키를 원격으로 열 수 순서로 서버와 클라이언트 컴퓨터에서 원격 레지스트리 서비스가 실행 하 고 원격 관리를 사용 하도록 설정 해야 합니다.  
  
 64 비트 버전의 Windows에서 레지스트리 일부 32 비트 및 64 비트 응용 프로그램에 개별적으로 저장 됩니다. 32 비트 응용 프로그램에 대 한 32 비트 뷰와 64 비트 응용 프로그램에 대 한 64 비트 보기가 있습니다. 경우 `view` 은 <xref:Microsoft.Win32.RegistryView.Registry64> 하지만 원격 컴퓨터가 실행 되는 32 비트 운영 체제, 반환 된 키 ´ ֲ는 <xref:Microsoft.Win32.RegistryView.Registry32> 보기.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> or <paramref name="view" /> is invalid.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="machineName" /> is not found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the required permissions to perform this operation.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves the specified subkey.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name or path of the subkey to open as read-only.</param>
        <summary>Retrieves a subkey as read-only.</summary>
        <returns>The subkey requested, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다른 메서드 및 속성으로 조작할 수 전에 키를 다시 열어야 합니다. 키를 수정 하려면 열어야의 오버 로드와는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 수와 같은 쓰기 액세스를 지정할 수 있는 메서드는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CMicrosoft.Win32.RegistryKeyPermissionCheck%29> 오버 로드 또는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CSystem.Boolean%29> 오버 로드 합니다.  
  
 지정된 된 하위 키를 찾을 수 없으면 다음 경우 `null` 반환 됩니다.  
  
 사용 하려면는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 있어야 인스턴스의 <xref:Microsoft.Win32.RegistryKey>합니다. 인스턴스를 가져오려면 <xref:Microsoft.Win32.RegistryKey>의 정적 멤버 중 하나를 사용 하 여는 <xref:Microsoft.Win32.Registry> 클래스입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 테스트 키를 만들고 사용 하 여 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 여 메서드 오버 로드를 모두 보여 주는 메서드를 합니다.  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" /></exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the registry key.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정 된 레지스트리 키를 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
      </Parameters>
      <Docs>
        <param name="name">The name or path of the subkey to create or open.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <summary>Retrieves the specified subkey for read or read/write access.</summary>
        <returns>The subkey requested, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 하는 예외를 throw 하는 대신 `null` 요청된 된 키가 없는 경우.  
  
 경우 `permissionCheck` 은 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, 읽기 및 쓰기;에 대 한 키를 열 경우 `permissionCheck` 은 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> 또는 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>, 부모 키로 열리지 않았으면 읽기에 대 한 키가 열립니다 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>합니다.  
  
 사용 하려면는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 있어야의 인스턴스는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다. 인스턴스를 가져오려면 <xref:Microsoft.Win32.RegistryKey>의 정적 멤버 중 하나를 사용 하 여는 <xref:Microsoft.Win32.Registry> 클래스입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 100 키/값 쌍을 포함 하는 하위 키를 만들고이 닫을 합니다. 이 예제에서는와 하위 키를 열고 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default>, 하위 키를 닫습니다 모든 값을 읽는 데 걸린 시간을 기록 합니다. 이 예제에서는와 하위 키를 열고 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree> 고 모든 값을 읽는 데 걸린 시간을 기록 합니다. 마지막으로 계산 하 고 향상 률 표시 됩니다.  
  
 [!code-csharp[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/cs/source.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contains an invalid value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the registry key.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정 된 레지스트리 키를 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, bool writable);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Name or path of the subkey to open.</param>
        <param name="writable">Set to <see langword="true" /> if you need write access to the key.</param>
        <summary>Retrieves a specified subkey, and specifies whether write access is to be applied to the key.</summary>
        <returns>The subkey requested, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요청된 된 키 존재 하지 않는 경우이 메서드는 반환 `null` 예외를 throw 하는 대신 합니다.  
  
 경우 `writable` 은 `true`, 읽기 및 쓰기에 대 한 키를 열어야, 읽기 전용으로 키 열 수, 합니다.  
  
 사용 하려면는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 있어야의 인스턴스는 <xref:Microsoft.Win32.RegistryKey> 메서드. 인스턴스를 가져오려면 <xref:Microsoft.Win32.RegistryKey>의 정적 멤버 중 하나를 사용 하 여는 <xref:Microsoft.Win32.Registry> 클래스입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 테스트 키를 만들고 사용 하 여 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 여 메서드 오버 로드를 모두 보여 주는 메서드를 합니다.  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to access the registry key in the specified mode.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정 된 레지스트리 키를 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" />
      </Parameters>
      <Docs>
        <param name="name">The name or path of the subkey to create or open.</param>
        <param name="rights">The rights for the registry key.</param>
        <summary>Retrieves a subkey with the specified name and .  Available starting in .NET Framework 4.6</summary>
        <returns>The subkey requested, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다른 메서드 및 속성으로 조작할 수 전에 키를 다시 열어야 합니다. 키를 수정 하려면 열어야의 오버 로드와는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 쓰기 액세스를 지정할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to access the registry key in the specified mode.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" />
      </Parameters>
      <Docs>
        <param name="name">The name or path of the subkey to create or open.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <param name="rights">A bitwise combination of enumeration values that specifies the desired security access.</param>
        <summary>Retrieves the specified subkey for read or read/write access, requesting the specified access rights.</summary>
        <returns>The subkey requested, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 하는 예외를 throw 하는 대신 `null` 요청된 된 키가 없는 경우.  
  
 경우 `permissionCheck` 은 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, 읽기 및 쓰기;에 대 한 키를 열 경우 `permissionCheck` 은 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> 또는 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>, 부모 키로 열리지 않았으면 읽기에 대 한 키가 열립니다 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>합니다.  
  
 에 지정 된 액세스 `permissionCheck` 에 대해 지정 된 액세스 권한 보다 우선 `rights`합니다. 예를 들어, 지정 하는 경우 <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> 에 대 한 `permissionCheck` 및 <xref:System.Security.AccessControl.RegistryRights.WriteKey?displayProperty=nameWithType> 에 대 한 `rights`, 예외를 throw 하는 하위 키에 쓰려고 했습니다.  
  
 사용 하려면는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 있어야의 인스턴스는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다. 인스턴스를 가져오려면 <xref:Microsoft.Win32.RegistryKey>의 정적 멤버 중 하나를 사용 하 여는 <xref:Microsoft.Win32.Registry> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contains an invalid value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="rights" /> includes invalid registry rights values.  -or-  The user does not have the requested permissions.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정 된 레지스트리 키를 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetAccessControl(System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.RegistrySecurity -&gt; unit" Usage="registryKey.SetAccessControl registrySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="registrySecurity">The access control security to apply to the current subkey.</param>
        <summary>Applies Windows access control security to an existing registry key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 레지스트리 키에 대 한 권한을 수정 하려면는 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A> 를 얻는 메서드를 한 <xref:System.Security.AccessControl.RegistrySecurity> 기존 Windows 액세스 제어 보안을 나타내는 개체를 수정 하는 <xref:System.Security.AccessControl.RegistrySecurity> 개체를 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A> 에 대 한 보안을 업데이트 하는 메서드 열쇠.  
  
> [!CAUTION]
>  <xref:System.Security.AccessControl.RegistrySecurity> 개체에 대해 지정 된 `registrySecurity` 레지스트리 키에 대 한 기존 보안을 대체 합니다. 새 사용자에 대 한 권한을 추가 하려면 사용 된 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A> 메서드를 기존 액세스 제어 보안을 한 다음 수정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 테스트 키를 만듭니다. 현재 사용자가 수 <xref:System.Security.AccessControl.RegistryRights.ReadKey> 및 <xref:System.Security.AccessControl.RegistryRights.Delete> 권한이 거부 하지만 <xref:System.Security.AccessControl.RegistryRights.ChangePermissions> 및 <xref:System.Security.AccessControl.RegistryRights.WriteKey> 권한. 후속 이러한 사용 권한에 따라 여부가 키 succeed 조작 하려고 합니다.  
  
 키를 삭제 하기 전에 코드 일시 중지 됩니다. 레지스트리 편집기를 전환할 수 있으며 레지스트리 편집기를 사용 하는 키에 액세스할 때 동일한 액세스 권한을 적용 됨을 확인 하십시오. (이 작업은 사용 하는 경우 **RunAs** 관리자 권한이 없는 로컬 사용자로 레지스트리 편집기와 예제 코드를 실행 하려면 명령줄에서. 레지스트리 편집기는 항상 특정 관리자의 이러한 권한을 거부 하는 경우에 사용 권한을 변경 하려면 관리자를 허용 합니다. TestUser 명령 라는 로컬 사용자를 정의한 경우 `runas /user:TestUser cmd` 레지스트리 편집기는 샘플 코드를 다음을 실행할 수 있는 명령 창을 엽니다.)  
  
 [!code-cpp[RegistrySecurity101#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistrySecurity101/cpp/source.cpp#1)]
 [!code-csharp[RegistrySecurity101#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistrySecurity101/CS/source.cs#1)]
 [!code-vb[RegistrySecurity101#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistrySecurity101/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> object represents a key with access control security, and the caller does not have <see cref="F:System.Security.AccessControl.RegistryRights.ChangePermissions" /> rights.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="registrySecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the value of a name/value pair in the registry key. Depending on the overload, the registry data type is determined from the type of data being stored or from a specified <see cref="T:Microsoft.Win32.RegistryValueKind" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj -&gt; unit" Usage="registryKey.SetValue (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to store.</param>
        <param name="value">The data to be stored.</param>
        <summary>Sets the specified name/value pair.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 레지스트리 키에 많은 값을 저장할 수 있으므로 사용 해야 합니다는 `name` 매개 변수를 설정 하려면 특정 값을 지정 합니다.  
  
> [!NOTE]
>  레지스트리 키 이름과 연결 되지 않은 하나의 값을 가질 수 있습니다. 레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열이 이름 대신 표시 됩니다. 명명 되지 않은 값을 설정 하려면 `null` 또는 빈 문자열 ("")에 대 한 `name`합니다.  
  
 키의 값을 설정 하기 위해 키 쓰기 권한으로 열어야 합니다. 쓰기 액세스 권한이 있는 키를 연 후에 해당 키의 이름/값 쌍의 변경할 수 있습니다.  
  
 하는 경우 지정 된 `name` 존재 하지 않는 키에 만들어지고 연결 된 값으로 설정 됩니다 `value`합니다.  
  
 이 오버 로드의 <xref:Microsoft.Win32.RegistryKey.SetValue%2A> 64 비트 정수를 문자열로 저장 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). 64 비트 숫자를 저장 하려면 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> 값을 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 지정 하는 오버 로드 <xref:Microsoft.Win32.RegistryValueKind>합니다.  
  
 이 오버 로드의 <xref:Microsoft.Win32.RegistryKey.SetValue%2A> 모든 문자열 값으로 저장 <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>확장 가능한 환경 변수에 참조를 포함 하는 경우에 합니다. 문자열 값으로 확장할 수 있는 문자열을 저장 하려면 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)를 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 지정 하는 오버 로드 <xref:Microsoft.Win32.RegistryValueKind>합니다.  
  
 이 메서드 오버 로드에서 32 비트 정수가 아닌 숫자 형식은 문자열로 저장 됩니다. 열거형 요소는 요소 이름을 포함 하는 문자열로 저장 됩니다.  
  
> [!CAUTION]
>  노출 하지 마십시오. <xref:Microsoft.Win32.RegistryKey> 방식 악의적인 프로그램 수 무의미 한 하위 수천 만들거나 않은 키/값 쌍 개체입니다. 예를 들어 임의의 키 또는 값을 입력 하는 호출자를 허용 하지 않습니다.  
  
> [!NOTE]
>  Windows 98 및 Windows Millennium Edition 레지스트리 유니코드, 아니며 모든 유니코드 문자는 모든 코드 페이지에 대해 유효 합니다. 현재 코드 페이지에 대 한 유효 하지 않은 유니코드 문자는 사용할 수 있는 가장 잘 일치에 의해 대체 됩니다. 예외가 throw되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제는 방법을 <xref:Microsoft.Win32.RegistryKey.SetValue%2A> 메서드 값을 설정할 때 레지스트리 데이터 형식을 결정 합니다. 이 예제에서는 테스트 키를 만들고 서로 다른 데이터 형식의 값을 키에 추가 합니다. 예제에서는 다음 이름/값 쌍을 읽고 콘솔에 표시를 사용 하는 <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> 메서드를 해당 레지스트리 데이터 형식을 표시 합니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> is an unsupported data type.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is read-only, and cannot be written to; for example, the key has not been opened with write access.  -or-  The <see cref="T:Microsoft.Win32.RegistryKey" /> object represents a root-level node, and the operating system is Windows Millennium Edition or Windows 98.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or modify registry keys.</exception>
        <exception cref="T:System.IO.IOException">The <see cref="T:Microsoft.Win32.RegistryKey" /> object represents a root-level node, and the operating system is Windows 2000, Windows XP, or Windows Server 2003.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">이 특성이 있으면 지정 된 레지스트리 키를 수정 하려면 또는 아직 없는 경우 레지스트리 키를 만들입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="registryKey.SetValue (name, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to be stored.</param>
        <param name="value">The data to be stored.</param>
        <param name="valueKind">The registry data type to use when storing the data.</param>
        <summary>Sets the value of a name/value pair in the registry key, using the specified registry data type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 레지스트리 키에 많은 값을 저장할 수 있으므로 사용 해야 합니다는 `name` 매개 변수를 설정 하려면 특정 값을 지정 합니다.  
  
> [!NOTE]
>  레지스트리 키 이름과 연결 되지 않은 하나의 값을 가질 수 있습니다. 레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열이 이름 대신 표시 됩니다. 명명 되지 않은 값을 설정 하려면 `null` 또는 빈 문자열 ("")에 대 한 `name`합니다.  
  
 키의 값을 설정 하기 위해 키 쓰기 권한으로 열어야 합니다. 쓰기 액세스 권한이 있는 키를 연 후에 해당 키의 이름/값 쌍의 변경할 수 있습니다.  
  
 하는 경우 지정 된 `name` 존재 하지 않는 키에 생성 하 고 연결 된 값으로 설정 됩니다 `value`합니다.  
  
> [!NOTE]
>  레지스트리 데이터 형식을 지정 <xref:Microsoft.Win32.RegistryValueKind.Unknown> 를 사용 하 여 동일는 <xref:Microsoft.Win32.RegistryKey.SetValue%2A> 오버 로드 합니다.  
  
 하는 경우 지정된 된 유형의 `value` 지정 된 일치 하지 않습니다 `valueKind`, 데이터 수 없습니다, 변환 <xref:System.ArgumentException> throw 됩니다. 예를 들어 저장할 수 있습니다는 <xref:System.Int64?displayProperty=nameWithType> 로 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, 해당 값의 최 댓 값 보다 작은 경우에 하지만 <xref:System.Int32?displayProperty=nameWithType>합니다. 단일 문자열 값으로 저장할 수 없습니다는 <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  Boxed 값에 대 한 전달 될 경우 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> 또는 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, 변환이 수행 되는 고정 문화권을 사용 하 여 합니다.  
  
> [!CAUTION]
>  노출 하지 마십시오. <xref:Microsoft.Win32.RegistryKey> 방식 악의적인 프로그램 수 무의미 한 하위 수천 만들거나 않은 키/값 쌍 개체입니다. 예를 들어 임의의 키 또는 값을 입력 하는 호출자를 허용 하지 않습니다.  
  
> [!NOTE]
>  Windows 98 및 Windows Millennium Edition 레지스트리 유니코드, 아니며 모든 유니코드 문자는 모든 코드 페이지에 대해 유효 합니다. 현재 코드 페이지에 대 한 유효 하지 않은 유니코드 문자는 사용할 수 있는 가장 잘 일치에 의해 대체 됩니다. 예외가 throw되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 테스트 키를 만들고 사용 하 여 <xref:Microsoft.Win32.RegistryKey.SetValue%2A> 각 값에 대 한 레지스트리 데이터 형식을 지정 하는 여러 값을 저장 하는 메서드. 예제에서는 다음 이름/값 쌍을 읽고 콘솔에 표시를 사용 하는 <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> 메서드를 해당 레지스트리 데이터 형식을 표시 합니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The type of <paramref name="value" /> did not match the registry data type specified by <paramref name="valueKind" />, therefore the data could not be converted properly.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is read-only, and cannot be written to; for example, the key has not been opened with write access.  -or-  The <see cref="T:Microsoft.Win32.RegistryKey" /> object represents a root-level node, and the operating system is Windows Millennium Edition or Windows 98.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or modify registry keys.</exception>
        <exception cref="T:System.IO.IOException">The <see cref="T:Microsoft.Win32.RegistryKey" /> object represents a root-level node, and the operating system is Windows 2000, Windows XP, or Windows Server 2003.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">이 특성이 있으면 지정 된 레지스트리 키를 수정 하려면 또는 아직 없는 경우 레지스트리 키를 만들입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="SubKeyCount">
      <MemberSignature Language="C#" Value="public int SubKeyCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubKeyCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubKeyCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubKeyCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SubKeyCount : int" Usage="Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieves the count of subkeys of the current key.</summary>
        <value>현재 키의 하위 키 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 재귀적으로 count 이름이 아닙니다. 호출 된 기본 수준의 이름의 수를 반환 합니다.  
  
   
  
## Examples  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have read permission for the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.IO.IOException">A system error occurred, for example the current key has been deleted.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정 된 레지스트리 키를 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="registryKey.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves a string representation of this key.</summary>
        <returns>A string representing the key. If the specified key is invalid (cannot be found) then <see langword="null" /> is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 값은 지정된 된 키 및 키에 대 한 16 진수 값의 레지스트리 경로 포함 합니다. 레지스트리 경로는 항상 시작는 레지스트리에 대 한 기본 키 중 하나에서 예를 들어 HKEY_LOCAL_MACHINE, 지정된 된 키의 절대 루트를 포함 됩니다.  
  
   
  
## Examples  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being accessed is closed (closed keys cannot be accessed).</exception>
        <altmember cref="P:Microsoft.Win32.RegistryKey.Name" />
      </Docs>
    </Member>
    <Member MemberName="ValueCount">
      <MemberSignature Language="C#" Value="public int ValueCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ValueCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ValueCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueCount : int" Usage="Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieves the count of values in the key.</summary>
        <value>키에 있는 이름/값 쌍의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 레지스트리 키의 이름과 연결 되지 않은 기본값입니다. 명명 되지 않은 값이 사용 하 여 설정할 수 있습니다는 <xref:Microsoft.Win32.RegistryKey.SetValue%2A> 메서드 중 하나를 지정 하 고 `null` 또는 빈 문자열 ("")에 대 한 `name`합니다. 하지만 반환 된 총 수로 기본값 설정 되지 않은 경우 반영 되지 않지만 <xref:Microsoft.Win32.RegistryKey.ValueCount%2A> 속성 설정 되 면 항상 계산 됩니다.  
  
   
  
## Examples  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:Microsoft.Win32.RegistryKey> 클래스입니다.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have read permission for the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.IO.IOException">A system error occurred, for example the current key has been deleted.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정 된 레지스트리 키를 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryView View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Win32.RegistryView View" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As RegistryView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::RegistryView View { Microsoft::Win32::RegistryView get(); };" />
      <MemberSignature Language="F#" Value="member this.View : Microsoft.Win32.RegistryView" Usage="Microsoft.Win32.RegistryKey.View" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the view that was used to create the registry key.</summary>
        <value>레지스트리 키를 만드는 데 사용된 뷰입니다.  -또는- <see cref="F:Microsoft.Win32.RegistryView.Default" />없는 뷰를 사용 하는 경우.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 64 비트 버전의 Windows에서 레지스트리 일부 32 비트 및 64 비트 응용 프로그램에 개별적으로 저장 됩니다. 32 비트 응용 프로그램에 대 한 32 비트 뷰와 64 비트 응용 프로그램에 대 한 64 비트 보기가 있습니다.  
  
 보기의 실제 보기에 항상 해당 하는지 가정 하지 않습니다는 <xref:Microsoft.Win32.RegistryKey>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>