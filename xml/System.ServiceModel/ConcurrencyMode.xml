<Type Name="ConcurrencyMode" FullName="System.ServiceModel.ConcurrencyMode">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="05ec8ae681b81889f4dba2cfb53bcd59c150db65" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public enum ConcurrencyMode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed ConcurrencyMode extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ConcurrencyMode" />
  <TypeSignature Language="VB.NET" Value="Public Enum ConcurrencyMode" />
  <TypeSignature Language="C++ CLI" Value="public enum class ConcurrencyMode" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>
      <span data-ttu-id="2fc2a-101">서비스 클래스가 단일 스레드 작업 모드를 지원할지 다중 스레드 작업 모드를 지원할지를 지정합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="2fc2a-101">Specifies whether a service class supports single-threaded or multi-threaded modes of operation.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fc2a-102">서비스 클래스의 단일 스레드 또는 다중 스레드 작업 모드 지원을 지정할 때 <xref:System.ServiceModel.ConcurrencyMode>를 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 속성과 함께 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2fc2a-102"><xref:System.ServiceModel.ConcurrencyMode> is used in conjunction with the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> property to specify whether a service class supports single-threaded or multi-threaded modes of operation.</span></span> <span data-ttu-id="2fc2a-103">단일 스레드 작업은 재진입이거나 재진입이 아닐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2fc2a-103">A single-threaded operation can be either reentrant or non-reentrant.</span></span>  
  
 <span data-ttu-id="2fc2a-104">다음 표에서는 [!INCLUDE[indigo1](~/includes/indigo1-md.md)]에 따라 <xref:System.ServiceModel.ConcurrencyMode>에서 다른 작업이 진행 중일 때 특정 작업의 호출이 허용되는 경우를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2fc2a-104">The following table shows when [!INCLUDE[indigo1](~/includes/indigo1-md.md)] permits an operation to be invoked while another one is in progress, depending upon the <xref:System.ServiceModel.ConcurrencyMode>.</span></span>  
  
|<span data-ttu-id="2fc2a-105">ConcurrencyMode 값</span><span class="sxs-lookup"><span data-stu-id="2fc2a-105">ConcurrencyMode Value</span></span>|<span data-ttu-id="2fc2a-106">새 작업 호출 가능 여부</span><span class="sxs-lookup"><span data-stu-id="2fc2a-106">Can a new operation be invoked?</span></span>|  
|---------------------------|-------------------------------------|  
|<span data-ttu-id="2fc2a-107">Single</span><span class="sxs-lookup"><span data-stu-id="2fc2a-107">Single</span></span>|<span data-ttu-id="2fc2a-108">불가능</span><span class="sxs-lookup"><span data-stu-id="2fc2a-108">Never.</span></span>|  
|<span data-ttu-id="2fc2a-109">재진입</span><span class="sxs-lookup"><span data-stu-id="2fc2a-109">Reentrant</span></span>|<span data-ttu-id="2fc2a-110">다른 서비스나 콜백 호출 도중에만 가능</span><span class="sxs-lookup"><span data-stu-id="2fc2a-110">Only while invoking another service or a callback.</span></span>|  
|<span data-ttu-id="2fc2a-111">다중</span><span class="sxs-lookup"><span data-stu-id="2fc2a-111">Multiple</span></span>|<span data-ttu-id="2fc2a-112">항상</span><span class="sxs-lookup"><span data-stu-id="2fc2a-112">Always.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2fc2a-113">다음 코드 예제에서는 단일, Reentrant, 및 다중 사용 간의 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2fc2a-113">The following code example demonstrates the different between using Single, Reentrant, and Multiple.</span></span> <span data-ttu-id="2fc2a-114">이 샘플은 실제 구현이 없어 컴파일되지는 않지만 [!INCLUDE[indigo2](~/includes/indigo2-md.md)]에서 사용 가능한 스레딩의 종류 및 이러한 스레딩이 사용자의 작업 코드에 미치는 영향을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2fc2a-114">This sample does not compile without a real implementation behind it, but does demonstrate the kind of threading guarantees that [!INCLUDE[indigo2](~/includes/indigo2-md.md)] makes and what that means for your operation code.</span></span>  
  
 [!code-csharp[C_BestPractices-Concurrency#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_bestpractices-concurrency/cs/reentrantandmultiple.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Multiple">
      <MemberSignature Language="C#" Value="Multiple" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.ServiceModel.ConcurrencyMode Multiple = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceModel.ConcurrencyMode.Multiple" />
      <MemberSignature Language="VB.NET" Value="Multiple" />
      <MemberSignature Language="C++ CLI" Value="Multiple" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="2fc2a-115">서비스 인스턴스가 다중 스레드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2fc2a-115">The service instance is multi-threaded.</span>
          </span>
          <span data-ttu-id="2fc2a-116">동기화가 보장되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2fc2a-116">No synchronization guarantees are made.</span>
          </span>
          <span data-ttu-id="2fc2a-117">다른 스레드가 언제든지 서비스 개체를 변경할 수 있으므로 항상 동기화 및 상태 일관성을 처리해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2fc2a-117">Because other threads can change your service object at any time, you must handle synchronization and state consistency at all times.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Reentrant">
      <MemberSignature Language="C#" Value="Reentrant" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.ServiceModel.ConcurrencyMode Reentrant = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceModel.ConcurrencyMode.Reentrant" />
      <MemberSignature Language="VB.NET" Value="Reentrant" />
      <MemberSignature Language="C++ CLI" Value="Reentrant" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="2fc2a-118">서비스 인스턴스가 단일 스레드이며 재진입 호출을 허용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2fc2a-118">The service instance is single-threaded and accepts reentrant calls.</span>
          </span>
          <span data-ttu-id="2fc2a-119">재진입 서비스는 사용자가 다른 서비스를 호출할 때 호출을 허용합니다. 따라서 사용자는 호출 전에 개체 상태의 일관성을 유지하고 호출 후에는 작업-로컬 데이터가 유효한지 확인해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2fc2a-119">The reentrant service accepts calls when you call another service; it is therefore your responsibility to leave your object state consistent before callouts and you must confirm that operation-local data is valid after callouts.</span>
          </span>
          <span data-ttu-id="2fc2a-120">서비스 인스턴스는 [!INCLUDE[indigo2](~/includes/indigo2-md.md)] 채널을 통해 다른 서비스를 호출하는 방법으로만 잠금 해제됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2fc2a-120">Note that the service instance is unlocked only by calling another service over a [!INCLUDE[indigo2](~/includes/indigo2-md.md)] channel.</span>
          </span>
          <span data-ttu-id="2fc2a-121">이런 경우 호출된 서비스는 콜백을 통해 첫 번째 서비스에 재진입할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2fc2a-121">In this case, the called service can reenter the first service via a callback.</span>
          </span>
          <span data-ttu-id="2fc2a-122">첫 번째 서비스가 재진입이 아닌 경우 호출 시퀀스는 교착 상태에 빠지게 됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2fc2a-122">If the first service is not reentrant, the sequence of calls results in a deadlock.</span>
          </span>
          <span data-ttu-id="2fc2a-123">자세한 내용은 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />를 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2fc2a-123">For details, see <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Single">
      <MemberSignature Language="C#" Value="Single" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.ServiceModel.ConcurrencyMode Single = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceModel.ConcurrencyMode.Single" />
      <MemberSignature Language="VB.NET" Value="Single" />
      <MemberSignature Language="C++ CLI" Value="Single" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="2fc2a-124">서비스 인스턴스가 단일 스레드이며 재진입 호출을 허용하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2fc2a-124">The service instance is single-threaded and does not accept reentrant calls.</span>
          </span>
          <span data-ttu-id="2fc2a-125">
            <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" /> 속성이 <see cref="F:System.ServiceModel.InstanceContextMode.Single" />이고 인스턴스가 호출을 처리하는 동안 추가 메시지가 도착하는 경우, 이 추가 메시지는 서비스가 사용 가능해지거나 메시지 제한 시간이 초과될 때까지 대기해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2fc2a-125">If the <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" /> property is <see cref="F:System.ServiceModel.InstanceContextMode.Single" />, and additional messages arrive while the instance services a call, these messages must wait until the service is available or until the messages time out.</span>
          </span>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>