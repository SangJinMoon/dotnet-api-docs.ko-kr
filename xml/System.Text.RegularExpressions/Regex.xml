<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bb2051ea3f84d7f65cf8d414a93bce613dcad0ff" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36608495" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>변경할 수 없는 정규식을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> 클래스는.NET Framework의 정규식 엔진을 나타냅니다. 신속 하 게 많은 양의; 특정 문자 패턴을 찾을 텍스트를 구문 분석에 사용할 수 있습니다. 추출, 편집, 바꾸기 또는 삭제 텍스트 부분 문자열입니다. 및 보고서를 생성 하는 컬렉션에 추출 된 문자열을 추가 합니다.  
  
> [!NOTE]
>  주 관심 특정 패턴을 따르는지 여부를 확인 하 여 문자열을 확인 하는 것을 사용할 수 있습니다는 <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> 클래스입니다.  
  
 에 설명 된 구문을 사용 하 여 텍스트 스트림에 확인 하는 패턴 정규식을 사용 하려면 정의한 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다. 그런 다음 필요에 따라를 인스턴스화할 수 있습니다는 <xref:System.Text.RegularExpressions.Regex> 개체입니다. 마지막으로, 정규식 패턴과 일치 하는 텍스트 바꾸기 또는 패턴 일치를 식별 하는 등 특정 작업을 수행 하는 메서드를 호출 합니다.  
  
> [!NOTE]
>  몇 가지 일반적인 정규식 패턴에 대 한 참조 [일반 식 예제](~/docs/standard/base-types/regular-expression-examples.md)합니다. 또한 온라인 라이브러리의 정규식 패턴에 있는 것과 같은 여러 가지 [일반 Expressions.info](https://www.regular-expressions.info/examples.html)합니다.  
  
<a name="remarks"></a> 사용 하는 방법에 대 한 자세한 내용은 <xref:System.Text.RegularExpressions.Regex> 이 항목의 다음 섹션을 참조 하세요.  
  
-   [Regex vs입니다. 문자열 처리 메서드](#regex_vs_string)  
  
-   [정적 포트 대 인스턴스 메서드](#static_vs_instance)  
  
-   [정규식 작업 수행](#regex_ops)  
  
-   [시간 제한 값을 정의합니다.](#define_timeout)  
  
 정규식 언어에 대한 자세한 내용은 [정규식 언어 - 빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)를 참조하거나, 다음 브로슈어 중 하나를 다운로드하여 인쇄하세요.  
  
 [Word(.docx) 형식의 빠른 참조](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [PDF(.pdf) 형식의 빠른 참조](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Regex vs입니다. 문자열 처리 메서드  
 <xref:System.String?displayProperty=nameWithType> 클래스는 텍스트 패턴 일치를 수행 하는 데 사용할 수 있는 몇 가지 검색 및 비교 메서드를 포함 합니다. 예를 들어는 <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, 및 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 메서드 문자열 인스턴스입니다; 지정된 된 부분 문자열에 포함 되는지 여부를 결정 및 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, 및 <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> 메서드 시작 반환 문자열에 지정된 된 부분 문자열의 위치입니다. 메서드를 사용 하 여는 <xref:System.String?displayProperty=nameWithType> 특정 문자열 검색 하는 클래스입니다. 사용 하 여는 <xref:System.Text.RegularExpressions.Regex> 문자열의 특정 패턴에 대 한 검색 하는 클래스입니다. 자세한 내용 및 예제에 대 한 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md)합니다.  
  
 [주의 돌아가기](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>정적 포트 대 인스턴스 메서드  
 정규식 패턴을 정의한 후에 두 가지 방법 중 하나로 정규식 엔진에 제공할 수 있습니다.  
  
-   인스턴스화하여는 <xref:System.Text.RegularExpressions.Regex> 정규식을 나타내는 개체입니다. 정규식 패턴을 전달 하면이 작업을 수행 하는 <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> 생성자입니다. A <xref:System.Text.RegularExpressions.Regex> 개체는 변경할 수 없습니다; 인스턴스화하는 경우는 <xref:System.Text.RegularExpressions.Regex> 개체는 정규식 개체의 정규식을 변경할 수 없습니다.  
  
-   정규식과에 검색할 텍스트를 모두 제공 하 여 한 `static` (`Shared` Visual basic에서) <xref:System.Text.RegularExpressions.Regex> 메서드. 이렇게 하면 명시적으로 만들지 않고도 정규식을 사용 하는 <xref:System.Text.RegularExpressions.Regex> 개체입니다.  
  
 모든 <xref:System.Text.RegularExpressions.Regex> 패턴 식별 포함 정적 메서드와 인스턴스 오버 로드 합니다.  
  
 정규식 엔진이 패턴을 사용 하려면 먼저 특정 패턴을 컴파일해야 합니다. 때문에 <xref:System.Text.RegularExpressions.Regex> 발생 하는 일회성 절차와, 개체를 변경할 수 없는 경우는 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자 또는 정적 메서드를 호출 합니다. 반복 해 서 단일 정규식을 컴파일할 필요를 제거 하려면 정규식 엔진은 정적 메서드 호출에 사용 된 컴파일된 정규식을 캐시 합니다. 결과적으로, 정규식 패턴 일치 메서드에 비슷한 성능을 정적 및 인스턴스 메서드를 제공합니다.  
  
> [!IMPORTANT]
>  .NET Framework 버전 1.0 및 1.1에서는 모든 컴파일된 정규식에서 인스턴스 또는 정적 메서드에 사용 되는 여부 호출, 캐시 되었습니다. .NET Framework 2.0 부터는 정규식만 정적 메서드 호출에 사용 되는 캐시 됩니다.  
  
 그러나 캐싱 다음 두 가지 경우에는 성능을 저하 될 수 있습니다.  
  
-   정규식의 다 수 포함 된 정적 메서드 호출을 사용 하면. 기본적으로 정규식 엔진은 15 가장 최근에 사용한 정적 정규식을 캐시합니다. 15 개 정적 정규식을 사용 하는 응용 프로그램, 몇 가지 일반 식은 컴파일해야 합니다. 이 재컴파일을 방지 하려면 늘릴 수 있습니다는 <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> 속성입니다.  
  
-   인스턴스화하는 경우 새로운 <xref:System.Text.RegularExpressions.Regex> 이전에 컴파일된 정규식을 사용 하 여 개체입니다. 예를 들어 다음 코드는 텍스트 스트림에 중복 된 단어를 찾을 수 있는 정규식을 정의 합니다. 이 예제에서는 단일 정규식을 사용 하지만 새 인스턴스화합니다 <xref:System.Text.RegularExpressions.Regex> 각 텍스트 줄을 처리 하는 개체입니다. 이 인해 루프의 각 반복 정규식 다시 컴파일해야 합니다.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     재컴파일을 방지 하려면 단일 인스턴스화해야 <xref:System.Text.RegularExpressions.Regex> 다시 쓴 다음 예에서 같이 필요로 하는 모든 코드에 액세스할 수 있는 개체입니다.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [주의 돌아가기](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>정규식 작업 수행  
 하기로 한 경우 인스턴스화하는 <xref:System.Text.RegularExpressions.Regex> 개체 및 해당 메서드를 호출 하거나 정적 메서드를 호출 하는 <xref:System.Text.RegularExpressions.Regex> 클래스는 다음 패턴 일치 기능을 제공:  
  
-   일치 하는 항목의 유효성을 검사 합니다. 호출 하는 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 메서드를 일치 하는 항목이 있는지 여부를 결정 합니다.  
  
-   단일 일치 항목의 검색입니다. 호출 하 여 <xref:System.Text.RegularExpressions.Regex.Match%2A> 를 검색할 메서드는 <xref:System.Text.RegularExpressions.Match> 나 부분 문자열로 문자열에서 첫 번째 일치 항목을 나타내는 개체입니다. 호출 하 여 후속 일치 항목을 검색할 수 있습니다는 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드.  
  
-   모든 일치 항목을 검색 합니다. 호출 하 여 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 를 검색할 메서드는 <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> 나 부분 문자열로 문자열에서 찾은 모든 일치 항목을 나타내는 개체입니다.  
  
-   일치 하는 텍스트 대체 합니다. 호출 하는 <xref:System.Text.RegularExpressions.Regex.Replace%2A> 메서드를 일치 하는 텍스트를 대체 합니다. 정규식으로 대체 텍스트를 정의할 수도 있습니다. 일부에서는 <xref:System.Text.RegularExpressions.Regex.Replace%2A> 메서드를 포함 한 <xref:System.Text.RegularExpressions.MatchEvaluator> 매개 변수를 사용 하는 프로그래밍 방식으로 바꿀 텍스트를 정의할 수 있습니다.  
  
-   입력된 문자열의 부분 구성 된 문자열 배열 만듭니다. 호출 하는 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드를 정규식으로 정의 된 위치에서 입력된 문자열을 분할 합니다.  
  
 해당 패턴 일치 메서드를 외에도 <xref:System.Text.RegularExpressions.Regex> 클래스는 몇 가지 특수 한 용도의 메서드를 포함 합니다.  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메서드 정규식 이나 입력된 문자열에서 정규식 연산자로 해석 될 수 있는 모든 문자를 이스케이프 합니다.  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 메서드 이러한 이스케이프 문자를 제거 합니다.  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> 메서드는 미리 정의 된 정규식을 포함 하는 어셈블리를 만듭니다. 이러한 특수 한 용도의 어셈블리의 예제를 포함 하는.NET Framework는 <xref:System.Web.RegularExpressions?displayProperty=nameWithType> 네임 스페이스입니다.  
  
 [주의 돌아가기](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>시간 제한 값을 정의합니다.  
 .NET Framework 상당한 기능과 유연성 패턴 일치에서 제공 하는 모든 기능을 갖춘 정규식 언어를 지원 합니다. 그러나 강력 하며 유연성 비용이 듭니다: 성능 저하의 위험 합니다. 불완전 하 게 수행 하는 정규식은 매우 쉽게 만들 수 있습니다. 일부 경우에는 정규식 패턴과 거의 일치 하는 텍스트를 처리 하는 경우 응답 하지 않는 것 과도 한 역 추적을 사용 하는 정규식 작업 나타날 수 있습니다. .NET Framework 정규식 엔진에 대 한 자세한 내용은 참조 [세부 정보 정규식 동작 정부](~/docs/standard/base-types/details-of-regular-expression-behavior.md)합니다. 과도 한 역 추적 하는 방법에 대 한 자세한 내용은 참조 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다.  
  
 부터는 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 정규식 일치에 대 한 시간 제한 간격을 정의할 수 있습니다. 정규식 엔진이이 시간 간격 내에서 일치 하는 항목을 식별할 수 없으면, 일치 하는 작업에서 throw 한 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 대부분의 경우에서 이렇게 하면 정규식 엔진에서 처리 능력을 정규식 패턴과 거의 일치 하는 텍스트와 일치 하도록 시도 하 여 낭비 됩니다. 그러나 또한 나타낼 수, 제한 시간 간격이 설정 되어 있는지를 너무 낮게 또는 현재 컴퓨터 부하가 성능에는 전반적인 성능 저하를 발생 했습니다.  
  
 예외를 처리 하는 방법은 예외의 원인에 따라 달라 집니다. 시간 제한 간격이 너무 낮게 설정 되어 있기 때문에 예외가 발생 하는 경우 또는 과도 한 시스템 부하 때문에, 시간 제한 간격을 늘릴 수 있으며 일치 하는 작업을 다시 시도 수 있습니다. 과도 한 역 추적이 정규식 사용 때문에 예외가 발생 하는 경우에 일치 하는 존재 하지 않는 하 고, 필요에 따라 정규식 패턴을 수정 하는 데 도움이 되는 정보를 기록할 수 있습니다를 가정할 수 있습니다.  
  
 호출 하 여 시간 제한 간격을 설정할 수 있습니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 정규식 개체를 인스턴스화할 때 생성자입니다. 정적 메서드에 대 한 일치 하는 메서드를 오버 로드를 호출 하 여 시간 제한 간격을 설정할 수 있습니다는 `matchTimeout` 매개 변수입니다. 시간 제한 값을 명시적으로 설정 하지 않으면 기본 제한 시간 값이 다음과 같이 결정 됩니다.  
  
-   응용 프로그램 수준 시간 제한을 사용 하 여 값을 한 경우 존재 합니다. 이는 응용 프로그램 도메인에 적용 되는 모든 시간 제한 값이 될 수는 <xref:System.Text.RegularExpressions.Regex> 개체가 인스턴스화되거나 정적 메서드 호출 합니다. 호출 하 여 응용 프로그램 수준 시간 제한 값을 설정할 수는 <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> 의 문자열 표현을 할당 하는 메서드는 <xref:System.TimeSpan> "REGEX_DEFAULT_MATCH_TIMEOUT" 속성 값입니다.  
  
-   값을 사용 하 여 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>없는 응용 프로그램 수준 시간 제한 값이 설정 된 경우.  
  
> [!IMPORTANT]
>  모든 정규식 패턴 일치 작업에서 시간 제한 값을 설정 하는 것이 좋습니다. 자세한 내용은 참조 [정규식에 대 한 유용한](~/docs/standard/base-types/best-practices.md)합니다.  
  
 [주의 돌아가기](#remarks)  
  
   
  
## Examples  
 다음 예제에서는 문자열에서 단어의 반복 된 발생에 대 한 확인 하려면 정규식을 사용 합니다. 정규식 `\b(?<word>\w+)\s+(\k<word>)\b` 다음 표와 같이 해석 될 수 있습니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작 합니다.|  
|`(?<word>\w+)`|단어 경계까지 하나 이상의 단어 문자를 찾습니다. 이 캡처된 그룹의 이름을 `word`합니다.|  
|`\s+`|하나 이상의 공백 문자를 찾습니다.|  
|`(\k<word>)`|라는 캡처된 그룹을 찾습니다 `word`합니다.|  
|`\b`|단어 경계를 찾습니다.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 다음 예제에서는 문자열에 통화 값을 나타내는 또는 통화 값을 나타내는 올바른 형식의 있는지 여부를 확인 하려면 정규식의 사용을 보여 줍니다. 이 경우 정규식에서 동적으로 작성 되는 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, 및 <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> 사용자의 현재 문화권에 대 한 속성. 시스템의 현재 문화권이 EN-US, 정규식은 `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`합니다. 이 정규식은 다음 표에 나와 있는 것 처럼 해석할 수 있습니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`^`|문자열의 시작 부분에서 시작 합니다.|  
|`\s*`|0개 이상의 공백 문자가 일치하는지 확인합니다.|  
|`[\+-]?`|양수 부호 또는 음의 부호가 없거나 1 개 발생을 찾습니다.|  
|`\s?`|0번 이상 나오는 공백 문자를 찾습니다.|  
|`\$?`|달러 기호는 없거나 1 개 발생을 찾습니다.|  
|`\s?`|0번 이상 나오는 공백 문자를 찾습니다.|  
|`\d*`|0번 이상 나오는 10진수를 찾습니다.|  
|`\.?`|소수점 기호가 0 회 이상 일치 합니다.|  
|`\d{2}?`|두 개의 10 진수 0 개 또는 1 개 찾습니다.|  
|`(\d*\.?\d{2}?){1}`|한 번 이상 소수점 기호로 구분 된 정수 부분과 소수 부분 자릿수 패턴과 일치 합니다.|  
|`$`|문자열의 끝 부분을 찾습니다.|  
  
 이 경우 정규식 가정 유효한 통화 문자열에 그룹 구분 기호가 포함 되지 않습니다는 현재 문화권에 의해 정의 된 소수 자릿수 또는 소수 자릿수 없이 있기 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> 속성입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 이 예의 정규식을 동적으로 작성 하기 때문에 알 수 없어도 디자인 타임에는 현재 문화권의 통화 기호, 10 진수 기호 또는 양수 기호와 음수 기호를 정기적으로 정규식 엔진의 잘못 해석 될 수 있는지 여부를 식 언어 연산자입니다. 이 예제에서는 잘못 된 해석을 방지 하려면를 동적으로 생성 된 각 문자열에 전달 된 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메서드.  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <see cref="T:System.Text.RegularExpressions.Regex" /> 클래스는 변경할 수 없습니다 (읽기 전용) 하 고 스레드로부터 안전 합니다. <see cref="T:System.Text.RegularExpressions.Regex" /> 개체는 모든 스레드에서 만들고 스레드 사이 공유할 수 있습니다. 자세한 내용은 [스레드 Safety](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)을 참조 하십시오.</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자가 보호 되는지; 참고 파생 된 클래스 에서만 호출 될 수는 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <summary>지정된 정규 식에 대해 <see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조는 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md) 항목입니다.  
  
 호출는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> 생성자는 호출 하는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 의 값과 <xref:System.Text.RegularExpressions.RegexOptions.None> 에 대 한는 `options` 인수입니다.  
  
 A <xref:System.Text.RegularExpressions.Regex> 개체가 변경 불가능, 즉, 만들 때 정의한 일치 패턴에 대해서만 사용할 수 있습니다. 그러나 수 있습니다 다시 컴파일하지 않고 여러 번 사용 합니다.  
  
 이 생성자에 정의 된 모든 알파벳 문자 대/소문자 구분 일치를 시도 하는 정규식 개체를 인스턴스화하고 `pattern`합니다. 대/소문자 구분 비교를 사용 하 여는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 생성자입니다.  
  
   
  
## Examples  
 다음 예제를 인스턴스화하는 문자로 시작 하는 단어와 일치 하는 정규식이이 생성자를 사용 하는 방법 "a" 또는 "t"입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 참고 정규식 패턴 일치 단어 수 없습니다 "The" 텍스트의 시작 부분에서 기본적으로 대/소문자를 구분 하 여 비교 하므로 합니다. 예를 보려면 대/소문자 비구분 비교 참조는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>이 생성자는 <see cref="T:System.Text.RegularExpressions.Regex" /> 생성는 응용 프로그램 도메인의 기본 제한 시간 값을 사용 하는 개체입니다. 응용 프로그램 도메인에 대 한 시간 제한 값이 정의 되지 않은 경우는 <see cref="T:System.Text.RegularExpressions.Regex" /> 값을 사용 하는 개체 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 작업이 시간 초과 방지 하는 합니다. 만들기 위한 권장된 생성자는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체가 <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">serialize된 패턴과 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 정보가 포함된 개체입니다.</param>
        <param name="context">이 serialization의 대상입니다. 이 매개 변수는 사용되지 않으므로 <see langword="null" />을 지정하세요.</param>
        <summary>serialize된 데이터를 사용하여 <see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" />에 포함된 패턴이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="info" />에 잘못된 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 플래그가 포함된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">정규식을 수정하는 열거형 값의 비트 조합입니다.</param>
        <summary>패턴을 수정할 수 있는 옵션을 사용하여 <see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 지정된 정규식에 대해 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조는 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md) 항목입니다.  
  
 A <xref:System.Text.RegularExpressions.Regex> 개체가 변경 불가능, 즉, 일치 매개 변수를 만들 경우 정의 대해서만 사용할 수 있습니다. 그러나 수 있습니다 다시 컴파일하지 않고 여러 번 사용 합니다.  
  
   
  
## Examples  
 다음 예제를 인스턴스화하는 문자로 시작 하는 단어와 일치 하는 정규식이이 생성자를 사용 하는 방법 "a" 또는 "t"입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 일치 컬렉션 때문에 텍스트를 시작 하 "The" 단어를 포함 하는 참고는 `options` 매개 변수의 대/소문자 구분 비교를 정의 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />에 잘못된 플래그가 포함된 경우</exception>
        <block subset="none" type="usage">
          <para>이 생성자는 <see cref="T:System.Text.RegularExpressions.Regex" /> 생성는 응용 프로그램 도메인의 기본 제한 시간 값을 사용 하는 개체입니다. 응용 프로그램 도메인에 대 한 시간 제한 값이 정의 되지 않은 경우는 <see cref="T:System.Text.RegularExpressions.Regex" /> 값을 사용 하는 개체 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 작업이 시간 초과 방지 하는 합니다. 만들기 위한 권장된 생성자는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체가 <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">정규식을 수정하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>시간이 초과되기 전에 패턴 일치 메서드가 일치하도록 시도해야 하는 시간을 지정한 패턴과 값을 수정할 수 있는 옵션을 사용하여 <see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 지정된 정규식에 대해 초기화하고 컴파일합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조는 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md) 항목입니다.  
  
 A <xref:System.Text.RegularExpressions.Regex> 개체가 변경 불가능, 즉, 만들 때 정의 하는 일치 패턴에 대해서만 사용할 수 있습니다. 그러나 수 있습니다 다시 컴파일하지 않고 여러 번 사용 합니다.  
  
 `matchTimeout` 매개 변수 지정 시간에 패턴 일치 메서드는 시간이 초과 되기 전에 일치 항목을 찾을 시도해 야 합니다. 일치 항목이 없으면 해당 시간 간격에서 발견 되 면 패턴 일치 메서드가 throw 한 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값 재정의 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 관찰 하는 인스턴스 패턴 일치 메서드는 `matchTimeout` 시간 제한 간격에는 다음과 같습니다.  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 입력을 처리 하는 경우 응답을 중지 하 게 표시 되지 않도록 과도 한 역 추적을 사용 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 들어 있는입니다. 자세한 내용은 참조 [정규식에 대 한 유용한](~/docs/standard/base-types/best-practices.md) 및 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 적절 한 시간 제한 간격을 설정 하려면 다음 요소를 고려 합니다.  
  
-   길이 복잡 한 정규식 패턴입니다. 길고 복잡 한 정규식 짧고 간단 것 보다 더 많은 시간이 필요합니다.  
  
-   에서는 예상된 컴퓨터 로드 합니다. 처리는 높은 CPU 및 메모리 사용률을 갖는 시스템에서 많은 시간이 소요 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 생성자를 인스턴스화하는 <xref:System.Text.RegularExpressions.Regex> 1 초의 시간 제한 값을 가진 개체입니다. 줄의 끝에 하나 이상의 "a" 문자가 포함된 하나 이상의 시퀀스와 일치하는 정규식 패턴 `(a+)+$`는 과도한 역추적의 대상이 됩니다. 경우는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 가 throw이 예제에서는 시간 제한 값 3 초의 최대값까지 늘립니다. 그렇지 않은 경우는 패턴 일치를 시도 중단 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />은 유효한 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값이 아닙니다.  -또는-  <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 매개 변수를 2 초 등의 적절 한 값입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다. 하지만 다음과 같은 경우에만 제한 시간을 비활성화 해야:-이 정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 또는 정적 텍스트로 구성 됩니다. 이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.  -정규식 패턴을 효율적으로 처리 하는 확인을 철저히 테스트 하는 경우 일치 하는 일치 하지 않는 하 고 가까운 일치 합니다.  -정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컴파일된 정규식에 대한 현재 정적 캐시의 최대 엔트리 수를 가져오거나 설정합니다.</summary>
        <value>현재 정적 캐시의 최대 엔트리 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> 클래스 정적 메서드 호출에 사용 된 컴파일된 정규식의 내부 캐시를 유지 관리 합니다. Set 작업에 지정 된 값을 사용 하면 현재 캐시 크기 보다 작으면, 캐시 항목은 캐시 크기는 지정 된 값과 같은 될 때까지 삭제 됩니다.  
  
 기본적으로 캐시 15 컴파일된 정적 정규식을 보유 합니다. 캐시의 크기를 수정 하려면 일반적으로 응용 프로그램을 설치 하지 않아도 됩니다. 사용 하 여는 <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> 캐싱 나 매우 큰 캐시를 보유 하는 경우 해제 하려는 경우에 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Set 작업의 값이 0보다 작습니다.</exception>
        <block subset="none" type="usage">
          <para>이전에.NET Framework에는 [! INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], 정적에 사용 되는 정규식 및 캐시 된 인스턴스 메서드 호출 합니다. 부터는 [! INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], 일반만에 사용 된 식 정적 메서드 호출 캐시 됩니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>명명된 캡처링 그룹을 인덱스 값에 매핑하는 사전을 가져오거나 설정합니다.</summary>
        <value>명명된 캡처링 그룹을 인덱스 값에 매핑하는 사전입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참고는이 속성은 보호 됩니다. 파생 된 클래스에서만 액세스할 수 있습니다는 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
 Set 작업 속성에 할당 된 값으로 변환 하려고 한 <xref:System.Collections.Hashtable> 개체;이 변환에 실패 하는 경우 호출 하는 <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">집합 작업의 <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> 속성에 할당된 값은 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>번호가 매겨진 캡처링 그룹을 인덱스 값에 매핑하는 사전을 가져오거나 설정합니다.</summary>
        <value>번호가 매겨진 캡처링 그룹을 인덱스 값에 매핑하는 사전입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참고는이 속성은 보호 됩니다. 파생 된 클래스에서만 액세스할 수 있습니다는 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
 Set 작업 속성에 할당 된 값으로 변환 하려고 한 <xref:System.Collections.Hashtable> 개체;이 변환에 실패 하는 경우 호출 하는 <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">집합 작업의 <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> 속성에 할당된 값은 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>정규식을 컴파일하고 단일 어셈블리의 디스크에 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

.NET Core에서 호출 하는 `Regex.CompileToAssembly` 메서드 throw 한 <xref:System.PlatformNotSupportedException>; 어셈블리를 쓰는 지원 되지 않습니다.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">컴파일할 정규식을 설명하는 배열입니다.</param>
        <param name="assemblyname">어셈블리의 파일 이름입니다.</param>
        <summary>하나 이상의 지정된 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체를 명명된 어셈블리로 컴파일합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> 각각의 정규식에서 정의에서.NET Framework 어셈블리를 생성 하는 메서드는 `regexinfos` 배열 클래스로 표현 됩니다. 일반적으로 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> 컴파일된 정규식의 어셈블리를 생성 하는 별도 응용 프로그램에서 메서드를 호출 합니다. 어셈블리에 포함 된 각 정규식에는 다음과 같은 특징이 있습니다.  
  
-   파생 된 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
-   정의 된 정규화 된 이름이 할당 됩니다는 `fullnamespace` 및 `name` 해당 매개 변수 <xref:System.Text.RegularExpressions.RegexCompilationInfo> 개체입니다.  
  
-   (또는 매개 변수가 없는) 기본 생성자입니다.  
  
 일반적으로 코드를 인스턴스화하고 컴파일된 정규식을 사용 하는 어셈블리 또는 어셈블리를 만드는 코드에서 별도 응용 프로그램에 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 RegexLib.dll 이라는 어셈블리를 만듭니다. 어셈블리에 두 개의 컴파일된 정규식에 포함 됩니다. 첫 번째 `Utilities.RegularExpressions.DuplicatedString`, 동일한 두 개의 연속 단어와 일치 합니다. 두 번째 페이지인 `Utilities.RegularExpressions.EmailAddress`, 문자열이 올바른 형식으로 전자 메일 주소에 있는지 여부를 확인 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 중복 된 단어에 대 한 문자열을 검사 하는 정규식은 다음 의해 인스턴스화되어 사용 되며 다음 예제에서는 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 이 두 번째 예제의 컴파일이 성공 프로젝트에 추가할 RegexLib.dll (첫 번째 예제에서 생성 된 어셈블리)에 대 한 참조가 필요 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyname" /> 매개 변수의 <see cref="P:System.Reflection.AssemblyName.Name" /> 속성 값이 비어 있거나 null 문자열인 경우  -또는-  <paramref name="regexinfos" />에 있는 개체 중 하나 이상의 정규식 패턴에 잘못된 구문이 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> 또는 <paramref name="regexinfos" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core에만 해당: 컴파일된 정규식의 어셈블리 만들기는 지원되지 않습니다.</exception>
        <block subset="none" type="usage">
          <para>포함 된 시스템에서 개발 하는 경우 [! INCLUDE[net_v45](~/includes/net-v45-md.md)] 대상 설치 해당 포인트 릴리스 또는 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 사용 하는 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 포함 된 어셈블리를 만드는 메서드를 컴파일된 정규식입니다. 가 시스템에서 어셈블리에 있는 정규식 중 하나를 사용 하는 동안 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 예외가 throw 됩니다. 이 문제를 해결 하려면 하나를 수행 하면 다음 중:-있는 시스템에서 컴파일된 정규식이 포함 된 어셈블리를 빌드합니다 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 대신 이후 버전의 설치 됩니다.  -대신 호출의 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 사용 정적 또는 인스턴스를 어셈블리에서 컴파일된 정규식을 검색 하 고 <see cref="T:System.Text.RegularExpressions.Regex" /> 있는 메서드는 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 인스턴스화할 때 옵션는 <see cref="T:System.Text.RegularExpressions.Regex" /> 정규식 호출할 또는 개체 패턴 일치 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">컴파일할 정규식을 설명하는 배열입니다.</param>
        <param name="assemblyname">어셈블리의 파일 이름입니다.</param>
        <param name="attributes">어셈블리에 적용할 특성을 정의하는 배열입니다.</param>
        <summary>지정된 특성을 사용하여 하나 이상의 지정된 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체를 명명된 어셈블리로 컴파일합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> 각각의 정규식에서 정의에서.NET Framework 어셈블리를 생성 하는 메서드는 `regexinfos` 배열 클래스로 표현 됩니다. 일반적으로 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> 컴파일된 정규식의 어셈블리를 생성 하는 별도 응용 프로그램에서 메서드를 호출 합니다. 어셈블리에 포함 된 각 정규식에는 다음과 같은 특징이 있습니다.  
  
-   파생 된 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
-   정의 된 정규화 된 이름이 할당 됩니다는 `fullnamespace` 및 `name` 해당 매개 변수 <xref:System.Text.RegularExpressions.RegexCompilationInfo> 개체입니다.  
  
-   (또는 매개 변수가 없는) 기본 생성자입니다.  
  
 일반적으로 코드를 인스턴스화하고 컴파일된 정규식을 사용 하는 어셈블리 또는 어셈블리를 만드는 코드에서 별도 응용 프로그램에 있습니다.  
  
 때문에 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> 특정 언어의 클래스 정의 키워드를 사용 하는 대신 메서드 호출에서.NET Framework 어셈블리를 생성 하는 메서드 (같은 `class` C# 또는 `Class`...`End Class` Visual basic)에서는.NET Framework 특성 개발 언어 표준 특성 구문을 사용 하 여 어셈블리에 할당할 수 없습니다. `attributes` 매개 변수는 어셈블리에 적용 되는 특성을 정의 하기 위한 대체 방법을 제공 합니다. 어셈블리에 적용 하려는 각 특성에 대해 다음을 수행 합니다.  
  
1.  배열을 만들어 <xref:System.Type> 호출 하고자 하는 특성 생성자의 매개 변수 형식을 나타내는 개체입니다.  
  
2.  검색 한 <xref:System.Type> 새 어셈블리에 적용할 특성 클래스를 나타내는 개체입니다.  
  
3.  호출의 <xref:System.Type.GetConstructor%2A> 메서드 특성의 <xref:System.Type> 검색할 개체는 <xref:System.Reflection.ConstructorInfo> 호출 하고자 하는 특성 생성자를 나타내는 개체입니다. 전달 된 <xref:System.Type.GetConstructor%2A> 메서드 배열의 <xref:System.Type> 생성자의 매개 변수 형식을 나타내는 개체입니다.  
  
4.  만들기는 <xref:System.Object> 특성의 생성자에 전달할 매개 변수를 정의 하는 배열입니다.  
  
5.  인스턴스화하는 <xref:System.Reflection.Emit.CustomAttributeBuilder> 생성자에 전달 하 여 개체는 <xref:System.Reflection.ConstructorInfo> 3 단계에서 개체 검색 및 <xref:System.Object> 4 단계에서 만든 배열입니다.  
  
 그런 다음 이러한 배열을 전달 <xref:System.Reflection.Emit.CustomAttributeBuilder> 개체 대신는 `attributes` 매개 변수를는 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 RegexLib.dll 이라는 어셈블리를 만들고 적용 하는 <xref:System.Reflection.AssemblyTitleAttribute> 특성을 합니다. 어셈블리에 두 개의 컴파일된 정규식에 포함 됩니다. 첫 번째 `Utilities.RegularExpressions.DuplicatedString`, 동일한 두 개의 연속 단어와 일치 합니다. 두 번째 페이지인 `Utilities.RegularExpressions.EmailAddress`, 문자열이 올바른 형식으로 전자 메일 주소에 있는지 여부를 확인 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 확인할 수 있습니다는 <xref:System.Reflection.AssemblyTitleAttribute> 특성이 해당 매니페스트 ILDasm 같은 리플렉션 유틸리티를 검사 하 여 어셈블리에 적용 되었습니다.  
  
 중복 된 단어에 대 한 문자열을 검사 하는 정규식은 다음 의해 인스턴스화되어 사용 되며 다음 예제에서는 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 이 두 번째 예제의 컴파일이 성공 프로젝트에 추가할 RegexLib.dll (첫 번째 예제에서 생성 된 어셈블리)에 대 한 참조가 필요 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyname" /> 매개 변수의 <see cref="P:System.Reflection.AssemblyName.Name" /> 속성 값이 비어 있거나 null 문자열인 경우  -또는-  <paramref name="regexinfos" />에 있는 개체 중 하나 이상의 정규식 패턴에 잘못된 구문이 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> 또는 <paramref name="regexinfos" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core에만 해당: 컴파일된 정규식의 어셈블리 만들기는 지원되지 않습니다.</exception>
        <block subset="none" type="usage">
          <para>포함 된 시스템에서 개발 하는 경우 [! INCLUDE[net_v45](~/includes/net-v45-md.md)] 대상 설치 해당 포인트 릴리스 또는 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 사용 하는 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 포함 된 어셈블리를 만드는 메서드를 컴파일된 정규식입니다. 가 시스템에서 어셈블리에 있는 정규식 중 하나를 사용 하는 동안 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 예외가 throw 됩니다. 이 문제를 해결 하려면 하나를 수행 하면 다음 중:-있는 시스템에서 컴파일된 정규식이 포함 된 어셈블리를 빌드합니다 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 대신 이후 버전의 설치 됩니다.  -대신 호출의 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 사용 정적 또는 인스턴스를 어셈블리에서 컴파일된 정규식을 검색 하 고 <see cref="T:System.Text.RegularExpressions.Regex" /> 있는 메서드는 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 인스턴스화할 때 옵션는 <see cref="T:System.Text.RegularExpressions.Regex" /> 정규식 호출할 또는 개체 패턴 일치 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">컴파일할 정규식을 설명하는 배열입니다.</param>
        <param name="assemblyname">어셈블리의 파일 이름입니다.</param>
        <param name="attributes">어셈블리에 적용할 특성을 정의하는 배열입니다.</param>
        <param name="resourceFile">어셈블리에 포함될 Win32 리소스 파일의 이름입니다.</param>
        <summary>지정된 특성을 사용하여 하나 이상의 지정된 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체와 지정된 리소스 파일을 명명된 어셈블리로 컴파일합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName% 2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 각각의 정규식에서 정의에서.NET Framework 어셈블리를 생성 하는 메서드는 `regexinfos` 배열 클래스로 표현 됩니다. 일반적으로 [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 컴파일된 정규식의 어셈블리를 생성 하는 별도 응용 프로그램에서 메서드를 호출 합니다. 어셈블리에 포함 된 각 정규식에는 다음과 같은 특징이 있습니다.  
  
-   파생 된 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
-   정의 된 정규화 된 이름이 할당 됩니다는 `fullnamespace` 및 `name` 해당 매개 변수 <xref:System.Text.RegularExpressions.RegexCompilationInfo> 개체입니다.  
  
-   (또는 매개 변수가 없는) 기본 생성자입니다.  
  
 일반적으로 코드를 인스턴스화하고 컴파일된 정규식을 사용 하는 어셈블리 또는 어셈블리를 만드는 코드에서 별도 응용 프로그램에 있습니다.  
  
 때문에 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> 특정 언어의 클래스 정의 키워드를 사용 하는 대신 메서드 호출에서.NET Framework 어셈블리를 생성 하는 메서드 (같은 `class` C# 또는 `Class`...`End Class` Visual basic)에서는.NET Framework 특성 개발 언어 표준 특성 구문을 사용 하 여 어셈블리에 할당할 수 없습니다. `attributes` 매개 변수는 어셈블리에 적용 되는 특성을 정의 하기 위한 대체 방법을 제공 합니다. 어셈블리에 적용 하려는 각 특성에 대해 다음을 수행 합니다.  
  
1.  배열을 만들어 <xref:System.Type> 호출 하고자 하는 특성 생성자의 매개 변수 형식을 나타내는 개체입니다.  
  
2.  검색 한 <xref:System.Type> 새 어셈블리에 적용할 특성 클래스를 나타내는 개체입니다.  
  
3.  호출의 <xref:System.Type.GetConstructor%2A> 메서드 특성의 <xref:System.Type> 검색할 개체는 <xref:System.Reflection.ConstructorInfo> 호출 하고자 하는 특성 생성자를 나타내는 개체입니다. 전달 된 <xref:System.Type.GetConstructor%2A> 메서드 배열의 <xref:System.Type> 생성자의 매개 변수 형식을 나타내는 개체  
  
4.  만들기는 <xref:System.Object> 특성의 생성자에 전달할 매개 변수를 정의 하는 배열입니다.  
  
5.  인스턴스화하는 <xref:System.Reflection.Emit.CustomAttributeBuilder> 생성자에 전달 하 여 개체는 <xref:System.Reflection.ConstructorInfo> 3 단계에서 개체 검색 및 <xref:System.Object> 4 단계에서 만든 배열입니다.  
  
 그런 다음 이러한 배열을 전달 <xref:System.Reflection.Emit.CustomAttributeBuilder> 개체 대신는 `attributes` 매개 변수를는 [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyname" /> 매개 변수의 <see cref="P:System.Reflection.AssemblyName.Name" /> 속성 값이 비어 있거나 null 문자열인 경우  -또는-  <paramref name="regexinfos" />에 있는 개체 중 하나 이상의 정규식 패턴에 잘못된 구문이 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> 또는 <paramref name="regexinfos" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="resourceFile" /> 매개 변수가 잘못된 Win32 리소스 파일을 지정합니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="resourceFile" /> 매개 변수가 지정된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core에만 해당: 컴파일된 정규식의 어셈블리 만들기는 지원되지 않습니다.</exception>
        <block subset="none" type="usage">
          <para>포함 된 시스템에서 개발 하는 경우 [! INCLUDE[net_v45](~/includes/net-v45-md.md)] 대상 설치 해당 포인트 릴리스 또는 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 사용 하는 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 포함 된 어셈블리를 만드는 메서드를 컴파일된 정규식입니다. 가 시스템에서 어셈블리에 있는 정규식 중 하나를 사용 하는 동안 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 예외가 throw 됩니다. 이 문제를 해결 하려면 하나를 수행 하면 다음 중:-있는 시스템에서 컴파일된 정규식이 포함 된 어셈블리를 빌드합니다 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 대신 이후 버전의 설치 됩니다.  -대신 호출의 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 사용 정적 또는 인스턴스를 어셈블리에서 컴파일된 정규식을 검색 하 고 <see cref="T:System.Text.RegularExpressions.Regex" /> 있는 메서드는 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 인스턴스화할 때 옵션는 <see cref="T:System.Text.RegularExpressions.Regex" /> 정규식 호출할 또는 개체 패턴 일치 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">변환할 텍스트가 포함된 입력 문자열입니다.</param>
        <summary>문자(\\, *, +, ?, |, {, [, (,), ^, $,., # 및 공백)의 최소 집합을 자체 이스케이프 코드로 대체하여 이스케이프합니다. 이렇게 하면 정규식 엔진은 이러한 문자를 메타문자가 아니라 문자 그대로 해석합니다.</summary>
        <returns>메타문자가 이스케이프 서식으로 변환된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 정규식 엔진은 문자 리터럴으로 포함 될 수 있는 모든 메타 문자를 해석할 수 있도록 문자열로 변환 합니다. 예를 들어, 정규식을 직선 열고 닫는 대괄호 ([및]) 텍스트와에서 구분 되는 주석을 추출 하도록 디자인 된 것이 좋습니다. 다음 예제에서는 정규식에에서 "[(.*?)]"는 문자 클래스로 해석 됩니다. 입력된 텍스트에 포함 된 주석과 일치 대신 정규식 각 열기 또는 닫는 괄호, 기간, 별표, 또는 매개 변수를 찾습니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 그러나 왼쪽 괄호를 전달 하 여 이스케이프 된 경우는 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메서드를 정규식 일치는 입력된 문자열에 포함 된 주석에서 성공 합니다. 다음은 이에 대한 예입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 정적 텍스트를 사용 하 여 정의 된 정규식을 메타 문자가 아닌 문자 그대로 해석 되어야 하는 문자는 백슬래시 기호 앞에 이스케이프 될 수 있습니다 (\\) 및 호출 된 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메서드. 디자인 타임에 알 수 없는 문자를 사용 하 여 동적으로 정의 된 정규식에서 호출 된 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메서드는 정규식 엔진에서 해석 하는 개별 문자 리터럴로 대신 구하도록 보다 메타 문자가 있습니다.  
  
> [!NOTE]
>  정규식 패턴에서 숫자 기호 (#) 또는 리터럴 공백 문자를 포함 하는 경우에 이스케이프 되어야 입력된 텍스트는으로 구문 분석 하는 경우는 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 옵션을 사용 합니다.  
  
 반면는 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메서드는 직선 이스케이프 여는 대괄호 () 하 고 여는 중괄호 ({) 문자를 해당 이스케이프 하지 않습니다의 해당 문자를 닫는 (] 및}). 대부분의 경우에서 이러한 이스케이프 필요는 없습니다. 메서드는 문자열의 유효성을 검사 하거나 후속 조작에 대 한 해당 문자열을 검색 하지 않고 문자열이 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다. 하나 이상의 문자열 정규식 패턴과 일치 하 고 후속 조작, 호출에 대 한 다음 검색 하 지 확인 하려는 경우는  또는  메서드. \\ 일치 하는 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는  생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는  개체가 만들어집니다.  
  
   
  
## Examples  
 제한 시간 없음을에 정의 된 경우는  생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 , 예외가 throw 되지 않습니다. 다음 예제에서는  메서드를 문자열로 유효한 부품 번호 인지 확인 합니다. 정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식을에 있다고 가정 합니다. 뒤에 두 개의 숫자 문자가 영숫자 문자로 이어지는 영숫자 문자 4 자 하는 첫 번째 집합을 구성 해야 합니다. 3 자로 구성 된 두 번째 집합은 숫자 여야 합니다. 4 자로 구성 된 세 번째 집합에는 세 자리 숫자로 영숫자 문자로 이어지는 있어야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>정규식에 대한 캡처링 그룹 이름의 배열을 반환합니다.</summary>
        <returns>그룹 이름의 문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 줄의 시작 부분에서 일치 항목 찾기를 시작 합니다. 일치는 단일 영문자 ( 통해  또는  통해 ) 또는 숫자 문자입니다. 두 개의 숫자 문자를 찾습니다. 정확히 세 개의 숫자 문자를 찾습니다.  
  
 세 자리 숫자로, 하이픈과 찾아이 패턴의 두 일치 항목 일치 합니다.  
  
   
  
## Examples  
 줄의 끝에서 검색을 종료 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 검색을 시작할 문자 위치입니다. 정규식에 지정 된 수 있는지 여부를 나타내며는  생성자 문자열에 지정 된 시작 위치부터 지정된 된 입력된 문자열에서 일치 하는 항목을 찾습니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`(?<FirstWord>\w+)`|하나 이상의 단어 문자를 찾습니다. 문자열의 콜론 (:) 문자 뒤에 포함 된 부품 번호를 검색 합니다.|  
|\s?|0회 이상 나오는 공백 문자를 찾습니다.|  
|(\w+)|하나 이상의 단어 문자를 찾습니다. 이 그룹은 두 번째 캡처링 그룹입니다.|  
|\s|공백 문자를 찾습니다.|  
|((\w+)\s)*|메서드에 전달 되는 콜론 문자 위치를 결정 하기를 사용 하는  메서드. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|(? \<LastWord > \w+)?|하나 이상의 단어 문자 0 회 이상 발생을 찾습니다. 문자열의 콜론 (:) 문자 뒤에 포함 된 부품 번호를 검색 합니다.|  
|(? \<문장 부호 > \p{Po})|문자를 유니코드 범주는 문장 부호, 기타 합니다. 문자열의 콜론 (:) 문자 뒤에 포함 된 부품 번호를 검색 합니다.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>배열 내의 그룹 이름에 해당하는 캡처링 그룹 번호의 배열을 반환합니다.</summary>
        <returns>그룹 번호의 정수 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명 되지 않은 및 명명 된 캡처링 그룹 수로 액세스할 수 있습니다. 명명 되지 않은 그룹 왼쪽에서 오른쪽 1부터 매겨집니다. (인덱스 0 (영) 캡처링 그룹이 나타냅니다 일치를 하는 전체.)  명명 된 그룹은 다음 왼쪽에서 번호가 매겨진 1 더 큰 숫자를 오른쪽부터 수보다 명명 되지 않은 캡처링 그룹입니다.  
  
 문자열 이름으로 참조 하는 대신 해당 번호로 그룹 빠른 액세스를 제공할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 정의 `\b((?<word>\w+)\s*)+(?<end>[.?!])`, 문장 일치 하는 합니다. 세 가지 캡처링 그룹을 포함 하는 정규식: 함께 하며 다음에 올 수 있는 공백 문자는 개별 단어를 캡처하는 명명 되지 않은 그룹 라는 그룹 `word` 을 캡처하는 개별 단어는 문장;에서 및 그룹 이라는 `end` 문장 끝나는 문장 부호를 캡처하는 합니다. 호출 된 <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> 모든 캡처의 번호를 가져올 메서드를 그룹, 한 다음 캡처된 해당 문자열을 표시 합니다. 또한는 <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> 메서드는 특정 번호가 매겨진된 그룹 명명 된 그룹에 해당 하는지 여부를 나타내는 데 사용 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 정규식 패턴은 다음 테이블과 같이 해석됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`(?<word>\w+)`|일치 하는 문자열 라는 그룹을 할당 하 고 하나 이상의 단어 문자를 찾습니다 `word`합니다.|  
|`\s*`|0개 이상의 공백 문자가 일치하는지 확인합니다.|  
|`((?<word>\w+)\s*)`|할당 된 `word` 된 캡처된 그룹 캡처된 첫 번째 캡처 그룹에 공백 문자입니다.|  
|`((?<word>\w+)\s*)+`|하나 이상의 단어 문자 다음에 모든 공백 문자가 한 번 이상 패턴과 일치 합니다.|  
|`(?<end>[.?!])`|마침표, 물음표 또는 느낌표를 찾습니다. 일치 하는 문자를 할당 된 `end` 캡처링 그룹입니다.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">해당 그룹 이름으로 변환할 그룹 번호입니다.</param>
        <summary>지정된 그룹 번호에 해당하는 그룹 이름을 가져옵니다.</summary>
        <returns>지정된 그룹 번호에 연결되어 있는 그룹 이름이 포함된 문자열입니다. <paramref name="i" />에 해당하는 그룹 이름이 없는 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정규식 패턴에 명명 되거나 번호가 매겨진 캡처링 그룹 내의 패턴 일치를 사용 하는 하위 식을 나타내는 포함 될 수 있습니다. 번호가 매겨진된 그룹 구문에 의해 구분 됩니다 (*subexpression*) 정규식에서의 순서에 따라 숫자 할당 됩니다. 명명 된 그룹 구문에 의해 구분 됩니다 (?`<` *이름*`>`*subexpression*) 또는 (?' *이름*'*subexpression*) 여기서 *이름* 부분식을 식별 하는 이름입니다. 자세한 내용은 [그룹화 구문](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)을 참조하세요. <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> 메서드는 명명 된 그룹 및 서 수 위치로 정규식에서 번호가 매겨진된 그룹 모두를 식별 합니다. 서 수 위치 0에는 항상 전체 정규식을 나타냅니다. 번호가 매겨진 모든 그룹의 정규식 패턴에서의 실제 위치에 관계 없이 명명 된 그룹 하기 전에 다음 계산 됩니다.  
  
 경우 `i` 수 명명된 된 그룹의 메서드는 그룹의 이름을 반환 합니다. 경우 `i` 수 명명 되지 않은 그룹의 메서드는 숫자의 문자열 표현을 반환 합니다. 예를 들어 경우 `i` 는 1, "1" 메서드를 반환 합니다. 경우 `i` 가 아닌 경우는 캡처링 그룹 메서드 반환 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 패턴 일치를 사용 하는 항목이 있는 경우이 메서드에서 반환 되는 값 다음 사용할 수를 검색 하는 <xref:System.Text.RegularExpressions.Group> 에서 캡처된 그룹을 나타내는 개체는 <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> 속성입니다. <xref:System.Text.RegularExpressions.GroupCollection> 개체에서 반환 된 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 미국 도시 이름, 상태 이름 및 우편 번호를 포함 하는 주소 줄 일치 하는 정규식 패턴을 정의 합니다. 이 예제에서는 사용은 <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> 캡처링 그룹의 이름을 검색 하는 메서드입니다. 다음이 이름을 사용 하 여 일치 하는 항목에 대 한 해당 캡처된 그룹을 검색 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 정규식 패턴은 다음 식으로 정의 됩니다.  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|패턴|설명|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|하나 이상의 영문자 또는 공백 문자를 찾습니다. 이 캡처된 그룹의 이름을 할당 `city`합니다.|  
|`,`|쉼표 (,) 뒤에 공백 문자를 찾습니다.|  
|`(?<state>[A-Za-z]{2})`|두 개의 알파벳 문자를 찾습니다. 이 캡처된 그룹의 이름을 할당 `state`합니다. 이 그룹 뒤에 공백 문자가 야 합니다.|  
|`(?<zip>\d{5}(-\d{4})?)`|5 자리 숫자를 4 자리 숫자가 나오는 하이픈 0 개 또는 1 번째와 일치 합니다. 이 캡처된 그룹의 이름을 할당 `zip`합니다.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">해당 그룹 번호로 변환할 그룹 이름입니다.</param>
        <summary>지정된 그룹 이름에 해당하는 그룹 번호를 반환합니다.</summary>
        <returns>지정된 그룹 이름에 해당하는 그룹 번호이거나 <paramref name="name" />이 유효한 그룹 이름이 아닌 경우 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정규식 패턴에 명명 되거나 번호가 매겨진 캡처링 그룹 내의 패턴 일치를 사용 하는 하위 식을 나타내는 포함 될 수 있습니다. 번호가 매겨진된 그룹 구문에 의해 구분 됩니다 (*subexpression*) 정규식에서의 순서에 따라 숫자 할당 됩니다. 명명 된 그룹 구문에 의해 구분 됩니다 (?`<` *이름*`>`*subexpression*) 또는 (?' *이름*'*subexpression*) 여기서 *이름* 부분식을 식별 하는 이름입니다. 자세한 내용은 [그룹화 구문](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)을 참조하세요. <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> 메서드는 명명 된 그룹 및 서 수 위치로 정규식에서 번호가 매겨진된 그룹 모두를 식별 합니다. 서 수 위치 0에는 항상 전체 정규식을 나타냅니다. 번호가 매겨진 모든 그룹의 정규식 패턴에서의 실제 위치에 관계 없이 명명 된 그룹 하기 전에 다음 계산 됩니다.  
  
 경우 `name` 번호는 메서드가 반환 정규식 패턴에 있는 그룹 번호의 문자열 표현입니다. 경우 `name` 해당 하는 명명 된 캡처링 그룹은 정규식 패턴에 있는, 메서드는 해당 번호를 반환 합니다. 비교 `name` 그룹 이름은 대/소문자 구분 합니다. 경우 `name` 해당 하지 않는 캡처링 그룹의 이름 또는 메서드를 캡처 그룹의 숫자의 문자열 표현을-1을 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>패턴 일치 작업의 시간이 초과되지 않도록 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 클래스 생성자 및 다양 한 일치 하는 정적 메서드 사용은 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> 패턴 일치를 찾으려고 시도 시간 제한이 없어야 함을 나타내려면 상수입니다.  
  
> [!WARNING]
>  정규식 엔진의 제한 시간 값을 설정 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> 정규식 패턴과 거의 일치 하는 텍스트를 처리할 때 응답 하지 않을에 과도 한 역 추적을 사용 하는 정규식이 발생할 수 있습니다. 제한 시간을 비활성화 하면 과도 한 역 추적이 정규식을 사용 하 여 정규식 패턴과 거의 일치 하는 텍스트를 처리 하는 해야 합니다.  
>   
>  역 추적을 처리 하는 방법에 대 한 자세한 내용은 참조 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다.  
  
 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> 상수 값으로 제공 될 수 있습니다는 `matchTimeout` 멤버의 인수:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">참조가 이미 초기화된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>작업 시간이 초과되기 전에 패턴 일치 작업에서 경과될 수 있는 최대 시간입니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>정규식이 입력 문자열에서 일치하는 항목을 찾을 것인지를 나타냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <summary>
          <see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에 지정된 정규식이 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지 여부를 나타냅니다.</summary>
        <returns>정규식에서 일치하는 항목을 찾으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 메서드는 문자열의 유효성을 검사 하거나 후속 조작에 대 한 해당 문자열을 검색 하지 않고 문자열이 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다. 하나 이상의 문자열 정규식 패턴과 일치 하 고 후속 조작, 호출에 대 한 다음 검색 하 지 확인 하려는 경우는 <xref:System.Text.RegularExpressions.Regex.Match%2A> 또는 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> 메서드를 문자열로 유효한 부품 번호 인지 확인 합니다. 정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식을에 있다고 가정 합니다. 뒤에 두 개의 숫자 문자가 영숫자 문자로 이어지는 영숫자 문자 4 자 하는 첫 번째 집합을 구성 해야 합니다. 3 자로 구성 된 두 번째 집합은 숫자 여야 합니다. 4 자로 구성 된 세 번째 집합에는 세 자리 숫자로 영숫자 문자로 이어지는 있어야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 정규식 패턴은 다음과 같습니다.  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|패턴|설명|  
|-------------|-----------------|  
|`^`|줄의 시작 부분에서 일치 항목 찾기를 시작 합니다.|  
|`[a-zA-Z0-9]`|일치는 단일 영문자 (`a` 통해 `z` 또는 `A` 통해 `Z`) 또는 숫자 문자입니다.|  
|`\d{2}`|두 개의 숫자 문자를 찾습니다.|  
|`[a-zA-Z0-9]`|일치는 단일 영문자 (`a` 통해 `z` 또는 `A` 통해 `Z`) 또는 숫자 문자입니다.|  
|`-`|하이픈을 찾습니다.|  
|`\d{3}`|정확히 세 개의 숫자 문자를 찾습니다.|  
|`(-\d{3}){2}`|세 자리 숫자로, 하이픈과 찾아이 패턴의 두 일치 항목 일치 합니다.|  
|`[a-zA-Z0-9]`|일치는 단일 영문자 (`a` 통해 `z` 또는 `A` 통해 `Z`) 또는 숫자 문자입니다.|  
|`$`|줄의 끝에서 검색을 종료 합니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="startat">검색을 시작할 문자 위치입니다.</param>
        <summary>
          <see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에 지정된 정규식이 지정된 입력 문자열의 지정된 시작 위치에서부터 일치하는 항목을 찾을 것인지 여부를 나타냅니다.</summary>
        <returns>정규식에서 일치하는 항목을 찾으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 메서드는 문자열의 유효성을 검사 하거나 후속 조작에 대 한 해당 문자열을 검색 하지 않고 문자열이 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다. 하나 이상의 문자열 정규식 패턴과 일치 하 고 후속 조작, 호출에 대 한 다음 검색 하 지 확인 하려는 경우는 <xref:System.Text.RegularExpressions.Regex.Match%2A> 또는 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> 메서드를 문자열로 유효한 부품 번호 인지 확인 합니다. 문자열의 콜론 (:) 문자 뒤에 포함 된 부품 번호를 검색 합니다. <xref:System.String.IndexOf%28System.Char%29> 메서드에 전달 되는 콜론 문자 위치를 결정 하기를 사용 하는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> 메서드. 정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식을에 있다고 가정 합니다. 뒤에 두 개의 숫자 문자가 영숫자 문자로 이어지는 영숫자 문자 4 자 하는 첫 번째 집합을 구성 해야 합니다. 3 자로 구성 된 두 번째 집합은 숫자 여야 합니다. 4 자로 구성 된 세 번째 집합에는 세 자리 숫자로 영숫자 문자로 이어지는 있어야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 정규식 패턴은 다음과 같습니다.  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|패턴|설명|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|일치는 단일 영문자 (`a` 통해 `z` 또는 `A` 통해 `Z`) 또는 숫자 문자입니다.|  
|`\d{2}`|두 개의 숫자 문자를 찾습니다.|  
|`[a-zA-Z0-9]`|일치는 단일 영문자 (`a` 통해 `z` 또는 `A` 통해 `Z`) 또는 숫자 문자입니다.|  
|`-`|하이픈을 찾습니다.|  
|`\d{3}`|정확히 세 개의 숫자 문자를 찾습니다.|  
|`(-\d{3}){2}`|세 자리 숫자로, 하이픈과 찾아이 패턴의 두 일치 항목 일치 합니다.|  
|`[a-zA-Z0-9]`|일치는 단일 영문자 (`a` 통해 `z` 또는 `A` 통해 `Z`) 또는 숫자 문자입니다.|  
|`$`|줄의 끝에서 검색을 종료 합니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <summary>지정된 정규식이 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지를 나타냅니다.</summary>
        <returns>정규식에서 일치하는 항목을 찾으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 메서드는 문자열의 유효성을 검사 하거나 후속 조작에 대 한 해당 문자열을 검색 하지 않고 문자열이 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다. 하나 이상의 문자열 정규식 패턴과 일치 하 고 후속 조작, 호출에 대 한 다음 검색 하 지 확인 하려는 경우는 <xref:System.Text.RegularExpressions.Regex.Match%2A> 또는 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 로 지정 된 정규식 패턴으로 개체 `pattern` 호출는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> 인스턴스 메서드. 이 정규식 패턴은 정규식 엔진에 의해 신속 하 게 검색을 위해 캐시 됩니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> 메서드를 문자열로 유효한 부품 번호 인지 확인 합니다. 정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식을에 있다고 가정 합니다. 뒤에 두 개의 숫자 문자가 영숫자 문자로 이어지는 영숫자 문자 4 자 하는 첫 번째 집합을 구성 해야 합니다. 3 자로 구성 된 두 번째 집합은 숫자 여야 합니다. 4 자로 구성 된 세 번째 집합에는 세 자리 숫자로 영숫자 문자로 이어지는 있어야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 정규식 패턴은 다음과 같습니다.  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|패턴|설명|  
|-------------|-----------------|  
|`^`|줄의 시작 부분에서 일치 항목 찾기를 시작 합니다.|  
|`[a-zA-Z0-9]`|일치는 단일 영문자 (`a` 통해 `z` 또는 `A` 통해 `Z`) 또는 숫자 문자입니다.|  
|`\d{2}`|두 개의 숫자 문자를 찾습니다.|  
|`[a-zA-Z0-9]`|일치는 단일 영문자 (`a` 통해 `z` 또는 `A` 통해 `Z`) 또는 숫자 문자입니다.|  
|`-`|하이픈을 찾습니다.|  
|`\d{3}`|정확히 세 개의 숫자 문자를 찾습니다.|  
|`(-\d{3}){2}`|세 자리 숫자로, 하이픈과 찾아이 패턴의 두 일치 항목 일치 합니다.|  
|`[a-zA-Z0-9]`|일치는 단일 영문자 (`a` 통해 `z` 또는 `A` 통해 `Z`) 또는 숫자 문자입니다.|  
|`$`|줄의 끝에서 검색을 종료 합니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>이 메서드가 제한 시간 초과 후 메서드가 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다. 응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는 데 사용 됩니다. 패턴 일치를 확인 하는 데 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 정규식이 지정된 일치 옵션을 사용하여 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지를 나타냅니다.</summary>
        <returns>정규식에서 일치하는 항목을 찾으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 메서드는 문자열의 유효성을 검사 하거나 후속 조작에 대 한 해당 문자열을 검색 하지 않고 문자열이 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다. 하나 이상의 문자열 정규식 패턴과 일치 하 고 후속 조작, 호출에 대 한 다음 검색 하 지 확인 하려는 경우는 <xref:System.Text.RegularExpressions.Regex.Match%2A> 또는 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 로 지정 된 정규식 패턴으로 개체 `pattern` 및로 지정 된 정규식 옵션이 `options` 호출의 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> 인스턴스 메서드입니다. 이 정규식 패턴은 정규식 엔진에 의해 신속 하 게 검색을 위해 캐시 됩니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> 메서드를 문자열로 유효한 부품 번호 인지 확인 합니다. 정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식을에 있다고 가정 합니다. 뒤에 두 개의 숫자 문자가 영숫자 문자로 이어지는 영숫자 문자 4 자 하는 첫 번째 집합을 구성 해야 합니다. 3 자로 구성 된 두 번째 집합은 숫자 여야 합니다. 4 자로 구성 된 세 번째 집합에는 세 자리 숫자로 영숫자 문자로 이어지는 있어야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 정규식 패턴은 다음과 같습니다.  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|패턴|설명|  
|-------------|-----------------|  
|`^`|문자열의 시작 부분에서 검색을 시작합니다.|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`\d{2}`|두 개의 숫자 문자를 찾습니다.|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`-`|하이픈을 찾습니다.|  
|`\d{3}`|정확히 세 개의 숫자 문자를 찾습니다.|  
|`(-\d{3}){2}`|세 자리 숫자로, 하이픈과 찾아이 패턴의 두 개의 일치 항목...|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`$`|문자열의 끝 부분에서 일치 항목 찾기를 끝냅니다.|  
  
 호출는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 사용 하 여 메서드는 `options` 매개 변수 설정 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 다음 정규식을 정의 하는 것과 같습니다.  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 반면에 대 한 예제를 참조 하십시오.는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />은 유효한 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값이 아닙니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다. 응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는 데 사용 됩니다. 패턴 일치를 확인 하는 데 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 정규식이 지정된 일치 옵션 및 시간 제한 간격을 사용하여 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지를 나타냅니다.</summary>
        <returns>정규식에서 일치하는 항목을 찾으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 메서드는 문자열의 유효성을 검사 하거나 후속 조작에 대 한 해당 문자열을 검색 하지 않고 문자열이 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다. 하나 이상의 문자열 정규식 패턴과 일치 하 고 후속 조작, 호출에 대 한 다음 검색 하 지 확인 하려는 경우는 <xref:System.Text.RegularExpressions.Regex.Match%2A> 또는 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 로 지정 된 정규식 패턴으로 개체 `pattern` 및로 지정 된 정규식 옵션이 `options` 호출의 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> 인스턴스 메서드입니다. 이 정규식 패턴은 정규식 엔진에 의해 신속 하 게 검색을 위해 캐시 됩니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 `matchTimeout` 매개 변수 지정 긴 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리 하는 경우 응답을 중지 하 게 표시 되지 않도록 과도 한 역 추적을 사용 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 들어 있는입니다. 자세한 내용은 참조 [정규식에 대 한 유용한](~/docs/standard/base-types/best-practices.md) 및 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 일치 항목이 없으면 해당 시간 간격에서 발견 되 면 경우에 메서드에서 throw 된 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 메서드가 실행 되는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 메서드를 문자열로 유효한 부품 번호 인지 확인 합니다. 정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식을에 있다고 가정 합니다. 뒤에 두 개의 숫자 문자가 영숫자 문자로 이어지는 영숫자 문자 4 자 하는 첫 번째 집합을 구성 해야 합니다. 3 자로 구성 된 두 번째 집합은 숫자 여야 합니다. 4 자로 구성 된 세 번째 집합에는 세 자리 숫자로 영숫자 문자로 이어지는 있어야 합니다. 정규식 패턴과 일치 하는 최소를 검색 하는 입력된 문자열에서 500 밀리초의 시간 제한 간격을 설정 하는 메서드가 있으므로 참여 시켜야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 정규식 패턴은 다음과 같습니다.  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|패턴|설명|  
|-------------|-----------------|  
|`^`|문자열의 시작 부분에서 검색을 시작합니다.|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`\d{2}`|두 개의 숫자 문자를 찾습니다.|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`-`|하이픈을 찾습니다.|  
|`\d{3}`|정확히 세 개의 숫자 문자를 찾습니다.|  
|`(-\d{3}){2}`|세 자리 숫자로, 하이픈과 찾아이 패턴의 두 일치 항목 일치 합니다.|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`$`|문자열의 끝 부분에서 일치 항목 찾기를 끝냅니다.|  
  
 호출는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 사용 하 여 메서드는 `options` 매개 변수 설정 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 다음 정규식을 정의 하는 것과 같습니다.  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 반면에 대 한 예제를 참조 하십시오.는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />은 유효한 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값이 아닙니다.  -또는-  <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큽니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다.</exception>
        <block subset="none" type="usage">
          <para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 매개 변수를 2 초 등의 적절 한 값입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다. 하지만 다음과 같은 경우에만 제한 시간을 비활성화 해야:-이 정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 또는 정적 텍스트로 구성 됩니다. 이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.  -정규식 패턴을 효율적으로 처리 하는 확인을 철저히 테스트 하는 경우 일치 하는 일치 하지 않는 하 고 가까운 일치 합니다.  -정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>입력 문자열에서 정규식 패턴과 일치하는 부분 문자열을 검색하고 맨 처음 발견되는 항목을 단일 <see cref="T:System.Text.RegularExpressions.Match" /> 개체로 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <summary>지정된 입력 문자열에서 <see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에 지정된 정규식의 처음 발견되는 항목을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다. 정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 일치 하는 항목이 있는 경우 해당 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 이 메서드가 반환에 첫 번째 하위 `input` 정규식 패턴과 일치 하는 합니다. 반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드. 호출 하 여 단일 메서드 호출에서 모든 일치 항목을 검색할 수도 있습니다는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식 패턴 일치 문자열에서 다음 일치 나열 그룹, 캡처 및 캡처 위치입니다.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 정규식 패턴 `(\w+)\s+(car)` 함께 앞에 오는 단어 "car" 라는 단어와 일치 합니다. 다음 표에 나와 있는 것 처럼 해석 됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`(\w+)`|하나 이상의 단어 문자를 찾습니다. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|`\s+`|하나 이상의 공백 문자를 찾습니다.|  
|(자동차)|리터럴 문자열 "car"와 일치 합니다. 이 그룹은 두 번째 캡처링 그룹입니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="startat">검색을 시작할 문자 위치(0부터 시작)입니다.</param>
        <summary>문자열의 지정된 시작 위치에서 시작하여 입력 문자열에서 처음 발견되는 정규식을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> 또는 후에 시작 하는 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 하는 메서드는 `startat` 문자 입력된 문자열에 위치 합니다. 정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정규식 패턴을는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> 메서드 검색 중 하나를 호출 하 여 정의 된는 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자입니다. 정규식 패턴을 만들 수 있는 요소에 대 한 자세한 내용은 참조 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 사용 하 여 필요에 따라 문자열의 시작 위치를 지정할 수는 `startat` 매개 변수입니다. 정규식 엔진은 왼쪽에서 오른쪽 (기본값) 구문 분석 하는 경우의 일치 및 검색은 이동, 패턴에 지정 된 문자에서 시작 `startat`합니다. 오른쪽에서 왼쪽으로 정규식 엔진은 구문 분석할 때 (사용 하 여 정규식 패턴은 생성 하는 경우는 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 옵션), 일치 및 검색 반대 방향으로 이동 하 고에서 문자로 시작 `startat` -1입니다. 시작 위치를 지정 하지 않으면 기본에서 검색이 시작 `startat` 위치입니다. 정규식이 왼쪽에서 오른쪽, 기본 검색 하는 경우 `startat` 위치가의 왼쪽된 끝에 있는 `input`오른쪽에서으로 검색 하는 경우, 왼쪽, 기본 `startat` 위치가의 오른쪽 끝에 있는 `input`합니다.  
  
 문자열에 특정 문자 위치에서 시작 하 고 정규식 엔진은 일치 하는 항목에 대 한 문자열의 나머지를 검색 하지 않게 되도록 일치 하는 항목을 제한 하려는 경우 고정 정규식과는 `\G` (왼쪽-오른쪽에는 왼쪽에 패턴 또는 오른쪽에서 왼쪽 패턴에 대 한 오른쪽에). 시작 해야 하므로이 일치 하는 경우 제한 `startat`합니다.  
  
 정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 일치 하는 항목이 있는 경우 해당 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 이 메서드가 반환 후에 발견 된 첫 번째 부분 문자열의 `startat` 에서 문자 위치 `input` 정규식 패턴과 일치 하는 합니다. 반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드. 호출 하 여 단일 메서드 호출에서 모든 일치 항목을 검색할 수도 있습니다는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대 한 제한 시간 값 설정 된 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <summary>지정된 입력 문자열에서 첫 번째 지정된 정규식을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다. 정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 지정 된 정규식 패턴으로 개체를 호출 하는 인스턴스 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 메서드. 이 경우 정규식 엔진이 정규식 패턴을 캐시합니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 일치 하는 항목이 있는 경우 해당 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 이 메서드가 반환에 첫 번째 하위 `input` 정규식 패턴과 일치 하는 합니다. 반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드. 호출 하 여 단일 메서드 호출에서 모든 일치 항목을 검색할 수도 있습니다는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> 하나 이상 포함 된 첫 번째 단어를 찾는 메서드 `z` 문자를 차례로 호출은 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드 추가 일치 항목을 찾을를 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 정규식 패턴 `\b\w*z+\w*\b`는 다음 테이블과 같이 해석됩니다.  
  
|패턴|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w*`|0 개 또는 하나 이상의 단어 문자가 일치 합니다.|  
|`z+`|하나 이상의 일치는 `z` 문자입니다.|  
|`\w*`|0 개 또는 하나 이상의 단어 문자가 일치 합니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다. 응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는 데 사용 됩니다. 패턴 일치를 검색 하기 위한 권장된 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="beginning">검색되는 가장 왼쪽 지점을 정의하는 입력 문자열의 0부터 시작하는 문자 위치입니다.</param>
        <param name="length">검색에 포함시킬 부분 문자열의 문자 수입니다.</param>
        <summary>지정된 시작 위치에서 시작하고 지정된 수의 문자만 검색하여 입력 문자열에서 첫 번째 정규식을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드 입력된 문자열의 일부에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다. 정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정규식 패턴을는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드 검색 중 하나를 호출 하 여 정의 된는 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자입니다. 정규식 패턴을 만들 수 있는 요소에 대 한 자세한 내용은 참조 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드 검색의 부분 `input` 정의한는 `beginning` 및 `length` 정규식 패턴에 대 한 매개 변수입니다. `beginning` 항상는 검색에 포함할 가장 왼쪽 문자의 인덱스를 정의 하 고 `length` 검색할 문자의 최대 수를 정의 합니다. 함께 검색의 범위를 정의합니다. 정규식 엔진은 검색 인덱스에 있는 문자가에서 검색이 왼쪽에서 오른쪽 (기본값) 계속 진행 하는 경우 `beginning` 인덱스에 있는 문자에 `beginning`  +  `length` – 1입니다. 사용 하 여 정규식 엔진은 인스턴스화할 경우는 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 옵션을 왼쪽으로 정규식 엔진 검색 인덱스에 있는 문자를 오른쪽에서 검색이 진행 됩니다 `beginning`  +  `length` – 1에 인덱스에 문자 `beginning`합니다. 이 메서드는이 범위 내에서 발견 된 첫 번째 일치 항목을 반환 합니다. 반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드.  
  
 정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 일치 하는 항목이 있는 경우 해당 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 제한 시간 값을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="beginning" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우  -또는-  <paramref name="length" />가 0보다 작거나 <paramref name="input" />의 길이보다 큽니다.  -또는-  <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="–1" />은 <paramref name="input" /> 범위를 벗어나는 위치를 식별합니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 일치 옵션을 사용하여 입력 문자열에서 첫 번째 지정된 정규식을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다. 정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 개체는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 생성자와 인스턴스 호출 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 메서드.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 일치 하는 항목이 있는 경우 해당 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 이 메서드가 반환에 첫 번째 하위 `input` 정규식 패턴과 일치 하는 합니다. 반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A> 메서드. 호출 하 여 단일 메서드 호출에서 모든 일치 항목을 검색할 수도 있습니다는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 문자로 시작 하는 단어와 일치 하는 정규식을 정의 하는 다음 예제에서는 "a"입니다. 사용 하 여는 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 정규식 "a"와 소문자 대문자는로 시작 단어 둔다는 하려면 옵션을 "a"입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 정규식 패턴 `\ba\w*\b`는 다음 테이블과 같이 해석됩니다.  
  
|패턴|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`a`|문자 "a"입니다.|  
|`\w*`|0 개 또는 하나 이상의 단어 문자가 일치 합니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다. 응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는 데 사용 됩니다. 패턴 일치를 검색 하기 위한 권장된 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 일치 옵션 및 제한 시간 간격을 사용하여 입력 문자열에서 첫 번째 지정된 정규식을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다. 정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 개체는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 생성자와 인스턴스 호출 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 메서드.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 일치 하는 항목이 있는 경우 해당 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 이 메서드가 반환에 첫 번째 하위 `input` 정규식 패턴과 일치 하는 합니다. 반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A> 메서드. 호출 하 여 단일 메서드 호출에서 모든 일치 항목을 검색할 수도 있습니다는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드.  
  
 `matchTimeout` 매개 변수 지정 긴 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리 하는 경우 응답을 중지 하 게 표시 되지 않도록 과도 한 역 추적을 사용 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 들어 있는입니다. 자세한 내용은 참조 [정규식에 대 한 유용한](~/docs/standard/base-types/best-practices.md) 및 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 일치 항목이 없으면 해당 시간 간격에서 발견 되 면 경우에 메서드에서 throw 된 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 메서드가 실행 되는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우  -또는-  <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큽니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 매개 변수를 2 초 등의 적절 한 값입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다. 하지만 다음과 같은 경우에만 제한 시간을 비활성화 해야:-이 정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 또는 정적 텍스트로 구성 됩니다. 이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.  -정규식 패턴을 효율적으로 처리 하는 확인을 철저히 테스트 하는 경우 일치 하는 일치 하지 않는 하 고 가까운 일치 합니다.  -정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>입력 문자열에 있는 정규식을 모두 검색하고 일치 항목을 모두 반환합니다.</summary>
        <block subset="none" type="usage">
          <para>일치 시도 호출 하 여 반복 되는 경우는 <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> 메서드, 정규식 엔진이 제공 빈 일치 항목 특별 하 게 처리 합니다. 일반적으로 정규식 엔진은 정확 하 게 이전 일치 항목 종료 한 위치에 관계 없이 다음 일치 항목에 대 한 검색을 시작 합니다. 그러나 빈 일치, 정규식 엔진은 일치 하는 다음을 시도 하기 전에 한 글자씩 이동 합니다. 이러한 동작은 보장 정규식 엔진이 문자열을 통해 진행 됩니다. 그렇지 않으면 빈 일치 하는 모든 앞으로 이동 되지 않습니다, 때문에 다음 일치 항목 정확히 이전 일치 항목으로 같은 위치에서 시작 및 찾게 동일한 빈 문자열입니다.  다음 예제에서는 정규식 패턴에서에서 <c>는 *</c> 문자의 0 개 이상의 항목을 검색 "abaabb" 문자열에 "a"입니다. 결과 예제에서 출력으로 <see cref="T:System.Text.RegularExpressions.MatchCollection" /> 개체에 포함 되어 6 <see cref="T:System.Text.RegularExpressions.Match" /> 개체입니다. 첫 번째 일치 시도가 찾은 첫 번째 "a"입니다. 정확 하 게 첫 번째 검사가 첫 번째 b; 앞에 끝에서 두 번째 검사를 시작 "a"의 0 항목을 찾아서 빈 문자열을 반환 합니다. 빈 문자열을 반환 하기 때문에 세 번째 일치는 정확 하 게 두 번째 일치 항목 찾기가 종료 된 위치, 시작 되지 않습니다. 대신, 첫 번째 "b" 후 나중에, 한 문자를 시작합니다. 세 번째 일치 하는 "a"의 두 일치 항목을 찾아 "aa"를 반환 합니다. 네 번째 일치 시도가 다음에 세 번째 검사에서 나옵니다, 앞의 두 번째 "b", 빈 문자열을 반환 합니다. 다섯 번째 일치 시도가 다시 진행 한 문자 "b" 세 번째 하기 전에 시작 하 고 빈 문자열을 반환 합니다. 여섯 번째 일치 하는 마지막 "b" 다음에 시작 하 고 빈 문자열을 다시 반환 합니다.  [! code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <summary>지정된 입력 문자열에 있는 정규식을 모두 검색합니다.</summary>
        <returns>검색에서 찾은 <see cref="T:System.Text.RegularExpressions.Match" /> 개체의 컬렉션입니다. 일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> 메서드는 비슷합니다는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 단일 일치 항목 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다. 다음 코드를 하는 것이 같습니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 컬렉션 일치만을 포함 하 고 첫 번째 비-일치에 종료 합니다.  
  
 정규식 패턴을는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> 메서드 검색 중 하나를 호출 하 여 정의 된는 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자입니다. 정규식 패턴을 만들 수 있는 요소에 대 한 자세한 내용은 참조 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드 지연 평가 사용 하 여 반환 된 채우는 <xref:System.Text.RegularExpressions.MatchCollection> 개체입니다. 이 컬렉션의 멤버와 같은 액세스 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 경우 컬렉션을 즉시 채워야 합니다. 지연 계산을 이용 하려면와 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 `foreach` C# 및 `For Each`...`Next` Visual Basic  
  
 해당 지연 계산 때문에 호출 된 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> 메서드 throw 하지 않습니다는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 그러나에서 작업이 수행 될 때 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.MatchCollection> 경우이 메서드에서 반환 된 개체는 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> 속성은 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> 하는 작업이 시간 제한 간격을 초과 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> "es"로 끝나는 문장에서 단어를 식별 하는 메서드.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 정규식 패턴 `\b\w+es\b`는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w+`|하나 이상의 단어 문자를 찾습니다.|  
|`es`|리터럴 문자열 "es"와 일치 합니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="startat">입력 문자열에서 검색을 시작할 문자 위치입니다.</param>
        <summary>문자열의 지정된 시작 위치에서 시작하여 지정된 입력 문자열에 있는 정규식을 모두 검색합니다.</summary>
        <returns>검색에서 찾은 <see cref="T:System.Text.RegularExpressions.Match" /> 개체의 컬렉션입니다. 일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> 메서드는 비슷합니다는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> 단일 일치 항목 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다. 다음 코드를 하는 것이 같습니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 정규식 패턴을는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> 메서드 검색 중 하나를 호출 하 여 정의 된는 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자입니다. 정규식 패턴을 만들 수 있는 요소에 대 한 자세한 내용은 참조 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드 지연 평가 사용 하 여 반환 된 채우는 <xref:System.Text.RegularExpressions.MatchCollection> 개체입니다. 이 컬렉션의 멤버와 같은 액세스 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 경우 컬렉션을 즉시 채워야 합니다. 지연 계산을 이용 하려면와 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 `foreach` C# 및 `For Each`...`Next` Visual Basic  
  
 해당 지연 계산 때문에 호출 된 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> 메서드 throw 하지 않습니다는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 그러나 작업에서 수행 될 때 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.MatchCollection> 경우이 메서드에서 반환 된 개체는 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> 속성은 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> 하는 작업이 제한 시간 간격을 초과 하 고...  
  
   
  
## Examples  
 사용 하 여 다음 예제는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 메서드를 "es"을 찾아 다음 호출 문장의 첫 번째 단어는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> "es"로 끝나는 다른 단어를 식별 하는 메서드.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 정규식 패턴 `\b\w+es\b`는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w+`|하나 이상의 단어 문자를 찾습니다.|  
|`es`|리터럴 문자열 "es"와 일치 합니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식을 모두 검색합니다.</summary>
        <returns>검색에서 찾은 <see cref="T:System.Text.RegularExpressions.Match" /> 개체의 컬렉션입니다. 일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> 메서드는 비슷합니다는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> 단일 일치 항목 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다. 다음 코드를 하는 것이 같습니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 정적 `Matches` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 `Matches`합니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드 지연 평가 사용 하 여 반환 된 채우는 <xref:System.Text.RegularExpressions.MatchCollection> 개체입니다. 이 컬렉션의 멤버와 같은 액세스 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 경우 컬렉션을 즉시 채워야 합니다. 지연 계산을 이용 하려면와 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 `foreach` C# 및 `For Each`...`Next` Visual Basic  
  
 해당 지연 계산 때문에 호출 된 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> 메서드 throw 하지 않습니다는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 그러나 작업에서 수행 될 때 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.MatchCollection> 시간 제한 간격을 현재 응용 프로그램 도메인 및 일치 작업의 "REGEX_DEFAULT_MATCH_TIMEOUT" 속성에 의해 정의 된 경우이 메서드에서 반환 된 개체 이 시간 제한 간격을 초과합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> 메서드 "es"로 끝나는 문장에서 모든 단어를 식별 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 정규식 패턴 `\b\w+es\b`는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w+`|하나 이상의 단어 문자를 찾습니다.|  
|`es`|리터럴 문자열 "es"와 일치 합니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다. 응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는 데 사용 됩니다. 권장 되는 정적 방법 일치 여러 패턴을 검색 하는 <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 지정할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 지정하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 일치 옵션을 사용하여 지정된 입력 문자열에서 지정된 정규식을 모두 검색합니다.</summary>
        <returns>검색에서 찾은 <see cref="T:System.Text.RegularExpressions.Match" /> 개체의 컬렉션입니다. 일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드는 비슷합니다는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 단일 일치 항목 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다. 다음 코드를 하는 것이 같습니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 정적 `Matches` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 `Matches`합니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드 지연 평가 사용 하 여 반환 된 채우는 <xref:System.Text.RegularExpressions.MatchCollection> 개체입니다. 이 컬렉션의 멤버와 같은 액세스 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 경우 컬렉션을 즉시 채워야 합니다. 지연 계산을 이용 하려면와 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 `foreach` C# 및 `For Each`...`Next` Visual Basic  
  
 해당 지연 계산 때문에 호출 된 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> 메서드 throw 하지 않습니다는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 그러나 작업에서 수행 될 때 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.MatchCollection> 시간 제한 간격을 현재 응용 프로그램 도메인 및 일치 작업의 "REGEX_DEFAULT_MATCH_TIMEOUT" 속성에 의해 정의 된 경우이 메서드에서 반환 된 개체 이 시간 제한 간격을 초과합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> 문장의 "es"로 끝나고 다음 호출 하는 모든 단어를 식별 하는 메서드는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드는 입력 문자열 패턴의 대/소문자 구분 비교를 수행 합니다. 출력에서 볼 수 있듯이 두 메서드는 다른 결과 반환 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 정규식 패턴 `\b\w+es\b`는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w+`|하나 이상의 단어 문자를 찾습니다.|  
|`es`|리터럴 문자열 "es"와 일치 합니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우</exception>
        <block subset="none" type="usage">
          <para>이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다. 응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는 데 사용 됩니다. 권장 되는 정적 방법 일치 여러 패턴을 검색 하는 <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 지정하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 일치 옵션 및 제한 시간 간격을 사용하여 지정된 입력 문자열에서 지정된 정규식을 모두 검색합니다.</summary>
        <returns>검색에서 찾은 <see cref="T:System.Text.RegularExpressions.Match" /> 개체의 컬렉션입니다. 일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 메서드는 비슷합니다는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 단일 일치 항목 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다. 다음 코드를 하는 것이 같습니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 정적 `Matches` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 `Matches`합니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드 지연 평가 사용 하 여 반환 된 채우는 <xref:System.Text.RegularExpressions.MatchCollection> 개체입니다. 이 컬렉션의 멤버와 같은 액세스 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 경우 컬렉션을 즉시 채워야 합니다. 지연 계산을 이용 하려면와 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 `foreach` C# 및 `For Each`...`Next` Visual Basic  
  
 해당 지연 계산 때문에 호출 된 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드 throw 하지 않습니다는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 그러나 작업에서 수행 될 때 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.MatchCollection> 일치 작업에서 지정 된이 시간 제한 간격을 초과 하는 경우이 메서드에서 반환 된 개체는`matchTimeout` 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 메서드 "es"로 끝나는 문장의 모든 단어가 일치 하는 대/소문자 구분 비교를 수행 합니다. 그런 다음 호출 하는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 메서드는 입력 문자열 패턴의 대/소문자 구분 비교를 수행 합니다. 두 경우 모두, 시간 제한 간격을 1 초로 설정 됩니다. 출력에서 볼 수 있듯이 두 메서드는 다른 결과 반환 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 정규식 패턴 `\b\w+es\b`는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w+`|하나 이상의 단어 문자를 찾습니다.|  
|`es`|리터럴 문자열 "es"와 일치 합니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우  -또는-  <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 매개 변수를 2 초 등의 적절 한 값입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다. 하지만 다음과 같은 경우에만 제한 시간을 비활성화 해야:-이 정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 또는 정적 텍스트로 구성 됩니다. 이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.  -정규식 패턴을 효율적으로 처리 하는 확인을 철저히 테스트 하는 경우 일치 하는 일치 하지 않는 하 고 가까운 일치 합니다.  -정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 인스턴스의 시간 제한 간격을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" />이 throw되기 전에 패턴 일치 작업에서 경과할 수 있는 최대 시간 간격이며, 제한 시간이 비활성화된 경우는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> 속성 정의 대 한 대략적인 최대 시간 간격을 <xref:System.Text.RegularExpressions.Regex> 작업 시간이 초과 하기 전에 단일 일치 작업을 실행 하는 인스턴스. 정규식 엔진은 throw 한 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 시간 제한 간격이 경과한 후 다음 타이밍 검사 중 발생 한 예외입니다. 따라서 정규식 엔진을에서 과도 한 역 추적 필요로 하는 입력된 문자열을 처리할 수 없습니다. 자세한 내용은 참조 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md) 및 [정규식에 대 한 유용한](~/docs/standard/base-types/best-practices.md)합니다.  
  
 이 속성은 읽기 전용입니다. 개인에 대 한 해당 값을 명시적으로 설정할 수 있습니다 <xref:System.Text.RegularExpressions.Regex> 호출 하 여 개체는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자; 하 고 모든 값을 설정 하려면 <xref:System.Text.RegularExpressions.Regex> 호출 하 여 일치 하는 응용 프로그램 도메인에서 작업의 <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> 메서드 제공 하는 <xref:System.TimeSpan> 다음 예제와 같이 "REGEX_DEFAULT_MATCH_TIMEOUT" 속성에 대 한 값입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 시간 제한 간격, 기본값을 명시적으로 설정 하지 않으면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> 사용 되는, 및 일치 하는 작업은 시간이 제한 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에 전달된 옵션을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 생성자에게 전달된 옵션을 나타내는 하나 이상의 <see cref="T:System.Text.RegularExpressions.Regex" /> 열거형 멤버입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값은 <xref:System.Text.RegularExpressions.Regex.Options%2A> 속성의 하나 이상의 멤버로 구성 된 <xref:System.Text.RegularExpressions.RegexOptions> 열거형. 에 정의 된 옵션 없이 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자의 값이 <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>합니다. 사용할 수 있는 옵션에 대 한 자세한 설명은 [정규식 옵션](~/docs/standard/base-types/regular-expression-options.md) 항목입니다.  
  
 <xref:System.Text.RegularExpressions.Regex.Options%2A> 속성 자체 패턴을 정규식에서 정의 된 인라인 옵션을 반영 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 만든 정규식의 기본 클래스는 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드. 이러한 컴파일된 정규식의 기본 클래스 구현을 사용 하 여는 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 속성입니다. 파생된 클래스에서 호출 된 경우는 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 속성에 전달 된 옵션을 반환 된 <paramref name="options" /> 의 매개 변수는 <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> 정규식 정의에 사용 된 클래스 생성자입니다.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 입력 문자열에서 정규식 패턴과 일치하는 문자열을 지정된 대체 문자열로 바꿉니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <summary>지정된 입력 문자열에서 정규식 패턴과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일치 하는 항목에 대 한 검색의 시작 부분에서 시작 된 `input` 문자열입니다. 정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <xref:System.Text.RegularExpressions.Regex> 개체입니다.  
  
 `replacement` 매개 변수에서 각 일치 되는 문자열을 지정 `input`합니다. `replacement` 리터럴 텍스트의 조합을 포함할 수 있습니다 및 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 `test` 다음 있는 경우 캡처 그룹, "b" 문자열입니다. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 다른 모든 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 발생 하지 않습니다  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 정의 `\s+`, 하나 이상의 공백 문자를 일치 하는 합니다. 대체 문자열 "", 공백 문자 하나로 바뀝니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 다음 예제에서는 정규식을 정의 `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`, 및 바꾸기 패턴에서 `$2`, 숫자 값에서 선행 또는 후행 통화 기호를 제거 하 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 정규식은 다음 표와 같이 해석됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\p{Sc}`|통화 기호를 찾습니다. `{Sc}` 유니코드 기호와 통화 범주의 구성원 인 모든 문자를 나타냅니다.|  
|`\s?`|0번 이상 나오는 공백 문자를 찾습니다.|  
|`(\p{Sc}\s?)?`|통화 기호 뒤에 0 번 이상 나오는 공백 문자 조합 없거나 1 개 발생을 찾습니다. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|`\d+`|하나 이상의 10진수 숫자가 일치하는지 확인합니다.|  
|`\.?`|마침표 (소수 구분 기호 문자도 사용 됨)의 0 번 이상 발생을 찾습니다.|  
|`((?<=\.)\d+)?`|마침표 이전 문자 이면 하나 이상의 10 진수 숫자가 일치 합니다. 이 패턴에는 0 개 또는 1 번 일치할 수 있습니다.|  
|`(\d+\.?((?<=\.)\d+)?)`|하나 이상의 10 진수 선택적 마침표와 추가 10 진수가 패턴과 일치 합니다. 이 그룹은 두 번째 캡처링 그룹입니다. 에 대 한 호출에서 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> 메서드가 캡처된 그룹의 값과 일치 하는 전체를 바꿉니다.|  
|`(?(1)&#124;\s?\p{Sc})?`|첫 번째 캡처된 그룹이 있는 경우에 빈 문자열과 일치 합니다. 그렇지 않으면 다음 통화 기호는 공백 문자 0 회 이상 일치 합니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="replacement" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="evaluator">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나에 해당 하는 경우 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열은 정규식 대체 패턴에서 쉽게 지정할 수 없습니다.  
  
-   대체 문자열 일부 처리 작업에 일치 하는 문자열에서에서 발생 합니다.  
  
-   대체 문자열 조건부 처리의 결과입니다.  
  
 호출 하는 메서드는는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> 메서드와 각각 전달 <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션에는 `evaluator` 위임 합니다.  
  
 정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <xref:System.Text.RegularExpressions.Regex> 개체입니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다. 사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 발생 하지 않습니다  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 원래 문자열을 표시 하 고 원래 문자열의 각 단어와 일치, 변환 된 문자열을 표시 한 다음 대문자로 각 일치 항목의 첫 번째 문자를 변환 합니다.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="evaluator" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <param name="count">대체하는 최대 횟수입니다.</param>
        <summary>지정된 입력 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 지정된 대체 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일치 하는 항목에 대 한 검색의 시작 부분에서 시작 된 `input` 문자열입니다. 정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <xref:System.Text.RegularExpressions.Regex> 개체입니다. 경우 `count` 가 음수 이면 문자열의 끝까지 바꾸기가 계속 합니다. 경우 `count` 일치 항목 개수를 초과 하면, 일치 하는 모든 대체 됩니다.  
  
 `replacement` 는를 첫 번째 바꿀 문자열을 지정 하는 매개 변수 `count` 에 일치 `input`합니다. `replacement` 리터럴 텍스트의 조합을 포함할 수 있습니다 및 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 `test` 다음 있는 경우 캡처 그룹, "b" 문자열입니다. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 다른 모든 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 발생 하지 않습니다  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 단일 문자 중복 문자의 처음 5 개 항목을 바꿉니다. 정규식 패턴 `(\w)\1` 연속 발견 되는 단일 문자 맨 처음 발견 되는 첫 번째 캡처링 그룹에 할당 합니다. 바꾸기 패턴 `$1` 처음 캡처한 그룹으로 일치 하는 전체를 바꿉니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="replacement" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정적 `Replace` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 `Replace`합니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다. 일치 하는 항목에 대 한 검색의 시작 부분에서 시작 된 `input` 문자열입니다.  
  
 `replacement` 매개 변수에서 각 일치 되는 문자열을 지정 `input`합니다. `replacement` 리터럴 텍스트의 조합을 포함할 수 있습니다 및 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 `test` 다음 있는 경우 캡처 그룹, "b" 문자열입니다. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 다른 모든 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 정의 `\s+`, 하나 이상의 공백 문자를 일치 하는 합니다. 대체 문자열 "", 공백 문자 하나로 바뀝니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> 메서드를 로컬 파일 경로 UNC 경로 로컬 컴퓨터 및 드라이브 이름을 바꿉니다. 정규식 사용 하 여는 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 로컬 컴퓨터의 이름을 포함 하는 속성 및 <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> 메서드 논리 드라이브의 이름을 포함 하도록 합니다. 이 예제를 성공적으로 실행 하려면 로컬 컴퓨터 이름을 가진 리터럴 문자열 "MyMachine" 바꿔야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 정규식 패턴은 다음 식으로 정의 됩니다.  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|패턴|설명|  
|-------------|-----------------|  
|`\\\\`|두 명의 일치 항목이 연속 된 백슬래시 (`\`) 문자. 백슬래시 문자는 이스케이프 문자로 해석 되며, 때문에 각 백슬래시는 두 개의 백슬래시를 이스케이프 해야 합니다.|  
|`(?i:" + Environment.MachineName + ")`|반환 되는 문자열의 소문자를 구분는 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 속성입니다.|  
|`(?:\.\w+)*`|일치는 기간 (`.`) 하나 이상의 단어 문자 다음에 오는 문자입니다. 이 일치 항목 0 개 이상 발생할 수 있습니다. 일치 하는 하위 식이 캡처되지 않습니다.|  
|`\\`|백슬래시 일치 (`\`) 문자.|  
|`((?i:[" + driveNames + "]))`|개별 드라이브 문자로 구성 된 문자 클래스는 대/소문자 구분 일치를 수행 합니다. 이 항목은 처음 캡처된 하위 식입니다.|  
|`\$`|일치 리터럴 달러 기호 (`$`) 문자.|  
  
 바꾸기 패턴 `$1` 처음 캡처된 하위 식에 일치 하는 전체를 바꿉니다. 즉, 드라이브 문자를 가진 UNC 드라이브 및 컴퓨터 이름을 대체합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="replacement" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다. 응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는 데 사용 됩니다. 패턴 일치를 교체 하도록 권장된 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="evaluator">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나에 해당 하는 경우 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열은 정규식 대체 패턴에서 쉽게 지정할 수 없습니다.  
  
-   대체 문자열 일부 처리 작업에 일치 하는 문자열에서에서 발생 합니다.  
  
-   대체 문자열 조건부 처리의 결과입니다.  
  
 호출 하는 메서드는는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> 메서드와 각각 전달 <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션에는 `evaluator` 위임 합니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다. 사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 사용 하 여 문자열에서 개별 단어를 추출 하 고 다음 사용 하 여는 <xref:System.Text.RegularExpressions.MatchEvaluator> 라는 메서드를 호출 하는 대리자 `WordScramble` 단어의 개별 문자를 스크램블입니다. 이 작업을 수행 하는 `WordScramble` 메서드는 일치에 문자를 포함 하는 배열을 만듭니다. 또한 임의의 부동 소수점 숫자를 채우는 한 병렬 배열을 만듭니다. 호출 하 여 배열 정렬 되는 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 메서드와 정렬 된 배열에 대 한 인수로 제공 됩니다는 <xref:System.String> 클래스 생성자입니다. 새로 만든된이 문자열은 다음 반환 된 `WordScramble` 메서드. 정규식 패턴 `\w+` ; 하나 이상의 단어 문자 일치 정규식 엔진은 계속 공백 문자 같은 한 단어가 아닌 문자에 도달할 때까지 문자 일치 항목으로 추가 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="evaluator" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다. 응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는 데 사용 됩니다. 평가 및 패턴 일치를 대체 하기 위한 권장된 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="evaluator">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <param name="count">바꾸기를 하는 최대 횟수입니다.</param>
        <summary>지정된 입력 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나에 해당 하는 경우 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열은 정규식 대체 패턴에서 쉽게 지정할 수 없습니다.  
  
-   대체 문자열 일부 처리 작업에 일치 하는 문자열에서에서 발생 합니다.  
  
-   대체 문자열 조건부 처리의 결과입니다.  
  
 호출 하는 메서드는는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> 메서드와 첫 번째 전달 `count` <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션에는 `evaluator` 위임 합니다.  
  
 정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <xref:System.Text.RegularExpressions.Regex> 개체입니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다. 사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 발생 하지 않습니다  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예에서는 의도적으로 잘못 입력 하는 목록에 있는 단어의 절반에 정규식을 사용 합니다. 정규식을 사용 하 여 `\w*(ie|ei)\w*` "ie" 또는 "ei" 문자를 포함 하는 단어를 찾습니다. 절반에 일치 하는 단어의 첫 번째 전달에서 `ReverseLetter` 메서드를 사용 하는 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> "i"와 일치 하는 문자열의 "e" 되돌리려면 메서드. 나머지 단어 그대로 유지 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 `\w*(ie|ei)\w*` 정규식은 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\w*`|0개 이상의 단어 문자를 찾습니다.|  
|`(ie&#124;ei)`|"Ie" 또는 "ei"와 일치 합니다.|  
|`\w*`|0개 이상의 단어 문자를 찾습니다.|  
  
 정규식 패턴 `([ie])([ie])` 에 `ReverseLetter` 메서드 이중 "ie" 또는 "ei"의 첫 번째 "i" 또는 "e"와 일치 하 고 첫 번째 캡처링 그룹에는 문자를 지정 합니다. 두 번째 "i" 또는 "e"와 일치 하 고 두 번째 캡처링 그룹에는 문자를 지정 합니다. 두 개의 문자를 호출 하 여 다음 반대가 됩니다는 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> 바꾸기 패턴을 사용 하 여 메서드 `$2$1`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="evaluator" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <param name="count">바꾸기를 하는 최대 횟수입니다.</param>
        <param name="startat">입력 문자열에서 검색을 시작할 문자 위치입니다.</param>
        <summary>지정된 입력 부분 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 지정된 대체 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일치 하는 항목 검색 시작는 `input` 문자열에 지정 된 위치에서는 `startat` 매개 변수입니다. 정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <xref:System.Text.RegularExpressions.Regex> 개체입니다. 경우 `count` 가 음수 이면 문자열의 끝까지 바꾸기가 계속 합니다. 경우 `count` 일치 항목 개수를 초과 하면, 일치 하는 모든 대체 됩니다.  
  
 `replacement` 매개 변수에서 각 일치 되는 문자열을 지정 `input`합니다. `replacement` 리터럴 텍스트의 조합을 포함할 수 있습니다 및 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 `test` 다음 있는 경우 캡처 그룹, "b" 문자열입니다. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 다른 모든 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 발생 하지 않습니다  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열의 첫 번째 줄을 제외한 모든 double-spaces 합니다. 정규식 패턴을 정의 `^.*$`, 텍스트, 호출의 줄에 일치 하는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 메서드를 사용 하 고 문자열의 첫 번째 줄과 일치는 `Match.Index` 및 `Match.Count` 두 번째의 시작 위치를 결정 하는 속성 선입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 정규식 패턴 `^.*$`는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`^`|줄의 시작을 찾습니다. (사항에 유의 <xref:System.Text.RegularExpressions.Regex> 개체가 사용 하 여 인스턴스화는 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 옵션;이 문자 클래스는 입력된 문자열의 시작 부분 것만 일치 하는 그렇지 않은 경우.)|  
|`.*`|임의의 문자 0 회 이상 일치 합니다.|  
|`$`|줄의 끝 부분을 찾습니다. (사항에 유의 <xref:System.Text.RegularExpressions.Regex> 개체가 사용 하 여 인스턴스화는 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 옵션;이 문자 클래스는 입력된 문자열의 시작 부분 것만 일치 하는 그렇지 않은 경우.)|  
  
 대체 문자열 (`vbCrLf + "$&"` Visual Basic의 `"\n$&"` C#) 일치 하는 문자열 앞에 새 줄을 추가 합니다. `\n` C# 예제로 해석 됩니다는 줄 바꿈 문자는 C# 컴파일러에 의해; 정규식 문자 이스케이프를 나타내지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="replacement" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다. 지정한 옵션에 따라 일치 작업이 수정됩니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정적 `Replace` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 `Replace`합니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다. 지정 하는 경우 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 에 대 한는 `options` 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽 이동, 그렇지 않으면 검색 입력된 문자열의 시작 부분에서 시작 하 고 오른쪽으로 이동 합니다.  
  
 `replacement` 매개 변수에서 각 일치 되는 문자열을 지정 `input`합니다. `replacement` 리터럴 텍스트의 조합을 포함할 수 있습니다 및 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 `test` 다음 있는 경우 캡처 그룹, "b" 문자열입니다. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 다른 모든 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드를 로컬 파일 경로 UNC 경로 로컬 컴퓨터 및 드라이브 이름을 바꿉니다. 정규식 사용 하 여는 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 로컬 컴퓨터의 이름을 포함 하는 속성 및 <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> 메서드 논리 드라이브의 이름을 포함 하도록 합니다. 모든 정규식 문자열 비교 대/소문자를 구분 하지 않습니다. 이 예제를 성공적으로 실행 하려면 로컬 컴퓨터 이름을 가진 리터럴 문자열 "MyMachine" 바꿔야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 정규식 패턴은 다음 식으로 정의 됩니다.  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|패턴|설명|  
|-------------|-----------------|  
|`\\\\`|두 명의 일치 항목이 연속 된 백슬래시 (`\`) 문자. 백슬래시 문자는 이스케이프 문자로 해석 되며, 때문에 각 백슬래시는 두 개의 백슬래시를 이스케이프 해야 합니다.|  
|`+ Environment.MachineName +`|반환 되는 문자열과 일치는 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 속성입니다.|  
|`(?:\.\w+)*`|일치는 기간 (`.`) 하나 이상의 단어 문자 다음에 오는 문자입니다. 이 일치 항목 0 개 이상 발생할 수 있습니다. 일치 하는 하위 식이 캡처되지 않습니다.|  
|`\\`|백슬래시 일치 (`\`) 문자.|  
|`([" + driveNames + "])`|개별 드라이브 문자 구성 된 문자 클래스와 일치 합니다. 이 항목은 처음 캡처된 하위 식입니다.|  
|`\$`|일치 리터럴 달러 기호 (`$`) 문자.|  
  
 바꾸기 패턴 `$1` 처음 캡처된 하위 식에 일치 하는 전체를 바꿉니다. 즉, 드라이브 문자를 가진 UNC 드라이브 및 컴퓨터 이름을 대체합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="replacement" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다. 응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는 데 사용 됩니다. 패턴 일치를 교체 하도록 권장된 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="evaluator">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다. 지정한 옵션에 따라 일치 작업이 수정됩니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나에 해당 되는 경우에 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열은 정규식 대체 패턴에서 쉽게 지정할 수 없습니다.  
  
-   대체 문자열 일부 처리 작업에 일치 하는 문자열에서에서 발생 합니다.  
  
-   대체 문자열 조건부 처리의 결과입니다.  
  
 호출 하는 메서드는는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드와 각각 전달 <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션에는 `evaluator` 위임 합니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다. 사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 지정 하는 경우 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 에 대 한는 `options` 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽 이동, 그렇지 않으면 검색 입력된 문자열의 시작 부분에서 시작 하 고 오른쪽으로 이동 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 사용 하 여 문자열에서 개별 단어를 추출 하 고 다음 사용 하 여는 <xref:System.Text.RegularExpressions.MatchEvaluator> 라는 메서드를 호출 하는 대리자 `WordScramble` 단어의 개별 문자를 스크램블입니다. 이 작업을 수행 하는 `WordScramble` 메서드는 일치에 문자를 포함 하는 배열을 만듭니다. 또한 임의의 부동 소수점 숫자를 채우는 한 병렬 배열을 만듭니다. 호출 하 여 배열 정렬 되는 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 메서드와 정렬 된 배열에 대 한 인수로 제공 됩니다는 <xref:System.String> 클래스 생성자입니다. 새로 만든된이 문자열은 다음 반환 된 `WordScramble` 메서드. 정규식 패턴 `\w+` ; 하나 이상의 단어 문자 일치 정규식 엔진은 계속 공백 문자 같은 한 단어가 아닌 문자에 도달할 때까지 문자 일치 항목으로 추가 됩니다. 에 대 한 호출에서 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드를 포함는 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 옵션 있도록 정규식 패턴에서 주석을 `\w+  # Matches all the characters in a word.` 정규식 엔진에 의해 무시 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="evaluator" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="evaluator">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <param name="count">바꾸기를 하는 최대 횟수입니다.</param>
        <param name="startat">입력 문자열에서 검색을 시작할 문자 위치입니다.</param>
        <summary>지정된 입력 부분 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나에 해당 하는 경우 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열은 정규식 대체 패턴에서 쉽게 지정할 수 없습니다.  
  
-   대체 문자열 일부 처리 작업에 일치 하는 문자열에서에서 발생 합니다.  
  
-   대체 문자열 조건부 처리의 결과입니다.  
  
 호출 하는 메서드는는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> 메서드와 첫 번째 전달 `count` <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션에는 `evaluator` 위임 합니다.  
  
 정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <xref:System.Text.RegularExpressions.Regex> 개체입니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다. 사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 발생 하지 않습니다  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="evaluator" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다. 추가 매개 변수는 일치하는 항목이 없는 경우 제한 시간 간격과 일치 작업을 수정하는 옵션을 지정합니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정적 `Replace` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 `Replace`합니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다. 지정 하는 경우 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 에 대 한는 `options` 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽 이동, 그렇지 않으면 검색 입력된 문자열의 시작 부분에서 시작 하 고 오른쪽으로 이동 합니다.  
  
 `replacement` 매개 변수에서 각 일치 되는 문자열을 지정 `input`합니다. `replacement` 리터럴 텍스트의 조합을 포함할 수 있습니다 및 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 `test` 다음 있는 경우 캡처 그룹, "b" 문자열입니다. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 다른 모든 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 `matchTimeout` 매개 변수 지정 긴 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리 하는 경우 응답을 중지 하 게 표시 되지 않도록 과도 한 역 추적을 사용 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 들어 있는입니다. 자세한 내용은 참조 [정규식에 대 한 유용한](~/docs/standard/base-types/best-practices.md) 및 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 일치 항목이 없으면 해당 시간 간격에서 발견 되 면 경우에 메서드에서 throw 된 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 메서드가 실행 되는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 메서드를 로컬 파일 경로 UNC 경로 로컬 컴퓨터 및 드라이브 이름을 바꿉니다. 정규식 사용 하 여는 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 로컬 컴퓨터의 이름을 포함 하는 속성 및 <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> 메서드 논리 드라이브의 이름을 포함 하도록 합니다. 모든 정규식 문자열 비교는 대/소문자를 구분 하 고 일치 하는 0.5 초에서 찾을 수 없는 경우 모든 단일 바꾸기 작업 시간이 초과 합니다. 이 예제를 성공적으로 실행 하려면 로컬 컴퓨터 이름을 가진 리터럴 문자열 "MyMachine" 바꿔야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 정규식 패턴은 다음 식으로 정의 됩니다.  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|패턴|설명|  
|-------------|-----------------|  
|`\\\\`|두 명의 일치 항목이 연속 된 백슬래시 (`\`) 문자. 백슬래시 문자는 이스케이프 문자로 해석 되며, 때문에 각 백슬래시는 두 개의 백슬래시를 이스케이프 해야 합니다.|  
|`+ Environment.MachineName +`|반환 되는 문자열과 일치는 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 속성입니다.|  
|`(?:\.\w+)*`|일치는 기간 (`.`) 하나 이상의 단어 문자 다음에 오는 문자입니다. 이 일치 항목 0 개 이상 발생할 수 있습니다. 일치 하는 하위 식이 캡처되지 않습니다.|  
|`\\`|백슬래시 일치 (`\`) 문자.|  
|`([" + driveNames + "])`|개별 드라이브 문자 구성 된 문자 클래스와 일치 합니다. 이 항목은 처음 캡처된 하위 식입니다.|  
|`\$`|일치 리터럴 달러 기호 (`$`) 문자.|  
  
 바꾸기 패턴 `$1` 처음 캡처된 하위 식에 일치 하는 전체를 바꿉니다. 즉, 드라이브 문자를 가진 UNC 드라이브 및 컴퓨터 이름을 대체합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="replacement" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우  -또는-  <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큽니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 매개 변수를 2 초 등의 적절 한 값입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다. 하지만 다음과 같은 경우에만 제한 시간을 비활성화 해야:-이 정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 또는 정적 텍스트로 구성 됩니다. 이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.  -정규식 패턴을 효율적으로 처리 하는 확인을 철저히 테스트 하는 경우 일치 하는 일치 하지 않는 하 고 가까운 일치 합니다.  -정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="evaluator">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 부분 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다. 추가 매개 변수는 일치하는 항목이 없는 경우 제한 시간 간격과 일치 작업을 수정하는 옵션을 지정합니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나에 해당 하는 경우 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열에 정규식 대체 패턴에서 쉽게 지정할 수 없는 경우.  
  
-   대체 문자열에서 발생 하는 경우 일부 처리 일치 하는 문자열에서 수행 합니다.  
  
-   대체 문자열 조건부 처리에서 발생 하는 경우.  
  
 호출 하는 메서드는는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드와 각각 전달 <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션에는 `evaluator` 위임 합니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다. 사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 지정 하는 경우 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 에 대 한는 `options` 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽 이동, 그렇지 않으면 검색 입력된 문자열의 시작 부분에서 시작 하 고 오른쪽으로 이동 합니다.  
  
 `matchTimeout` 매개 변수 지정 긴 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 정규식에 나타나지 않도록 과도 한 역 추적을 사용 하는 시간 제한 간격을 설정 하면 "입력을 처리할 때 응답 하지 유사 항목 들어 있는입니다. 자세한 내용은 참조 [정규식에 대 한 유용한](~/docs/standard/base-types/best-practices.md) 및 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 일치 항목이 없으면 해당 시간 간격에서 발견 되 면 경우에 메서드에서 throw 된 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 메서드가 실행 되는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.  
  
 메서드가 반환 하므로 `input` 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 사용 하 여 문자열에서 개별 단어를 추출 하 고 다음 사용 하 여는 <xref:System.Text.RegularExpressions.MatchEvaluator> 라는 메서드를 호출 하는 대리자 `WordScramble` 단어의 개별 문자를 스크램블입니다. 이 작업을 수행 하는 `WordScramble` 메서드는 일치에 문자를 포함 하는 배열을 만듭니다. 또한 임의의 부동 소수점 숫자를 채우는 한 병렬 배열을 만듭니다. 호출 하 여 배열 정렬 되는 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 메서드와 정렬 된 배열에 대 한 인수로 제공 됩니다는 <xref:System.String> 클래스 생성자입니다. 새로 만든된이 문자열은 다음 반환 된 `WordScramble` 메서드. 정규식 패턴 `\w+` ; 하나 이상의 단어 문자 일치 정규식 엔진은 계속 공백 문자 같은 한 단어가 아닌 문자에 도달할 때까지 문자 일치 항목으로 추가 됩니다. 에 대 한 호출에서 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드를 포함는 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 옵션 있도록 정규식 패턴에서 주석을 `\w+  # Matches all the characters in a word.` 정규식 엔진에 의해 무시 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="evaluator" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우  -또는-  <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큽니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 매개 변수를 2 초 등의 적절 한 값입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다. 하지만 다음과 같은 경우에만 제한 시간을 비활성화 해야:-이 정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 또는 정적 텍스트로 구성 됩니다. 이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.  -정규식 패턴을 효율적으로 처리 하는 확인을 철저히 테스트 하는 경우 일치 하는 일치 하지 않는 하 고 가까운 일치 합니다.  -정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>정규식을 사용하여 오른쪽에서 왼쪽으로 검색하는지를 나타내는 값을 가져옵니다.</summary>
        <value>정규식을 사용하여 오른쪽에서 왼쪽으로 검색하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> `true` 경우는 <xref:System.Text.RegularExpressions.Regex> 와 인스턴스를 만들었습니다.는 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 옵션입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>정규식 일치에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">분할할 문자열입니다.</param>
        <summary>
          <see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에서 지정된 정규식 패턴에 의해 정의된 위치에서 입력 문자열을 부분 문자열의 배열로 분할합니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> 메서드와 비슷하지만 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다. 문자열은 최대한 많이 분할 됩니다. 구분 기호 없음이 없으면 반환 값은 하나의 값이 인 요소는 원래 입력된 문자열을 포함 합니다.  
  
 여러 명의 일치 항목을 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다. 예를 들어 단일 하이픈에서 문자열을 분할 하면 반환 된 배열의 다음 코드와 같이 인접 한 두 개의 하이픈은 찾을 수 위치에 빈 문자열을 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 시작 부분이 나 입력된 문자열의 끝에 일치 하는 빈 문자열의 시작 이나 반환 된 배열의 끝에 포함 됩니다. 다음 예제에서는 정규식 패턴을 사용 하 여 `\d+` 숫자 문자에는 입력된 문자열을 분할 합니다. 반환 된 배열의 첫 번째 및 마지막 요소의 값이 문자열이 시작 되 고 숫자 문자 일치 끝나는, 때문에 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 캡처링 괄호에 사용 되는 경우는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 식, 캡처된 모든 텍스트는 결과 문자열 배열에 포함 되어 있습니다. 예를 들어 "plum 기준" 하이픈에서 캡처 괄호 안에 배치 하는 문자열을 분할 하면 반환 되는 배열 하이픈을 포함 하는 문자열 요소를 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다. .NET Framework 1.0 및 1.1 캡처 괄호, 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에. .NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다. 예를 들어 다음 코드 캡처 괄호의 두 집합을 사용 하 여 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 합니다. 캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 슬래시 문자; 제외 컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우에 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다. 예:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 참고가 반환 되는 배열 시작과 배열의 끝에 빈 문자열을도 포함 됩니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> split 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 발생 하지 않습니다  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">분할될 문자열입니다.</param>
        <param name="count">분할할 수 있는 최대 횟수입니다.</param>
        <summary>입력 문자열을 <see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에서 지정된 정규식에 의해 정의된 위치에서 지정된 최대 수만큼 부분 문자열의 배열로 분할합니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%2A?displayProperty=nameWithType> 메서드와 비슷하지만 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다. `count` 문자열의 최대 수를 지정 하는 매개 변수는 `input` 문자열을 분할 될 수 있습니다; 마지막 문자열 문자열 변수를 포함 합니다. A `count` 최대한 많이 분할의 기본 동작을 제공 하는 값이 0입니다.  
  
 여러 명의 일치 항목이 서로 인접 한 경우 또는 시작 이나 끝 일치 하는 경우 `input`, 발견 된 일치 레코드 수는 2 이상 및 보다 작은 `count`, 빈 문자열 배열에 삽입 됩니다. 즉, 일치 하는 인접 한 항목 또는 시작 이나 입력된 문자열의 끝 부분에서 일치 항목에서 발생 하는 빈 문자열 판단할 때 고려 됩니다 수에 부분 문자열 equals와 일치 하는지 여부 `count`합니다. 다음 예제에서는 정규식에서에서 `/d+` 세 부분 문자열을 최대 하나 이상의 10 진수 숫자가 포함 된 입력된 문자열을 분할 하는 데 사용 됩니다. 첫 번째 배열 요소를 포함 하는 정규식 패턴과 일치 하는 입력된 문자열의 시작 하기 때문에 <xref:System.String.Empty?displayProperty=nameWithType>, 영문자 입력된 문자열에서 첫 번째 집합을 포함 하는 두 번째 및 세 번째 문자열의 나머지를 포함 합니다. 세 번째 일치 항목 다음에 오는 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 정규식의 캡처링 괄호를 사용 하면 캡처된 텍스트가 모두 분할 문자열의 배열에 포함 됩니다. 그러나 캡처된 텍스트가 들어 있는 배열 요소 고려 되지 않습니다 확인 된 일치 레코드 수에 도달 하는지 여부를 `count`합니다. 예를 들어 다음 코드와 7 개 요소 배열의 네 부분 문자열 결과의 최대값에 "apple-장의-plum-배-바나나" 문자열을 분할을 보여 줍니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다. .NET Framework 1.0 및 1.1에서 캡처된 텍스트 캡처 괄호의 첫 번째 집합에서 반환된 된 배열에 포함 됩니다. .NET Framework 2.0 부터는 모든 캡처된 텍스트가 반환된 된 배열에 추가 됩니다. 그러나 요소 반환된 된 배열에 캡처된 텍스트가 들어 있는 고려 되지 않습니다 결정할 때의 수에 부분 문자열 equals와 일치 하는지 여부 `count`합니다. 예를 들어 다음 코드에서는 정규식을 사용 하 여 캡처 괄호의 두 집합 날짜 문자열에서 날짜의 요소를 추출 합니다. 캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다. 에 대 한 호출에서 <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> 메서드 다음 반환된 된 배열에는 최대 두 개의 요소를 지정 합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 메서드는 두 요소 문자열 배열을 반환 합니다. 컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우 메서드는 세 요소로 문자열 배열을 반환 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다. 다음 예제에서는 입력된 문자열에 있는 요소 수 만큼를 "문자" 문자열을 분할 합니다. Null 문자열은 입력된 문자열의 시작 부분와 일치 하므로 null 문자열이 반환 되는 배열의 시작 부분에 삽입 됩니다. 이렇게 하면 10 번째 요소는 입력된 문자열의 끝에 두 개의 문자로 구성 됩니다.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> split 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 발생 하지 않습니다  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">분할할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <summary>정규식 패턴에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%2A?displayProperty=nameWithType> 메서드와 비슷하지만 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다. `input` 가능한 횟수 만큼 문자열을 분할 합니다. 경우 `pattern` 사전에 `input` 문자열, 반환 값은 원래 값을 가진 요소가 하나 포함 되어 `input` 문자열입니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
> [!IMPORTANT]
>  컴파일된 정적에 대 한 호출에 사용 된 정규식 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드 자동으로 캐시 됩니다. 컴파일된 정규식의 수명을 직접 관리 하려면 인스턴스를 사용 하 여 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드.  
  
 여러 명의 일치 항목을 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다. 예를 들어 단일 하이픈에서 문자열을 분할 하면 반환 된 배열의 다음 코드와 같이 인접 한 두 개의 하이픈은 찾을 수 위치에 빈 문자열을 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 시작 부분이 나 입력된 문자열의 끝에 일치 하는 빈 문자열의 시작 이나 반환 된 배열의 끝에 포함 됩니다. 다음 예제에서는 정규식 패턴을 사용 하 여 `\d+` 숫자 문자에는 입력된 문자열을 분할 합니다. 반환 된 배열의 첫 번째 및 마지막 요소의 값이 문자열이 시작 되 고 숫자 문자 일치 끝나는, 때문에 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 캡처링 괄호에 사용 되는 경우는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 식, 캡처된 모든 텍스트는 결과 문자열 배열에 포함 되어 있습니다. 예를 들어 "plum 기준" 하이픈에서 캡처 괄호 안에 배치 하는 문자열을 분할 하면 반환 되는 배열 하이픈을 포함 하는 문자열 요소를 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다. .NET Framework 1.0 및 1.1 캡처 괄호, 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에. .NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다. 예를 들어 다음 코드 캡처 괄호의 두 집합을 사용 하 여 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 합니다. 캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 슬래시 문자; 제외 컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우에 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%2A> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다. 예:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 참고가 반환 되는 배열 시작과 배열의 끝에 빈 문자열을도 포함 됩니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> split 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>이 메서드가 제한 시간 초과 후 메서드가 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다. 응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는 데 사용 됩니다. 텍스트 패턴 일치를 분할 하는 데 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">분할될 문자열입니다.</param>
        <param name="count">분할할 수 있는 최대 횟수입니다.</param>
        <param name="startat">입력 문자열에서 검색을 시작할 문자 위치입니다.</param>
        <summary>입력 문자열을 <see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에서 지정된 정규식에 의해 정의된 위치에서 지정된 최대 수만큼 부분 문자열의 배열로 분할합니다. 입력 문자열에서 지정된 문자 위치부터 정규식 패턴을 검색합니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%2A?displayProperty=nameWithType> 메서드와 비슷하지만 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다. `count` 문자열의 최대 수를 지정 하는 매개 변수는 `input` 문자열을 분할 마지막 문자열 문자열 변수를 포함 합니다. A `count` 최대한 많이 분할의 기본 동작을 제공 하는 값이 0입니다. `startat` 매개 변수는 첫 번째 구분 기호에 대 한 검색을 시작할 지점 정의 (이 수에 사용할 선행 공백은 건너뛰도록).  
  
 일치 하는 경우는 `count`+ 1 위치를 표시, 메서드가 포함 된 요소가 하나인 배열을 반환는 `input` 문자열입니다. 하나 이상의 일치 항목 발견 되 면 반환 된 배열의 첫 번째 요소는 한 문자는 일치 항목 앞까지 첫 번째 문자부터 문자열의 첫 번째 부분을 포함 합니다.  
  
 여러 명의 일치 항목이 서로 인접 한 있으며 발견 된 일치 레코드 수는 최소한 2 보다 작은 `count`, 빈 문자열 배열에 삽입 됩니다. 마찬가지로,에 일치 하는 경우 `startat`을 만드는데 문자열의 첫 번째 문자, 반환 된 배열의 첫 번째 요소는 빈 문자열입니다. 즉, 일치 하는 인접 한 항목에서 발생 하는 빈 문자열 판단할 때 고려 됩니다 수에 부분 문자열 equals와 일치 하는지 여부 `count`합니다. 다음 예제에서는 정규식에서에서 `\d+` 를 사용 하는 문자열에 숫자 문자의 첫 번째 부분 문자열의 시작 위치를 찾을 문자열을 분할의 최대는 차례로 세 번 해당 위치에서 시작 합니다. 빈 문자열, 5 자로 이루어진 영 문자열 및 문자열의 나머지 부분에서는 반환 된 문자열 배열 구성 정규식 패턴이 입력된 문자열의 시작 일치 하기 때문에  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 정규식의 캡처링 괄호를 사용 하면 캡처된 텍스트가 모두 분할 문자열의 배열에 포함 됩니다. 그러나 캡처된 텍스트가 들어 있는 배열 요소 고려 되지 않습니다 확인 된 일치 레코드 수에 도달 하는지 여부를 `count`합니다. 예를 들어 문자열을 분할 ' "apple-apricot-plum-pear-pomegranate-pineapple-peach" 4 개의 최대 7 개 요소 배열에서 문자열 결과에 15 문자에서 시작 하는 다음 코드 에서처럼 부분 문자열입니다.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다. .NET Framework 1.0 및 1.1 캡처 괄호, 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에. .NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다. 예를 들어 다음 코드를 사용 하 여 캡처 괄호의 두 집합 문자열에서 개별 단어를 추출 합니다. 캡처 괄호의 첫 번째 집합에서 하이픈을 캡처하고 두 번째 집합 세로 막대를 캡처합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우이 메서드를 제외 세로 막대 지정할 때; 컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우에 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%2A> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다. 다음 예제에서는 입력된 문자열에는 문자로 시작 하는 대로 많은 요소에 "문자" 문자열을 분할 "a"입니다. Null 문자열은 입력된 문자열의 끝와 일치 하므로 null 문자열이 반환 된 배열의 끝에 삽입 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> split 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간 없음을에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 발생 하지 않습니다  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">분할할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 정규식 패턴에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다. 지정한 옵션에 따라 일치 작업이 수정됩니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> 메서드와 비슷하지만 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다. 문자열은 최대한 많이 분할 됩니다. 구분 기호를 찾을 수 없으면 반환 값은 원래 값을 갖는 하나의 요소를 포함 하는 `input` 문자열입니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
> [!IMPORTANT]
>  컴파일된 정적에 대 한 호출에 사용 된 정규식 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드 자동으로 캐시 됩니다. 컴파일된 정규식의 수명을 직접 관리 하려면 인스턴스를 사용 하 여 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드.  
  
 여러 명의 일치 항목을 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다. 예를 들어 단일 하이픈에서 문자열을 분할 하면 반환 된 배열의 인접 한 하이픈을 두 개 발견 되는 위치에 빈 문자열을 포함 합니다.  
  
 시작 부분이 나 입력된 문자열의 끝에 일치 하는 빈 문자열의 시작 이나 반환 된 배열의 끝에 포함 됩니다. 다음 예제에서는 정규식 패턴을 사용 하 여 `[a-z]+` 를 대문자 또는 소문자 알파벳 문자에는 입력된 문자열을 분할 합니다. 반환 된 배열의 첫 번째 및 마지막 요소의 값이 문자열이 시작 되 고 알파벳 문자 일치 끝나는, 때문에 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 캡처링 괄호에 사용 되는 경우는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 식, 캡처된 모든 텍스트는 결과 문자열 배열에 포함 되어 있습니다. 예를 들어 "plum 기준" 하이픈에서 캡처 괄호 안에 배치 하는 문자열을 분할 하면 반환 되는 배열 하이픈을 포함 하는 문자열 요소를 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다. .NET Framework 1.0 및 1.1 캡처 괄호, 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에. .NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다. 예를 들어 다음 코드 캡처 괄호의 두 집합을 사용 하 여 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 합니다. 캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 슬래시 문자; 제외 컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우에 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%2A> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> split 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>이 메서드가 제한 시간 초과 후 메서드가 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다. 응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는 데 사용 됩니다. 텍스트 패턴 일치를 분할 하는 데 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">분할할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 정규식 패턴에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다. 추가 매개 변수는 일치하는 항목이 없는 경우 제한 시간 간격과 일치 작업을 수정하는 옵션을 지정합니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> 메서드와 비슷하지만 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다. 문자열은 최대한 많이 분할 됩니다. 구분 기호를 찾을 수 없으면 반환 값은 원래 값을 갖는 하나의 요소를 포함 하는 `input` 문자열입니다.  
  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
> [!IMPORTANT]
>  컴파일된 정적에 대 한 호출에 사용 된 정규식 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드 자동으로 캐시 됩니다. 컴파일된 정규식의 수명을 직접 관리 하려면 인스턴스를 사용 하 여 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드.  
  
 여러 명의 일치 항목을 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다. 예를 들어 단일 하이픈에서 문자열을 분할 하면 반환 된 배열의 인접 한 하이픈을 두 개 발견 되는 위치에 빈 문자열을 포함 합니다.  
  
 시작 부분이 나 입력된 문자열의 끝에 일치 하는 빈 문자열의 시작 이나 반환 된 배열의 끝에 포함 됩니다. 다음 예제에서는 정규식 패턴을 사용 하 여 `[a-z]+` 를 대문자 또는 소문자 알파벳 문자에는 입력된 문자열을 분할 합니다. 반환 된 배열의 첫 번째 및 마지막 요소의 값이 문자열이 시작 되 고 알파벳 문자 일치 끝나는, 때문에 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 캡처링 괄호에 사용 되는 경우는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 식, 캡처된 모든 텍스트는 결과 문자열 배열에 포함 되어 있습니다. 예를 들어 "plum 기준" 하이픈에서 캡처 괄호 안에 배치 하는 문자열을 분할 하면 반환 되는 배열 하이픈을 포함 하는 문자열 요소를 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다. .NET Framework 1.0 및 1.1 캡처 괄호, 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에. .NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다. 예를 들어 다음 코드 캡처 괄호의 두 집합을 사용 하 여 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 합니다. 캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 슬래시 문자; 제외 컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우에 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%2A> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다.  
  
 `matchTimeout` 매개 변수 지정 긴 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리 하는 경우 응답을 중지 하 게 표시 되지 않도록 과도 한 역 추적을 사용 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 들어 있는입니다. 자세한 내용은 참조 [정규식에 대 한 유용한](~/docs/standard/base-types/best-practices.md) 및 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 일치 항목이 없으면 해당 시간 간격에서 발견 되 면 경우에 메서드에서 throw 된 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 메서드가 실행 되는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우  -또는-  <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큽니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage">
          <para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 매개 변수를 2 초 등의 적절 한 값입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다. 하지만 다음과 같은 경우에만 제한 시간을 비활성화 해야:-이 정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 또는 정적 텍스트로 구성 됩니다. 이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.  -정규식 패턴을 효율적으로 처리 하는 확인을 철저히 테스트 하는 경우 일치 하는 일치 하지 않는 하 고 가까운 일치 합니다.  -정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">serialization 정보로 채울 개체입니다.</param>
        <param name="context">serialize된 데이터를 저장 및 검색할 위치입니다. 이 매개 변수는 나중에 사용하기 위해 예약되어 있습니다.</param>
        <summary>현재 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체를 deserialize하는 데 필요한 데이터로 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체를 채웁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see langword="Regex" /> 생성자로 전달된 정규식 패턴을 반환합니다.</summary>
        <returns>
          <see langword="Regex" /> 생성자로 전달된 <paramref name="pattern" /> 매개 변수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다. 정규식에 대 한 자세한 내용은 참조 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 및 [일반 식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 만든 정규식의 기본 클래스는 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드. 이러한 정규식 사용 하 여 컴파일된는 <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> 기본 클래스의 구현입니다. 파생된 클래스에서 호출 된 경우는 <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> 에 전달 된 문자열을 반환 하는 메서드는 <paramref name="pattern" /> 의 매개 변수는 <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> 정규식 정의에 사용 된 클래스 생성자입니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">변환할 텍스트가 포함된 입력 문자열입니다.</param>
        <summary>입력 문자열에서 이스케이프된 문자를 변환합니다.</summary>
        <returns>이스케이프된 문자가 이스케이프되지 않은 형식으로 변환된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 메서드는 다음 두 개의 변환 중 하나를 수행 합니다.  
  
-   변환을 수행한 취소는 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 이스케이프 문자를 제거 하 여 메서드 ("\\") 메서드에 의해 이스케이프 된 각 문자를 합니다. 여기에 \\, *, +,?, &#124;, {, [, (,), ^, $., #, 및 공백 문자입니다. 또한는 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 메서드 닫는 대괄호 (]) 태그와 닫는 중괄호 (}) 문자가 이스케이프 해제 합니다.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 되돌릴 수 없습니다. 이스케이프 문자열 완벽 하 게 문자 이스케이프 되었는지 정확 하 게 추론할 수 없습니다.  
  
-   자체로 표현 인쇄할 수 없는 문자를 대체합니다. 예를 들어 \x07으로 \a를 대체 합니다. 대체 문자 표현 되며 \a, \b, \e, \n, \r, \f, \t, \v 있습니다.  
  
 경우는 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 변환할 수 없는 다른 이스케이프 시퀀스가 발생 \w 또는 \s 처럼 throw는 <xref:System.ArgumentException>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" />에는 인식할 수 없는 이스케이프 시퀀스가 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <returns>
          <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 속성에 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 옵션이 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <returns>
          <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 속성에 <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> 옵션이 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">확인할 시간 제한 간격입니다.</param>
        <summary>시간 제한 간격이 허용 범위 내에 있는지를 확인합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>