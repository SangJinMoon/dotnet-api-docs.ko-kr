<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Regex.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5646ce7ee28b4835a77eed74edc78f5d335dd6320.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">646ce7ee28b4835a77eed74edc78f5d335dd6320</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Represents an immutable regular expression.</source>
          <target state="translated">변경할 수 없는 정규식을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class represents the .NET Framework's regular expression engine.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스는.NET Framework의 정규식 엔진을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>It can be used to quickly parse large amounts of text to find specific character patterns; to extract, edit, replace, or delete text substrings; and to add the extracted strings to a collection to generate a report.</source>
          <target state="translated">신속 하 게 많은 양의; 특정 문자 패턴을 찾을 텍스트를 구문 분석에 사용할 수 있습니다. 추출, 편집, 바꾸기 또는 삭제 텍스트 부분 문자열입니다. 및 보고서를 생성 하는 컬렉션에 추출 된 문자열을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If your primary interest is to validate a string by determining whether it conforms to a particular pattern, you can use the <ph id="ph1">&lt;xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">주 관심 특정 패턴을 따르는지 여부를 확인 하 여 문자열을 확인 하는 것을 사용할 수 있습니다는 <ph id="ph1">&lt;xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To use regular expressions, you define the pattern that you want to identify in a text stream by using the syntax documented in <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">에 설명 된 구문을 사용 하 여 텍스트 스트림에 확인 하는 패턴 정규식을 사용 하려면 정의한 <bpt id="p1">[</bpt>일반 식 언어-빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Next, you can optionally instantiate a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">그런 다음 필요에 따라를 인스턴스화할 수 있습니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Finally, you call a method that performs some operation, such as replacing text that matches the regular expression pattern, or identifying a pattern match.</source>
          <target state="translated">마지막으로, 정규식 패턴과 일치 하는 텍스트 바꾸기 또는 패턴 일치를 식별 하는 등 특정 작업을 수행 하는 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For some common regular expression patterns, see <bpt id="p1">[</bpt>Regular Expression Examples<ept id="p1">](~/docs/standard/base-types/regular-expression-examples.md)</ept>.</source>
          <target state="translated">몇 가지 일반적인 정규식 패턴에 대 한 참조 <bpt id="p1">[</bpt>일반 식 예제<ept id="p1">](~/docs/standard/base-types/regular-expression-examples.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>There are also a number of online libraries of regular expression patterns, such as the one at <bpt id="p1">[</bpt>Regular-Expressions.info<ept id="p1">](http://www.regular-expressions.info/examples.html)</ept>.</source>
          <target state="translated">또한 온라인 라이브러리의 정규식 패턴에 있는 것과 같은 여러 가지 <bpt id="p1">[</bpt>일반 Expressions.info<ept id="p1">](http://www.regular-expressions.info/examples.html)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">&lt;a name="remarks"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> For more information about using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class, see the following sections in this topic:</source>
          <target state="translated"><bpt id="p1">&lt;a name="remarks"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> 사용 하는 방법에 대 한 자세한 내용은 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 이 항목의 다음 섹션을 참조 하세요.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Regex vs. String Methods<ept id="p1">](#regex_vs_string)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Regex vs입니다. 문자열 처리 메서드<ept id="p1">](#regex_vs_string)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Static vs. Instance Methods<ept id="p1">](#static_vs_instance)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정적 포트 대 인스턴스 메서드<ept id="p1">](#static_vs_instance)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Performing Regular Expression Operations<ept id="p1">](#regex_ops)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정규식 작업 수행<ept id="p1">](#regex_ops)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Defining a Time-Out Value<ept id="p1">](#define_timeout)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>시간 제한 값을 정의합니다.<ept id="p1">](#define_timeout)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about the regular expression language, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> or download and print one of these brochures:</source>
          <target state="translated">정규식 언어에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식 언어 - 빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>를 참조하거나, 다음 브로슈어 중 하나를 다운로드하여 인쇄하세요.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Quick Reference in Word (.docx) format<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Word(.docx) 형식의 빠른 참조<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Quick Reference in PDF (.pdf) format<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>PDF(.pdf) 형식의 빠른 참조<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Regex vs. String Methods</source>
          <target state="translated">Regex vs입니다. 문자열 처리 메서드</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> class includes several search and comparison methods that you can use to perform pattern matching with text.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> 클래스는 텍스트 패턴 일치를 수행 하는 데 사용할 수 있는 몇 가지 검색 및 비교 메서드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Contains%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> methods determine whether a string instance contains a specified substring; and the <ph id="ph4">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOfAny%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph7">&lt;xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType&gt;</ph> methods return the starting position of a specified substring in a string.</source>
          <target state="translated">예를 들어는 <ph id="ph1">&lt;xref:System.String.Contains%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A?displayProperty=nameWithType&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> 메서드 문자열 인스턴스입니다; 지정된 된 부분 문자열에 포함 되는지 여부를 결정 및 <ph id="ph4">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOfAny%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>, 및 <ph id="ph7">&lt;xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType&gt;</ph> 메서드 문자열의 지정된 된 부분 문자열의 시작 위치를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Use the methods of the <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> class when you are searching for a specific string.</source>
          <target state="translated">메서드를 사용 하 여는 <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> 특정 문자열 검색 하는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class when you are searching for a specific pattern in a string.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 문자열의 특정 패턴에 대 한 검색 하는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information and examples, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">자세한 내용 및 예제에 대 한 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>주의 돌아가기<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Static vs. Instance Methods</source>
          <target state="translated">정적 포트 대 인스턴스 메서드</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>After you define a regular expression pattern, you can provide it to the regular expression engine in either of two ways:</source>
          <target state="translated">정규식 패턴을 정의한 후에 두 가지 방법 중 하나로 정규식 엔진에 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By instantiating a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object that represents the regular expression.</source>
          <target state="translated">인스턴스화하여는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 정규식을 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To do this, you pass the regular expression pattern to a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">정규식 패턴을 전달 하면이 작업을 수행 하는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%2A&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable; when you instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with a regular expression, that object's regular expression cannot be changed.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체는 변경할 수 없습니다; 인스턴스화하는 경우는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체는 정규식 개체의 정규식을 변경할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By supplying both the regular expression and the text to search to a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> method.</source>
          <target state="translated">정규식과에 검색할 텍스트를 모두 제공 하 여 한 <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> Visual basic에서) <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This enables you to use a regular expression without explicitly creating a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">이렇게 하면 명시적으로 만들지 않고도 정규식을 사용 하는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>All <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> pattern identification methods include both static and instance overloads.</source>
          <target state="translated">모든 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 패턴 식별 포함 정적 메서드와 인스턴스 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The regular expression engine must compile a particular pattern before the pattern can be used.</source>
          <target state="translated">정규식 엔진이 패턴을 사용 하려면 먼저 특정 패턴을 컴파일해야 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Because <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objects are immutable, this is a one-time procedure that occurs when a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor or a static method is called.</source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 발생 하는 일회성 절차와, 개체를 변경할 수 없는 경우는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스 생성자 또는 정적 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To eliminate the need to repeatedly compile a single regular expression, the regular expression engine caches the compiled regular expressions used in static method calls.</source>
          <target state="translated">반복 해 서 단일 정규식을 컴파일할 필요를 제거 하려면 정규식 엔진은 정적 메서드 호출에 사용 된 컴파일된 정규식을 캐시 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>As a result, regular expression pattern-matching methods offer comparable performance for static and instance methods.</source>
          <target state="translated">결과적으로, 정규식 패턴 일치 메서드에 비슷한 성능을 정적 및 인스턴스 메서드를 제공합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In the .NET Framework versions 1.0 and 1.1, all compiled regular expressions, whether they were used in instance or static method calls, were cached.</source>
          <target state="translated">.NET Framework 버전 1.0 및 1.1에서는 모든 컴파일된 정규식에서 인스턴스 또는 정적 메서드에 사용 되는 여부 호출, 캐시 되었습니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Starting with the .NET Framework 2.0, only regular expressions used in static method calls are cached.</source>
          <target state="translated">.NET Framework 2.0 부터는 정규식만 정적 메서드 호출에 사용 되는 캐시 됩니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, caching can adversely affect performance in the following two cases:</source>
          <target state="translated">그러나 캐싱 다음 두 가지 경우에는 성능을 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When you use static method calls with a large number of regular expressions.</source>
          <target state="translated">정규식의 다 수 포함 된 정적 메서드 호출을 사용 하면.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By default, the regular expression engine caches the 15 most recently used static regular expressions.</source>
          <target state="translated">기본적으로 정규식 엔진은 15 가장 최근에 사용한 정적 정규식을 캐시합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If your application uses more than 15 static regular expressions, some regular expressions must be recompiled.</source>
          <target state="translated">15 개 정적 정규식을 사용 하는 응용 프로그램, 몇 가지 일반 식은 컴파일해야 합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent this recompilation, you can increase the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">이 재컴파일을 방지 하려면 늘릴 수 있습니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When you instantiate new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objects with regular expressions that have previously been compiled.</source>
          <target state="translated">인스턴스화하는 경우 새로운 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 이전에 컴파일된 정규식을 사용 하 여 개체입니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For example, the following code defines a regular expression to locate duplicated words in a text stream.</source>
          <target state="translated">예를 들어 다음 코드는 텍스트 스트림에 중복 된 단어를 찾을 수 있는 정규식을 정의 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Although the example uses a single regular expression, it instantiates a new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object to process each line of text.</source>
          <target state="translated">이 예제에서는 단일 정규식을 사용 하지만 새 인스턴스화합니다 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 각 텍스트 줄을 처리 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This results in the recompilation of the regular expression with each iteration of the loop.</source>
          <target state="translated">이 인해 루프의 각 반복 정규식 다시 컴파일해야 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent recompilation, you should instantiate a single <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object that is accessible to all code that requires it, as shown in the following rewritten example.</source>
          <target state="translated">재컴파일을 방지 하려면 단일 인스턴스화해야 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 다시 쓴 다음 예에서 같이 필요로 하는 모든 코드에 액세스할 수 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>주의 돌아가기<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Performing Regular Expression Operations</source>
          <target state="translated">정규식 작업 수행</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Whether you decide to instantiate a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object and call its methods or call static methods, the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class offers the following pattern-matching functionality:</source>
          <target state="translated">하기로 한 경우 인스턴스화하는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체 및 해당 메서드를 호출 하거나 정적 메서드를 호출 하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스는 다음 패턴 일치 기능을 제공:</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Validation of a match.</source>
          <target state="translated">일치 하는 항목의 유효성을 검사 합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method to determine whether a match is present.</source>
          <target state="translated">호출 하는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> 메서드를 일치 하는 항목이 있는지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Retrieval of a single match.</source>
          <target state="translated">단일 일치 항목의 검색입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that represents the first match in a string or in part of a string.</source>
          <target state="translated">호출 하 여 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> 를 검색할 메서드는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 나 부분 문자열로 문자열에서 첫 번째 일치 항목을 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Subsequent matches can be retrieved by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">호출 하 여 후속 일치 항목을 검색할 수 있습니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Retrieval of all matches.</source>
          <target state="translated">모든 일치 항목을 검색 합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType&gt;</ph> object that represents all the matches found in a string or in part of a string.</source>
          <target state="translated">호출 하 여 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 를 검색할 메서드는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType&gt;</ph> 나 부분 문자열로 문자열에서 찾은 모든 일치 항목을 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Replacement of matched text.</source>
          <target state="translated">일치 하는 텍스트 대체 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> method to replace matched text.</source>
          <target state="translated">호출 하는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> 메서드를 일치 하는 텍스트를 대체 합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The replacement text can also be defined by a regular expression.</source>
          <target state="translated">정규식으로 대체 텍스트를 정의할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In addition, some of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> methods include a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> parameter that enables you to programmatically define the replacement text.</source>
          <target state="translated">일부에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> 메서드를 포함 한 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> 매개 변수를 사용 하는 프로그래밍 방식으로 바꿀 텍스트를 정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Creation of a string array that is formed from parts of an input string.</source>
          <target state="translated">입력된 문자열의 부분 구성 된 문자열 배열 만듭니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> method to split an input string at positions that are defined by the regular expression.</source>
          <target state="translated">호출 하는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> 메서드를 정규식으로 정의 된 위치에서 입력된 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In addition to its pattern-matching methods, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class includes several special-purpose methods:</source>
          <target state="translated">해당 패턴 일치 메서드를 외에도 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스는 몇 가지 특수 한 용도의 메서드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method escapes any characters that may be interpreted as regular expression operators in a regular expression or input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> 메서드 정규식 이나 입력된 문자열에서 정규식 연산자로 해석 될 수 있는 모든 문자를 이스케이프 합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method removes these escape characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> 메서드 이러한 이스케이프 문자를 제거 합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method creates an assembly that contains predefined regular expressions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> 메서드는 미리 정의 된 정규식을 포함 하는 어셈블리를 만듭니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The .NET Framework contains examples of these special-purpose assemblies in the <ph id="ph1">&lt;xref:System.Web.RegularExpressions?displayProperty=nameWithType&gt;</ph> namespace.</source>
          <target state="translated">이러한 특수 한 용도의 어셈블리의 예제를 포함 하는.NET Framework는 <ph id="ph1">&lt;xref:System.Web.RegularExpressions?displayProperty=nameWithType&gt;</ph> 네임 스페이스입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>주의 돌아가기<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Defining a Time-Out Value</source>
          <target state="translated">시간 제한 값을 정의합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The .NET Framework supports a full-featured regular expression language that provides substantial power and flexibility in pattern matching.</source>
          <target state="translated">.NET Framework 상당한 기능과 유연성 패턴 일치에서 제공 하는 모든 기능을 갖춘 정규식 언어를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, the power and flexibility come at a cost: the risk of poor performance.</source>
          <target state="translated">그러나 강력 하며 유연성 비용이 듭니다: 성능 저하의 위험 합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Regular expressions that perform poorly are surprisingly easy to create.</source>
          <target state="translated">불완전 하 게 수행 하는 정규식은 매우 쉽게 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In some cases, regular expression operations that rely on excessive backtracking can appear to stop responding when they process text that nearly matches the regular expression pattern.</source>
          <target state="translated">일부 경우에는 정규식 패턴과 거의 일치 하는 텍스트를 처리 하는 경우 응답 하지 않는 것 과도 한 역 추적을 사용 하는 정규식 작업 나타날 수 있습니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about the .NET Framework regular expression engine, see <bpt id="p1">[</bpt>Details of Regular Expression Behavior<ept id="p1">](~/docs/standard/base-types/details-of-regular-expression-behavior.md)</ept>.</source>
          <target state="translated">.NET Framework 정규식 엔진에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>세부 정보 정규식 동작 정부<ept id="p1">](~/docs/standard/base-types/details-of-regular-expression-behavior.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about excessive backtracking, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">과도 한 역 추적 하는 방법에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>역 추적<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, you can define a time-out interval for regular expression matches.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 정규식 일치에 대 한 시간 제한 간격을 정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the regular expression engine cannot identify a match within this time interval, the matching operation throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">정규식 엔진이이 시간 간격 내에서 일치 하는 항목을 식별할 수 없으면, 일치 하는 작업에서 throw 한 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In most cases, this prevents the regular expression engine from wasting processing power by trying to match text that nearly matches the regular expression pattern.</source>
          <target state="translated">대부분의 경우에서 이렇게 하면 정규식 엔진에서 처리 능력을 정규식 패턴과 거의 일치 하는 텍스트와 일치 하도록 시도 하 여 낭비 됩니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>It also could indicate, however, that the timeout interval has been set too low, or that the current machine load has caused an overall degradation in performance.</source>
          <target state="translated">그러나 또한 나타낼 수, 제한 시간 간격이 설정 되어 있는지를 너무 낮게 또는 현재 컴퓨터 부하가 성능에는 전반적인 성능 저하를 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>How you handle the exception depends on the cause of the exception.</source>
          <target state="translated">예외를 처리 하는 방법은 예외의 원인에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the exception occurs because the time-out interval is set too low or because of excessive machine load, you can increase the time-out interval and retry the matching operation.</source>
          <target state="translated">시간 제한 간격이 너무 낮게 설정 되어 있기 때문에 예외가 발생 하는 경우 또는 과도 한 시스템 부하 때문에, 시간 제한 간격을 늘릴 수 있으며 일치 하는 작업을 다시 시도 수 있습니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the exception occurs because the regular expression relies on excessive backtracking, you can assume that a match does not exist, and, optionally, you can log information that will help you modify the regular expression pattern.</source>
          <target state="translated">과도 한 역 추적이 정규식 사용 때문에 예외가 발생 하는 경우에 일치 하는 존재 하지 않는 하 고, 필요에 따라 정규식 패턴을 수정 하는 데 도움이 되는 정보를 기록할 수 있습니다를 가정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You can set a time-out interval by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor when you instantiate a regular expression object.</source>
          <target state="translated">호출 하 여 시간 제한 간격을 설정할 수 있습니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 정규식 개체를 인스턴스화할 때 생성자입니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For static methods, you can set a time-out interval by calling an overload of a matching method that has a <ph id="ph1">`matchTimeout`</ph> parameter.</source>
          <target state="translated">정적 메서드에 대 한 일치 하는 메서드를 오버 로드를 호출 하 여 시간 제한 간격을 설정할 수 있습니다는 <ph id="ph1">`matchTimeout`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If you do not set a time-out value explicitly, the default time-out value  is determined as follows:</source>
          <target state="translated">시간 제한 값을 명시적으로 설정 하지 않으면 기본 제한 시간 값이 다음과 같이 결정 됩니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By using the application-wide time-out value, if one exists.</source>
          <target state="translated">응용 프로그램 수준 시간 제한을 사용 하 여 값을 한 경우 존재 합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This can be any time-out value that applies to the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is instantiated or the static method call is made.</source>
          <target state="translated">이는 응용 프로그램 도메인에 적용 되는 모든 시간 제한 값이 될 수는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 인스턴스화되거나 정적 메서드 호출 합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You can set the application-wide time-out value by calling the <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> method to assign the string representation of a <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> value to the "REGEX_DEFAULT_MATCH_TIMEOUT" property.</source>
          <target state="translated">호출 하 여 응용 프로그램 수준 시간 제한 값을 설정할 수는 <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> 의 문자열 표현을 할당 하는 메서드는 <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> "REGEX_DEFAULT_MATCH_TIMEOUT" 속성 값입니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By using the value <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>, if no application-wide time-out value has been set.</source>
          <target state="translated">값을 사용 하 여 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>없는 응용 프로그램 수준 시간 제한 값이 설정 된 경우.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>We recommend that you set a time-out value in all regular expression pattern-matching operations.</source>
          <target state="translated">모든 정규식 패턴 일치 작업에서 시간 제한 값을 설정 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>정규식에 대 한 유용한<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>주의 돌아가기<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The following example uses a regular expression to check for repeated occurrences of words in a string.</source>
          <target state="translated">다음 예제에서는 문자열에서 단어의 반복 된 발생에 대 한 확인 하려면 정규식을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The regular expression <ph id="ph1">`\b(?&lt;word&gt;\w+)\s+(\k&lt;word&gt;)\b`</ph> can be interpreted as shown in the following table.</source>
          <target state="translated">정규식 <ph id="ph1">`\b(?&lt;word&gt;\w+)\s+(\k&lt;word&gt;)\b`</ph> 다음 표와 같이 해석 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Start the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작 합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match one or more word characters up to a word boundary.</source>
          <target state="translated">단어 경계까지 하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Name this captured group <ph id="ph1">`word`</ph>.</source>
          <target state="translated">이 캡처된 그룹의 이름을 <ph id="ph1">`word`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match one or more white-space characters.</source>
          <target state="translated">하나 이상의 공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the captured group that is named <ph id="ph1">`word`</ph>.</source>
          <target state="translated">라는 캡처된 그룹을 찾습니다 <ph id="ph1">`word`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match a word boundary.</source>
          <target state="translated">단어 경계를 찾습니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The following example illustrates the use of a regular expression to check whether a string either represents a currency value or has the correct format to represent a currency value.</source>
          <target state="translated">다음 예제에서는 문자열에 통화 값을 나타내는 또는 통화 값을 나타내는 올바른 형식의 있는지 여부를 확인 하려면 정규식의 사용을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In this case, the regular expression is built dynamically from the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> properties for the user's current culture.</source>
          <target state="translated">이 경우 정규식에서 동적으로 작성 되는 <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>, 및 <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> 사용자의 현재 문화권에 대 한 속성.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the system's current culture is en-US, the resulting regular expression is <ph id="ph1">`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`</ph>.</source>
          <target state="translated">시스템의 현재 문화권이 EN-US, 정규식은 <ph id="ph1">`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This regular expression can be interpreted as shown in the following table.</source>
          <target state="translated">이 정규식은 다음 표에 나와 있는 것 처럼 해석할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Start at the beginning of the string.</source>
          <target state="translated">문자열의 시작 부분에서 시작 합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">0개 이상의 공백 문자가 일치하는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one occurrence of either the positive sign or the negative sign.</source>
          <target state="translated">양수 부호 또는 음의 부호가 없거나 1 개 발생을 찾습니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one white-space character.</source>
          <target state="translated">0번 이상 나오는 공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one occurrence of the dollar sign.</source>
          <target state="translated">달러 기호는 없거나 1 개 발생을 찾습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one white-space character.</source>
          <target state="translated">0번 이상 나오는 공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or more decimal digits.</source>
          <target state="translated">0번 이상 나오는 10진수를 찾습니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one decimal point symbol.</source>
          <target state="translated">소수점 기호가 0 회 이상 일치 합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match two decimal digits zero or one time.</source>
          <target state="translated">두 개의 10 진수 0 개 또는 1 개 찾습니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the pattern of integral and fractional digits separated by a decimal point symbol at least one time.</source>
          <target state="translated">한 번 이상 소수점 기호로 구분 된 정수 부분과 소수 부분 자릿수 패턴과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the end of the string.</source>
          <target state="translated">문자열의 끝 부분을 찾습니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In this case, the regular expression assumes that a valid currency string does not contain group separator symbols, and that it has either no fractional digits or the number of fractional digits defined by the current culture's <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph> property.</source>
          <target state="translated">이 경우 정규식 가정 유효한 통화 문자열에 그룹 구분 기호가 포함 되지 않습니다는 현재 문화권에 의해 정의 된 소수 자릿수 또는 소수 자릿수 없이 있기 <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Because the regular expression in this example is built dynamically, we do not know at design time whether the current culture's currency symbol, decimal sign, or positive and negative signs might be misinterpreted by the regular expression engine as regular expression language operators.</source>
          <target state="translated">이 예의 정규식을 동적으로 작성 하기 때문에 म 알지 못할 디자인 타임에 현재 문화권의 통화 기호, 10 진수 기호 또는 양수 기호와 음수 기호 잘못 해석 될 수는 정규식 엔진이 정규식 언어 연산자로 여부.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent any misinterpretation, the example passes each dynamically generated string to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method.</source>
          <target state="translated">이 예제에서는 잘못 된 해석을 방지 하려면를 동적으로 생성 된 각 문자열에 전달 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class is immutable (read-only) and thread safe.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 클래스는 변경할 수 없습니다 (읽기 전용) 하 고 스레드로부터 안전 합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects can be created on any thread and shared between threads.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체는 모든 스레드에서 만들고 스레드 사이 공유할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information, see <bpt id="p1">[</bpt>Thread Safety<ept id="p1">](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>스레드 보안<ept id="p1">](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor">
          <source>Note that this constructor is protected; it can only be called by classes derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">이 생성자가 보호 되는지; 참고 파생 된 클래스 에서만 호출 될 수는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression.</source>
          <target state="translated">지정된 정규 식에 대해 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조는 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29&gt;</ph> constructor is equivalent to calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor with a value of <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.None&gt;</ph> for the <ph id="ph4">`options`</ph> argument.</source>
          <target state="translated">호출는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29&gt;</ph> 생성자는 호출 하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 의 값과 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.None&gt;</ph> 에 대 한는 <ph id="ph4">`options`</ph> 인수입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match pattern you define when you create it.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 변경 불가능, 즉, 만들 때 정의한 일치 패턴에 대해서만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">그러나 수 있습니다 다시 컴파일하지 않고 여러 번 사용 합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>This constructor instantiates a regular expression object that attempts a case-sensitive match of any alphabetical characters defined in <ph id="ph1">`pattern`</ph>.</source>
          <target state="translated">이 생성자에 정의 된 모든 알파벳 문자 대/소문자 구분 일치를 시도 하는 정규식 개체를 인스턴스화하고 <ph id="ph1">`pattern`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For a case-insensitive match, use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">대/소문자 구분 비교를 사용 하 여는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</source>
          <target state="translated">다음 예제를 인스턴스화하는 문자로 시작 하는 단어와 일치 하는 정규식이이 생성자를 사용 하는 방법 "a" 또는 "t"입니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Note that the regular expression pattern cannot match the word "The" at the beginning of the text, because comparisons are case-sensitive by default.</source>
          <target state="translated">참고 정규식 패턴 일치 단어 수 없습니다 "The" 텍스트의 시작 부분에서 기본적으로 대/소문자를 구분 하 여 비교 하므로 합니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For an example of case-insensitive comparison, see the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor.</source>
          <target state="translated">예를 보려면 대/소문자 비구분 비교 참조는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>This constructor creates a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object that uses the default time-out value of the application domain in which it is created.</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 생성는 응용 프로그램 도메인의 기본 제한 시간 값을 사용 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>If a time-out value has not been defined for the application domain,  the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object uses the value <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the operation from timing out. The recommended constructor for creating a <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object is <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">응용 프로그램 도메인에 대 한 시간 제한 값이 정의 되지 않은 경우는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 값을 사용 하는 개체 <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 작업이 시간 초과 방지 하는 합니다. 만들기 위한 권장된 생성자는 <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체가 <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object that contains a serialized pattern and <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> information.</source>
          <target state="translated">serialize된 패턴과 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 정보가 포함된 개체입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination for this serialization.</source>
          <target state="translated">이 serialization의 대상입니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>(This parameter is not used; specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.)</source>
          <target state="translated">이 매개 변수는 사용되지 않으므로 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 지정하세요.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class by using serialized data.</source>
          <target state="translated">serialize된 데이터를 사용하여 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The pattern that <ph id="ph1">&lt;paramref name="info" /&gt;</ph> contains is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph>에 포함된 패턴이 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> contains an invalid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> flag.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph>에 잘못된 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 플래그가 포함된 경우</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that modify the regular expression.</source>
          <target state="translated">정규식을 수정하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression, with options that modify the pattern.</source>
          <target state="translated">패턴을 수정할 수 있는 옵션을 사용하여 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 클래스의 새 인스턴스를 지정된 정규식에 대해 초기화합니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조는 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match parameters you define when you create it.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 변경 불가능, 즉, 일치 매개 변수를 만들 경우 정의 대해서만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">그러나 수 있습니다 다시 컴파일하지 않고 여러 번 사용 합니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</source>
          <target state="translated">다음 예제를 인스턴스화하는 문자로 시작 하는 단어와 일치 하는 정규식이이 생성자를 사용 하는 방법 "a" 또는 "t"입니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Note that the match collection includes the word "The" that begins the text because the <ph id="ph1">`options`</ph> parameter has defined case-insensitive comparisons.</source>
          <target state="translated">일치 컬렉션 때문에 텍스트를 시작 하 "The" 단어를 포함 하는 참고는 <ph id="ph1">`options`</ph> 매개 변수의 대/소문자 구분 비교를 정의 합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> contains an invalid flag.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>에 잘못된 플래그가 포함된 경우</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This constructor creates a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object that uses the default time-out value of the application domain in which it is created.</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 생성는 응용 프로그램 도메인의 기본 제한 시간 값을 사용 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object uses the value <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the operation from timing out. The recommended constructor for creating a <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object is <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">응용 프로그램 도메인에 대 한 시간 제한 값이 정의 되지 않은 경우는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 값을 사용 하는 개체 <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 작업이 시간 초과 방지 하는 합니다. 만들기 위한 권장된 생성자는 <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체가 <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that modify the regular expression.</source>
          <target state="translated">정규식을 수정하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression, with options that modify the pattern and a value that specifies how long a pattern matching method should attempt a match before it times out.</source>
          <target state="translated">시간이 초과되기 전에 패턴 일치 메서드가 일치하도록 시도해야 하는 시간을 지정한 패턴과 값을 수정할 수 있는 옵션을 사용하여 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 클래스의 새 인스턴스를 지정된 정규식에 대해 초기화하고 컴파일합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조는 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match pattern that you define when you create it.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 변경 불가능, 즉, 만들 때 정의 하는 일치 패턴에 대해서만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">그러나 수 있습니다 다시 컴파일하지 않고 여러 번 사용 합니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern-matching method should try to find a match before it times out. If no match is found in that time interval, the pattern-matching method throws a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 매개 변수 지정 시간에 패턴 일치 메서드는 시간이 초과 되기 전에 일치 항목을 찾을 시도해 야 합니다. 일치 항목이 없으면 해당 시간 간격에서 발견 되 면 패턴 일치 메서드가 throw 한 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값 재정의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The instance pattern-matching methods that observe the <ph id="ph1">`matchTimeout`</ph> time-out interval include the following:</source>
          <target state="translated">관찰 하는 인스턴스 패턴 일치 메서드는 <ph id="ph1">`matchTimeout`</ph> 시간 제한 간격에는 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">입력을 처리 하는 경우 응답을 중지 하 게 표시 되지 않도록 과도 한 역 추적을 사용 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 들어 있는입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>정규식에 대 한 유용한<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> 및 <bpt id="p2">[</bpt>역 추적<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To set a reasonable time-out interval, consider the following factors:</source>
          <target state="translated">적절 한 시간 제한 간격을 설정 하려면 다음 요소를 고려 합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The length and complexity of the regular expression pattern.</source>
          <target state="translated">길이 복잡 한 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Longer and more complex regular expressions require more time than shorter and simpler ones.</source>
          <target state="translated">길고 복잡 한 정규식 짧고 간단 것 보다 더 많은 시간이 필요합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The expected machine load.</source>
          <target state="translated">에서는 예상된 컴퓨터 로드 합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Processing takes more time on systems that have high CPU and memory utilization.</source>
          <target state="translated">처리는 높은 CPU 및 메모리 사용률을 갖는 시스템에서 많은 시간이 소요 됩니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with a time-out value of one second.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 생성자를 인스턴스화하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 1 초의 시간 제한 값을 가진 개체입니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`(a+)+$`</ph>, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</source>
          <target state="translated">줄의 끝에 하나 이상의 "a" 문자가 포함된 하나 이상의 시퀀스와 일치하는 정규식 패턴 <ph id="ph1">`(a+)+$`</ph>는 과도한 역추적의 대상이 됩니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> is thrown, the example increases the time-out value up to the maximum value of three seconds.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 가 throw이 예제에서는 시간 제한 값 3 초의 최대값까지 늘립니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Otherwise, it abandons the attempt to match the pattern.</source>
          <target state="translated">그렇지 않은 경우는 패턴 일치를 시도 중단 합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>은 유효한 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값이 아닙니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>이 음수, 0 또는 약 24일보다 큰 경우</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">설정 하는 것이 좋습니다는 <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 매개 변수를 2 초 등의 적절 한 값입니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">제한 시간을 사용 하지 않도록 지정 하 여 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">그러나 다음과 같은 경우에만 제한 시간을 비활성화 해야 합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 시기나 정적 텍스트로 구성 합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">가까운 일치 및 일치 하는 일치 하지 않는 경우 정규식 패턴에 철저히 테스트 효율적으로 처리 하는입니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">경우 정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Gets or sets the maximum number of entries in the current static cache of compiled regular expressions.</source>
          <target state="translated">컴파일된 정규식에 대한 현재 정적 캐시의 최대 엔트리 수를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The maximum number of entries in the static cache.</source>
          <target state="translated">현재 정적 캐시의 최대 엔트리 수입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class maintains an internal cache of compiled regular expressions used in static method calls.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스 정적 메서드 호출에 사용 된 컴파일된 정규식의 내부 캐시를 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>If the value specified in a set operation is less than the current cache size, cache entries are discarded until the cache size is equal to the specified value.</source>
          <target state="translated">Set 작업에 지정 된 값을 사용 하면 현재 캐시 크기 보다 작으면, 캐시 항목은 캐시 크기는 지정 된 값과 같은 될 때까지 삭제 됩니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>By default, the cache holds 15 compiled static regular expressions.</source>
          <target state="translated">기본적으로 캐시 15 컴파일된 정적 정규식을 보유 합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Your application typically will not have to modify the size of the cache.</source>
          <target state="translated">캐시의 크기를 수정 하려면 일반적으로 응용 프로그램을 설치 하지 않아도 됩니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A&gt;</ph> property only when you want to turn off caching or when you have an unusually large cache.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A&gt;</ph> 캐싱 나 매우 큰 캐시를 보유 하는 경우 해제 하려는 경우에 속성입니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The value in a set operation is less than zero.</source>
          <target state="translated">Set 작업의 값이 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>In the .NET Framework prior to the <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, regular expressions used in both static and instance method calls were cached.</source>
          <target state="translated">이전에.NET framework는 <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, 정적에 사용 되는 정규식 및 캐시 된 인스턴스 메서드 호출 합니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, only regular expressions used in static method calls are cached.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>regular만, 정적 메서드 호출에 사용 되는 식은 캐시 됩니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capnames">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드에서 생성되는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체에서 사용됩니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>Gets or sets a dictionary that maps named capturing groups to their index values.</source>
          <target state="translated">명명된 캡처링 그룹을 인덱스 값에 매핑하는 사전을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>A dictionary that maps named capturing groups to their index values.</source>
          <target state="translated">명명된 캡처링 그룹을 인덱스 값에 매핑하는 사전입니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>Note that this property is protected; it can only be accessed from a class derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">참고는이 속성은 보호 됩니다. 파생 된 클래스에서만 액세스할 수 있습니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>A set operation attempts to convert the value assigned to the property to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object; if this conversion fails, it calls the <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Set 작업 속성에 할당 된 값으로 변환 하려고 한 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체;이 변환에 실패 하는 경우 호출 하는 <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>The value assigned to the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.CapNames" /&gt;</ph> property in a set operation is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">집합 작업의 <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.CapNames" /&gt;</ph> 속성에 할당된 값은 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.caps">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드에서 생성되는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체에서 사용됩니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>Gets or sets a dictionary that maps numbered capturing groups to their index values.</source>
          <target state="translated">번호가 매겨진 캡처링 그룹을 인덱스 값에 매핑하는 사전을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>A dictionary that maps numbered capturing groups to their index values.</source>
          <target state="translated">번호가 매겨진 캡처링 그룹을 인덱스 값에 매핑하는 사전입니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>Note that this property is protected; it can only be accessed from a class derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">참고는이 속성은 보호 됩니다. 파생 된 클래스에서만 액세스할 수 있습니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>A set operation attempts to convert the value assigned to the property to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object; if this conversion fails, it calls the <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Set 작업 속성에 할당 된 값으로 변환 하려고 한 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체;이 변환에 실패 하는 경우 호출 하는 <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>The value assigned to the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Caps" /&gt;</ph> property in a set operation is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">집합 작업의 <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Caps" /&gt;</ph> 속성에 할당된 값은 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capsize">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드에서 생성되는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체에서 사용됩니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capslist">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드에서 생성되는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체에서 사용됩니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Compiles regular expressions and saves them to disk in a single assembly.</source>
          <target state="translated">정규식을 컴파일하고 단일 어셈블리의 디스크에 저장합니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">컴파일할 정규식을 설명하는 배열입니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The file name of the assembly.</source>
          <target state="translated">어셈블리의 파일 이름입니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects to a named assembly.</source>
          <target state="translated">하나 이상의 지정된 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체를 명명된 어셈블리로 컴파일합니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph2">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> 각각의 정규식에서 정의에서.NET Framework 어셈블리를 생성 하는 메서드는 <ph id="ph2">`regexinfos`</ph> 배열 클래스로 표현 됩니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">일반적으로 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> 컴파일된 정규식의 어셈블리를 생성 하는 별도 응용 프로그램에서 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">어셈블리에 포함 된 각 정규식에는 다음과 같은 특징이 있습니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">파생 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">정의 된 정규화 된 이름이 할당 됩니다는 <ph id="ph1">`fullnamespace`</ph> 및 <ph id="ph2">`name`</ph> 해당 매개 변수 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">(또는 매개 변수가 없는) 기본 생성자입니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">일반적으로 코드를 인스턴스화하고 컴파일된 정규식을 사용 하는 어셈블리 또는 어셈블리를 만드는 코드에서 별도 응용 프로그램에 있습니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The following example creates an assembly named RegexLib.dll.</source>
          <target state="translated">다음 예제에서는 RegexLib.dll 이라는 어셈블리를 만듭니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The assembly includes two compiled regular expressions.</source>
          <target state="translated">어셈블리에 두 개의 컴파일된 정규식에 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The first, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, matches two identical contiguous words.</source>
          <target state="translated">첫 번째 <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, 동일한 두 개의 연속 단어와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The second, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, checks whether a string has the correct format to be an email address.</source>
          <target state="translated">두 번째 페이지인 <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, 문자열이 올바른 형식으로 전자 메일 주소에 있는지 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</source>
          <target state="translated">중복 된 단어에 대 한 문자열을 검사 하는 정규식은 다음 의해 인스턴스화되어 사용 되며 다음 예제에서는 합니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</source>
          <target state="translated">이 두 번째 예제의 컴파일이 성공 프로젝트에 추가할 RegexLib.dll (첫 번째 예제에서 생성 된 어셈블리)에 대 한 참조가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 매개 변수의 <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> 속성 값이 비어 있거나 null 문자열인 경우</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph>에 있는 개체 중 하나 이상의 정규식 패턴에 잘못된 구문이 포함된 경우</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">있는 시스템에서 개발 하는 경우 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> 대상 설치 해당 포인트 릴리스 또는 <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>를 사용 하는 <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> 포함 된 어셈블리를 만드는 메서드를 컴파일된 정규식입니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">가 시스템에서 어셈블리에 있는 정규식 중 하나를 사용 하는 동안 <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">이 문제를 해결하기 위해서는 다음 중 하나를 수행합니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">포함 된 시스템에서 컴파일된 정규식이 포함 된 어셈블리를 빌드합니다 <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> 이상 버전이 설치 된 대신 합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">호출 하는 대신 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> 사용 정적 또는 인스턴스를 어셈블리에서 컴파일된 정규식을 검색 하 고 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 있는 메서드는 <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> 인스턴스화할 때 옵션는 <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 정규식 호출할 또는 개체 패턴 일치 하는 메서드.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">컴파일할 정규식을 설명하는 배열입니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The file name of the assembly.</source>
          <target state="translated">어셈블리의 파일 이름입니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>An array that defines the attributes to apply to the assembly.</source>
          <target state="translated">어셈블리에 적용할 특성을 정의하는 배열입니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects to a named assembly with the specified attributes.</source>
          <target state="translated">지정된 특성을 사용하여 하나 이상의 지정된 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체를 명명된 어셈블리로 컴파일합니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph2">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> 각각의 정규식에서 정의에서.NET Framework 어셈블리를 생성 하는 메서드는 <ph id="ph2">`regexinfos`</ph> 배열 클래스로 표현 됩니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">일반적으로 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> 컴파일된 정규식의 어셈블리를 생성 하는 별도 응용 프로그램에서 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">어셈블리에 포함 된 각 정규식에는 다음과 같은 특징이 있습니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">파생 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">정의 된 정규화 된 이름이 할당 됩니다는 <ph id="ph1">`fullnamespace`</ph> 및 <ph id="ph2">`name`</ph> 해당 매개 변수 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">(또는 매개 변수가 없는) 기본 생성자입니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">일반적으로 코드를 인스턴스화하고 컴파일된 정규식을 사용 하는 어셈블리 또는 어셈블리를 만드는 코드에서 별도 응용 프로그램에 있습니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as <ph id="ph2">`class`</ph> in C# or <ph id="ph3">`Class`</ph>…<ph id="ph4">`End Class`</ph></source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> 특정 언어의 클래스 정의 키워드를 사용 하는 대신 메서드 호출에서.NET Framework 어셈블리를 생성 하는 메서드 (같은 <ph id="ph2">`class`</ph> C# 또는 <ph id="ph3">`Class`</ph>...<ph id="ph4">`End Class`</ph></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</source>
          <target state="translated">Visual basic)에서는.NET Framework 특성 개발 언어 표준 특성 구문을 사용 하 여 어셈블리에 할당할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The <ph id="ph1">`attributes`</ph> parameter provides an alternative method for defining the attributes that apply to the assembly.</source>
          <target state="translated"><ph id="ph1">`attributes`</ph> 매개 변수는 어셈블리에 적용 되는 특성을 정의 하기 위한 대체 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>For each attribute that you want to apply to the assembly, do the following:</source>
          <target state="translated">어셈블리에 적용 하려는 각 특성에 대해 다음을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Create an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing the parameter types of the attribute constructor that you want to call.</source>
          <target state="translated">배열을 만들어 <ph id="ph1">&lt;xref:System.Type&gt;</ph> 호출 하고자 하는 특성 생성자의 매개 변수 형식을 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Retrieve a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing the attribute class that you want to apply to the new assembly.</source>
          <target state="translated">검색 한 <ph id="ph1">&lt;xref:System.Type&gt;</ph> 새 어셈블리에 적용할 특성 클래스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method of the attribute <ph id="ph2">&lt;xref:System.Type&gt;</ph> object to retrieve a <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object representing the attribute constructor that you want to call.</source>
          <target state="translated">호출의 <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> 메서드 특성의 <ph id="ph2">&lt;xref:System.Type&gt;</ph> 검색할 개체는 <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> 호출 하고자 하는 특성 생성자를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Pass the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method the array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects that represents the constructor's parameter types.</source>
          <target state="translated">전달 된 <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> 메서드 배열의 <ph id="ph2">&lt;xref:System.Type&gt;</ph> 생성자의 매개 변수 형식을 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Create a <ph id="ph1">&lt;xref:System.Object&gt;</ph> array that defines the parameters to pass to the attribute's constructor.</source>
          <target state="translated">만들기는 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 특성의 생성자에 전달할 매개 변수를 정의 하는 배열입니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Instantiate a <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> object by passing its constructor the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object retrieved in step 3 and the <ph id="ph3">&lt;xref:System.Object&gt;</ph> array created in step 4.</source>
          <target state="translated">인스턴스화하는 <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> 생성자에 전달 하 여 개체는 <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> 3 단계에서 개체 검색 및 <ph id="ph3">&lt;xref:System.Object&gt;</ph> 4 단계에서 만든 배열입니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>You can then pass an array of these <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects instead of the <ph id="ph2">`attributes`</ph> parameter to the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">그런 다음 이러한 배열을 전달 <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> 개체 대신는 <ph id="ph2">`attributes`</ph> 매개 변수를는 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The following example creates an assembly named RegexLib.dll and applies the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute to it.</source>
          <target state="translated">다음 예제에서는 RegexLib.dll 이라는 어셈블리를 만들고 적용 하는 <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> 특성을 합니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The assembly includes two compiled regular expressions.</source>
          <target state="translated">어셈블리에 두 개의 컴파일된 정규식에 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The first, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, matches two identical contiguous words.</source>
          <target state="translated">첫 번째 <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, 동일한 두 개의 연속 단어와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The second, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, checks whether a string has the correct format to be an email address.</source>
          <target state="translated">두 번째 페이지인 <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, 문자열이 올바른 형식으로 전자 메일 주소에 있는지 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>You can verify that the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute has been applied to the assembly by examining its manifest with a reflection utility such as ILDasm.</source>
          <target state="translated">확인할 수 있습니다는 <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> 특성이 해당 매니페스트 ILDasm 같은 리플렉션 유틸리티를 검사 하 여 어셈블리에 적용 되었습니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</source>
          <target state="translated">중복 된 단어에 대 한 문자열을 검사 하는 정규식은 다음 의해 인스턴스화되어 사용 되며 다음 예제에서는 합니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</source>
          <target state="translated">이 두 번째 예제의 컴파일이 성공 프로젝트에 추가할 RegexLib.dll (첫 번째 예제에서 생성 된 어셈블리)에 대 한 참조가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 매개 변수의 <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> 속성 값이 비어 있거나 null 문자열인 경우</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph>에 있는 개체 중 하나 이상의 정규식 패턴에 잘못된 구문이 포함된 경우</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">있는 시스템에서 개발 하는 경우 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> 대상 설치 해당 포인트 릴리스 또는 <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>를 사용 하는 <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> 포함 된 어셈블리를 만드는 메서드를 컴파일된 정규식입니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">가 시스템에서 어셈블리에 있는 정규식 중 하나를 사용 하는 동안 <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">이 문제를 해결하기 위해서는 다음 중 하나를 수행합니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">포함 된 시스템에서 컴파일된 정규식이 포함 된 어셈블리를 빌드합니다 <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> 이상 버전이 설치 된 대신 합니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">호출 하는 대신 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> 사용 정적 또는 인스턴스를 어셈블리에서 컴파일된 정규식을 검색 하 고 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 있는 메서드는 <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> 인스턴스화할 때 옵션는 <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 정규식 호출할 또는 개체 패턴 일치 하는 메서드.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">컴파일할 정규식을 설명하는 배열입니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The file name of the assembly.</source>
          <target state="translated">어셈블리의 파일 이름입니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>An array that defines the attributes to apply to the assembly.</source>
          <target state="translated">어셈블리에 적용할 특성을 정의하는 배열입니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The name of the Win32 resource file to include in the assembly.</source>
          <target state="translated">어셈블리에 포함될 Win32 리소스 파일의 이름입니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects and a specified resource file to a named assembly with the specified attributes.</source>
          <target state="translated">지정된 특성을 사용하여 하나 이상의 지정된 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체와 지정된 리소스 파일을 명명된 어셈블리로 컴파일합니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph3">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated">The [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph3">`regexinfos`</ph> array is represented by a class.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Typically, the [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">일반적으로 [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 &gt; 컴파일된 정규식의 어셈블리를 생성 하는 별도 응용 프로그램에서 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">어셈블리에 포함 된 각 정규식에는 다음과 같은 특징이 있습니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">파생 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">정의 된 정규화 된 이름이 할당 됩니다는 <ph id="ph1">`fullnamespace`</ph> 및 <ph id="ph2">`name`</ph> 해당 매개 변수 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">(또는 매개 변수가 없는) 기본 생성자입니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">일반적으로 코드를 인스턴스화하고 컴파일된 정규식을 사용 하는 어셈블리 또는 어셈블리를 만드는 코드에서 별도 응용 프로그램에 있습니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as <ph id="ph2">`class`</ph> in C# or <ph id="ph3">`Class`</ph>…<ph id="ph4">`End Class`</ph></source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> 특정 언어의 클래스 정의 키워드를 사용 하는 대신 메서드 호출에서.NET Framework 어셈블리를 생성 하는 메서드 (같은 <ph id="ph2">`class`</ph> C# 또는 <ph id="ph3">`Class`</ph>...<ph id="ph4">`End Class`</ph></target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</source>
          <target state="translated">Visual basic)에서는.NET Framework 특성 개발 언어 표준 특성 구문을 사용 하 여 어셈블리에 할당할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The <ph id="ph1">`attributes`</ph> parameter provides an alternative method for defining the attributes that apply to the assembly.</source>
          <target state="translated"><ph id="ph1">`attributes`</ph> 매개 변수는 어셈블리에 적용 되는 특성을 정의 하기 위한 대체 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>For each attribute that you want to apply to the assembly, do the following:</source>
          <target state="translated">어셈블리에 적용 하려는 각 특성에 대해 다음을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Create an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing the parameter types of the attribute constructor that you want to call.</source>
          <target state="translated">배열을 만들어 <ph id="ph1">&lt;xref:System.Type&gt;</ph> 호출 하고자 하는 특성 생성자의 매개 변수 형식을 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Retrieve a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing the attribute class that you want to apply to the new assembly.</source>
          <target state="translated">검색 한 <ph id="ph1">&lt;xref:System.Type&gt;</ph> 새 어셈블리에 적용할 특성 클래스를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method of the attribute <ph id="ph2">&lt;xref:System.Type&gt;</ph> object to retrieve a <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object representing the attribute constructor that you want to call.</source>
          <target state="translated">호출의 <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> 메서드 특성의 <ph id="ph2">&lt;xref:System.Type&gt;</ph> 검색할 개체는 <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> 호출 하고자 하는 특성 생성자를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Pass the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method the array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects that represents the constructor's parameter types</source>
          <target state="translated">전달 된 <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> 메서드 배열의 <ph id="ph2">&lt;xref:System.Type&gt;</ph> 생성자의 매개 변수 형식을 나타내는 개체</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Create a <ph id="ph1">&lt;xref:System.Object&gt;</ph> array that defines the parameters to pass to the attribute's constructor.</source>
          <target state="translated">만들기는 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 특성의 생성자에 전달할 매개 변수를 정의 하는 배열입니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Instantiate a <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> object by passing its constructor the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object retrieved in step 3 and the <ph id="ph3">&lt;xref:System.Object&gt;</ph> array created in step 4.</source>
          <target state="translated">인스턴스화하는 <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> 생성자에 전달 하 여 개체는 <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> 3 단계에서 개체 검색 및 <ph id="ph3">&lt;xref:System.Object&gt;</ph> 4 단계에서 만든 배열입니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>You can then pass an array of these <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects instead of the <ph id="ph2">`attributes`</ph> parameter to the [<ph id="ph3">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph4">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method.</source>
          <target state="translated">그런 다음 이러한 배열을 전달 <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> 개체 대신는 <ph id="ph2">`attributes`</ph> 매개 변수를는 [<ph id="ph3">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph4">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 &gt; 메서드.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 매개 변수의 <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> 속성 값이 비어 있거나 null 문자열인 경우</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph>에 있는 개체 중 하나 이상의 정규식 패턴에 잘못된 구문이 포함된 경우</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> parameter designates an invalid Win32 resource file.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> 매개 변수가 잘못된 Win32 리소스 파일을 지정합니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The file designated by the <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> parameter cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> 매개 변수가 지정된 파일을 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">있는 시스템에서 개발 하는 경우 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> 대상 설치 해당 포인트 릴리스 또는 <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>를 사용 하는 <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> 포함 된 어셈블리를 만드는 메서드를 컴파일된 정규식입니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">가 시스템에서 어셈블리에 있는 정규식 중 하나를 사용 하는 동안 <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">이 문제를 해결하기 위해서는 다음 중 하나를 수행합니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">포함 된 시스템에서 컴파일된 정규식이 포함 된 어셈블리를 빌드합니다 <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> 이상 버전이 설치 된 대신 합니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">호출 하는 대신 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> 사용 정적 또는 인스턴스를 어셈블리에서 컴파일된 정규식을 검색 하 고 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 있는 메서드는 <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> 인스턴스화할 때 옵션는 <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 정규식 호출할 또는 개체 패턴 일치 하는 메서드.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The input string that contains the text to convert.</source>
          <target state="translated">변환할 텍스트가 포함된 입력 문자열입니다.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Escapes a minimal set of characters (<ph id="ph1">\\</ph>, *, +, ?, |, {, [, (,), ^, $,., #, and white space) by replacing them with their escape codes.</source>
          <target state="translated">문자(<ph id="ph1">\\</ph>, *, +, ?, |, {, [, (,), ^, $,., # 및 공백)의 최소 집합을 자체 이스케이프 코드로 대체하여 이스케이프합니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>This instructs the regular expression engine to interpret these characters literally rather than as metacharacters.</source>
          <target state="translated">이렇게 하면 정규식 엔진은 이러한 문자를 메타문자가 아니라 문자 그대로 해석합니다.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>A string of characters with metacharacters converted to their escaped form.</source>
          <target state="translated">메타문자가 이스케이프 서식으로 변환된 문자열입니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> converts a string so that the regular expression engine will interpret any metacharacters that it may contain as character literals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> 정규식 엔진은 문자 리터럴으로 포함 될 수 있는 모든 메타 문자를 해석할 수 있도록 문자열로 변환 합니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>For example, consider a regular expression that is designed to extract comments that are delimited by straight opening and closing brackets ([ and ]) from text.</source>
          <target state="translated">예를 들어, 정규식을 직선 열고 닫는 대괄호 ([및]) 텍스트와에서 구분 되는 주석을 추출 하도록 디자인 된 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In the following example, the regular expression "[(.*?)]" is interpreted as a character class.</source>
          <target state="translated">다음 예제에서는 정규식에에서 "[(.*?)]"는 문자 클래스로 해석 됩니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Rather than matching comments embedded in the input text, the regular expression matches each opening or closing parenthesis, period, asterisk, or question mark.</source>
          <target state="translated">입력된 텍스트에 포함 된 주석과 일치 대신 정규식 각 열기 또는 닫는 괄호, 기간, 별표, 또는 매개 변수를 찾습니다.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>However, if the opening bracket is escaped by passing it to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method, the regular expression succeeds in matching comments that are embedded in the input string.</source>
          <target state="translated">그러나 왼쪽 괄호를 전달 하 여 이스케이프 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> 메서드를 정규식 일치는 입력된 문자열에 포함 된 주석에서 성공 합니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The following example illustrates this.</source>
          <target state="translated">다음은 이에 대한 예입니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In a regular expression that is defined by using static text, characters that are to be interpreted literally rather than as metacharacters can be escaped by preceding them with a backslash symbol (<ph id="ph1">\\</ph>) as well as by calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method.</source>
          <target state="translated">정적 텍스트를 사용 하 여 정의 된 정규식을 메타 문자가 아닌 문자 그대로 해석 되어야 하는 문자는 백슬래시 기호 앞에 이스케이프 될 수 있습니다 (<ph id="ph1">\\</ph>) 및 호출 된 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In a regular expression that is defined dynamically using characters that are not known at design time, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method is particularly important to ensure that the regular expression engine interprets individual characters as literals rather than as metacharacters.</source>
          <target state="translated">디자인 타임에 알 수 없는 문자를 사용 하 여 동적으로 정의 된 정규식에서 호출 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> 메서드는 정규식 엔진에서 해석 하는 개별 문자 리터럴로 대신 구하도록 보다 메타 문자가 있습니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If a regular expression pattern includes either the number sign (#) or literal white-space characters, they must be escaped if input text is parsed with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option enabled.</source>
          <target state="translated">정규식 패턴에서 숫자 기호 (#) 또는 리터럴 공백 문자를 포함 하는 경우에 이스케이프 되어야 입력된 텍스트는으로 구문 분석 하는 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> 옵션을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>While the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method escapes the straight opening bracket ([) and opening brace ({) characters, it does not escape their corresponding closing characters (] and }).</source>
          <target state="translated">반면는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> 메서드는 직선 이스케이프 여는 대괄호 () 하 고 여는 중괄호 ({) 문자를 해당 이스케이프 하지 않습니다의 해당 문자를 닫는 (] 및}).</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In most cases, escaping these is not necessary.</source>
          <target state="translated">대부분의 경우에서 이러한 이스케이프 필요는 없습니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If a closing bracket or brace is not preceded by its corresponding opening character, the regular expression engine interprets it literally.</source>
          <target state="translated">닫는 대괄호 또는 중괄호는 앞에 해당 여는 문자가, 정규식 엔진은 것를 문자 그대로 해석 합니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If an opening braket or brace is interpreted as a metacharacter, the regular expression engine interprets the first corresponding closing character as a metacharacter.</source>
          <target state="translated">여는 대괄호 또는 중괄호 메타로 해석 되, 정규식 엔진은 첫 번째 해당 닫는 문자 메타으로 해석 됩니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If this is not the desired behavior, the closing bracket or brace should be escaped by explicitly prepending the backslash (<ph id="ph1">\\</ph>) character.</source>
          <target state="translated">이것이 원하는 동작 하는 경우 닫는 대괄호 또는 중괄호를 이스케이프 해야 백슬래시 앞에 명시적으로 추가 (<ph id="ph1">\\</ph>) 문자.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>For an illustration, see the Example section.</source>
          <target state="translated">예시의 경우 "예" 섹션을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The following example extracts comments from text.</source>
          <target state="translated">다음 예제에서는 텍스트에서 의견을 추출합니다.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>It assumes that the comments are delimited by a begin comment symbol and an end comment symbol that is selected by the user.</source>
          <target state="translated">주석은 begin 주석 기호 및 사용자가 선택 되어 있는 종료 주석 기호로 구분 됩니다 가정 합니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Because the comment symbols are to be interpreted literally, they are passed to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method to ensure that they cannot be misinterpreted as metacharacters.</source>
          <target state="translated">에 전달 되므로 이기 때문에 주석 기호 문자 그대로 해석 하는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> 메서드를 메타 문자가 해석 없습니다 것을 확인 합니다.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In addition, the example explicitly checks whether the end comment symbol entered by the user is a closing bracket (]) or brace (}).</source>
          <target state="translated">또한이 예제는 명시적으로 사용자가 입력 한 종료 주석 기호 닫는 대괄호 (]) 또는 중괄호 (}) 있는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If it is, a backslash character (<ph id="ph1">\\</ph>) is prepended to the bracket or brace so that it is interpreted literally.</source>
          <target state="translated">그럴 경우 백슬래시 문자 (<ph id="ph1">\\</ph>) 앞에 추가 되는 대괄호 또는 중괄호 문자 그대로 해석 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Note that the example also uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> collection to display the comment only, rather than the comment together with its opening and closing comment symbols.</source>
          <target state="translated">또한 참고는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> 중괄호와 닫는 주석 기호 함께 설명 하는 대신만 메모를 표시 하는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.factory">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드에서 생성되는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체에서 사용됩니다.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Returns an array of capturing group names for the regular expression.</source>
          <target state="translated">정규식에 대한 캡처링 그룹 이름의 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>A string array of group names.</source>
          <target state="translated">그룹 이름의 문자열 배열입니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The collection of group names contains the set of strings used to name capturing groups in the expression.</source>
          <target state="translated">그룹 이름 컬렉션을 집합 식에서 캡처링 그룹의 이름 사용 하는 문자열을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Even if capturing groups are not explicitly named, they are automatically assigned numerical names ("0", "1", "2", "3", and so on).</source>
          <target state="translated">숫자 이름이 자동으로 할당 된 캡처링 그룹의 명시적으로 이름이 지정 되지 않은 경우에 ("0", "1", "2", "3", 및 등).</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The "0" named group represents all text matched by the regular expression pattern.</source>
          <target state="translated">"0" 그룹 나타냅니다 정규식 패턴과 일치 하는 모든 텍스트를 지정 된 합니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Numbered groups precede explicitly named groups in the collection, and named groups appear in the order in which they are defined in the regular expression pattern.</source>
          <target state="translated">컬렉션에 명시적으로 명명 된 그룹 앞에 번호가 매겨진된 그룹 및 명명 된 그룹은 정규식 패턴에 정의 된 순서로 표시 합니다.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>You can use the <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property on the array returned by this method to determine the number of groups in a regular expression.</source>
          <target state="translated">사용할 수는 <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> 정규식에서 그룹의 수를 확인 하려면이 메서드에서 반환 된 배열에는 속성입니다.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The following example defines a general-purpose <ph id="ph1">`ShowMatches`</ph> method that displays the names of regular expression groups and their matched text.</source>
          <target state="translated">다음 예제에서는 정의 범용 <ph id="ph1">`ShowMatches`</ph> 정규식 그룹과 일치 하는 텍스트의 이름을 표시 하는 메서드입니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>In this case, the regular expression pattern <ph id="ph1">`\b(?&lt;FirstWord&gt;\w+)\s?((\w+)\s)*(?&lt;LastWord&gt;\w+)?(?&lt;Punctuation&gt;\p{Po})`</ph> is intended to parse a simple sentence, and to identify its first word, last word, and ending punctuation mark.</source>
          <target state="translated">이 경우, 정규식 패턴 <ph id="ph1">`\b(?&lt;FirstWord&gt;\w+)\s?((\w+)\s)*(?&lt;LastWord&gt;\w+)?(?&lt;Punctuation&gt;\p{Po})`</ph> 의 첫 번째 단어, 마지막 단어 및 끝 문장 부호를 식별 하 고 간단한 문장을 구문 분석을 위한 것입니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The following table shows how the regular expression pattern is interpreted:</source>
          <target state="translated">다음 표에서 정규식 패턴이 해석 되는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`FirstWord`</ph> named group.</source>
          <target state="translated">이는 <ph id="ph1">`FirstWord`</ph> 명명 된 그룹입니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>\s?</source>
          <target state="translated">\s?</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or one white-space characters.</source>
          <target state="translated">0회 이상 나오는 공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(\w+)</source>
          <target state="translated">(\w+)</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the second capturing group.</source>
          <target state="translated">이 그룹은 두 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>\s</source>
          <target state="translated">\s</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match a white-space character.</source>
          <target state="translated">공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>((\w+)\s)*</source>
          <target state="translated">((\w+)\s)*</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or more occurrences of one or more word characters followed by a white space.</source>
          <target state="translated">일치 항목 0 개 이상의 단어 문자 하나 이상의 공백 뒤의 합니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the first capturing group.</source>
          <target state="translated">이 그룹은 첫 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(?<ph id="ph1">\&lt;</ph>LastWord&gt;\w+)?</source>
          <target state="translated">(?<ph id="ph1">\&lt;</ph>LastWord&gt;\w+)?</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or one occurrence of one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자 0 회 이상 발생을 찾습니다.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`LastWord`</ph> named group.</source>
          <target state="translated">이는 <ph id="ph1">`LastWord`</ph> 명명 된 그룹입니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(?<ph id="ph1">\&lt;</ph>Punctuation&gt;\p{Po})</source>
          <target state="translated">(? <ph id="ph1">\&lt;</ph>문장 부호 &gt; \p{Po})</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match a character whose Unicode category is Punctuation, Other.</source>
          <target state="translated">문자를 유니코드 범주는 문장 부호, 기타 합니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`Punctuation`</ph> named group.</source>
          <target state="translated">이는 <ph id="ph1">`Punctuation`</ph> 명명 된 그룹입니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Returns an array of capturing group numbers that correspond to group names in an array.</source>
          <target state="translated">배열 내의 그룹 이름에 해당하는 캡처링 그룹 번호의 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>An integer array of group numbers.</source>
          <target state="translated">그룹 번호의 정수 배열입니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Both unnamed and named capturing groups can be accessed by number.</source>
          <target state="translated">명명 되지 않은 및 명명 된 캡처링 그룹 수로 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Unnamed groups are numbered from left to right starting with 1.</source>
          <target state="translated">명명 되지 않은 그룹 왼쪽에서 오른쪽 1부터 매겨집니다.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>(The capturing group in index 0 (zero) represents the match as a whole.)  Named groups are then numbered from left to right starting with a number that is one greater than the number of unnamed capturing groups.</source>
          <target state="translated">(인덱스 0 (영) 캡처링 그룹이 나타냅니다 일치를 하는 전체.)  명명 된 그룹은 다음 왼쪽에서 번호가 매겨진 1 더 큰 숫자를 오른쪽부터 수보다 명명 되지 않은 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Referencing a group by its number instead of by string name can provide faster access.</source>
          <target state="translated">문자열 이름으로 참조 하는 대신 해당 번호로 그룹 빠른 액세스를 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The following example defines a regular expression, <ph id="ph1">`\b((?&lt;word&gt;\w+)\s*)+(?&lt;end&gt;[.?!])`</ph>, that matches a sentence.</source>
          <target state="translated">다음 예제에서는 정규식을 정의 <ph id="ph1">`\b((?&lt;word&gt;\w+)\s*)+(?&lt;end&gt;[.?!])`</ph>, 문장 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The regular expression includes three capturing groups: an unnamed group that captures an individual word along with a space character that may follow it; a group named <ph id="ph1">`word`</ph> that captures the individual words in the sentence; and a group named <ph id="ph2">`end`</ph> that captures the punctuation that ends the sentence.</source>
          <target state="translated">세 가지 캡처링 그룹을 포함 하는 정규식: 함께 하며 다음에 올 수 있는 공백 문자는 개별 단어를 캡처하는 명명 되지 않은 그룹 라는 그룹 <ph id="ph1">`word`</ph> 을 캡처하는 개별 단어는 문장;에서 및 그룹 이라는 <ph id="ph2">`end`</ph> 문장 끝나는 문장 부호를 캡처하는 합니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A&gt;</ph> method to get the numbers of all capturing groups, and then displays their captured string.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A&gt;</ph> 모든 캡처의 번호를 가져올 메서드를 그룹, 한 다음 캡처된 해당 문자열을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method is used to indicate whether a particular numbered group corresponds to a named group.</source>
          <target state="translated">또한는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> 메서드는 특정 번호가 매겨진된 그룹 명명 된 그룹에 해당 하는지 여부를 나타내는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">정규식 패턴은 다음 테이블과 같이 해석됩니다.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match one or more word characters and assign the matched strings to a group named <ph id="ph1">`word`</ph>.</source>
          <target state="translated">일치 하는 문자열 라는 그룹을 할당 하 고 하나 이상의 단어 문자를 찾습니다 <ph id="ph1">`word`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">0개 이상의 공백 문자가 일치하는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Assign the <ph id="ph1">`word`</ph> captured group followed by any captured white-space characters to the first captured group.</source>
          <target state="translated">할당 된 <ph id="ph1">`word`</ph> 된 캡처된 그룹 캡처된 첫 번째 캡처 그룹에 공백 문자입니다.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match the pattern of one or more word characters followed by any white-space characters one or more times.</source>
          <target state="translated">하나 이상의 단어 문자 다음에 모든 공백 문자가 한 번 이상 패턴과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match a period, question mark, or exclamation point.</source>
          <target state="translated">마침표, 물음표 또는 느낌표를 찾습니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Assign the matched character to the <ph id="ph1">`end`</ph> capturing group.</source>
          <target state="translated">일치 하는 문자를 할당 된 <ph id="ph1">`end`</ph> 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The group number to convert to the corresponding group name.</source>
          <target state="translated">해당 그룹 이름으로 변환할 그룹 번호입니다.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Gets the group name that corresponds to the specified group number.</source>
          <target state="translated">지정된 그룹 번호에 해당하는 그룹 이름을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>A string that contains the group name associated with the specified group number.</source>
          <target state="translated">지정된 그룹 번호에 연결되어 있는 그룹 이름이 포함된 문자열입니다.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If there is no group name that corresponds to <ph id="ph1">&lt;paramref name="i" /&gt;</ph>, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="i" /&gt;</ph>에 해당하는 그룹 이름이 없는 경우 이 메서드는 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</source>
          <target state="translated">정규식 패턴에 명명 되거나 번호가 매겨진 캡처링 그룹 내의 패턴 일치를 사용 하는 하위 식을 나타내는 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Numbered groups are delimited by the syntax (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) and are assigned numbers based on their order in the regular expression.</source>
          <target state="translated">번호가 매겨진된 그룹 구문에 의해 구분 됩니다 (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) 정규식에서의 순서에 따라 숫자 할당 됩니다.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Named groups are delimited by the syntax (?<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?'<bpt id="p3">*</bpt>name<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>), where <bpt id="p5">*</bpt>name<ept id="p5">*</ept> is the name by which the subexpression will be identified.</source>
          <target state="translated">명명 된 그룹 구문에 의해 구분 됩니다 (?<ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>이름<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) 또는 (?' <bpt id="p3">*</bpt>이름<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>) 여기서 <bpt id="p5">*</bpt>이름<ept id="p5">*</ept> 부분식을 식별 하는 이름입니다.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>그룹화 구문<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>을 참조하세요. <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> 메서드는 명명 된 그룹 및 서 수 위치로 정규식에서 번호가 매겨진된 그룹 모두를 식별 합니다.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Ordinal position zero always represents the entire regular expression.</source>
          <target state="translated">서 수 위치 0에는 항상 전체 정규식을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</source>
          <target state="translated">번호가 매겨진 모든 그룹의 정규식 패턴에서의 실제 위치에 관계 없이 명명 된 그룹 하기 전에 다음 계산 됩니다.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is the number of a named group, the method returns the name of the group.</source>
          <target state="translated">경우 <ph id="ph1">`i`</ph> 수 명명된 된 그룹의 메서드는 그룹의 이름을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is the number of an unnamed group, the method returns the string representation of the number.</source>
          <target state="translated">경우 <ph id="ph1">`i`</ph> 수 명명 되지 않은 그룹의 메서드는 숫자의 문자열 표현을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>For example, if <ph id="ph1">`i`</ph> is 1, the method returns "1".</source>
          <target state="translated">예를 들어 경우 <ph id="ph1">`i`</ph> 는 1, "1" 메서드를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is not the number of a capturing group, the method returns <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`i`</ph> 가 아닌 경우는 캡처링 그룹 메서드 반환 <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If a pattern match is found, the value returned by this method can then be used to retrieve the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object that represents the captured group from the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">패턴 일치를 사용 하는 항목이 있는 경우이 메서드에서 반환 되는 값 다음 사용할 수를 검색 하는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> 에서 캡처된 그룹을 나타내는 개체는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> 개체에서 반환 된 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The following example defines a regular expression pattern that matches an address line containing a U.S. city name, state name, and zip code.</source>
          <target state="translated">다음 예제에서는 미국 도시 이름, 상태 이름 및 우편 번호를 포함 하는 주소 줄 일치 하는 정규식 패턴을 정의 합니다.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method to retrieve the names of capturing groups.</source>
          <target state="translated">이 예제에서는 사용은 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> 캡처링 그룹의 이름을 검색 하는 메서드입니다.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>It then uses these names to retrieve the corresponding captured groups for matches.</source>
          <target state="translated">다음이 이름을 사용 하 여 일치 하는 항목에 대 한 해당 캡처된 그룹을 검색 합니다.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">정규식 패턴은 다음 식으로 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match one or more alphabetic or white-space character.</source>
          <target state="translated">하나 이상의 영문자 또는 공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`city`</ph>.</source>
          <target state="translated">이 캡처된 그룹의 이름을 할당 <ph id="ph1">`city`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match a comma (,) followed by a white-space character.</source>
          <target state="translated">쉼표 (,) 뒤에 공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match two alphabetic characters.</source>
          <target state="translated">두 개의 알파벳 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`state`</ph>.</source>
          <target state="translated">이 캡처된 그룹의 이름을 할당 <ph id="ph1">`state`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>This group should be followed by a white-space character.</source>
          <target state="translated">이 그룹 뒤에 공백 문자가 야 합니다.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match five numeric digits followed by either zero or one occurrence of a hyphen followed by four digits.</source>
          <target state="translated">5 자리 숫자를 4 자리 숫자가 나오는 하이픈 0 개 또는 1 번째와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`zip`</ph>.</source>
          <target state="translated">이 캡처된 그룹의 이름을 할당 <ph id="ph1">`zip`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The group name to convert to the corresponding group number.</source>
          <target state="translated">해당 그룹 번호로 변환할 그룹 이름입니다.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Returns the group number that corresponds to the specified group name.</source>
          <target state="translated">지정된 그룹 이름에 해당하는 그룹 번호를 반환합니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The group number that corresponds to the specified group name, or -1 if <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid group name.</source>
          <target state="translated">지정된 그룹 이름에 해당하는 그룹 번호이거나 <ph id="ph1">&lt;paramref name="name" /&gt;</ph>이 유효한 그룹 이름이 아닌 경우 -1입니다.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</source>
          <target state="translated">정규식 패턴에 명명 되거나 번호가 매겨진 캡처링 그룹 내의 패턴 일치를 사용 하는 하위 식을 나타내는 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Numbered groups are delimited by the syntax (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) and are assigned numbers based on their order in the regular expression.</source>
          <target state="translated">번호가 매겨진된 그룹 구문에 의해 구분 됩니다 (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) 정규식에서의 순서에 따라 숫자 할당 됩니다.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Named groups are delimited by the syntax (?<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?'<bpt id="p3">*</bpt>name<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>), where <bpt id="p5">*</bpt>name<ept id="p5">*</ept> is the name by which the subexpression will be identified.</source>
          <target state="translated">명명 된 그룹 구문에 의해 구분 됩니다 (?<ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>이름<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) 또는 (?' <bpt id="p3">*</bpt>이름<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>) 여기서 <bpt id="p5">*</bpt>이름<ept id="p5">*</ept> 부분식을 식별 하는 이름입니다.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A&gt;</ph> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>그룹화 구문<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>을 참조하세요. <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A&gt;</ph> 메서드는 명명 된 그룹 및 서 수 위치로 정규식에서 번호가 매겨진된 그룹 모두를 식별 합니다.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Ordinal position zero always represents the entire regular expression.</source>
          <target state="translated">서 수 위치 0에는 항상 전체 정규식을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</source>
          <target state="translated">번호가 매겨진 모든 그룹의 정규식 패턴에서의 실제 위치에 관계 없이 명명 된 그룹 하기 전에 다음 계산 됩니다.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> is the string representation of a group number that is present in the regular expression pattern, the method returns that number.</source>
          <target state="translated">경우 <ph id="ph1">`name`</ph> 번호는 메서드가 반환 정규식 패턴에 있는 그룹 번호의 문자열 표현입니다.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> corresponds to a named capturing group that is present in the regular expression pattern, the method returns its corresponding number.</source>
          <target state="translated">경우 <ph id="ph1">`name`</ph> 해당 하는 명명 된 캡처링 그룹은 정규식 패턴에 있는, 메서드는 해당 번호를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The comparison of <ph id="ph1">`name`</ph> with the group name is case-sensitive.</source>
          <target state="translated">비교 <ph id="ph1">`name`</ph> 그룹 이름은 대/소문자 구분 합니다.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> does not correspond to the name of a capturing group or to the string representation of the number of a capturing group, the method returns -1.</source>
          <target state="translated">경우 <ph id="ph1">`name`</ph> 해당 하지 않는 캡처링 그룹의 이름 또는 메서드를 캡처 그룹의 숫자의 문자열 표현을-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>Specifies that a pattern-matching operation should not time out.</source>
          <target state="translated">패턴 일치 작업의 시간이 초과되지 않도록 지정합니다.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> class constructor and a number of static matching methods use the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constant to indicate that the attempt to find a pattern match should not time out.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 클래스 생성자 및 다양 한 일치 하는 정적 메서드 사용은 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> 패턴 일치를 찾으려고 시도 시간 제한이 없어야 함을 나타내려면 상수입니다.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>Setting the regular expression engine's time-out value to <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> can cause regular expressions that rely on excessive backtracking to appear to stop responding when processing text that nearly matches the regular expression pattern.</source>
          <target state="translated">정규식 엔진의 제한 시간 값을 설정 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> 정규식 패턴과 거의 일치 하는 텍스트를 처리할 때 응답 하지 않을에 과도 한 역 추적을 사용 하는 정규식이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>If you disable time-outs, you should ensure that your regular expression does not rely on excessive backtracking and that it handles text that nearly matches the regular expression pattern.</source>
          <target state="translated">제한 시간을 비활성화 하면 과도 한 역 추적이 정규식을 사용 하 여 정규식 패턴과 거의 일치 하는 텍스트를 처리 하는 해야 합니다.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>For more information about handling backtracking, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">역 추적을 처리 하는 방법에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>역 추적<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constant can be supplied as the value of the <ph id="ph2">`matchTimeout`</ph> argument of the following members:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> 상수 값으로 제공 될 수 있습니다는 <ph id="ph2">`matchTimeout`</ph> 멤버의 인수:</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.InitializeReferences">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드에서 생성되는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체에서 사용됩니다.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.InitializeReferences">
          <source>References have already been initialized.</source>
          <target state="translated">참조가 이미 초기화된 경우</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.internalMatchTimeout">
          <source>The maximum amount of time that can elapse in a pattern-matching operation before the operation times out.</source>
          <target state="translated">작업 시간이 초과되기 전에 패턴 일치 작업에서 경과될 수 있는 최대 시간입니다.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Indicates whether the regular expression finds a match in the input string.</source>
          <target state="translated">정규식이 입력 문자열에서 일치하는 항목을 찾을 것인지를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Indicates whether the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor finds a match in a specified input string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 생성자에 지정된 정규식이 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지 여부를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">정규식에서 일치하는 항목을 찾으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> 메서드는 문자열의 유효성을 검사 하거나 후속 조작에 대 한 해당 문자열을 검색 하지 않고 문자열이 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">하나 이상의 문자열 정규식 패턴과 일치 하 고 후속 조작, 호출에 대 한 다음 검색 하 지 확인 하려는 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 일치 하는 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> 메서드를 문자열로 유효한 부품 번호 인지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식을에 있다고 가정 합니다.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">뒤에 두 개의 숫자 문자가 영숫자 문자로 이어지는 영숫자 문자 4 자 하는 첫 번째 집합을 구성 해야 합니다.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">3 자로 구성 된 두 번째 집합은 숫자 여야 합니다.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">4 자로 구성 된 세 번째 집합에는 세 자리 숫자로 영숫자 문자로 이어지는 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The regular expression pattern is:</source>
          <target state="translated">정규식 패턴은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Begin the match at the beginning of the line.</source>
          <target state="translated">줄의 시작 부분에서 일치 항목 찾기를 시작 합니다.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">일치는 단일 영문자 (<ph id="ph1">`a`</ph> 통해 <ph id="ph2">`z`</ph> 또는 <ph id="ph3">`A`</ph> 통해 <ph id="ph4">`Z`</ph>) 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match two numeric characters.</source>
          <target state="translated">두 개의 숫자 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">일치는 단일 영문자 (<ph id="ph1">`a`</ph> 통해 <ph id="ph2">`z`</ph> 또는 <ph id="ph3">`A`</ph> 통해 <ph id="ph4">`Z`</ph>) 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a hyphen.</source>
          <target state="translated">하이픈을 찾습니다.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">정확히 세 개의 숫자 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">세 자리 숫자로, 하이픈과 찾아이 패턴의 두 일치 항목 일치 합니다.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">일치는 단일 영문자 (<ph id="ph1">`a`</ph> 통해 <ph id="ph2">`z`</ph> 또는 <ph id="ph3">`A`</ph> 통해 <ph id="ph4">`Z`</ph>) 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>End the match at the end of the line.</source>
          <target state="translated">줄의 끝에서 검색을 종료 합니다.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The character position at which to start the search.</source>
          <target state="translated">검색을 시작할 문자 위치입니다.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Indicates whether the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor finds a match in the specified input string, beginning at the specified starting position in the string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 생성자에 지정된 정규식이 지정된 입력 문자열의 지정된 시작 위치에서부터 일치하는 항목을 찾을 것인지 여부를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">정규식에서 일치하는 항목을 찾으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> 메서드는 문자열의 유효성을 검사 하거나 후속 조작에 대 한 해당 문자열을 검색 하지 않고 문자열이 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">하나 이상의 문자열 정규식 패턴과 일치 하 고 후속 조작, 호출에 대 한 다음 검색 하 지 확인 하려는 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 일치 하는 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> 메서드를 문자열로 유효한 부품 번호 인지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>It searches for a part number that follows a colon (:) character in a string.</source>
          <target state="translated">문자열의 콜론 (:) 문자 뒤에 포함 된 부품 번호를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> method is used to determine the position of the colon character, which is then passed to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> 메서드에 전달 되는 콜론 문자 위치를 결정 하기를 사용 하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식을에 있다고 가정 합니다.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">뒤에 두 개의 숫자 문자가 영숫자 문자로 이어지는 영숫자 문자 4 자 하는 첫 번째 집합을 구성 해야 합니다.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">3 자로 구성 된 두 번째 집합은 숫자 여야 합니다.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">4 자로 구성 된 세 번째 집합에는 세 자리 숫자로 영숫자 문자로 이어지는 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The regular expression pattern is:</source>
          <target state="translated">정규식 패턴은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">일치는 단일 영문자 (<ph id="ph1">`a`</ph> 통해 <ph id="ph2">`z`</ph> 또는 <ph id="ph3">`A`</ph> 통해 <ph id="ph4">`Z`</ph>) 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match two numeric characters.</source>
          <target state="translated">두 개의 숫자 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">일치는 단일 영문자 (<ph id="ph1">`a`</ph> 통해 <ph id="ph2">`z`</ph> 또는 <ph id="ph3">`A`</ph> 통해 <ph id="ph4">`Z`</ph>) 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a hyphen.</source>
          <target state="translated">하이픈을 찾습니다.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">정확히 세 개의 숫자 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">세 자리 숫자로, 하이픈과 찾아이 패턴의 두 일치 항목 일치 합니다.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">일치는 단일 영문자 (<ph id="ph1">`a`</ph> 통해 <ph id="ph2">`z`</ph> 또는 <ph id="ph3">`A`</ph> 통해 <ph id="ph4">`Z`</ph>) 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>End the match at the end of the line.</source>
          <target state="translated">줄의 끝에서 검색을 종료 합니다.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph>이 0보다 작거나 <ph id="ph2">&lt;paramref name="input" /&gt;</ph>의 길이보다 큰 경우</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string.</source>
          <target state="translated">지정된 정규식이 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">정규식에서 일치하는 항목을 찾으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> 메서드는 문자열의 유효성을 검사 하거나 후속 조작에 대 한 해당 문자열을 검색 하지 않고 문자열이 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">하나 이상의 문자열 정규식 패턴과 일치 하 고 후속 조작, 호출에 대 한 다음 검색 하 지 확인 하려는 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and calling the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">정적 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> 생성 하는 것과 같습니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 로 지정 된 정규식 패턴으로 개체 <ph id="ph3">`pattern`</ph> 호출는 <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> 인스턴스 메서드.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">이 정규식 패턴은 정규식 엔진에 의해 신속 하 게 검색을 위해 캐시 됩니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 일치 하는 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> 메서드를 문자열로 유효한 부품 번호 인지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식을에 있다고 가정 합니다.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">뒤에 두 개의 숫자 문자가 영숫자 문자로 이어지는 영숫자 문자 4 자 하는 첫 번째 집합을 구성 해야 합니다.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">3 자로 구성 된 두 번째 집합은 숫자 여야 합니다.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">4 자로 구성 된 세 번째 집합에는 세 자리 숫자로 영숫자 문자로 이어지는 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression pattern is:</source>
          <target state="translated">정규식 패턴은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Begin the match at the beginning of the line.</source>
          <target state="translated">줄의 시작 부분에서 일치 항목 찾기를 시작 합니다.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">일치는 단일 영문자 (<ph id="ph1">`a`</ph> 통해 <ph id="ph2">`z`</ph> 또는 <ph id="ph3">`A`</ph> 통해 <ph id="ph4">`Z`</ph>) 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match two numeric characters.</source>
          <target state="translated">두 개의 숫자 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">일치는 단일 영문자 (<ph id="ph1">`a`</ph> 통해 <ph id="ph2">`z`</ph> 또는 <ph id="ph3">`A`</ph> 통해 <ph id="ph4">`Z`</ph>) 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a hyphen.</source>
          <target state="translated">하이픈을 찾습니다.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">정확히 세 개의 숫자 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">세 자리 숫자로, 하이픈과 찾아이 패턴의 두 일치 항목 일치 합니다.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">일치는 단일 영문자 (<ph id="ph1">`a`</ph> 통해 <ph id="ph2">`z`</ph> 또는 <ph id="ph3">`A`</ph> 통해 <ph id="ph4">`Z`</ph>) 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>End the match at the end of the line.</source>
          <target state="translated">줄의 끝에서 검색을 종료 합니다.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">이 메서드가 제한 시간 초과 후 메서드가 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 메서드 시간 초과 방지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The recommended static method for verifying a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">패턴 일치를 확인 하는 데 권장 되는 정적 메서드는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options.</source>
          <target state="translated">지정된 정규식이 지정된 일치 옵션을 사용하여 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">정규식에서 일치하는 항목을 찾으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> 메서드는 문자열의 유효성을 검사 하거나 후속 조작에 대 한 해당 문자열을 검색 하지 않고 문자열이 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">하나 이상의 문자열 정규식 패턴과 일치 하 고 후속 조작, 호출에 대 한 다음 검색 하 지 확인 하려는 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and the regular expression options specified by <ph id="ph4">`options`</ph> and calling the <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">정적 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 생성 하는 것과 같습니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 로 지정 된 정규식 패턴으로 개체 <ph id="ph3">`pattern`</ph> 및로 지정 된 정규식 옵션이 <ph id="ph4">`options`</ph> 호출의 <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> 인스턴스 메서드입니다.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">이 정규식 패턴은 정규식 엔진에 의해 신속 하 게 검색을 위해 캐시 됩니다.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 일치 하는 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> 메서드를 문자열로 유효한 부품 번호 인지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식을에 있다고 가정 합니다.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">뒤에 두 개의 숫자 문자가 영숫자 문자로 이어지는 영숫자 문자 4 자 하는 첫 번째 집합을 구성 해야 합니다.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">3 자로 구성 된 두 번째 집합은 숫자 여야 합니다.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">4 자로 구성 된 세 번째 집합에는 세 자리 숫자로 영숫자 문자로 이어지는 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern is:</source>
          <target state="translated">정규식 패턴은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">문자열의 시작 부분에서 검색을 시작합니다.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">단일 문자와 일치 <ph id="ph1">`A`</ph> 통해 <ph id="ph2">`Z`</ph>, 문자 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match two numeric characters.</source>
          <target state="translated">두 개의 숫자 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">단일 문자와 일치 <ph id="ph1">`A`</ph> 통해 <ph id="ph2">`Z`</ph>, 문자 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match a hyphen.</source>
          <target state="translated">하이픈을 찾습니다.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">정확히 세 개의 숫자 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern..</source>
          <target state="translated">세 자리 숫자로, 하이픈과 찾아이 패턴의 두 개의 일치 항목...</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">단일 문자와 일치 <ph id="ph1">`A`</ph> 통해 <ph id="ph2">`Z`</ph>, 문자 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at the end of the string.</source>
          <target state="translated">문자열의 끝 부분에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> is equivalent to defining the following regular expression:</source>
          <target state="translated">호출는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 사용 하 여 메서드는 <ph id="ph2">`options`</ph> 매개 변수 설정 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> 다음 정규식을 정의 하는 것과 같습니다.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For comparison, see the example for the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">반면에 대 한 예제를 참조 하십시오.는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>은 유효한 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값이 아닙니다.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 메서드 시간 초과 방지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for verifying a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">패턴 일치를 확인 하는 데 권장 되는 정적 메서드는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options and time-out interval.</source>
          <target state="translated">지정된 정규식이 지정된 일치 옵션 및 시간 제한 간격을 사용하여 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">정규식에서 일치하는 항목을 찾으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> 메서드는 문자열의 유효성을 검사 하거나 후속 조작에 대 한 해당 문자열을 검색 하지 않고 문자열이 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">하나 이상의 문자열 정규식 패턴과 일치 하 고 후속 조작, 호출에 대 한 다음 검색 하 지 확인 하려는 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and the regular expression options specified by <ph id="ph4">`options`</ph> and calling the <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">정적 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 생성 하는 것과 같습니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 로 지정 된 정규식 패턴으로 개체 <ph id="ph3">`pattern`</ph> 및로 지정 된 정규식 옵션이 <ph id="ph4">`options`</ph> 호출의 <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> 인스턴스 메서드입니다.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">이 정규식 패턴은 정규식 엔진에 의해 신속 하 게 검색을 위해 캐시 됩니다.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 매개 변수 지정 긴 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리 하는 경우 응답을 중지 하 게 표시 되지 않도록 과도 한 역 추적을 사용 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 들어 있는입니다.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>정규식에 대 한 유용한<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> 및 <bpt id="p2">[</bpt>역 추적<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">일치 항목이 없으면 해당 시간 간격에서 발견 되 면 경우에 메서드에서 throw 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 메서드가 실행 되는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 메서드를 문자열로 유효한 부품 번호 인지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식을에 있다고 가정 합니다.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">뒤에 두 개의 숫자 문자가 영숫자 문자로 이어지는 영숫자 문자 4 자 하는 첫 번째 집합을 구성 해야 합니다.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">3 자로 구성 된 두 번째 집합은 숫자 여야 합니다.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">4 자로 구성 된 세 번째 집합에는 세 자리 숫자로 영숫자 문자로 이어지는 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Matching the regular expression pattern should involve minimal searching through the input string, so the method sets a time-out interval of 500 milliseconds.</source>
          <target state="translated">정규식 패턴과 일치 하는 최소를 검색 하는 입력된 문자열에서 500 밀리초의 시간 제한 간격을 설정 하는 메서드가 있으므로 참여 시켜야 합니다.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern is:</source>
          <target state="translated">정규식 패턴은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">문자열의 시작 부분에서 검색을 시작합니다.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">단일 문자와 일치 <ph id="ph1">`A`</ph> 통해 <ph id="ph2">`Z`</ph>, 문자 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match two numeric characters.</source>
          <target state="translated">두 개의 숫자 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">단일 문자와 일치 <ph id="ph1">`A`</ph> 통해 <ph id="ph2">`Z`</ph>, 문자 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match a hyphen.</source>
          <target state="translated">하이픈을 찾습니다.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">정확히 세 개의 숫자 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">세 자리 숫자로, 하이픈과 찾아이 패턴의 두 일치 항목 일치 합니다.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">단일 문자와 일치 <ph id="ph1">`A`</ph> 통해 <ph id="ph2">`Z`</ph>, 문자 또는 숫자 문자입니다.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>End the match at the end of the string.</source>
          <target state="translated">문자열의 끝 부분에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> is equivalent to defining the following regular expression:</source>
          <target state="translated">호출는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 사용 하 여 메서드는 <ph id="ph2">`options`</ph> 매개 변수 설정 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> 다음 정규식을 정의 하는 것과 같습니다.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For comparison, see the example for the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">반면에 대 한 예제를 참조 하십시오.는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>은 유효한 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값이 아닙니다.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>이 음수, 0 또는 약 24일보다 큰 경우</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">설정 하는 것이 좋습니다는 <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 매개 변수를 2 초 등의 적절 한 값입니다.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">제한 시간을 사용 하지 않도록 지정 하 여 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">그러나 다음과 같은 경우에만 제한 시간을 비활성화 해야 합니다.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 시기나 정적 텍스트로 구성 합니다.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">가까운 일치 및 일치 하는 일치 하지 않는 경우 정규식 패턴에 철저히 테스트 효율적으로 처리 하는입니다.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">경우 정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Searches an input string for a substring that matches a regular expression pattern and returns the first occurrence as a single <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> object.</source>
          <target state="translated">입력 문자열에서 정규식 패턴과 일치하는 부분 문자열을 검색하고 맨 처음 발견되는 항목을 단일 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 개체로 반환합니다.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Searches the specified input string for the first occurrence of the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">지정된 입력 문자열에서 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 생성자에 지정된 정규식의 처음 발견되는 항목을 검색합니다.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>An object that contains information about the match.</source>
          <target state="translated">일치에 대한 정보가 포함된 개체입니다.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>일반 식 언어-빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">일치 하는 항목이 없는 경우 반환 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 속성에서 부분 문자열이 포함 <ph id="ph3">`input`</ph> 정규식 패턴과 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">일치 하는 항목이 있는 경우 해당 값은 <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This method returns the first substring in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">이 메서드가 반환에 첫 번째 하위 <ph id="ph1">`input`</ph> 정규식 패턴과 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">호출 하 여 단일 메서드 호출에서 모든 일치 항목을 검색할 수도 있습니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 일치 하는 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The following example finds regular expression pattern matches in a string, then lists the matched groups, captures, and capture positions.</source>
          <target state="translated">다음 예제에서는 정규식 패턴 일치 문자열에서 다음 일치 나열 그룹, 캡처 및 캡처 위치입니다.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The regular expression pattern <ph id="ph1">`(\w+)\s+(car)`</ph> matches occurrences of the word "car" along with the word that precedes it.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`(\w+)\s+(car)`</ph> 함께 앞에 오는 단어 "car" 라는 단어와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>It is interpreted as shown in the following table.</source>
          <target state="translated">다음 표에 나와 있는 것 처럼 해석 됩니다.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">이 그룹은 첫 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match one or more white-space characters.</source>
          <target state="translated">하나 이상의 공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>(car)</source>
          <target state="translated">(자동차)</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match the literal string "car".</source>
          <target state="translated">리터럴 문자열 "car"와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This is the second capturing group.</source>
          <target state="translated">이 그룹은 두 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The zero-based character position at which to start the search.</source>
          <target state="translated">검색을 시작할 문자 위치(0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position in the string.</source>
          <target state="translated">문자열의 지정된 시작 위치에서 시작하여 입력 문자열에서 처음 발견되는 정규식을 검색합니다.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>An object that contains information about the match.</source>
          <target state="translated">일치에 대한 정보가 포함된 개체입니다.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method returns the first substring that matches a regular expression pattern, starting at or after the <ph id="ph2">`startat`</ph> character position, in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> 또는 후에 시작 하는 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 하는 메서드는 <ph id="ph2">`startat`</ph> 문자 입력된 문자열에 위치 합니다.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>일반 식 언어-빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">정규식 패턴을는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> 메서드 검색 중 하나를 호출 하 여 정의 된는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스 생성자입니다.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식 패턴을 만들 수 있는 요소에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>일반 식 언어-빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can optionally specify a starting position in the string by using the <ph id="ph1">`startat`</ph> parameter.</source>
          <target state="translated">사용 하 여 필요에 따라 문자열의 시작 위치를 지정할 수는 <ph id="ph1">`startat`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>When the regular expression engine parses from left to right (the default), the match and the scan move rightward, starting at the character specified in <ph id="ph1">`startat`</ph>.</source>
          <target state="translated">정규식 엔진은 왼쪽에서 오른쪽 (기본값) 구문 분석 하는 경우의 일치 및 검색은 이동, 패턴에 지정 된 문자에서 시작 <ph id="ph1">`startat`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>When the regular expression engine parses from right to left (when the regular expression pattern is constructed with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option), the match and scan move in the opposite direction and begin with the character at <ph id="ph2">`startat`</ph> -1.</source>
          <target state="translated">오른쪽에서 왼쪽으로 정규식 엔진은 구문 분석할 때 (사용 하 여 정규식 패턴은 생성 하는 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> 옵션), 일치 및 검색 반대 방향으로 이동 하 고에서 문자로 시작 <ph id="ph2">`startat`</ph> -1입니다.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you do not specify a starting position, the search begins at the default <ph id="ph1">`startat`</ph> position.</source>
          <target state="translated">시작 위치를 지정 하지 않으면 기본에서 검색이 시작 <ph id="ph1">`startat`</ph> 위치입니다.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If the regular expression searches from left to right, the default <ph id="ph1">`startat`</ph> position is at the left end of <ph id="ph2">`input`</ph>; if it searches from right to left, the default <ph id="ph3">`startat`</ph> position is at the right end of <ph id="ph4">`input`</ph>.</source>
          <target state="translated">정규식이 왼쪽에서 오른쪽, 기본 검색 하는 경우 <ph id="ph1">`startat`</ph> 위치가의 왼쪽된 끝에 있는 <ph id="ph2">`input`</ph>오른쪽에서으로 검색 하는 경우, 왼쪽, 기본 <ph id="ph3">`startat`</ph> 위치가의 오른쪽 끝에 있는 <ph id="ph4">`input`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you want to restrict a match so that it begins at a particular character position in the string and the regular expression engine does not scan the remainder of the string for a match, anchor the regular expression with a <ph id="ph1">`\G`</ph> (at the left for a left-to-right pattern, or at the right for a right-to-left pattern).</source>
          <target state="translated">문자열에 특정 문자 위치에서 시작 하 고 정규식 엔진은 일치 하는 항목에 대 한 문자열의 나머지를 검색 하지 않게 되도록 일치 하는 항목을 제한 하려는 경우 고정 정규식과는 <ph id="ph1">`\G`</ph> (왼쪽-오른쪽에는 왼쪽에 패턴 또는 오른쪽에서 왼쪽 패턴에 대 한 오른쪽에).</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>This restricts the match so it must start exactly at <ph id="ph1">`startat`</ph>.</source>
          <target state="translated">시작 해야 하므로이 일치 하는 경우 제한 <ph id="ph1">`startat`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">일치 하는 항목이 없는 경우 반환 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 속성에서 부분 문자열이 포함 <ph id="ph3">`input`</ph> 정규식 패턴과 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">일치 하는 항목이 있는 경우 해당 값은 <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>This method returns the first substring found at or after the <ph id="ph1">`startat`</ph> character position in <ph id="ph2">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">이 메서드가 반환 후에 발견 된 첫 번째 부분 문자열의 <ph id="ph1">`startat`</ph> 에서 문자 위치 <ph id="ph2">`input`</ph> 정규식 패턴과 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">호출 하 여 단일 메서드 호출에서 모든 일치 항목을 검색할 수도 있습니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 일치 하는 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exeeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대 한 제한 시간 값 설정 된 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph>이 0보다 작거나 <ph id="ph2">&lt;paramref name="input" /&gt;</ph>의 길이보다 큰 경우</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Searches the specified input string for the first occurrence of the specified regular expression.</source>
          <target state="translated">지정된 입력 문자열에서 첫 번째 지정된 정규식을 검색합니다.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>An object that contains information about the match.</source>
          <target state="translated">일치에 대한 정보가 포함된 개체입니다.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>일반 식 언어-빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">정적 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> 생성 하는 것과 같습니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 지정 된 정규식 패턴으로 개체를 호출 하는 인스턴스 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>In this case, the regular expression engine caches the regular expression pattern.</source>
          <target state="translated">이 경우 정규식 엔진이 정규식 패턴을 캐시합니다.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">일치 하는 항목이 없는 경우 반환 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 속성에서 부분 문자열이 포함 <ph id="ph3">`input`</ph> 정규식 패턴과 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">일치 하는 항목이 있는 경우 해당 값은 <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>This method returns the first substring in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">이 메서드가 반환에 첫 번째 하위 <ph id="ph1">`input`</ph> 정규식 패턴과 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">호출 하 여 단일 메서드 호출에서 모든 일치 항목을 검색할 수도 있습니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 일치 하는 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method to find the first word that contains at least one <ph id="ph2">`z`</ph> character, and then calls the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method to find any additional matches.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> 하나 이상 포함 된 첫 번째 단어를 찾는 메서드 <ph id="ph2">`z`</ph> 문자를 차례로 호출은 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> 메서드 추가 일치 항목을 찾을를 합니다.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w*z+\w*\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\b\w*z+\w*\b`</ph>는 다음 테이블과 같이 해석됩니다.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">0 개 또는 하나 이상의 단어 문자가 일치 합니다.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match one or more occurrences of the <ph id="ph1">`z`</ph> character.</source>
          <target state="translated">하나 이상의 일치는 <ph id="ph1">`z`</ph> 문자입니다.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">0 개 또는 하나 이상의 단어 문자가 일치 합니다.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 메서드 시간 초과 방지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The recommended static method for retrieving a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">패턴 일치를 검색 하기 위한 권장된 정적 메서드는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The zero-based character position in the input string that defines the leftmost position to be searched.</source>
          <target state="translated">검색되는 가장 왼쪽 지점을 정의하는 입력 문자열의 0부터 시작하는 문자 위치입니다.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The number of characters in the substring to include in the search.</source>
          <target state="translated">검색에 포함시킬 부분 문자열의 문자 수입니다.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position and searching only the specified number of characters.</source>
          <target state="translated">지정된 시작 위치에서 시작하고 지정된 수의 문자만 검색하여 입력 문자열에서 첫 번째 정규식을 검색합니다.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>An object that contains information about the match.</source>
          <target state="translated">일치에 대한 정보가 포함된 개체입니다.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method returns the first substring that matches a regular expression pattern in a portion of an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 메서드 입력된 문자열의 일부에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>일반 식 언어-빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">정규식 패턴을는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 메서드 검색 중 하나를 호출 하 여 정의 된는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스 생성자입니다.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식 패턴을 만들 수 있는 요소에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>일반 식 언어-빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method searches the portion of <ph id="ph2">`input`</ph> defined by the <ph id="ph3">`beginning`</ph> and <ph id="ph4">`length`</ph> parameters for the regular expression pattern.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 메서드 검색의 부분 <ph id="ph2">`input`</ph> 정의한는 <ph id="ph3">`beginning`</ph> 및 <ph id="ph4">`length`</ph> 정규식 패턴에 대 한 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">`beginning`</ph> always defines the index of the leftmost character to include in the search, and <ph id="ph2">`length`</ph> defines the maximum number of characters to search.</source>
          <target state="translated"><ph id="ph1">`beginning`</ph> 항상는 검색에 포함할 가장 왼쪽 문자의 인덱스를 정의 하 고 <ph id="ph2">`length`</ph> 검색할 문자의 최대 수를 정의 합니다.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>Together, they define the range of the search.</source>
          <target state="translated">함께 검색의 범위를 정의합니다.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If the search proceeds from left to right (the default), the regular expression engine searches from the character at index <ph id="ph1">`beginning`</ph> to the character at index <ph id="ph2">`beginning`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1.</source>
          <target state="translated">정규식 엔진은 검색 인덱스에 있는 문자가에서 검색이 왼쪽에서 오른쪽 (기본값) 계속 진행 하는 경우 <ph id="ph1">`beginning`</ph> 인덱스에 있는 문자에 <ph id="ph2">`beginning`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1입니다.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If the regular expression engine was instantiated by using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option so that the search proceeds from right to left, the regular expression engine searches from the character at index <ph id="ph2">`beginning`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1 to the character at index <ph id="ph5">`beginning`</ph>.</source>
          <target state="translated">사용 하 여 정규식 엔진은 인스턴스화할 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> 옵션을 왼쪽으로 정규식 엔진 검색 인덱스에 있는 문자를 오른쪽에서 검색이 진행 됩니다 <ph id="ph2">`beginning`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1에 인덱스에 문자 <ph id="ph5">`beginning`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>This method returns the first match that it finds within this range.</source>
          <target state="translated">이 메서드는이 범위 내에서 발견 된 첫 번째 일치 항목을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">일치 하는 항목이 없는 경우 반환 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 속성에서 부분 문자열이 포함 <ph id="ph3">`input`</ph> 정규식 패턴과 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">일치 하는 항목이 있는 경우 해당 값은 <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 일치 하는 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out value when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 제한 시간 값을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph>이 0보다 작거나 <ph id="ph2">&lt;paramref name="input" /&gt;</ph>의 길이보다 큰 경우</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>이 0보다 작거나 <ph id="ph2">&lt;paramref name="input" /&gt;</ph>의 길이보다 큰 경우</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph><ph id="ph2">&lt;see langword="+" /&gt;</ph><ph id="ph3">&lt;paramref name="length" /&gt;</ph><ph id="ph4">&lt;see langword="–1" /&gt;</ph> identifies a position that is outside the range of <ph id="ph5">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph><ph id="ph2">&lt;see langword="+" /&gt;</ph><ph id="ph3">&lt;paramref name="length" /&gt;</ph><ph id="ph4">&lt;see langword="–1" /&gt;</ph>이 <ph id="ph5">&lt;paramref name="input" /&gt;</ph> 범위 밖에 있는 위치를 식별하는 경우</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options.</source>
          <target state="translated">지정된 일치 옵션을 사용하여 입력 문자열에서 첫 번째 지정된 정규식을 검색합니다.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>An object that contains information about the match.</source>
          <target state="translated">일치에 대한 정보가 포함된 개체입니다.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>일반 식 언어-빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor and calling the instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">정적 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 생성 하는 것과 같습니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체는 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 생성자와 인스턴스 호출 <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">일치 하는 항목이 없는 경우 반환 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 속성에서 부분 문자열이 포함 <ph id="ph3">`input`</ph> 정규식 패턴과 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">일치 하는 항목이 있는 경우 해당 값은 <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method returns the first substring found in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">이 메서드가 반환에 첫 번째 하위 <ph id="ph1">`input`</ph> 정규식 패턴과 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method.</source>
          <target state="translated">반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">호출 하 여 단일 메서드 호출에서 모든 일치 항목을 검색할 수도 있습니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 일치 하는 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example defines a regular expression that matches words beginning with the letter "a".</source>
          <target state="translated">문자로 시작 하는 단어와 일치 하는 정규식을 정의 하는 다음 예제에서는 "a"입니다.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>It uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> option to ensure that the regular expression locates words beginning with both an uppercase "a" and a lowercase "a".</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> 정규식 "a"와 소문자 대문자는로 시작 단어 둔다는 하려면 옵션을 "a"입니다.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\ba\w*\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\ba\w*\b`</ph>는 다음 테이블과 같이 해석됩니다.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the character "a".</source>
          <target state="translated">문자 "a"입니다.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">0 개 또는 하나 이상의 단어 문자가 일치 합니다.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값의 유효한 비트 조합이 아닌 경우</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 메서드 시간 초과 방지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for retrieving a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">패턴 일치를 검색 하기 위한 권장된 정적 메서드는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options and time-out interval.</source>
          <target state="translated">지정된 일치 옵션 및 제한 시간 간격을 사용하여 입력 문자열에서 첫 번째 지정된 정규식을 검색합니다.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>An object that contains information about the match.</source>
          <target state="translated">일치에 대한 정보가 포함된 개체입니다.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식 패턴을 작성 하는 데 언어 요소에 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>일반 식 언어-빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor and calling the instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">정적 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 생성 하는 것과 같습니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체는 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 생성자와 인스턴스 호출 <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">정규식 패턴의 반환 된 값을 확인 하 여 입력된 문자열에서 발견 되었는지 여부를 확인 하기 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">일치 하는 항목이 없는 경우 반환 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 속성에서 부분 문자열이 포함 <ph id="ph3">`input`</ph> 정규식 패턴과 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">일치 하는 항목이 있는 경우 해당 값은 <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This method returns the first substring found in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">이 메서드가 반환에 첫 번째 하위 <ph id="ph1">`input`</ph> 정규식 패턴과 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method.</source>
          <target state="translated">반복 해 서 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">호출 하 여 단일 메서드 호출에서 모든 일치 항목을 검색할 수도 있습니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 매개 변수 지정 긴 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리 하는 경우 응답을 중지 하 게 표시 되지 않도록 과도 한 역 추적을 사용 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 들어 있는입니다.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>정규식에 대 한 유용한<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> 및 <bpt id="p2">[</bpt>역 추적<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">일치 항목이 없으면 해당 시간 간격에서 발견 되 면 경우에 메서드에서 throw 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 메서드가 실행 되는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값의 유효한 비트 조합이 아닌 경우</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>이 음수, 0 또는 약 24일보다 큰 경우</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">설정 하는 것이 좋습니다는 <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 매개 변수를 2 초 등의 적절 한 값입니다.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">제한 시간을 사용 하지 않도록 지정 하 여 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">그러나 다음과 같은 경우에만 제한 시간을 비활성화 해야 합니다.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 시기나 정적 텍스트로 구성 합니다.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">가까운 일치 및 일치 하는 일치 하지 않는 경우 정규식 패턴에 철저히 테스트 효율적으로 처리 하는입니다.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">경우 정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Searches an input string for all occurrences of a regular expression and returns all the matches.</source>
          <target state="translated">입력 문자열에 있는 정규식을 모두 검색하고 일치 항목을 모두 반환합니다.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When a match attempt is repeated by calling the <ph id="ph1">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /&gt;</ph> method, the regular expression engine gives empty matches special treatment.</source>
          <target state="translated">일치 시도 호출 하 여 반복 되는 경우는 <ph id="ph1">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /&gt;</ph> 메서드, 정규식 엔진이 제공 빈 일치 항목 특별 하 게 처리 합니다.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Usually, the regular expression engine begins the search for the next match exactly where the previous match left off.</source>
          <target state="translated">일반적으로 정규식 엔진은 정확 하 게 이전 일치 항목 종료 한 위치에 관계 없이 다음 일치 항목에 대 한 검색을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, after an empty match, the regular expression engine advances by one character before trying the next match.</source>
          <target state="translated">그러나 빈 일치, 정규식 엔진은 일치 하는 다음을 시도 하기 전에 한 글자씩 이동 합니다.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This behavior guarantees that the regular expression engine will progress through the string.</source>
          <target state="translated">이러한 동작은 보장 정규식 엔진이 문자열을 통해 진행 됩니다.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Otherwise, because an empty match does not result in any forward movement, the next match would start in exactly the same place as the previous match, and it would match the same empty string repeatedly.</source>
          <target state="translated">그렇지 않으면 빈 일치 하는 모든 앞으로 이동 되지 않습니다, 때문에 다음 일치 항목 정확히 이전 일치 항목으로 같은 위치에서 시작 및 찾게 동일한 빈 문자열입니다.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In the following example, the regular expression pattern <bpt id="p1">&lt;c&gt;</bpt>a*<ept id="p1">&lt;/c&gt;</ept> searches for zero or more occurrences of the letter "a" in the string "abaabb".</source>
          <target state="translated">다음 예제에서는 정규식 패턴에서에서 <bpt id="p1">&lt;c&gt;</bpt>는 *<ept id="p1">&lt;/c&gt;</ept> 문자의 0 개 이상의 항목을 검색 "abaabb" 문자열에 "a"입니다.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>As the output from the example shows, the resulting <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph> object contains six <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects.</source>
          <target state="translated">결과 예제에서 출력으로 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph> 개체에 포함 되어 6 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The first match attempt finds the first "a".</source>
          <target state="translated">첫 번째 일치 시도가 찾은 첫 번째 "a"입니다.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The second match starts exactly where the first match ends, before the first b; it finds zero occurrences of "a" and returns an empty string.</source>
          <target state="translated">정확 하 게 첫 번째 검사가 첫 번째 b; 앞에 끝에서 두 번째 검사를 시작 "a"의 0 항목을 찾아서 빈 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The third match does not begin exactly where the second match ended, because the second match returned an empty string.</source>
          <target state="translated">빈 문자열을 반환 하기 때문에 세 번째 일치는 정확 하 게 두 번째 일치 항목 찾기가 종료 된 위치, 시작 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Instead, it begins one character later, after the first "b".</source>
          <target state="translated">대신, 첫 번째 "b" 후 나중에, 한 문자를 시작합니다.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The third match finds two occurrences of "a" and returns "aa".</source>
          <target state="translated">세 번째 일치 하는 "a"의 두 일치 항목을 찾아 "aa"를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The fourth match attempt begins where the third match ended, before the second "b", and returns an empty string.</source>
          <target state="translated">네 번째 일치 시도가 다음에 세 번째 검사에서 나옵니다, 앞의 두 번째 "b", 빈 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The fifth match attempt again advances one character so that it begins before the third "b" and returns an empty string.</source>
          <target state="translated">다섯 번째 일치 시도가 다시 진행 한 문자 "b" 세 번째 하기 전에 시작 하 고 빈 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The sixth match begins after the last "b" and returns an empty string again.</source>
          <target state="translated">여섯 번째 일치 하는 마지막 "b" 다음에 시작 하 고 빈 문자열을 다시 반환 합니다.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Searches the specified input string for all occurrences of a regular expression.</source>
          <target state="translated">지정된 입력 문자열에 있는 정규식을 모두 검색합니다.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">검색에서 찾은 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 개체의 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> 메서드는 비슷합니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> 단일 일치 항목 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">다음 코드를 하는 것이 같습니다.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The collection includes only matches and terminates at the first non-match.</source>
          <target state="translated">컬렉션 일치만을 포함 하 고 첫 번째 비-일치에 종료 합니다.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">정규식 패턴을는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> 메서드 검색 중 하나를 호출 하 여 정의 된는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스 생성자입니다.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식 패턴을 만들 수 있는 요소에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>일반 식 언어-빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 메서드 지연 평가 사용 하 여 반환 된 채우는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">이 컬렉션의 멤버와 같은 액세스 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> 경우 컬렉션을 즉시 채워야 합니다.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">지연 계산을 이용 하려면와 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 <ph id="ph1">`foreach`</ph> C# 및 <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>in Visual Basic.</source>
          <target state="translated">Visual Basic</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">해당 지연 계산 때문에 호출 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> 메서드 throw 하지 않습니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property is not <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> and a matching operation exceeds the time-out interval.</source>
          <target state="translated">그러나에서 작업이 수행 될 때 예외가 throw 됩니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 경우이 메서드에서 반환 된 개체는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> 속성은 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> 하는 작업이 시간 제한 간격을 초과 합니다.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method to identify any words in a sentence that end in "es".</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> "es"로 끝나는 문장에서 단어를 식별 하는 메서드.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\b\w+es\b`</ph>는 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Match the literal string "es".</source>
          <target state="translated">리터럴 문자열 "es"와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The character position in the input string at which to start the search.</source>
          <target state="translated">입력 문자열에서 검색을 시작할 문자 위치입니다.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Searches the specified input string for all occurrences of a regular expression, beginning at the specified starting position in the string.</source>
          <target state="translated">문자열의 지정된 시작 위치에서 시작하여 지정된 입력 문자열에 있는 정규식을 모두 검색합니다.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">검색에서 찾은 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 개체의 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The  <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method is similar to the  <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> 메서드는 비슷합니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> 단일 일치 항목 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">다음 코드를 하는 것이 같습니다.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">정규식 패턴을는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> 메서드 검색 중 하나를 호출 하 여 정의 된는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스 생성자입니다.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식 패턴을 만들 수 있는 요소에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>일반 식 언어-빠른 참조<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 메서드 지연 평가 사용 하 여 반환 된 채우는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">이 컬렉션의 멤버와 같은 액세스 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> 경우 컬렉션을 즉시 채워야 합니다.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">지연 계산을 이용 하려면와 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 <ph id="ph1">`foreach`</ph> C# 및 <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>in Visual Basic.</source>
          <target state="translated">Visual Basic</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">해당 지연 계산 때문에 호출 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> 메서드 throw 하지 않습니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property is not <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> and a matching operation exceeds the time-out interval..</source>
          <target state="translated">그러나 작업에서 수행 될 때 예외가 throw 됩니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 경우이 메서드에서 반환 된 개체는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> 속성은 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> 하는 작업이 제한 시간 간격을 초과 하 고...</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method to find the first word in a sentence that ends in "es", and then calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method to identify any additional words that end in "es".</source>
          <target state="translated">사용 하 여 다음 예제는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> 메서드를 "es"을 찾아 다음 호출 문장의 첫 번째 단어는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> "es"로 끝나는 다른 단어를 식별 하는 메서드.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\b\w+es\b`</ph>는 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Match the literal string "es".</source>
          <target state="translated">리터럴 문자열 "es"와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>End the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph>이 0보다 작거나 <ph id="ph2">&lt;paramref name="input" /&gt;</ph>의 길이보다 큰 경우</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Searches the specified input string for all occurrences of a specified regular expression.</source>
          <target state="translated">지정된 입력 문자열에서 지정된 정규식을 모두 검색합니다.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">검색에서 찾은 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 개체의 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> 메서드는 비슷합니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> 단일 일치 항목 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">다음 코드를 하는 것이 같습니다.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">정적 <ph id="ph1">`Matches`</ph> 메서드는 구성에 해당 하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 <ph id="ph3">`Matches`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 메서드 지연 평가 사용 하 여 반환 된 채우는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">이 컬렉션의 멤버와 같은 액세스 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> 경우 컬렉션을 즉시 채워야 합니다.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">지연 계산을 이용 하려면와 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 <ph id="ph1">`foreach`</ph> C# 및 <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>in Visual Basic.</source>
          <target state="translated">Visual Basic</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">해당 지연 계산 때문에 호출 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> 메서드 throw 하지 않습니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</source>
          <target state="translated">그러나 작업에서 수행 될 때 예외가 throw 됩니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 시간 제한 간격을 현재 응용 프로그램 도메인 및 일치 작업의 "REGEX_DEFAULT_MATCH_TIMEOUT" 속성에 의해 정의 된 경우이 메서드에서 반환 된 개체 이 시간 제한 간격을 초과합니다.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method to identify any word in a sentence that ends in "es".</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> 메서드 "es"로 끝나는 문장에서 모든 단어를 식별 합니다.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\b\w+es\b`</ph>는 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Match the literal string "es".</source>
          <target state="translated">리터럴 문자열 "es"와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 메서드 시간 초과 방지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The recommended static method for retrieving multiple pattern matches is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you specify the time-out interval.</source>
          <target state="translated">권장 되는 정적 방법 일치 여러 패턴을 검색 하는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, 시간 제한 간격을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that specify options for matching.</source>
          <target state="translated">일치 옵션을 지정하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options.</source>
          <target state="translated">지정된 일치 옵션을 사용하여 지정된 입력 문자열에서 지정된 정규식을 모두 검색합니다.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">검색에서 찾은 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 개체의 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 메서드는 비슷합니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 단일 일치 항목 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">다음 코드를 하는 것이 같습니다.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">정적 <ph id="ph1">`Matches`</ph> 메서드는 구성에 해당 하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 <ph id="ph3">`Matches`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 메서드 지연 평가 사용 하 여 반환 된 채우는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">이 컬렉션의 멤버와 같은 액세스 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> 경우 컬렉션을 즉시 채워야 합니다.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">지연 계산을 이용 하려면와 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 <ph id="ph1">`foreach`</ph> C# 및 <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>in Visual Basic.</source>
          <target state="translated">Visual Basic</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">해당 지연 계산 때문에 호출 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> 메서드 throw 하지 않습니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</source>
          <target state="translated">그러나 작업에서 수행 될 때 예외가 throw 됩니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 시간 제한 간격을 현재 응용 프로그램 도메인 및 일치 작업의 "REGEX_DEFAULT_MATCH_TIMEOUT" 속성에 의해 정의 된 경우이 메서드에서 반환 된 개체 이 시간 제한 간격을 초과합니다.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method to identify any word in a sentence that ends in "es", and then calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to perform a case-insensitive comparison of the pattern with the input string.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> 문장의 "es"로 끝나고 다음 호출 하는 모든 단어를 식별 하는 메서드는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 메서드는 입력 문자열 패턴의 대/소문자 구분 비교를 수행 합니다.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>As the output shows, the two methods return different results.</source>
          <target state="translated">출력에서 볼 수 있듯이 두 메서드는 다른 결과 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\b\w+es\b`</ph>는 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the literal string "es".</source>
          <target state="translated">리터럴 문자열 "es"와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값의 유효한 비트 조합이 아닌 경우</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 메서드 시간 초과 방지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for retrieving multiple pattern matches is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">권장 되는 정적 방법 일치 여러 패턴을 검색 하는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that specify options for matching.</source>
          <target state="translated">일치 옵션을 지정하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options and time-out interval.</source>
          <target state="translated">지정된 일치 옵션 및 제한 시간 간격을 사용하여 지정된 입력 문자열에서 지정된 정규식을 모두 검색합니다.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">검색에서 찾은 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 개체의 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 메서드는 비슷합니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 단일 일치 항목 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">다음 코드를 하는 것이 같습니다.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">정적 <ph id="ph1">`Matches`</ph> 메서드는 구성에 해당 하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 <ph id="ph3">`Matches`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 메서드 지연 평가 사용 하 여 반환 된 채우는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">이 컬렉션의 멤버와 같은 액세스 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> 경우 컬렉션을 즉시 채워야 합니다.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">지연 계산을 이용 하려면와 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 <ph id="ph1">`foreach`</ph> C# 및 <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>in Visual Basic.</source>
          <target state="translated">Visual Basic</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">해당 지연 계산 때문에 호출 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 메서드 throw 하지 않습니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, an exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a matching operation exceeds this time-out interval specified by the<ph id="ph2">`matchTimeout`</ph> parameter.</source>
          <target state="translated">그러나 작업에서 수행 될 때 예외가 throw 됩니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 일치 작업에서 지정 된이 시간 제한 간격을 초과 하는 경우이 메서드에서 반환 된 개체는<ph id="ph2">`matchTimeout`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to perform a case-sensitive comparison that matches any word in a sentence that ends in "es".</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 메서드 "es"로 끝나는 문장의 모든 단어가 일치 하는 대/소문자 구분 비교를 수행 합니다.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to perform a case-insensitive comparison of the pattern with the input string.</source>
          <target state="translated">그런 다음 호출 하는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 메서드는 입력 문자열 패턴의 대/소문자 구분 비교를 수행 합니다.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In both cases, the time-out interval is set to one second.</source>
          <target state="translated">두 경우 모두, 시간 제한 간격을 1 초로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>As the output shows, the two methods return different results.</source>
          <target state="translated">출력에서 볼 수 있듯이 두 메서드는 다른 결과 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\b\w+es\b`</ph>는 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the literal string "es".</source>
          <target state="translated">리터럴 문자열 "es"와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>End the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값의 유효한 비트 조합이 아닌 경우</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>이 음수, 0 또는 약 24일보다 큰 경우</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">설정 하는 것이 좋습니다는 <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 매개 변수를 2 초 등의 적절 한 값입니다.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">제한 시간을 사용 하지 않도록 지정 하 여 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">그러나 다음과 같은 경우에만 제한 시간을 비활성화 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 시기나 정적 텍스트로 구성 합니다.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">가까운 일치 및 일치 하는 일치 하지 않는 경우 정규식 패턴에 철저히 테스트 효율적으로 처리 하는입니다.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">경우 정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>Gets the time-out interval of the current instance.</source>
          <target state="translated">현재 인스턴스의 시간 제한 간격을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>The maximum time interval that can elapse in a pattern-matching operation before a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /&gt;</ph> is thrown, or <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> if time-outs are disabled.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /&gt;</ph>이 throw되기 전에 패턴 일치 작업에서 경과할 수 있는 최대 시간 간격이며, 제한 시간이 비활성화된 경우는 <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property defines the approximate maximum time interval for a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance to execute a single matching operation before the operation times out. The regular expression engine throws a <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception during its next timing check after the time-out interval has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> 속성 정의 대 한 대략적인 최대 시간 간격을 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 작업 시간이 초과 하기 전에 단일 일치 작업을 실행 하는 인스턴스. 정규식 엔진은 throw 한 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 시간 제한 간격이 경과한 후 다음 타이밍 검사 중 발생 한 예외입니다.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>This prevents the regular expression engine from processing input strings that require excessive backtracking.</source>
          <target state="translated">따라서 정규식 엔진을에서 과도 한 역 추적 필요로 하는 입력된 문자열을 처리할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>For more information, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Best Practices for Regular Expressions<ept id="p2">](~/docs/standard/base-types/best-practices.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>역 추적<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>정규식에 대 한 유용한<ept id="p2">](~/docs/standard/base-types/best-practices.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>This property is read-only.</source>
          <target state="translated">이 속성은 읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>You can set its value explicitly for an individual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object by calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor; and you can set its value for all <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> matching operations in an application domain by calling the <ph id="ph4">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> method and providing a <ph id="ph5">&lt;xref:System.TimeSpan&gt;</ph> value for the "REGEX_DEFAULT_MATCH_TIMEOUT" property, as the following example illustrates.</source>
          <target state="translated">개인에 대 한 해당 값을 명시적으로 설정할 수 있습니다 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 호출 하 여 개체는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자; 하 고 모든 값을 설정 하려면 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 호출 하 여 일치 하는 응용 프로그램 도메인에서 작업의 <ph id="ph4">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> 메서드 제공 하는 <ph id="ph5">&lt;xref:System.TimeSpan&gt;</ph> 다음 예제와 같이 "REGEX_DEFAULT_MATCH_TIMEOUT" 속성에 대 한 값입니다.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>If you do not explicitly set a time-out interval, the default value <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> is used, and matching operations do not time out.</source>
          <target state="translated">시간 제한 간격, 기본값을 명시적으로 설정 하지 않으면 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> 사용 되는, 및 일치 하는 작업은 시간이 제한 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>Gets the options that were passed into the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 생성자에 전달된 옵션을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>One or more members of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> enumeration that represent options that were passed to the <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 생성자에게 전달된 옵션을 나타내는 하나 이상의 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 열거형 멤버입니다.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>The value of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> property consists of one or more members of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> enumeration.</source>
          <target state="translated">값은 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> 속성의 하나 이상의 멤버로 구성 된 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> 열거형.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>If no options were defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor, its value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">에 정의 된 옵션 없이 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 클래스 생성자의 값이 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>The available options are discussed in detail in the <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](~/docs/standard/base-types/regular-expression-options.md)</ept> topic.</source>
          <target state="translated">사용할 수 있는 옵션에 대 한 자세한 설명은 <bpt id="p1">[</bpt>정규식 옵션<ept id="p1">](~/docs/standard/base-types/regular-expression-options.md)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> property does not reflect inline options defined in the regular expression pattern itself.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> 속성 자체 패턴을 정규식에서 정의 된 인라인 옵션을 반영 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> is the base class of regular expressions created by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 만든 정규식의 기본 클래스는 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>These compiled regular expressions use the base class implementation of the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property.</source>
          <target state="translated">이러한 컴파일된 정규식의 기본 클래스 구현을 사용 하 여는 <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>If called from a derived class, the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property returns the options that were passed to the <ph id="ph2">&lt;paramref name="options" /&gt;</ph> parameter of the <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> class constructor that was used to define the regular expression.</source>
          <target state="translated">파생된 클래스에서 호출 된 경우는 <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> 속성에 전달 된 옵션을 반환 된 <ph id="ph2">&lt;paramref name="options" /&gt;</ph> 의 매개 변수는 <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> 정규식 정의에 사용 된 클래스 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.pattern">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드에서 생성되는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체에서 사용됩니다.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>In a specified input string, replaces strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">지정된 입력 문자열에서 정규식 패턴과 일치하는 문자열을 지정된 대체 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The replacement string.</source>
          <target state="translated">대체 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">지정된 입력 문자열에서 정규식 패턴과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">일치 하는 항목에 대 한 검색의 시작 부분에서 시작 된 <ph id="ph1">`input`</ph> 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 매개 변수에서 각 일치 되는 문자열을 지정 <ph id="ph2">`input`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 리터럴 텍스트의 조합을 포함할 수 있습니다 및 <bpt id="p1">[</bpt>대체<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">예를 들어 바꾸기 패턴 <ph id="ph1">`a*${test}b`</ph> 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 <ph id="ph2">`test`</ph> 다음 있는 경우 캡처 그룹, "b" 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">다른 모든 정규식 언어 요소를 포함 하 여 <bpt id="p1">[</bpt>이스케이프 문자<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 발생 하지 않습니다</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`\s+`</ph>, that matches one or more white-space characters.</source>
          <target state="translated">다음 예제에서는 정규식을 정의 <ph id="ph1">`\s+`</ph>, 하나 이상의 공백 문자를 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The replacement string, " ", replaces them with a single space character.</source>
          <target state="translated">대체 문자열 "", 공백 문자 하나로 바뀝니다.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`(\p{Sc}\s?)?(\d+\.?((?&lt;=\.)\d+)?)(?(1)|\s?\p{Sc})?`</ph>, and a replacement pattern, <ph id="ph2">`$2`</ph>, that removes either a leading or a trailing currency symbol from a numeric value.</source>
          <target state="translated">다음 예제에서는 정규식을 정의 <ph id="ph1">`(\p{Sc}\s?)?(\d+\.?((?&lt;=\.)\d+)?)(?(1)|\s?\p{Sc})?`</ph>, 및 바꾸기 패턴에서 <ph id="ph2">`$2`</ph>, 숫자 값에서 선행 또는 후행 통화 기호를 제거 하 합니다.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The regular expression is interpreted as shown in the following table.</source>
          <target state="translated">정규식은 다음 표와 같이 해석됩니다.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match a currency symbol.</source>
          <target state="translated">통화 기호를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">`{Sc}`</ph> denotes any character that is a member of the Unicode Symbol, Currency category.</source>
          <target state="translated"><ph id="ph1">`{Sc}`</ph> 유니코드 기호와 통화 범주의 구성원 인 모든 문자를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one white-space character.</source>
          <target state="translated">0번 이상 나오는 공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one occurrence of the combination of a currency symbol followed by zero or one white-space character.</source>
          <target state="translated">통화 기호 뒤에 0 번 이상 나오는 공백 문자 조합 없거나 1 개 발생을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">이 그룹은 첫 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match one or more decimal digits.</source>
          <target state="translated">하나 이상의 10진수 숫자가 일치하는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one occurrence of a period (used as a decimal separator character).</source>
          <target state="translated">마침표 (소수 구분 기호 문자도 사용 됨)의 0 번 이상 발생을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If a period is the previous character, match one or more decimal digits.</source>
          <target state="translated">마침표 이전 문자 이면 하나 이상의 10 진수 숫자가 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This pattern can be matched either zero or one time.</source>
          <target state="translated">이 패턴에는 0 개 또는 1 번 일치할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match the pattern of one or more decimal digits followed by an optional period and additional decimal digits.</source>
          <target state="translated">하나 이상의 10 진수 선택적 마침표와 추가 10 진수가 패턴과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This is the second capturing group.</source>
          <target state="translated">이 그룹은 두 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29&gt;</ph> method replaces the entire match with the value of this captured group.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29&gt;</ph> 메서드가 캡처된 그룹의 값과 일치 하는 전체를 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If the first captured group exists, match an empty string.</source>
          <target state="translated">첫 번째 캡처된 그룹이 있는 경우에 빈 문자열과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Otherwise, match zero or one white-space character followed by a currency symbol.</source>
          <target state="translated">그렇지 않으면 다음 통화 기호는 공백 문자 0 회 이상 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 대리자가 반환한 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> 메서드는 다음 조건 중 하나에 해당 하는 경우 정규식 일치 항목을 대체 하는 데 유용 합니다.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">대체 문자열은 정규식 대체 패턴에서 쉽게 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">대체 문자열 일부 처리 작업에 일치 하는 문자열에서에서 발생 합니다.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">대체 문자열 조건부 처리의 결과입니다.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">호출 하는 메서드는는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> 메서드와 각각 전달 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 반환 된 개체 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 컬렉션에는 <ph id="ph4">`evaluator`</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 발생 하지 않습니다</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The following code example displays an original string, matches each word in the original string, converts the first character of each match to uppercase, then displays the converted string.</source>
          <target state="translated">다음 코드 예제에서는 원래 문자열을 표시 하 고 원래 문자열의 각 단어와 일치, 변환 된 문자열을 표시 한 다음 대문자로 각 일치 항목의 첫 번째 문자를 변환 합니다.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The replacement string.</source>
          <target state="translated">대체 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The maximum number of times the replacement can occur.</source>
          <target state="translated">대체하는 최대 횟수입니다.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">지정된 입력 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 지정된 대체 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">일치 하는 항목에 대 한 검색의 시작 부분에서 시작 된 <ph id="ph1">`input`</ph> 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The regular expression is the pattern that is defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is negative, replacements continue to the end of the string.</source>
          <target state="translated">경우 <ph id="ph1">`count`</ph> 가 음수 이면 문자열의 끝까지 바꾸기가 계속 합니다.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> exceeds the number of matches, all matches are replaced.</source>
          <target state="translated">경우 <ph id="ph1">`count`</ph> 일치 항목 개수를 초과 하면, 일치 하는 모든 대체 됩니다.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace the first <ph id="ph2">`count`</ph> matches in <ph id="ph3">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 는를 첫 번째 바꿀 문자열을 지정 하는 매개 변수 <ph id="ph2">`count`</ph> 에 일치 <ph id="ph3">`input`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 리터럴 텍스트의 조합을 포함할 수 있습니다 및 <bpt id="p1">[</bpt>대체<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">예를 들어 바꾸기 패턴 <ph id="ph1">`a*${test}b`</ph> 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 <ph id="ph2">`test`</ph> 다음 있는 경우 캡처 그룹, "b" 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">다른 모든 정규식 언어 요소를 포함 하 여 <bpt id="p1">[</bpt>이스케이프 문자<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 발생 하지 않습니다</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The following example replaces the first five occurrences of duplicated characters with a single character.</source>
          <target state="translated">다음 예제에서는 단일 문자 중복 문자의 처음 5 개 항목을 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`(\w)\1`</ph> matches consecutive occurrences of a single character and assigns the first occurrence to the first capturing group.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`(\w)\1`</ph> 연속 발견 되는 단일 문자 맨 처음 발견 되는 첫 번째 캡처링 그룹에 할당 합니다.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured group.</source>
          <target state="translated">바꾸기 패턴 <ph id="ph1">`$1`</ph> 처음 캡처한 그룹으로 일치 하는 전체를 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement string.</source>
          <target state="translated">대체 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">현재 인스턴스에서 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph>이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">정적 <ph id="ph1">`Replace`</ph> 메서드는 구성에 해당 하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 <ph id="ph3">`Replace`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">일치 하는 항목에 대 한 검색의 시작 부분에서 시작 된 <ph id="ph1">`input`</ph> 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 매개 변수에서 각 일치 되는 문자열을 지정 <ph id="ph2">`input`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 리터럴 텍스트의 조합을 포함할 수 있습니다 및 <bpt id="p1">[</bpt>대체<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">예를 들어 바꾸기 패턴 <ph id="ph1">`a*${test}b`</ph> 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 <ph id="ph2">`test`</ph> 다음 있는 경우 캡처 그룹, "b" 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">다른 모든 정규식 언어 요소를 포함 하 여 <bpt id="p1">[</bpt>이스케이프 문자<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 바꾸기 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`\s+`</ph>, that matches one or more white-space characters.</source>
          <target state="translated">다음 예제에서는 정규식을 정의 <ph id="ph1">`\s+`</ph>, 하나 이상의 공백 문자를 일치 하는 합니다.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement string, " ", replaces them with a single space character.</source>
          <target state="translated">대체 문자열 "", 공백 문자 하나로 바뀝니다.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> 메서드를 로컬 파일 경로 UNC 경로 로컬 컴퓨터 및 드라이브 이름을 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer, and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">정규식 사용 하 여는 <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> 로컬 컴퓨터의 이름을 포함 하는 속성 및 <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> 메서드 논리 드라이브의 이름을 포함 하도록 합니다.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">이 예제를 성공적으로 실행 하려면 로컬 컴퓨터 이름을 가진 리터럴 문자열 "MyMachine" 바꿔야 합니다.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">정규식 패턴은 다음 식으로 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">두 명의 일치 항목이 연속 된 백슬래시 (<ph id="ph1">`\`</ph>) 문자.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">백슬래시 문자는 이스케이프 문자로 해석 되며, 때문에 각 백슬래시는 두 개의 백슬래시를 이스케이프 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Perform a case-insensitive match of the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">반환 되는 문자열의 소문자를 구분는 <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">일치는 기간 (<ph id="ph1">`.`</ph>) 하나 이상의 단어 문자 다음에 오는 문자입니다.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">이 일치 항목 0 개 이상 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">일치 하는 하위 식이 캡처되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">백슬래시 일치 (<ph id="ph1">`\`</ph>) 문자.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Perform a case-insensitive match of the character class that consists of the individual drive lettters.</source>
          <target state="translated">개별 드라이브 문자로 구성 된 문자 클래스는 대/소문자 구분 일치를 수행 합니다.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">이 항목은 처음 캡처된 하위 식입니다.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">일치 리터럴 달러 기호 (<ph id="ph1">`$`</ph>) 문자.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">바꾸기 패턴 <ph id="ph1">`$1`</ph> 처음 캡처된 하위 식에 일치 하는 전체를 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">즉, 드라이브 문자를 가진 UNC 드라이브 및 컴퓨터 이름을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph>가 <ph id="ph4">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 메서드 시간 초과 방지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The recommended static method for replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">패턴 일치를 교체 하도록 권장된 정적 메서드는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 대리자가 반환한 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">현재 인스턴스에서 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph>이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> 메서드는 다음 조건 중 하나에 해당 하는 경우 정규식 일치 항목을 대체 하는 데 유용 합니다.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">대체 문자열은 정규식 대체 패턴에서 쉽게 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">대체 문자열 일부 처리 작업에 일치 하는 문자열에서에서 발생 합니다.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">대체 문자열 조건부 처리의 결과입니다.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">호출 하는 메서드는는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> 메서드와 각각 전달 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 반환 된 개체 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 컬렉션에는 <ph id="ph4">`evaluator`</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 바꾸기 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">다음 예제에서는 정규식을 사용 하 여 문자열에서 개별 단어를 추출 하 고 다음 사용 하 여는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> 라는 메서드를 호출 하는 대리자 <ph id="ph2">`WordScramble`</ph> 단어의 개별 문자를 스크램블입니다.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">이 작업을 수행 하는 <ph id="ph1">`WordScramble`</ph> 메서드는 일치에 문자를 포함 하는 배열을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">또한 임의의 부동 소수점 숫자를 채우는 한 병렬 배열을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">호출 하 여 배열 정렬 되는 <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> 메서드와 정렬 된 배열에 대 한 인수로 제공 됩니다는 <ph id="ph2">&lt;xref:System.String&gt;</ph> 클래스 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">새로 만든된이 문자열은 다음 반환 된 <ph id="ph1">`WordScramble`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\w+`</ph> ; 하나 이상의 단어 문자 일치 정규식 엔진은 계속 공백 문자 같은 한 단어가 아닌 문자에 도달할 때까지 문자 일치 항목으로 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph>가 <ph id="ph4">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 메서드 시간 초과 방지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The recommended static method for evaluating and replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">평가 및 패턴 일치를 대체 하기 위한 권장된 정적 메서드는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The maximum number of times the replacement will occur.</source>
          <target state="translated">바꾸기를 하는 최대 횟수입니다.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">지정된 입력 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 대리자가 반환한 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> 메서드는 다음 조건 중 하나에 해당 하는 경우 정규식 일치 항목을 대체 하는 데 유용 합니다.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">대체 문자열은 정규식 대체 패턴에서 쉽게 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">대체 문자열 일부 처리 작업에 일치 하는 문자열에서에서 발생 합니다.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">대체 문자열 조건부 처리의 결과입니다.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method and passing the first <ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph5">`evaluator`</ph> delegate.</source>
          <target state="translated">호출 하는 메서드는는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> 메서드와 첫 번째 전달 <ph id="ph2">`count`</ph> <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 반환 된 개체 <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 컬렉션에는 <ph id="ph5">`evaluator`</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 발생 하지 않습니다</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The following example uses a regular expression to deliberately misspell half of the words in a list.</source>
          <target state="translated">다음 예에서는 의도적으로 잘못 입력 하는 목록에 있는 단어의 절반에 정규식을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It uses the regular expression <ph id="ph1">`\w*(ie|ei)\w*`</ph> to match words that include the characters "ie" or "ei".</source>
          <target state="translated">정규식을 사용 하 여 <ph id="ph1">`\w*(ie|ei)\w*`</ph> "ie" 또는 "ei" 문자를 포함 하는 단어를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It passes the first half of the matching words to the <ph id="ph1">`ReverseLetter`</ph> method, which, in turn, uses the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to reverse "i" and "e" in the matched string.</source>
          <target state="translated">절반에 일치 하는 단어의 첫 번째 전달에서 <ph id="ph1">`ReverseLetter`</ph> 메서드를 사용 하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> "i"와 일치 하는 문자열의 "e" 되돌리려면 메서드.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The remaining words remain unchanged.</source>
          <target state="translated">나머지 단어 그대로 유지 됩니다.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression <ph id="ph1">`\w*(ie|ei)\w*`</ph> is defined as shown in the following table.</source>
          <target state="translated"><ph id="ph1">`\w*(ie|ei)\w*`</ph> 정규식은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match zero or more word characters.</source>
          <target state="translated">0개 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match either "ie" or "ei".</source>
          <target state="translated">"Ie" 또는 "ei"와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match zero or more word characters.</source>
          <target state="translated">0개 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`([ie])([ie])`</ph> in the <ph id="ph2">`ReverseLetter`</ph> method matches the first "i" or "e" in the diphthong "ie" or "ei" and assigns the letter to the first capturing group.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`([ie])([ie])`</ph> 에 <ph id="ph2">`ReverseLetter`</ph> 메서드 이중 "ie" 또는 "ei"의 첫 번째 "i" 또는 "e"와 일치 하 고 첫 번째 캡처링 그룹에는 문자를 지정 합니다.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It matches the second "i" or "e" and assigns the letter to the second capturing group.</source>
          <target state="translated">두 번째 "i" 또는 "e"와 일치 하 고 두 번째 캡처링 그룹에는 문자를 지정 합니다.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The two characters are then reversed by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> method with the replacement pattern <ph id="ph2">`$2$1`</ph>.</source>
          <target state="translated">두 개의 문자를 호출 하 여 다음 반대가 됩니다는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> 바꾸기 패턴을 사용 하 여 메서드 <ph id="ph2">`$2$1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The replacement string.</source>
          <target state="translated">대체 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Maximum number of times the replacement can occur.</source>
          <target state="translated">바꾸기를 하는 최대 횟수입니다.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The character position in the input string where the search begins.</source>
          <target state="translated">입력 문자열에서 검색을 시작할 문자 위치입니다.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">지정된 입력 부분 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 지정된 대체 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The search for matches starts in the <ph id="ph1">`input`</ph> string at the position specified by the <ph id="ph2">`startat`</ph> parameter.</source>
          <target state="translated">일치 하는 항목 검색 시작는 <ph id="ph1">`input`</ph> 문자열에 지정 된 위치에서는 <ph id="ph2">`startat`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is negative, replacements continue to the end of the string.</source>
          <target state="translated">경우 <ph id="ph1">`count`</ph> 가 음수 이면 문자열의 끝까지 바꾸기가 계속 합니다.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> exceeds the number of matches, all matches are replaced.</source>
          <target state="translated">경우 <ph id="ph1">`count`</ph> 일치 항목 개수를 초과 하면, 일치 하는 모든 대체 됩니다.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 매개 변수에서 각 일치 되는 문자열을 지정 <ph id="ph2">`input`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 리터럴 텍스트의 조합을 포함할 수 있습니다 및 <bpt id="p1">[</bpt>대체<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">예를 들어 바꾸기 패턴 <ph id="ph1">`a*${test}b`</ph> 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 <ph id="ph2">`test`</ph> 다음 있는 경우 캡처 그룹, "b" 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">다른 모든 정규식 언어 요소를 포함 하 여 <bpt id="p1">[</bpt>이스케이프 문자<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 발생 하지 않습니다</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The following example double-spaces all but the first line of a string.</source>
          <target state="translated">다음 예제에서는 문자열의 첫 번째 줄을 제외한 모든 double-spaces 합니다.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>It defines a regular expression pattern, <ph id="ph1">`^.*$`</ph>, that matches a line of text, calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method to match the first line of the string, and uses the <ph id="ph3">`Match.Index`</ph> and <ph id="ph4">`Match.Count`</ph> properties to determine the starting position of the second line.</source>
          <target state="translated">정규식 패턴을 정의 <ph id="ph1">`^.*$`</ph>, 텍스트, 호출의 줄에 일치 하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> 메서드를 사용 하 고 문자열의 첫 번째 줄과 일치는 <ph id="ph3">`Match.Index`</ph> 및 <ph id="ph4">`Match.Count`</ph> 두 번째의 시작 위치를 결정 하는 속성 선입니다.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`^.*$`</ph> is defined as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`^.*$`</ph>는 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match the start of a line.</source>
          <target state="translated">줄의 시작을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>(Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object was instantiated by using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; otherwise, this character class would only match the beginning of the input string.)</source>
          <target state="translated">(사항에 유의 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 사용 하 여 인스턴스화는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> 옵션;이 문자 클래스는 입력된 문자열의 시작 부분 것만 일치 하는 그렇지 않은 경우.)</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match any character zero or more times.</source>
          <target state="translated">임의의 문자 0 회 이상 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match the end of a line.</source>
          <target state="translated">줄의 끝 부분을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>(Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object was instantiated by using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; otherwise, this character class would only match the beginning of the input string.)</source>
          <target state="translated">(사항에 유의 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 사용 하 여 인스턴스화는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> 옵션;이 문자 클래스는 입력된 문자열의 시작 부분 것만 일치 하는 그렇지 않은 경우.)</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The replacement string (<ph id="ph1">`vbCrLf + "$&amp;"`</ph> in Visual Basic, <ph id="ph2">`"\n$&amp;"`</ph> in C#) adds a new line before the matched string.</source>
          <target state="translated">대체 문자열 (<ph id="ph1">`vbCrLf + "$&amp;"`</ph> Visual Basic의 <ph id="ph2">`"\n$&amp;"`</ph> C#) 일치 하는 문자열 앞에 새 줄을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Note that <ph id="ph1">`\n`</ph> in the C# example is interpreted as the newline character by the C# compiler; it does not represent a regular expression character escape.</source>
          <target state="translated"><ph id="ph1">`\n`</ph> C# 예제로 해석 됩니다는 줄 바꿈 문자는 C# 컴파일러에 의해; 정규식 문자 이스케이프를 나타내지 않습니다.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph>이 0보다 작거나 <ph id="ph2">&lt;paramref name="input" /&gt;</ph>의 길이보다 큰 경우</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string.</source>
          <target state="translated">대체 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">지정한 옵션에 따라 일치 작업이 수정됩니다.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">현재 인스턴스에서 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph>이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">정적 <ph id="ph1">`Replace`</ph> 메서드는 구성에 해당 하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 <ph id="ph3">`Replace`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">지정 하는 경우 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> 에 대 한는 <ph id="ph2">`options`</ph> 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽 이동, 그렇지 않으면 검색 입력된 문자열의 시작 부분에서 시작 하 고 오른쪽으로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 매개 변수에서 각 일치 되는 문자열을 지정 <ph id="ph2">`input`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 리터럴 텍스트의 조합을 포함할 수 있습니다 및 <bpt id="p1">[</bpt>대체<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">예를 들어 바꾸기 패턴 <ph id="ph1">`a*${test}b`</ph> 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 <ph id="ph2">`test`</ph> 다음 있는 경우 캡처 그룹, "b" 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">다른 모든 정규식 언어 요소를 포함 하 여 <bpt id="p1">[</bpt>이스케이프 문자<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 바꾸기 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 메서드를 로컬 파일 경로 UNC 경로 로컬 컴퓨터 및 드라이브 이름을 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer, and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">정규식 사용 하 여는 <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> 로컬 컴퓨터의 이름을 포함 하는 속성 및 <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> 메서드 논리 드라이브의 이름을 포함 하도록 합니다.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>All regular expression string comparisons are case-insensitive.</source>
          <target state="translated">모든 정규식 문자열 비교 대/소문자를 구분 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">이 예제를 성공적으로 실행 하려면 로컬 컴퓨터 이름을 가진 리터럴 문자열 "MyMachine" 바꿔야 합니다.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">정규식 패턴은 다음 식으로 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">두 명의 일치 항목이 연속 된 백슬래시 (<ph id="ph1">`\`</ph>) 문자.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">백슬래시 문자는 이스케이프 문자로 해석 되며, 때문에 각 백슬래시는 두 개의 백슬래시를 이스케이프 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">반환 되는 문자열과 일치는 <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">일치는 기간 (<ph id="ph1">`.`</ph>) 하나 이상의 단어 문자 다음에 오는 문자입니다.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">이 일치 항목 0 개 이상 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">일치 하는 하위 식이 캡처되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">백슬래시 일치 (<ph id="ph1">`\`</ph>) 문자.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the character class that consists of the individual drive letters.</source>
          <target state="translated">개별 드라이브 문자 구성 된 문자 클래스와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">이 항목은 처음 캡처된 하위 식입니다.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">일치 리터럴 달러 기호 (<ph id="ph1">`$`</ph>) 문자.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">바꾸기 패턴 <ph id="ph1">`$1`</ph> 처음 캡처된 하위 식에 일치 하는 전체를 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">즉, 드라이브 문자를 가진 UNC 드라이브 및 컴퓨터 이름을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph>가 <ph id="ph4">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값의 유효한 비트 조합이 아닌 경우</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">이 메서드가 제한 시간 초과 후 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 메서드 시간 초과 방지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">패턴 일치를 교체 하도록 권장된 정적 메서드는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 대리자가 반환한 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">지정한 옵션에 따라 일치 작업이 수정됩니다.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">현재 인스턴스에서 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph>이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match in if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> 메서드는 다음 조건 중 하나에 해당 되는 경우에 정규식 일치 항목을 대체 하는 데 유용 합니다.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">대체 문자열은 정규식 대체 패턴에서 쉽게 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">대체 문자열 일부 처리 작업에 일치 하는 문자열에서에서 발생 합니다.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">대체 문자열 조건부 처리의 결과입니다.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">호출 하는 메서드는는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> 메서드와 각각 전달 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 반환 된 개체 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 컬렉션에는 <ph id="ph4">`evaluator`</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">지정 하는 경우 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> 에 대 한는 <ph id="ph2">`options`</ph> 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽 이동, 그렇지 않으면 검색 입력된 문자열의 시작 부분에서 시작 하 고 오른쪽으로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 바꾸기 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">다음 예제에서는 정규식을 사용 하 여 문자열에서 개별 단어를 추출 하 고 다음 사용 하 여는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> 라는 메서드를 호출 하는 대리자 <ph id="ph2">`WordScramble`</ph> 단어의 개별 문자를 스크램블입니다.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">이 작업을 수행 하는 <ph id="ph1">`WordScramble`</ph> 메서드는 일치에 문자를 포함 하는 배열을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">또한 임의의 부동 소수점 숫자를 채우는 한 병렬 배열을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">호출 하 여 배열 정렬 되는 <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> 메서드와 정렬 된 배열에 대 한 인수로 제공 됩니다는 <ph id="ph2">&lt;xref:System.String&gt;</ph> 클래스 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">새로 만든된이 문자열은 다음 반환 된 <ph id="ph1">`WordScramble`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\w+`</ph> ; 하나 이상의 단어 문자 일치 정규식 엔진은 계속 공백 문자 같은 한 단어가 아닌 문자에 도달할 때까지 문자 일치 항목으로 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method includes the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option so that the comment in the regular expression pattern <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> is ignored by the regular expression engine.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 메서드를 포함는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> 옵션 있도록 정규식 패턴에서 주석을 <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> 정규식 엔진에 의해 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph>가 <ph id="ph4">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값의 유효한 비트 조합이 아닌 경우</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The maximum number of times the replacement will occur.</source>
          <target state="translated">바꾸기를 하는 최대 횟수입니다.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The character position in the input string where the search begins.</source>
          <target state="translated">입력 문자열에서 검색을 시작할 문자 위치입니다.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">지정된 입력 부분 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 대리자가 반환한 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> 메서드는 다음 조건 중 하나에 해당 하는 경우 정규식 일치 항목을 대체 하는 데 유용 합니다.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">대체 문자열은 정규식 대체 패턴에서 쉽게 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">대체 문자열 일부 처리 작업에 일치 하는 문자열에서에서 발생 합니다.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">대체 문자열 조건부 처리의 결과입니다.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method and passing the first <ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph5">`evaluator`</ph> delegate.</source>
          <target state="translated">호출 하는 메서드는는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> 메서드와 첫 번째 전달 <ph id="ph2">`count`</ph> <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 반환 된 개체 <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 컬렉션에는 <ph id="ph5">`evaluator`</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">정규식은 현재에 대 한 생성자에 의해 정의 된 패턴 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 바꾸기 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 발생 하지 않습니다</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph>이 0보다 작거나 <ph id="ph2">&lt;paramref name="input" /&gt;</ph>의 길이보다 큰 경우</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The replacement string.</source>
          <target state="translated">대체 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">추가 매개 변수는 일치하는 항목이 없는 경우 제한 시간 간격과 일치 작업을 수정하는 옵션을 지정합니다.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">현재 인스턴스에서 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph>이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">정적 <ph id="ph1">`Replace`</ph> 메서드는 구성에 해당 하는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 인스턴스 메서드를 호출 하는 지정 된 정규식 패턴을 가진 개체 <ph id="ph3">`Replace`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">지정 하는 경우 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> 에 대 한는 <ph id="ph2">`options`</ph> 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽 이동, 그렇지 않으면 검색 입력된 문자열의 시작 부분에서 시작 하 고 오른쪽으로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 매개 변수에서 각 일치 되는 문자열을 지정 <ph id="ph2">`input`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 리터럴 텍스트의 조합을 포함할 수 있습니다 및 <bpt id="p1">[</bpt>대체<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">예를 들어 바꾸기 패턴 <ph id="ph1">`a*${test}b`</ph> 문자열을 삽입 "는 *"과 일치 하는 부분 문자열 뒤의 <ph id="ph2">`test`</ph> 다음 있는 경우 캡처 그룹, "b" 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">다른 모든 정규식 언어 요소를 포함 하 여 <bpt id="p1">[</bpt>이스케이프 문자<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, 정규식 패턴에 대해서만에 사용할 수 및 바꾸기 패턴에서 인식 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 매개 변수 지정 긴 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리 하는 경우 응답을 중지 하 게 표시 되지 않도록 과도 한 역 추적을 사용 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 들어 있는입니다.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>정규식에 대 한 유용한<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> 및 <bpt id="p2">[</bpt>역 추적<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">일치 항목이 없으면 해당 시간 간격에서 발견 되 면 경우에 메서드에서 throw 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 메서드가 실행 되는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> 메서드를 로컬 파일 경로 UNC 경로 로컬 컴퓨터 및 드라이브 이름을 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">정규식 사용 하 여는 <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> 로컬 컴퓨터의 이름을 포함 하는 속성 및 <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> 메서드 논리 드라이브의 이름을 포함 하도록 합니다.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>All regular expression string comparisons are case-insensitive, and any single replacement operation times out if a match cannot be found in 0.5 second.</source>
          <target state="translated">모든 정규식 문자열 비교는 대/소문자를 구분 하 고 일치 하는 0.5 초에서 찾을 수 없는 경우 모든 단일 바꾸기 작업 시간이 초과 합니다.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">이 예제를 성공적으로 실행 하려면 로컬 컴퓨터 이름을 가진 리터럴 문자열 "MyMachine" 바꿔야 합니다.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">정규식 패턴은 다음 식으로 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">두 명의 일치 항목이 연속 된 백슬래시 (<ph id="ph1">`\`</ph>) 문자.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">백슬래시 문자는 이스케이프 문자로 해석 되며, 때문에 각 백슬래시는 두 개의 백슬래시를 이스케이프 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">반환 되는 문자열과 일치는 <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">일치는 기간 (<ph id="ph1">`.`</ph>) 하나 이상의 단어 문자 다음에 오는 문자입니다.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">이 일치 항목 0 개 이상 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">일치 하는 하위 식이 캡처되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">백슬래시 일치 (<ph id="ph1">`\`</ph>) 문자.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the character class that consists of the individual drive letters.</source>
          <target state="translated">개별 드라이브 문자 구성 된 문자 클래스와 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">이 항목은 처음 캡처된 하위 식입니다.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">일치 리터럴 달러 기호 (<ph id="ph1">`$`</ph>) 문자.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">바꾸기 패턴 <ph id="ph1">`$1`</ph> 처음 캡처된 하위 식에 일치 하는 전체를 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">즉, 드라이브 문자를 가진 UNC 드라이브 및 컴퓨터 이름을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph>가 <ph id="ph4">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값의 유효한 비트 조합이 아닌 경우</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>이 음수, 0 또는 약 24일보다 큰 경우</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">설정 하는 것이 좋습니다는 <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 매개 변수를 2 초 등의 적절 한 값입니다.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">제한 시간을 사용 하지 않도록 지정 하 여 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">그러나 다음과 같은 경우에만 제한 시간을 비활성화 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 시기나 정적 텍스트로 구성 합니다.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">가까운 일치 및 일치 하는 일치 하지 않는 경우 정규식 패턴에 철저히 테스트 효율적으로 처리 하는입니다.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">경우 정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">일치 항목을 검색할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">각 항목의 일치 여부를 조사하고 원래 일치 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of enumeration values that provide options for matching.</source>
          <target state="translated">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In a specified input string, replaces all substrings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 부분 문자열을 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 대리자가 반환한 문자열로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">추가 매개 변수는 일치하는 항목이 없는 경우 제한 시간 간격과 일치 작업을 수정하는 옵션을 지정합니다.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">현재 인스턴스에서 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph>이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> 메서드는 다음 조건 중 하나에 해당 하는 경우 정규식 일치 항목을 대체 하는 데 유용 합니다.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">대체 문자열에 정규식 대체 패턴에서 쉽게 지정할 수 없는 경우.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string results from some processing performed on the matched string.</source>
          <target state="translated">대체 문자열에서 발생 하는 경우 일부 처리 일치 하는 문자열에서 수행 합니다.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string results from conditional processing.</source>
          <target state="translated">대체 문자열 조건부 처리에서 발생 하는 경우.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">호출 하는 메서드는는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> 메서드와 각각 전달 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 반환 된 개체 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> 컬렉션에는 <ph id="ph4">`evaluator`</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph> 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 하 고 일치 하는 문자열을 검사 하 합니다.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">사용자 지정 메서드는 다음 서명이 일치 하도록 있어야는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">지정 하는 경우 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> 에 대 한는 <ph id="ph2">`options`</ph> 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽 이동, 그렇지 않으면 검색 입력된 문자열의 시작 부분에서 시작 하 고 오른쪽으로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to "stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 매개 변수 지정 긴 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 정규식에 나타나지 않도록 과도 한 역 추적을 사용 하는 시간 제한 간격을 설정 하면 "입력을 처리할 때 응답 하지 유사 항목 들어 있는입니다.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>정규식에 대 한 유용한<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> 및 <bpt id="p2">[</bpt>역 추적<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">일치 항목이 없으면 해당 시간 간격에서 발견 되 면 경우에 메서드에서 throw 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 메서드가 실행 되는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">메서드가 반환 하므로 <ph id="ph1">`input`</ph> 일치 하는 경우 변경 되지 않고 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드가 입력된 문자열 대체 하는지 여부도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">다음 예제에서는 정규식을 사용 하 여 문자열에서 개별 단어를 추출 하 고 다음 사용 하 여는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> 라는 메서드를 호출 하는 대리자 <ph id="ph2">`WordScramble`</ph> 단어의 개별 문자를 스크램블입니다.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">이 작업을 수행 하는 <ph id="ph1">`WordScramble`</ph> 메서드는 일치에 문자를 포함 하는 배열을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">또한 임의의 부동 소수점 숫자를 채우는 한 병렬 배열을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">호출 하 여 배열 정렬 되는 <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> 메서드와 정렬 된 배열에 대 한 인수로 제공 됩니다는 <ph id="ph2">&lt;xref:System.String&gt;</ph> 클래스 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">새로 만든된이 문자열은 다음 반환 된 <ph id="ph1">`WordScramble`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\w+`</ph> ; 하나 이상의 단어 문자 일치 정규식 엔진은 계속 공백 문자 같은 한 단어가 아닌 문자에 도달할 때까지 문자 일치 항목으로 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method includes the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option so that the comment in the regular expression pattern <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> is ignored by the regular expression engine.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> 메서드를 포함는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> 옵션 있도록 정규식 패턴에서 주석을 <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> 정규식 엔진에 의해 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph>가 <ph id="ph4">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값의 유효한 비트 조합이 아닌 경우</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>이 음수, 0 또는 약 24일보다 큰 경우</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">설정 하는 것이 좋습니다는 <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 매개 변수를 2 초 등의 적절 한 값입니다.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">제한 시간을 사용 하지 않도록 지정 하 여 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">그러나 다음과 같은 경우에만 제한 시간을 비활성화 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 시기나 정적 텍스트로 구성 합니다.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">가까운 일치 및 일치 하는 일치 하지 않는 경우 정규식 패턴에 철저히 테스트 효율적으로 처리 하는입니다.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">경우 정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source>Gets a value that indicates whether the regular expression searches from right to left.</source>
          <target state="translated">정규식을 사용하여 오른쪽에서 왼쪽으로 검색하는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression searches from right to left; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">정규식을 사용하여 오른쪽에서 왼쪽으로 검색하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.RightToLeft%2A&gt;</ph> is <ph id="ph2">`true`</ph> if the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance was created with the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> option.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.RightToLeft%2A&gt;</ph> <ph id="ph2">`true`</ph> 경우는 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 와 인스턴스를 만들었습니다.는 <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> 옵션입니다.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.roptions">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드에서 생성되는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체에서 사용됩니다.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression match.</source>
          <target state="translated">정규식 일치에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The string to split.</source>
          <target state="translated">분할할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 생성자에서 지정된 정규식 패턴에 의해 정의된 위치에서 입력 문자열을 부분 문자열의 배열로 분할합니다.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>An array of strings.</source>
          <target state="translated">문자열 배열입니다.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 메서드는 비슷합니다는 <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> 메서드와 비슷하지만 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">문자열은 최대한 많이 분할 됩니다.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If no delimiter is found, the return value contains one element whose value is the original input string.</source>
          <target state="translated">구분 기호 없음이 없으면 반환 값은 하나의 값이 인 요소는 원래 입력된 문자열을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">여러 명의 일치 항목을 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</source>
          <target state="translated">예를 들어 단일 하이픈에서 문자열을 분할 하면 반환 된 배열의 다음 코드와 같이 인접 한 두 개의 하이픈은 찾을 수 위치에 빈 문자열을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">시작 부분이 나 입력된 문자열의 끝에 일치 하는 빈 문자열의 시작 이나 반환 된 배열의 끝에 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`\d+`</ph> to split an input string on numeric characters.</source>
          <target state="translated">다음 예제에서는 정규식 패턴을 사용 하 여 <ph id="ph1">`\d+`</ph> 숫자 문자에는 입력된 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">반환 된 배열의 첫 번째 및 마지막 요소의 값이 문자열이 시작 되 고 숫자 문자 일치 끝나는, 때문에 <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">캡처링 괄호에 사용 되는 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 식, 캡처된 모든 텍스트는 결과 문자열 배열에 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">예를 들어 "plum 기준" 하이픈에서 캡처 괄호 안에 배치 하는 문자열을 분할 하면 반환 되는 배열 하이픈을 포함 하는 문자열 요소를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">.NET Framework 1.0 및 1.1 캡처 괄호, 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">.NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">예를 들어 다음 코드 캡처 괄호의 두 집합을 사용 하 여 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 합니다.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 슬래시 문자; 제외 컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우에 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%29&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">정규식에는 빈 문자열이 면과 일치할 수 있으면 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%29&gt;</ph> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example:</source>
          <target state="translated">예:</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Note that the returned array also includes an empty string at the beginning and end of the array.</source>
          <target state="translated">참고가 반환 되는 배열 시작과 배열의 끝에 빈 문자열을도 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> split 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 발생 하지 않습니다</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The string to be split.</source>
          <target state="translated">분할될 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The maximum number of times the split can occur.</source>
          <target state="translated">분할할 수 있는 최대 횟수입니다.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">입력 문자열을 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 생성자에서 지정된 정규식에 의해 정의된 위치에서 지정된 최대 수만큼 부분 문자열의 배열로 분할합니다.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>An array of strings.</source>
          <target state="translated">문자열 배열입니다.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 메서드는 비슷합니다는 <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> 메서드와 비슷하지만 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter specifies the maximum number of substrings into which the <ph id="ph2">`input`</ph> string can be split; the last string contains the unsplit remainder of the string.</source>
          <target state="translated"><ph id="ph1">`count`</ph> 문자열의 최대 수를 지정 하는 매개 변수는 <ph id="ph2">`input`</ph> 문자열을 분할 될 수 있습니다; 마지막 문자열 문자열 변수를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>A <ph id="ph1">`count`</ph> value of zero provides the default behavior of splitting as many times as possible.</source>
          <target state="translated">A <ph id="ph1">`count`</ph> 최대한 많이 분할의 기본 동작을 제공 하는 값이 0입니다.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If multiple matches are adjacent to one another or if a match is found at the beginning or end of <ph id="ph1">`input`</ph>, and the number of matches found is at least two less than <ph id="ph2">`count`</ph>, an empty string is inserted into the array.</source>
          <target state="translated">여러 명의 일치 항목이 서로 인접 한 경우 또는 시작 이나 끝 일치 하는 경우 <ph id="ph1">`input`</ph>, 발견 된 일치 레코드 수는 2 이상 및 보다 작은 <ph id="ph2">`count`</ph>, 빈 문자열 배열에 삽입 됩니다.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>That is, empty strings that result from adjacent matches or from matches at the beginning or end of the input string are counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">즉, 일치 하는 인접 한 항목 또는 시작 이나 입력된 문자열의 끝 부분에서 일치 항목에서 발생 하는 빈 문자열 판단할 때 고려 됩니다 수에 부분 문자열 equals와 일치 하는지 여부 <ph id="ph1">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>In the following example, the regular expression <ph id="ph1">`/d+`</ph> is used to split an input string that includes one or more decimal digits into a maximum of three substrings.</source>
          <target state="translated">다음 예제에서는 정규식에서에서 <ph id="ph1">`/d+`</ph> 세 부분 문자열을 최대 하나 이상의 10 진수 숫자가 포함 된 입력된 문자열을 분할 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Because the beginning of the input string matches the regular expression pattern, the first array element contains <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, the second contains the first set of alphabetic characters in the input string, and the third contains the remainder of the string that follows the third match.</source>
          <target state="translated">첫 번째 배열 요소를 포함 하는 정규식 패턴과 일치 하는 입력된 문자열의 시작 하기 때문에 <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, 영문자 입력된 문자열에서 첫 번째 집합을 포함 하는 두 번째 및 세 번째 문자열의 나머지를 포함 합니다. 세 번째 일치 항목 다음에 오는 합니다.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</source>
          <target state="translated">정규식의 캡처링 괄호를 사용 하면 캡처된 텍스트가 모두 분할 문자열의 배열에 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, any array elements that contain captured text are not counted in determining whether the number of matches has reached <ph id="ph1">`count`</ph>.</source>
          <target state="translated">그러나 캡처된 텍스트가 들어 있는 배열 요소 고려 되지 않습니다 확인 된 일치 레코드 수에 도달 하는지 여부를 <ph id="ph1">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For example, splitting the string "apple-apricot-plum-pear-banana" into a maximum of four substrings results in a seven-element array, as the following code shows.</source>
          <target state="translated">예를 들어 다음 코드와 7 개 요소 배열의 네 부분 문자열 결과의 최대값에 "apple-장의-plum-배-바나나" 문자열을 분할을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>In the .NET Framework 1.0 and 1.1, only captured text from the first set of capturing parentheses is included in the returned array.</source>
          <target state="translated">.NET Framework 1.0 및 1.1에서 캡처된 텍스트 캡처 괄호의 첫 번째 집합에서 반환된 된 배열에 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Starting with the .NET Framework 2.0, all captured text is added to the returned array.</source>
          <target state="translated">.NET Framework 2.0 부터는 모든 캡처된 텍스트가 반환된 된 배열에 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, elements in the returned array that contain captured text are not counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">그러나 요소 반환된 된 배열에 캡처된 텍스트가 들어 있는 고려 되지 않습니다 결정할 때의 수에 부분 문자열 equals와 일치 하는지 여부 <ph id="ph1">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For example, in the following code, a regular expression uses two sets of capturing parentheses to extract the elements of a date from a date string.</source>
          <target state="translated">예를 들어 다음 코드에서는 정규식을 사용 하 여 캡처 괄호의 두 집합 날짜 문자열에서 날짜의 요소를 추출 합니다.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> method then specifies a maximum of two elements in the returned array.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> 메서드 다음 반환된 된 배열에는 최대 두 개의 요소를 지정 합니다.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, the method returns a two-element string array.</source>
          <target state="translated">예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 메서드는 두 요소 문자열 배열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If it is compiled and run under the .NET Framework 2.0 or later versions, the method returns a three-element string array.</source>
          <target state="translated">컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우 메서드는 세 요소로 문자열 배열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">정규식에는 빈 문자열이 면과 일치할 수 있으면 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The following example splits the string "characters" into as many elements as there are in the input string.</source>
          <target state="translated">다음 예제에서는 입력된 문자열에 있는 요소 수 만큼를 "문자" 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Because the null string matches the beginning of the input string, a null string is inserted at the beginning of the returned array.</source>
          <target state="translated">Null 문자열은 입력된 문자열의 시작 부분와 일치 하므로 null 문자열이 반환 되는 배열의 시작 부분에 삽입 됩니다.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>This causes the tenth element to consist of the two characters at the end of the input string.</source>
          <target state="translated">이렇게 하면 10 번째 요소는 입력된 문자열의 끝에 두 개의 문자로 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> split 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 발생 하지 않습니다</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The string to split.</source>
          <target state="translated">분할할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression pattern.</source>
          <target state="translated">정규식 패턴에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>An array of strings.</source>
          <target state="translated">문자열 배열입니다.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 메서드는 비슷합니다는 <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> 메서드와 비슷하지만 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">`input`</ph> string is split as many times as possible.</source>
          <target state="translated"><ph id="ph1">`input`</ph> 가능한 횟수 만큼 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If <ph id="ph1">`pattern`</ph> is not found in the <ph id="ph2">`input`</ph> string, the return value contains one element whose value is the original <ph id="ph3">`input`</ph> string.</source>
          <target state="translated">경우 <ph id="ph1">`pattern`</ph> 사전에 <ph id="ph2">`input`</ph> 문자열, 반환 값은 원래 값을 가진 요소가 하나 포함 되어 <ph id="ph3">`input`</ph> 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">컴파일된 정적에 대 한 호출에 사용 된 정규식 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> 메서드 자동으로 캐시 됩니다.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">컴파일된 정규식의 수명을 직접 관리 하려면 인스턴스를 사용 하 여 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">여러 명의 일치 항목을 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</source>
          <target state="translated">예를 들어 단일 하이픈에서 문자열을 분할 하면 반환 된 배열의 다음 코드와 같이 인접 한 두 개의 하이픈은 찾을 수 위치에 빈 문자열을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">시작 부분이 나 입력된 문자열의 끝에 일치 하는 빈 문자열의 시작 이나 반환 된 배열의 끝에 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`\d+`</ph> to split an input string on numeric characters.</source>
          <target state="translated">다음 예제에서는 정규식 패턴을 사용 하 여 <ph id="ph1">`\d+`</ph> 숫자 문자에는 입력된 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">반환 된 배열의 첫 번째 및 마지막 요소의 값이 문자열이 시작 되 고 숫자 문자 일치 끝나는, 때문에 <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">캡처링 괄호에 사용 되는 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 식, 캡처된 모든 텍스트는 결과 문자열 배열에 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">예를 들어 "plum 기준" 하이픈에서 캡처 괄호 안에 배치 하는 문자열을 분할 하면 반환 되는 배열 하이픈을 포함 하는 문자열 요소를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">.NET Framework 1.0 및 1.1 캡처 괄호, 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">.NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">예를 들어 다음 코드 캡처 괄호의 두 집합을 사용 하 여 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 합니다.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 슬래시 문자; 제외 컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우에 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">정규식에는 빈 문자열이 면과 일치할 수 있으면 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example:</source>
          <target state="translated">예:</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Note that the returned array also includes an empty string at the beginning and end of the array.</source>
          <target state="translated">참고가 반환 되는 배열 시작과 배열의 끝에 빈 문자열을도 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> split 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">이 메서드가 제한 시간 초과 후 메서드가 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 메서드 시간 초과 방지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The recommended static method for splitting text on a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">텍스트 패턴 일치를 분할 하는 데 권장 되는 정적 메서드는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The string to be split.</source>
          <target state="translated">분할될 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The maximum number of times the split can occur.</source>
          <target state="translated">분할할 수 있는 최대 횟수입니다.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The character position in the input string where the search will begin.</source>
          <target state="translated">입력 문자열에서 검색을 시작할 문자 위치입니다.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">입력 문자열을 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 생성자에서 지정된 정규식에 의해 정의된 위치에서 지정된 최대 수만큼 부분 문자열의 배열로 분할합니다.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The search for the regular expression pattern starts at a specified character position in the input string.</source>
          <target state="translated">입력 문자열에서 지정된 문자 위치부터 정규식 패턴을 검색합니다.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>An array of strings.</source>
          <target state="translated">문자열 배열입니다.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 메서드는 비슷합니다는 <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> 메서드와 비슷하지만 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter specifies the maximum number of substrings into which the <ph id="ph2">`input`</ph> string is split; the last string contains the unsplit remainder of the string.</source>
          <target state="translated"><ph id="ph1">`count`</ph> 문자열의 최대 수를 지정 하는 매개 변수는 <ph id="ph2">`input`</ph> 문자열을 분할 마지막 문자열 문자열 변수를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>A <ph id="ph1">`count`</ph> value of zero provides the default behavior of splitting as many times as possible.</source>
          <target state="translated">A <ph id="ph1">`count`</ph> 최대한 많이 분할의 기본 동작을 제공 하는 값이 0입니다.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startat`</ph> parameter defines the point at which the search for the first delimiter begins (this can be used for skipping leading white space).</source>
          <target state="translated"><ph id="ph1">`startat`</ph> 매개 변수는 첫 번째 구분 기호에 대 한 검색을 시작할 지점 정의 (이 수에 사용할 선행 공백은 건너뛰도록).</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If no matches are found from the <ph id="ph1">`count`</ph>+1 position in the string, the method returns a one-element array that contains the <ph id="ph2">`input`</ph> string.</source>
          <target state="translated">일치 하는 경우는 <ph id="ph1">`count`</ph>+ 1 위치를 표시, 메서드가 포함 된 요소가 하나인 배열을 반환는 <ph id="ph2">`input`</ph> 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If one or more matches are found, the first element of the returned array contains the first portion of the string from the first character up to one character before the match.</source>
          <target state="translated">하나 이상의 일치 항목 발견 되 면 반환 된 배열의 첫 번째 요소는 한 문자는 일치 항목 앞까지 첫 번째 문자부터 문자열의 첫 번째 부분을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If multiple matches are adjacent to one another and the number of matches found is at least two less than <ph id="ph1">`count`</ph>, an empty string is inserted into the array.</source>
          <target state="translated">여러 명의 일치 항목이 서로 인접 한 있으며 발견 된 일치 레코드 수는 최소한 2 보다 작은 <ph id="ph1">`count`</ph>, 빈 문자열 배열에 삽입 됩니다.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Similarly, if a match is found at <ph id="ph1">`startat`</ph>, which is the first character in the string, the first element of the returned array is an empty string.</source>
          <target state="translated">마찬가지로,에 일치 하는 경우 <ph id="ph1">`startat`</ph>을 만드는데 문자열의 첫 번째 문자, 반환 된 배열의 첫 번째 요소는 빈 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>That is, empty strings that result from adjacent matches are counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">즉, 일치 하는 인접 한 항목에서 발생 하는 빈 문자열 판단할 때 고려 됩니다 수에 부분 문자열 equals와 일치 하는지 여부 <ph id="ph1">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>In the following example, the regular expression <ph id="ph1">`\d+`</ph> is used to find the starting position of the first substring of numeric characters in a string, and then to split the string a maximum of three times starting at that position.</source>
          <target state="translated">다음 예제에서는 정규식에서에서 <ph id="ph1">`\d+`</ph> 를 사용 하는 문자열에 숫자 문자의 첫 번째 부분 문자열의 시작 위치를 찾을 문자열을 분할의 최대는 차례로 세 번 해당 위치에서 시작 합니다.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Because the regular expression pattern matches the beginning of the input string, the returned string array consists of an empty string, a five-character alphabetic string, and the remainder of the string,</source>
          <target state="translated">빈 문자열, 5 자로 이루어진 영 문자열 및 문자열의 나머지 부분에서는 반환 된 문자열 배열 구성 정규식 패턴이 입력된 문자열의 시작 일치 하기 때문에</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</source>
          <target state="translated">정규식의 캡처링 괄호를 사용 하면 캡처된 텍스트가 모두 분할 문자열의 배열에 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>However, any array elements that contain captured text are not counted in determining whether the number of matches has reached <ph id="ph1">`count`</ph>.</source>
          <target state="translated">그러나 캡처된 텍스트가 들어 있는 배열 요소 고려 되지 않습니다 확인 된 일치 레코드 수에 도달 하는지 여부를 <ph id="ph1">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For example, splitting the string '"apple-apricot-plum-pear-pomegranate-pineapple-peach" into a maximum of four substrings beginning at character 15 in the string results in a seven-element array, as the following code shows.</source>
          <target state="translated">예를 들어 문자열을 분할 ' "apple-apricot-plum-pear-pomegranate-pineapple-peach" 4 개의 최대 7 개 요소 배열에서 문자열 결과에 15 문자에서 시작 하는 다음 코드 에서처럼 부분 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>In .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">.NET Framework 1.0 및 1.1 캡처 괄호, 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">.NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the individual words in a string.</source>
          <target state="translated">예를 들어 다음 코드를 사용 하 여 캡처 괄호의 두 집합 문자열에서 개별 단어를 추출 합니다.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the vertical bar.</source>
          <target state="translated">캡처 괄호의 첫 번째 집합에서 하이픈을 캡처하고 두 번째 집합 세로 막대를 캡처합니다.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the vertical bar characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우이 메서드를 제외 세로 막대 지정할 때; 컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우에 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">정규식에는 빈 문자열이 면과 일치할 수 있으면 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The following example splits the string "characters" into as many elements as the input string contains, starting with the character "a".</source>
          <target state="translated">다음 예제에서는 입력된 문자열에는 문자로 시작 하는 대로 많은 요소에 "문자" 문자열을 분할 "a"입니다.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Because the null string matches the end of the input string, a null string is inserted at the end of the returned array.</source>
          <target state="translated">Null 문자열은 입력된 문자열의 끝와 일치 하므로 null 문자열이 반환 된 배열의 끝에 삽입 됩니다.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> split 작업의 실행 시간으로 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">생성자를 호출 하는 경우에 시간 제한 간격을 설정 하지 않으면 작업이 있는 응용 프로그램 도메인에 대해 설정 된 제한 시간 값을 초과 하는 경우 예외가 throw 되는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">제한 시간 없음을에 정의 된 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 생성자 호출 응용 프로그램 도메인의 속성에서 제한 시간 값이 또는 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 발생 하지 않습니다</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph>이 0보다 작거나 <ph id="ph2">&lt;paramref name="input" /&gt;</ph>의 길이보다 큰 경우</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to split.</source>
          <target state="translated">분할할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</source>
          <target state="translated">지정된 정규식 패턴에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">지정한 옵션에 따라 일치 작업이 수정됩니다.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>An array of strings.</source>
          <target state="translated">문자열 배열입니다.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 메서드는 비슷합니다는 <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> 메서드와 비슷하지만 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">문자열은 최대한 많이 분할 됩니다.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no delimiter is found, the return value contains one element whose value is the original <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">구분 기호를 찾을 수 없으면 반환 값은 원래 값을 갖는 하나의 요소를 포함 하는 <ph id="ph1">`input`</ph> 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">컴파일된 정적에 대 한 호출에 사용 된 정규식 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> 메서드 자동으로 캐시 됩니다.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">컴파일된 정규식의 수명을 직접 관리 하려면 인스턴스를 사용 하 여 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">여러 명의 일치 항목을 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</source>
          <target state="translated">예를 들어 단일 하이픈에서 문자열을 분할 하면 반환 된 배열의 인접 한 하이픈을 두 개 발견 되는 위치에 빈 문자열을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">시작 부분이 나 입력된 문자열의 끝에 일치 하는 빈 문자열의 시작 이나 반환 된 배열의 끝에 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`[a-z]+`</ph> to split an input string on any uppercase or lowercase alphabetic character.</source>
          <target state="translated">다음 예제에서는 정규식 패턴을 사용 하 여 <ph id="ph1">`[a-z]+`</ph> 를 대문자 또는 소문자 알파벳 문자에는 입력된 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">반환 된 배열의 첫 번째 및 마지막 요소의 값이 문자열이 시작 되 고 알파벳 문자 일치 끝나는, 때문에 <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">캡처링 괄호에 사용 되는 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 식, 캡처된 모든 텍스트는 결과 문자열 배열에 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">예를 들어 "plum 기준" 하이픈에서 캡처 괄호 안에 배치 하는 문자열을 분할 하면 반환 되는 배열 하이픈을 포함 하는 문자열 요소를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">.NET Framework 1.0 및 1.1 캡처 괄호, 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">.NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">예를 들어 다음 코드 캡처 괄호의 두 집합을 사용 하 여 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 합니다.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 슬래시 문자; 제외 컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우에 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">정규식에는 빈 문자열이 면과 일치할 수 있으면 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> split 작업의 실행 시간 메서드가 호출 되는 응용 프로그램 도메인에 대해 지정 된 시간 제한 간격을 초과 하면 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 또는 제한 시간 값이 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값의 유효한 비트 조합이 아닌 경우</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">이 메서드가 제한 시간 초과 후 메서드가 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값을 해당 간격입니다.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">응용 프로그램 도메인에 값에 대 한 시간 제한 값이 정의 되지 않은 경우 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 메서드 시간 초과 방지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for splitting text on a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">텍스트 패턴 일치를 분할 하는 데 권장 되는 정적 메서드는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, 시간 제한 간격을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to split.</source>
          <target state="translated">분할할 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">일치 항목을 찾을 정규식 패턴입니다.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</source>
          <target state="translated">지정된 정규식 패턴에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">추가 매개 변수는 일치하는 항목이 없는 경우 제한 시간 간격과 일치 작업을 수정하는 옵션을 지정합니다.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A string array.</source>
          <target state="translated">문자열 배열입니다.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 메서드는 비슷합니다는 <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> 메서드와 비슷하지만 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 구분 기호 문자 집합이 아닌 정규식에 의해 결정에서 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">문자열은 최대한 많이 분할 됩니다.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no delimiter is found, the return value contains one element whose value is the original <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">구분 기호를 찾을 수 없으면 반환 값은 원래 값을 갖는 하나의 요소를 포함 하는 <ph id="ph1">`input`</ph> 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">컴파일된 정적에 대 한 호출에 사용 된 정규식 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> 메서드 자동으로 캐시 됩니다.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">컴파일된 정규식의 수명을 직접 관리 하려면 인스턴스를 사용 하 여 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">여러 명의 일치 항목을 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</source>
          <target state="translated">예를 들어 단일 하이픈에서 문자열을 분할 하면 반환 된 배열의 인접 한 하이픈을 두 개 발견 되는 위치에 빈 문자열을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">시작 부분이 나 입력된 문자열의 끝에 일치 하는 빈 문자열의 시작 이나 반환 된 배열의 끝에 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`[a-z]+`</ph> to split an input string on any uppercase or lowercase alphabetic character.</source>
          <target state="translated">다음 예제에서는 정규식 패턴을 사용 하 여 <ph id="ph1">`[a-z]+`</ph> 를 대문자 또는 소문자 알파벳 문자에는 입력된 문자열을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">반환 된 배열의 첫 번째 및 마지막 요소의 값이 문자열이 시작 되 고 알파벳 문자 일치 끝나는, 때문에 <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">캡처링 괄호에 사용 되는 경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> 식, 캡처된 모든 텍스트는 결과 문자열 배열에 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">예를 들어 "plum 기준" 하이픈에서 캡처 괄호 안에 배치 하는 문자열을 분할 하면 반환 되는 배열 하이픈을 포함 하는 문자열 요소를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">그러나 정규식 패턴에 여러 세트 캡처 괄호의 경우이 메서드의 동작은.NET Framework의 버전에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">.NET Framework 1.0 및 1.1 캡처 괄호, 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">.NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">예를 들어 다음 코드 캡처 괄호의 두 집합을 사용 하 여 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 합니다.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 슬래시 문자; 제외 컴파일된 되 고.NET Framework 2.0 또는 이상 버전에서 실행 되며, 경우에 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">정규식에는 빈 문자열이 면과 일치할 수 있으면 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> 모든 위치에서 빈 문자열 구분 기호를 찾을 수 없으므로 문자열 단일 문자 문자열의 배열으로 분할 합니다.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 매개 변수 지정 긴 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리 하는 경우 응답을 중지 하 게 표시 되지 않도록 과도 한 역 추적을 사용 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 들어 있는입니다.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>정규식에 대 한 유용한<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> 및 <bpt id="p2">[</bpt>역 추적<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">일치 항목이 없으면 해당 시간 간격에서 발견 되 면 경우에 메서드에서 throw 된 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 메서드가 실행 되는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">정규식 구문 분석 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 값의 유효한 비트 조합이 아닌 경우</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>이 음수, 0 또는 약 24일보다 큰 경우</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">시간이 초과되었습니다.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">설정 하는 것이 좋습니다는 <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 매개 변수를 2 초 등의 적절 한 값입니다.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">제한 시간을 사용 하지 않도록 지정 하 여 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, 정규식 엔진에는 약간 더 나은 성능을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">그러나 다음과 같은 경우에만 제한 시간을 비활성화 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">정규식에 의해 처리 된 입력 신뢰할 수 있고 알려진 원본에서 파생 시기나 정적 텍스트로 구성 합니다.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">이 동적으로 사용자가 입력 한 텍스트를 제외 합니다.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">가까운 일치 및 일치 하는 일치 하지 않는 경우 정규식 패턴에 철저히 테스트 효율적으로 처리 하는입니다.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">경우 정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object to populate with serialization information.</source>
          <target state="translated">serialization 정보로 채울 개체입니다.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The place to store and retrieve serialized data.</source>
          <target state="translated">serialize된 데이터를 저장 및 검색할 위치입니다.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This parameter is reserved for future use.</source>
          <target state="translated">이 매개 변수는 나중에 사용하기 위해 예약되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object with the data necessary to deserialize the current <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> 개체를 deserialize하는 데 필요한 데이터로 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체를 채웁니다.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>Returns the regular expression pattern that was passed into the <ph id="ph1">&lt;see langword="Regex" /&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Regex" /&gt;</ph> 생성자로 전달된 정규식 패턴을 반환합니다.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>The <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> parameter that was passed into the <ph id="ph2">&lt;see langword="Regex" /&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph2">&lt;see langword="Regex" /&gt;</ph> 생성자로 전달된 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 기호로 일치 시킬 문자열을 설명 하는 정규식 언어 요소의 매개 변수 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">정규식에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>.NET Framework 정규식<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> 및 <bpt id="p2">[</bpt>일반 식 언어-빠른 참조<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> is the base class of regular expressions created by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 만든 정규식의 기본 클래스는 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>These compiled regular expressions use the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> implementation of the base class.</source>
          <target state="translated">이러한 정규식 사용 하 여 컴파일된는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> 기본 클래스의 구현입니다.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>If called from a derived class, the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> method returns the string that was passed to the <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> parameter of the <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> class constructor that was used to define the regular expression.</source>
          <target state="translated">파생된 클래스에서 호출 된 경우는 <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> 에 전달 된 문자열을 반환 하는 메서드는 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 의 매개 변수는 <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> 정규식 정의에 사용 된 클래스 생성자입니다.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The input string containing the text to convert.</source>
          <target state="translated">변환할 텍스트가 포함된 입력 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>Converts any escaped characters in the input string.</source>
          <target state="translated">입력 문자열에서 이스케이프된 문자를 변환합니다.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>A string of characters with any escaped characters converted to their unescaped form.</source>
          <target state="translated">이스케이프된 문자가 이스케이프되지 않은 형식으로 변환된 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method performs one of the following two transformations:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> 메서드는 다음 두 개의 변환 중 하나를 수행 합니다.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>It reverses the transformation performed by the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method by removing the escape character ("<ph id="ph2">\\</ph>") from each character escaped by the method.</source>
          <target state="translated">변환을 수행한 취소는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> 이스케이프 문자를 제거 하 여 메서드 ("<ph id="ph2">\\</ph>") 메서드에 의해 이스케이프 된 각 문자를 합니다.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>These include the <ph id="ph1">\\</ph>, *, +, ?, &amp;#124;, {, [, (,), ^, $,., #, and white space characters.</source>
          <target state="translated">여기에 <ph id="ph1">\\</ph>, *, +,?, &amp;#124;, {, [, (,), ^, $., #, 및 공백 문자입니다.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method unescapes the closing bracket (]) and closing brace (}) characters.</source>
          <target state="translated">또한는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> 메서드 닫는 대괄호 (]) 태그와 닫는 중괄호 (}) 문자가 이스케이프 해제 합니다.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> cannot reverse an escaped string perfectly because it cannot deduce precisely which characters were escaped,</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> 되돌릴 수 없습니다. 이스케이프 문자열 완벽 하 게 문자 이스케이프 되었는지 정확 하 게 추론할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>It replaces the representation of unprintable characters with the characters themselves.</source>
          <target state="translated">자체로 표현 인쇄할 수 없는 문자를 대체합니다.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>For example, it replaces \a with \x07.</source>
          <target state="translated">예를 들어 \x07으로 \a를 대체 합니다.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The character representations it replaces are \a, \b, \e, \n, \r, \f, \t, and \v.</source>
          <target state="translated">대체 문자 표현 되며 \a, \b, \e, \n, \r, \f, \t, \v 있습니다.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method encounters other escape sequences that it cannot convert, such as \w or \s, it throws an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> 변환할 수 없는 다른 이스케이프 시퀀스가 발생 \w 또는 \s 처럼 throw는 <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> includes an unrecognized escape sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph>에는 인식할 수 없는 이스케이프 시퀀스가 있습니다.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionC">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드에서 생성되는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체에서 사용됩니다.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionC">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property contains the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> 속성에 <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> 옵션이 포함되어 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionR">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 메서드에서 생성되는 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 개체에서 사용됩니다.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionR">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property contains the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /&gt;</ph> option; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> 속성에 <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /&gt;</ph> 옵션이 포함되어 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)">
          <source>The time-out interval to check.</source>
          <target state="translated">확인할 시간 제한 간격입니다.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)">
          <source>Checks whether a time-out interval is within an acceptable range.</source>
          <target state="translated">시간 제한 간격이 허용 범위 내에 있는지를 확인합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>