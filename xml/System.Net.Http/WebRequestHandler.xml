<Type Name="WebRequestHandler" FullName="System.Net.Http.WebRequestHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="78e1210b4a91957a00054abc0eda2dfca311b629" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55323309" /></Metadata><TypeSignature Language="C#" Value="public class WebRequestHandler : System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebRequestHandler extends System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.WebRequestHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class WebRequestHandler&#xA;Inherits HttpClientHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebRequestHandler : System::Net::Http::HttpClientHandler" />
  <TypeSignature Language="F#" Value="type WebRequestHandler = class&#xA;    inherit HttpClientHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpClientHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="f9b83-101">Windows 스토어 응용 프로그램 또는 다른 환경에서 사용할 수 없는 데스크톱 고유의 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-101">Provides desktop-specific features not available to Windows Store apps or other environments.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b83-102">이 클래스를 사용 하 여 전송 처리기 구현 <xref:System.Net.HttpWebRequest> 인스턴스를 서버에 HTTP 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-102">This class implements a transport handler using <xref:System.Net.HttpWebRequest> instances to send HTTP requests to servers.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebRequestHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.WebRequestHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebRequestHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f9b83-103"><see cref="T:System.Net.Http.WebRequestHandler" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-103">Initializes a new instance of the <see cref="T:System.Net.Http.WebRequestHandler" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowPipelining">
      <MemberSignature Language="C#" Value="public bool AllowPipelining { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPipelining" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowPipelining As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPipelining { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowPipelining : bool with get, set" Usage="System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f9b83-104">요청을 인터넷 리소스에 파이프라인할 것인지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-104">Gets or sets a value that indicates whether to pipeline the request to the Internet resource.</span></span></summary>
        <value><span data-ttu-id="f9b83-105"><see cref="T:System.Boolean" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-105">Returns <see cref="T:System.Boolean" />.</span></span>  
  
 <span data-ttu-id="f9b83-106">요청을 파이프라인해야 하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-106"><see langword="true" /> if the request should be pipelined; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f9b83-107">기본값은 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-107">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b83-108">애플리케이션이 사용 하 여 <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> 파이프라인된 연결에 대 한 기본 설정을 나타내는 속성을 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-108">An application uses the <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> property to indicate a preference for pipelined connections.</span></span> <span data-ttu-id="f9b83-109">때 <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> 는 `true`, 애플리케이션에서 지 원하는 서버에 연결할 파이프라인.</span><span class="sxs-lookup"><span data-stu-id="f9b83-109">When <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> is `true`, an application makes pipelined connections to the servers that support them.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.AuthenticationLevel AuthenticationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.AuthenticationLevel AuthenticationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationLevel As AuthenticationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::AuthenticationLevel AuthenticationLevel { System::Net::Security::AuthenticationLevel get(); void set(System::Net::Security::AuthenticationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationLevel : System.Net.Security.AuthenticationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.AuthenticationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f9b83-110">이 요청에 사용되는 인증 및 가장 수준을 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-110">Gets or sets a value indicating the level of authentication and impersonation used for this request.</span></span></summary>
        <value><span data-ttu-id="f9b83-111"><see cref="T:System.Net.Security.AuthenticationLevel" /> 값의 비트 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-111">A bitwise combination of the <see cref="T:System.Net.Security.AuthenticationLevel" /> values.</span></span> <span data-ttu-id="f9b83-112">기본값은 <see cref="F:System.Net.Security.AuthenticationLevel.MutualAuthRequested" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-112">The default value is <see cref="F:System.Net.Security.AuthenticationLevel.MutualAuthRequested" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b83-113">상호 인증에서는 클라이언트와 서버가 모두 자격 증명을 제공해야 ID를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-113">In mutual authentication, both the client and server present credentials to establish their identity.</span></span> <span data-ttu-id="f9b83-114"><xref:System.Net.Security.AuthenticationLevel.MutualAuthRequired> 및 <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequested> 값은 Kerberos 인증과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-114">The <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequired> and <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequested> values are relevant for Kerberos authentication.</span></span> <span data-ttu-id="f9b83-115">Kerberos 인증은 직접 지원될 수도 있고, 보안 협상 프로토콜을 사용하여 실제 보안 프로토콜을 선택하는 경우에 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-115">Kerberos authentication can be supported directly, or can be used if the Negotiate security protocol is used to select the actual security protocol.</span></span> <span data-ttu-id="f9b83-116">인증 프로토콜에 대 한 자세한 내용은 참조 하세요. [인터넷 인증](~/docs/framework/network-programming/internet-authentication.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-116">For more information about authentication protocols, see [Internet Authentication](~/docs/framework/network-programming/internet-authentication.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CachePolicy">
      <MemberSignature Language="C#" Value="public System.Net.Cache.RequestCachePolicy CachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Cache.RequestCachePolicy CachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Cache::RequestCachePolicy ^ CachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f9b83-117">이 요청에 대한 캐시 정책을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-117">Gets or sets the cache policy for this request.</span></span></summary>
        <value><span data-ttu-id="f9b83-118">캐시 정책을 정의하는 <see cref="T:System.Net.Cache.RequestCachePolicy" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-118">A <see cref="T:System.Net.Cache.RequestCachePolicy" /> object that defines a cache policy.</span></span> <span data-ttu-id="f9b83-119">기본값은 <see cref="P:System.Net.WebRequest.DefaultCachePolicy" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-119">The default is <see cref="P:System.Net.WebRequest.DefaultCachePolicy" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b83-120">현재 캐시 정책 및 캐시에 요청된 된 리소스의 현재 상태 응답을 캐시에서 검색할 수 있는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-120">The current cache policy and the presence of the requested resource in the cache determine whether a response can be retrieved from the cache.</span></span> <span data-ttu-id="f9b83-121">일반적으로 캐시 된 응답을 사용 하 여 애플리케이션 성능이 향상 됩니다. 하지만 캐시에서 응답 서버의 응답에 맞지 않습니다 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-121">Using cached responses usually improves application performance, but there is a risk that the response in the cache does not match the response on the server.</span></span>  
  
 <span data-ttu-id="f9b83-122">기본 캐시 정책을 설정 하 여 또는 Machine.config 구성 파일에서 지정할 수 있습니다는 <xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-122">The default cache policy can be specified in the Machine.config configuration file or by setting the <xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A> property.</span></span>  
  
 <span data-ttu-id="f9b83-123">응답 스트림에 리소스를 검색 하 고 스트림의 끝까지 읽는 경우에 리소스의 복사본이 캐시에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-123">A copy of a resource is only added to the cache if the response stream for the resource is retrieved and read to the end of the stream.</span></span> <span data-ttu-id="f9b83-124">이므로 동일한 리소스에 대 한 다른 요청에는이 요청에 대 한 캐시 정책 수준에 따라 캐시 된 복사본을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-124">So another request for the same resource could use a cached copy, depending on the cache policy level for this request.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection" Usage="System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f9b83-125">이 요청과 관련된 보안 인증서의 컬렉션을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-125">Gets or sets the collection of security certificates that are associated with this request.</span></span></summary>
        <value><span data-ttu-id="f9b83-126">이 요청과 연결된 보안 인증서의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-126">The collection of security certificates associated with this request.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ContinueTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : TimeSpan with get, set" Usage="System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f9b83-127">애플리케이션이 데이터를 언로드하기 전에 서버에서 100-continue를 기다리는 시간(밀리초)을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-127">Gets or sets the amount of time, in milliseconds, the application will wait for 100-continue from the server before uploading data.</span></span></summary>
        <value><span data-ttu-id="f9b83-128">애플리케이션이 데이터를 업로드하기 전에 서버에서 100-continue를 기다리는 시간(밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-128">The amount of time, in milliseconds, the application will wait for 100-continue from the server before uploading data.</span></span> <span data-ttu-id="f9b83-129">기본값은 350 밀리초입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-129">The default value is 350 milliseconds.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); void set(System::Security::Principal::TokenImpersonationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f9b83-130">현재 요청에 대한 가장 수준을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-130">Gets or sets the impersonation level for the current request.</span></span></summary>
        <value><span data-ttu-id="f9b83-131">요청의 가장 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-131">The impersonation level for the request.</span></span> <span data-ttu-id="f9b83-132">기본값은 <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-132">The default is <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b83-133">가장 수준을 서버에서 클라이언트의 자격 증명을 사용 하는 방법을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-133">The impersonation level determines how the server can use the client's credentials.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaxResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxResponseHeadersLength : int with get, set" Usage="System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f9b83-134">응답 헤더의 허용되는 최대 길이를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-134">Gets or sets the maximum allowed length of the response headers.</span></span></summary>
        <value><span data-ttu-id="f9b83-135">응답 헤더의 킬로바이트(1024바이트) 단위 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-135">The length, in kilobytes (1024 bytes), of the response headers.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b83-136">응답 헤더 길이 응답 상태 줄 및 HTTP 프로토콜의 일부로 받은 추가 제어 문자를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-136">The length of the response header includes the response status line and any extra control characters that are received as part of HTTP protocol.</span></span> <span data-ttu-id="f9b83-137">값이-1 이면 응답 헤더;에 제한 되지 않습니다 0 이면 모든 요청이 실패 하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-137">A value of -1 means no limit is imposed on the response headers; a value of 0 means that all requests fail.</span></span>  
  
 <span data-ttu-id="f9b83-138">경우는 <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> 속성이 명시적으로 설정 되지 않은의 값을 기본적으로 <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-138">If the <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> property is not explicitly set, it defaults to the value of the <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> property.</span></span>  
  
 <span data-ttu-id="f9b83-139">받은 응답 헤더 길이 값을 초과할 경우는 <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> 속성을 응답에 액세스할 때 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-139">If the length of the response header received exceeds the value of the <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> property, an exception is thrown when the response is accessed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f9b83-140">서버에 요청을 쓰거나 서버에서 요청을 읽을 때의 제한 시간을 밀리초 단위로 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-140">Gets or sets a time-out in milliseconds when writing a request to or reading a response from a server.</span></span></summary>
        <value><span data-ttu-id="f9b83-141">쓰기 또는 읽기가 가능한 제한 시간(밀리초)입니다. 기본값은 300,000밀리초(5분)입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-141">The number of milliseconds before the writing or reading times out. The default value is 300,000 milliseconds (5 minutes).</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f9b83-142">서버 인증서의 유효성을 검사할 콜백 메서드를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-142">Gets or sets a callback method to validate the server certificate.</span></span></summary>
        <value><span data-ttu-id="f9b83-143">서버 인증서의 유효성을 검사할 콜백 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-143">A callback method to validate the server certificate.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b83-144">경우는 <xref:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback%2A> 는 `null`, 서버 인증서는 표준 잘 알려진 인증 기관을 사용 하 여 검사할 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-144">If the <xref:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback%2A> is `null`, the server certificate will be validated using standard well-known  certificate authorities.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f9b83-145">고속 NTLM 인증 연결 공유가 허용되는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-145">Gets or sets a value that indicates whether to allow high-speed NTLM-authenticated connection sharing.</span></span></summary>
        <value><span data-ttu-id="f9b83-146"><see cref="T:System.Boolean" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-146">Returns <see cref="T:System.Boolean" />.</span></span>  
  
 <span data-ttu-id="f9b83-147">인증된 연결을 열어 두려면 <see langword="true" />이고, 열어 두지 않으려면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-147"><see langword="true" /> to keep the authenticated connection open; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b83-148">이 속성의 기본값은 `false`, 요청이 완료 된 후에 닫을 수에 대 한 현재 연결에 이르게 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-148">The default value for this property is `false`, which causes the current connection to be closed after a request is completed.</span></span> <span data-ttu-id="f9b83-149">새 요청을 발급 될 때마다 애플리케이션에 인증 시퀀스 거쳐야 합니다. 이 속성 설정 된 경우 `true`, 응답을 검색 하는 데 사용 하는 연결 인증을 수행한 후에 계속 열려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-149">Your application must go through the authentication sequence every time it issues a new request.If this property is set to `true`, the connection used to retrieve the response remains open after the authentication has been performed.</span></span> <span data-ttu-id="f9b83-150">이 경우에이 속성이 설정 요청 다른 `true` 다시 인증 하지 않고 연결을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-150">In this case, other requests that have this property set to `true` may use the connection without re-authenticating.</span></span> <span data-ttu-id="f9b83-151">즉, 사용자 A에 대 한 연결을 인증 된 경우 사용자 B 다시 사용할 수 있습니다 A의 연결 1. 사용자의 자격 증명에 따라 사용자 B의 요청이 처리 된</span><span class="sxs-lookup"><span data-stu-id="f9b83-151">In other words, if a connection has been authenticated for user A, user B may reuse A's connection; user B's request is fulfilled based on the credentials of user A.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f9b83-152">수 있는지 관리 문제가 시스템의 경우이 속성을 설정 해야 하는 애플리케이션을 인증 하지 않고 연결을 사용 하도록 이기 때문에 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-152">Because it is possible for an application to use the connection without being authenticated, you need to be sure that there is no administrative vulnerability in your system when setting this property to `true`.</span></span> <span data-ttu-id="f9b83-153">애플리케이션에서 여러 사용자에 대 한 요청을 전송 하는 경우 (여러 사용자 계정을 가장 합니다.) 하며 리소스를 보호 하는 인증,이 속성 설정 하지 않으면이 `true` 아래 설명 된 대로 연결 그룹을 사용 하지 않는 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-153">If your application sends requests for multiple users (impersonates multiple user accounts) and relies on authentication to protect resources, do not set this property to `true` unless you use connection groups as described below.</span></span>  
  
 <span data-ttu-id="f9b83-154">하는 경우이 메커니즘을 사용 하도록 설정 하려는 경우에 성능 문제가 발생 하는 애플리케이션 통합된 Windows 인증을 사용 하 여 웹 서버에서 실행 되 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-154">You may want to consider enabling this mechanism if your are having performance problems and your application is running on a Web server with integrated Windows authentication.</span></span>  
  
 <span data-ttu-id="f9b83-155">이 설정을 사용 하면 시스템 보안 위험을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-155">Enabling this setting opens the system to security risks.</span></span> <span data-ttu-id="f9b83-156">설정한 경우에 <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> 속성을 `true` 다음 예방 조치를 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-156">If you set the <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> property to `true` be sure to take the following precautions:</span></span>  
  
-   <span data-ttu-id="f9b83-157">연결이 악용을 방지 하려면 보호 된 환경에서 애플리케이션을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-157">Run your application in a protected environment to help avoid possible connection exploits.</span></span>  
  
 <span data-ttu-id="f9b83-158">백 엔드 서버를 제어 하는 경우는 대 안으로 좋습니다 인증 지 속성을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-158">If you control the back-end server, as an alternative you might consider turning off authentication persistence.</span></span> <span data-ttu-id="f9b83-159">어느 정도 성능이 향상 되지만 것이 더 안전 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-159">This increases performance to a lesser degree, but it is safer.</span></span> <span data-ttu-id="f9b83-160">자세한 내용은 MSDN library에서 AuthPersistence 검색 [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library)합니다.</span><span class="sxs-lookup"><span data-stu-id="f9b83-160">For more details, search for AuthPersistence in the MSDN library at [http://msdn.microsoft.com/library](https://msdn.microsoft.com/library).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>