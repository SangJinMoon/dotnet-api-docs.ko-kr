<Type Name="Queue" FullName="System.Collections.Queue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f90e495aede68fc0d7b446c40af0734c43204f68" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36712886" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Queue : ICloneable, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Queue extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Queue" />
  <TypeSignature Language="VB.NET" Value="Public Class Queue&#xA;Implements ICloneable, ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class Queue : ICloneable, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Queue = class&#xA;    interface ICollection&#xA;    interface ICloneable&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a first-in, first-out collection of objects.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스는 순환 배열로 큐를 구현합니다. 에 저장 된 개체는 <xref:System.Collections.Queue> 한쪽 끝에 삽입 되 고 다른에서 제거 합니다.  
  
 큐 및 스택은 유용 정보에 대 한 임시 저장소를 사용 해야 하는 경우 즉 때 하려는 경우도 요소 값을 검색 한 후 취소 합니다. 사용 하 여 <xref:System.Collections.Queue> 순서는 컬렉션에 저장 된 정보에 액세스 해야 합니다. 사용 하 여 <xref:System.Collections.Stack> 반대 순서로 정보에 액세스 해야 할 경우. 사용 하 여 <xref:System.Collections.Concurrent.ConcurrentQueue%601> 또는 <xref:System.Collections.Concurrent.ConcurrentStack%601> 동시에 여러 스레드에서 컬렉션에 액세스 해야 할 경우.  
  
 세 가지 주요 작업을 수행할 수는 <xref:System.Collections.Queue> 와 해당 요소:  
  
-   <xref:System.Collections.Queue.Enqueue%2A> 끝에 요소를 추가 <xref:System.Collections.Queue>합니다.  
  
-   <xref:System.Collections.Queue.Dequeue%2A> 시작 부분부터 가장 오래 된 요소를 제거는 <xref:System.Collections.Queue>합니다.  
  
-   <xref:System.Collections.Queue.Peek%2A> 시작 부분에 있는 가장 오래 된 요소를 반환 하는 <xref:System.Collections.Queue> 하지만 제거 하지 않습니다는 <xref:System.Collections.Queue>합니다.  
  
 용량을 <xref:System.Collections.Queue> 요소의 수가는 <xref:System.Collections.Queue> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.Queue>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라 합니다.  호출 하 여 용량을 줄일 수 있습니다 <xref:System.Collections.Queue.TrimToSize%2A>합니다.  
  
 증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 결정 됩니다 때는 <xref:System.Collections.Queue> 생성 됩니다. 기본 증가 비율은 2.0입니다. 용량은 <xref:System.Collections.Queue> 최소한 증가 비율에 관계 없이 다음 4 개 증가 합니다. 예를 들어 한 <xref:System.Collections.Queue> 1.0 증가 비율와 항상 증가 용량에 네 개의 때 더 큰 용량이 필요 합니다.  
  
 <xref:System.Collections.Queue> 허용 `null` 을 유효한 값으로 중복 요소를 허용 합니다.  
  
 이 컬렉션의 제네릭 버전은를 참조 하세요. <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType>  
  
   
  
## Examples  
 만들고 값을 추가 하는 방법을 보여 주는 다음 예제는 <xref:System.Collections.Queue> 및 해당 값을 출력 하는 방법입니다.  
  
 [!code-cpp[Classic Queue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>공용 정적 (<see langword="Shared" /> Visual basic에서)이 형식의 멤버는 스레드로부터 안전 합니다. 인터페이스 멤버는 스레드로부터 안전하지 않습니다.  스레드로부터 안전을 보장 하려면는 <see cref="T:System.Collections.Queue" />에서 반환 되는 래퍼를 통해 모든 작업을 완료 해야 합니다는 <see cref="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" /> 메서드.  컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</threadsafe>
    <altmember cref="T:System.Collections.Generic.Queue`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.Queue" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.Queue" /> class that is empty, has the default initial capacity, and uses the default growth factor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Queue> 요소의 수가는 <xref:System.Collections.Queue> 보유할 수 있습니다.  요소에 추가 되는 <xref:System.Collections.Queue>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라 합니다.  호출 하 여 용량을 줄일 수 있습니다 <xref:System.Collections.Queue.TrimToSize%2A>합니다.  
  
 증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 결정 됩니다 때는 <xref:System.Collections.Queue> 생성 됩니다.  
  
 이 생성자는 o (1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (System.Collections.ICollection col);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ICollection col) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (col As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(System::Collections::ICollection ^ col);" />
      <MemberSignature Language="F#" Value="new System.Collections.Queue : System.Collections.ICollection -&gt; System.Collections.Queue" Usage="new System.Collections.Queue col" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="col" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="col">The <see cref="T:System.Collections.ICollection" /> to copy elements from.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.Queue" /> class that contains elements copied from the specified collection, has the same initial capacity as the number of elements copied, and uses the default growth factor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Queue> 요소의 수가는 <xref:System.Collections.Queue> 보유할 수 있습니다.  요소에 추가 되는 <xref:System.Collections.Queue>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라 합니다.  호출 하 여 용량을 줄일 수 있습니다 <xref:System.Collections.Queue.TrimToSize%2A>합니다.  
  
 증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 결정 됩니다 때는 <xref:System.Collections.Queue> 생성 됩니다.  
  
 요소에 복사 됩니다는 <xref:System.Collections.Queue> 가 읽는 순서는 <xref:System.Collections.IEnumerator> 의 <xref:System.Collections.ICollection>합니다.  
  
 이 생성자는는 O (`n`) 작업, 여기서 `n` 에 있는 요소의 수는 `col`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="col" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Queue : int -&gt; System.Collections.Queue" Usage="new System.Collections.Queue capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Queue" /> can contain.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.Queue" /> class that is empty, has the specified initial capacity, and uses the default growth factor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Queue> 요소의 수가는 <xref:System.Collections.Queue> 보유할 수 있습니다.  요소에 추가 되는 <xref:System.Collections.Queue>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라 합니다.  호출 하 여 용량을 줄일 수 있습니다 <xref:System.Collections.Queue.TrimToSize%2A>합니다.  
  
 증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 결정 됩니다 때는 <xref:System.Collections.Queue> 생성 됩니다.  
  
 컬렉션의 크기를 예상할 수 있는 경우에 다양 한 크기 조정 작업에 요소를 추가 하는 동안 수행할 필요가 없습니다 초기 용량을 지정 하는 <xref:System.Collections.Queue>합니다.  
  
 이 생성자는는 O (`n`) 작업, 여기서 `n` 은 `capacity`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (int capacity, float growFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 growFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, growFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(int capacity, float growFactor);" />
      <MemberSignature Language="F#" Value="new System.Collections.Queue : int * single -&gt; System.Collections.Queue" Usage="new System.Collections.Queue (capacity, growFactor)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="growFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Queue" /> can contain.</param>
        <param name="growFactor">The factor by which the capacity of the <see cref="T:System.Collections.Queue" /> is expanded.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.Queue" /> class that is empty, has the specified initial capacity, and uses the specified growth factor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Queue> 요소의 수가는 <xref:System.Collections.Queue> 보유할 수 있습니다.  요소에 추가 되는 <xref:System.Collections.Queue>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라 합니다.  호출 하 여 용량을 줄일 수 있습니다 <xref:System.Collections.Queue.TrimToSize%2A>합니다.  
  
 증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 결정 됩니다 때는 <xref:System.Collections.Queue> 생성 됩니다. 용량은 <xref:System.Collections.Queue> 증가 비율에 관계 없이 최소 값은 증가 합니다. 1.0 증가 비율을 주지 않는 것은 <xref:System.Collections.Queue> 의 크기가 증가 합니다.  
  
 컬렉션의 크기를 예상할 수 있는 경우에 다양 한 크기 조정 작업에 요소를 추가 하는 동안 수행할 필요가 없습니다 초기 용량을 지정 하는 <xref:System.Collections.Queue>합니다.  
  
 이 생성자는는 O (`n`) 작업, 여기서 `n` 은 `capacity`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.  -or-  <paramref name="growFactor" /> is less than 1.0 or greater than 10.0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="queue.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all objects from the <see cref="T:System.Collections.Queue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Queue.Count%2A> 가 0으로 설정 하 고 컬렉션의 요소에 다른 개체에 대 한 참조도 해제 됩니다.  
  
 용량 변경 되지 않습니다. 용량을 다시 설정 하는 <xref:System.Collections.Queue>, 호출 <xref:System.Collections.Queue.TrimToSize%2A>합니다. 빈 트리밍 <xref:System.Collections.Queue> 의 용량 설정는 <xref:System.Collections.Queue> 기본 용량을 합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>합니다.  
  
   
  
## Examples  
 값을 지우는 방법을 보여 주는 다음 예제는 <xref:System.Collections.Queue>합니다.  
  
 [!code-cpp[Classic Queue.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Queue.TrimToSize" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="queue.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a shallow copy of the <see cref="T:System.Collections.Queue" />.</summary>
        <returns>A shallow copy of the <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션의 단순 복사본은 참조 형식 또는 값 형식 참조에서 참조 하는 개체를 복사 하지 않습니다 여부는 컬렉션의 요소에만 복사 합니다. 새 컬렉션에 대 한 참조는 원본 컬렉션에 대 한 참조를 가리키는 동일한 개체를 가리킵니다.  
  
 반면, 요소를 복사 하는 컬렉션의 전체 복사본 및 뿐만 아니라 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목입니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="queue.Contains obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.Queue" />. The value can be <see langword="null" />.</param>
        <summary>Determines whether an element is in the <see cref="T:System.Collections.Queue" />.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> is found in the <see cref="T:System.Collections.Queue" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하 여 일치 여부를 확인 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>합니다.  
  
 컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 에 대 한 메서드 `obj` 확인 하려면 여부 `item` 존재 합니다. .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `obj` 컬렉션의 개체에 대 한 매개 변수입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="queue.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Queue" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
        <param name="index">The zero-based index in <c>array</c> at which copying begins.</param>
        <summary>Copies the <see cref="T:System.Collections.Queue" /> elements to an existing one-dimensional <see cref="T:System.Array" />, starting at the specified array index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소가 복사 되는 <xref:System.Array> 열거자가 반복는 동일한 순서로 <xref:System.Collections.Queue>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>합니다.  
  
   
  
## Examples  
 복사 하는 방법을 보여 주는 다음 예제는 <xref:System.Collections.Queue> 1 차원 배열에 있습니다.  
  
 [!code-cpp[Classic Queue.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> is multidimensional.  -or-  The number of elements in the source <see cref="T:System.Collections.Queue" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">The type of the source <see cref="T:System.Collections.Queue" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Queue.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Queue.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of elements contained in the <see cref="T:System.Collections.Queue" />.</summary>
        <value>
          <see cref="T:System.Collections.Queue" />에 포함된 요소의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량은 <xref:System.Collections.Queue> 요소의 수가 하는 <xref:System.Collections.Queue> 저장할 수 있습니다. <xref:System.Collections.Queue.Count%2A> 에 실제로 있는 요소의 수가 고 <xref:System.Collections.Queue>합니다.  
  
 용량을 <xref:System.Collections.Queue> 보다 크거나 같은 경우는 항상 <xref:System.Collections.Queue.Count%2A>합니다. 경우 <xref:System.Collections.Queue.Count%2A> 요소를 추가 하는 동안 용량을 초과, 용량 이전 요소를 복사 하 고 새 요소를 추가 하기 전에 내부 배열을 다시 할당 하 여 자동으로 증가 합니다. 새 용량 증가 비율을은 현재 용량을 곱하여 결정 됩니다 때 결정는 <xref:System.Collections.Queue> 생성 됩니다. 용량은 <xref:System.Collections.Queue> 증가 비율에 관계 없이 최소 값은 증가 합니다. 1.0 증가 비율을 주지 않는 것은 <xref:System.Collections.Queue> 의 크기가 증가 합니다.  
  
 호출 하 여 용량을 줄일 수 있습니다 <xref:System.Collections.Queue.TrimToSize%2A>합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dequeue">
      <MemberSignature Language="C#" Value="public virtual object Dequeue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Dequeue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Dequeue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Dequeue () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Dequeue();" />
      <MemberSignature Language="F#" Value="abstract member Dequeue : unit -&gt; obj&#xA;override this.Dequeue : unit -&gt; obj" Usage="queue.Dequeue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes and returns the object at the beginning of the <see cref="T:System.Collections.Queue" />.</summary>
        <returns>The object that is removed from the beginning of the <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Collections.Queue.Peek%2A> 메서드와 유사하지만 <xref:System.Collections.Queue.Peek%2A>는 <xref:System.Collections.Queue>를 수정하지 않습니다.  
  
 `null` 에 추가할 수는 <xref:System.Collections.Queue> 값으로. 끝과 null 값을 구분 하기 위해는 <xref:System.Collections.Queue>, 확인는 <xref:System.Collections.Queue.Count%2A> 속성 또는 catch는 <xref:System.InvalidOperationException>때 throw 되는 <xref:System.Collections.Queue> 비어 있습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 예제에서는 요소를 추가 하는 방법을 보여 줍니다.는 <xref:System.Collections.Queue>, 요소를 제거할는 <xref:System.Collections.Queue>, 맨 앞에 요소를 보거나는 <xref:System.Collections.Queue>합니다.  
  
 [!code-cpp[Classic Queue.Enqueue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Enqueue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Enqueue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Collections.Queue" /> is empty.</exception>
        <altmember cref="M:System.Collections.Queue.Enqueue(System.Object)" />
        <altmember cref="M:System.Collections.Queue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="Enqueue">
      <MemberSignature Language="C#" Value="public virtual void Enqueue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Enqueue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Enqueue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Enqueue (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Enqueue(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Enqueue : obj -&gt; unit&#xA;override this.Enqueue : obj -&gt; unit" Usage="queue.Enqueue obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object to add to the <see cref="T:System.Collections.Queue" />. The value can be <see langword="null" />.</param>
        <summary>Adds an object to the end of the <see cref="T:System.Collections.Queue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Queue> 요소의 수가는 <xref:System.Collections.Queue> 보유할 수 있습니다.  요소에 추가 되는 <xref:System.Collections.Queue>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라 합니다.  호출 하 여 용량을 줄일 수 있습니다 <xref:System.Collections.Queue.TrimToSize%2A>합니다.  
  
 증가 비율은 현재 용량이 더 큰 용량이 필요할 때 기준이 곱한 숫자입니다.  증가 비율은 결정 됩니다 때는 <xref:System.Collections.Queue> 생성 됩니다. 용량은 <xref:System.Collections.Queue> 증가 비율에 관계 없이 최소 값은 증가 합니다. 1.0 증가 비율을 주지 않는 것은 <xref:System.Collections.Queue> 의 크기가 증가 합니다.  
  
 경우 <xref:System.Collections.Queue.Count%2A> 작으면 내부 배열의 용량 보다이 메서드는 o (1) 작업입니다. 내부 배열을 재할당 하 여 새 요소로 적용 하는 경우이 메서드는 O는 됩니다 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 요소를 추가 하는 방법을 보여 줍니다.는 <xref:System.Collections.Queue>, 요소를 제거할는 <xref:System.Collections.Queue>, 맨 앞에 요소를 보거나는 <xref:System.Collections.Queue>합니다.  
  
 [!code-cpp[Classic Queue.Enqueue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Enqueue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Enqueue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Queue.Dequeue" />
        <altmember cref="M:System.Collections.Queue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="queue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that iterates through the <see cref="T:System.Collections.Queue" />.</summary>
        <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @FSHO1@C# 언어의 `foreach` 문(Visual Basic의 경우 `for each`)은 열거자의 복잡성을 숨깁니다.  그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다.  이 위치에서 <xref:System.Collections.IEnumerator.Current%2A>는 정의되지 않습니다. 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A>의 값을 읽기 전에 <xref:System.Collections.IEnumerator.Current%2A>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.  
  
 <xref:System.Collections.IEnumerator.Current%2A>에서는 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A>이 호출될 때까지 동일한 개체를 반환합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.IEnumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Queue.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.Queue.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether access to the <see cref="T:System.Collections.Queue" /> is synchronized (thread safe).</summary>
        <value>
          <see langword="true" />에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되면 <see cref="T:System.Collections.Queue" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드로부터 안전을 보장 하려면는 <xref:System.Collections.Queue>에서 반환 되는 래퍼를 통해 모든 작업을 완료 해야 합니다는 <xref:System.Collections.Queue.Synchronized%2A> 메서드.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.Queue.SyncRoot%2A> 열거 하는 중입니다. 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Queue.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source2.vb#2)]  
  
 동기화 하는 방법을 보여 주는 다음 예제는 <xref:System.Collections.Queue>를 결정 하는 경우는 <xref:System.Collections.Queue> 동기화 되 고 동기화를 사용 하 여 <xref:System.Collections.Queue>합니다.  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Queue.SyncRoot" />
        <altmember cref="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public virtual object Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Peek () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Peek();" />
      <MemberSignature Language="F#" Value="abstract member Peek : unit -&gt; obj&#xA;override this.Peek : unit -&gt; obj" Usage="queue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the object at the beginning of the <see cref="T:System.Collections.Queue" /> without removing it.</summary>
        <returns>The object at the beginning of the <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Collections.Queue.Dequeue%2A> 메서드와 유사하지만 <xref:System.Collections.Queue.Peek%2A>는 <xref:System.Collections.Queue>를 수정하지 않습니다.  
  
 `null` 에 추가할 수는 <xref:System.Collections.Queue> 값으로. 끝과 null 값을 구분 하기 위해는 <xref:System.Collections.Queue>, 확인는 <xref:System.Collections.Queue.Count%2A> 속성 또는 catch는 <xref:System.InvalidOperationException>때 throw 되는 <xref:System.Collections.Queue> 비어 있습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 예제에서는 요소를 추가 하는 방법을 보여 줍니다.는 <xref:System.Collections.Queue>, 요소를 제거할는 <xref:System.Collections.Queue>, 맨 앞에 요소를 보거나는 <xref:System.Collections.Queue>합니다.  
  
 [!code-cpp[Classic Queue.Enqueue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Enqueue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Enqueue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Collections.Queue" /> is empty.</exception>
        <altmember cref="M:System.Collections.Queue.Enqueue(System.Object)" />
        <altmember cref="M:System.Collections.Queue.Dequeue" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Queue Synchronized (System.Collections.Queue queue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Queue Synchronized(class System.Collections.Queue queue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Queue ^ Synchronized(System::Collections::Queue ^ queue);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.Queue -&gt; System.Collections.Queue" Usage="System.Collections.Queue.Synchronized queue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Queue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queue" Type="System.Collections.Queue" />
      </Parameters>
      <Docs>
        <param name="queue">The <see cref="T:System.Collections.Queue" /> to synchronize.</param>
        <summary>Returns a new <see cref="T:System.Collections.Queue" /> that wraps the original queue, and is thread safe.</summary>
        <returns>A <see cref="T:System.Collections.Queue" /> wrapper that is synchronized (thread safe).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에 의해 반환 되는 래퍼를 스레드로부터 안전한 방식으로 수행 되는 작업을 수행 하기 전에 큐를 잠급니다.  
  
 스레드로부터 안전을 보장 하려면는 <xref:System.Collections.Queue>만이 래퍼를 통해 모든 작업을 완료 해야 합니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.Queue.SyncRoot%2A> 열거 하는 중입니다. 이 메서드는 o (1) 작업.  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Queue.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source2.vb#2)]  
  
 동기화 하는 방법을 보여 주는 다음 예제는 <xref:System.Collections.Queue>를 결정 하는 경우는 <xref:System.Collections.Queue> 동기화 되 고 동기화를 사용 하 여 <xref:System.Collections.Queue>합니다.  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queue" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.Queue.IsSynchronized" />
        <altmember cref="P:System.Collections.Queue.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Queue.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.Queue.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.Queue" />.</summary>
        <value>
          <see cref="T:System.Collections.Queue" />에 대한 액세스를 동기화하는 데 사용할 수 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동기화 된 버전을 만들려면는 <xref:System.Collections.Queue>를 사용 하 여는 <xref:System.Collections.Queue.Synchronized%2A> 메서드. 하지만 파생된 클래스의 동기화 된 버전을 제공할 수 있습니다는 <xref:System.Collections.Queue> 를 사용 하는 <xref:System.Collections.Queue.SyncRoot%2A> 속성입니다. 동기화 하는 코드에서 작업을 수행 해야는 <xref:System.Collections.Queue.SyncRoot%2A> 의 <xref:System.Collections.Queue>에서 직접는 <xref:System.Collections.Queue>합니다. 이렇게 하면 다른 개체에서 파생되는 컬렉션에 대해 적절한 작업이 수행됩니다. 특히, 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 관리는 <xref:System.Collections.Queue> 개체입니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.Queue.SyncRoot%2A> 열거 하는 중입니다. 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Queue.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Queue.IsSynchronized" />
        <altmember cref="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual object[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; obj[]&#xA;override this.ToArray : unit -&gt; obj[]" Usage="queue.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copies the <see cref="T:System.Collections.Queue" /> elements to a new array.</summary>
        <returns>A new array containing elements copied from the <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Queue> 수정 되지 않습니다. 새 배열의 요소 순서의 시작 부분에서 요소의 순서와 같습니다는 <xref:System.Collections.Queue> 끝입니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>합니다.  
  
   
  
## Examples  
 복사 하는 방법을 보여 주는 다음 예제는 <xref:System.Collections.Queue> 1 차원 배열에 있습니다.  
  
 [!code-cpp[Classic Queue.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="queue.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the capacity to the actual number of elements in the <see cref="T:System.Collections.Queue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 요소가 더 이상 큐에 추가 될 경우 큐의 메모리 오버 헤드를 최소화할이 메서드를 사용할 수 있습니다.  
  
 다시 설정 하는 <xref:System.Collections.Queue> 를 초기 상태로 호출는 <xref:System.Collections.Queue.Clear%2A> 메서드 호출 하기 전에 <xref:System.Collections.Queue.TrimToSize%2A>합니다. 빈 트리밍 <xref:System.Collections.Queue> 의 용량 설정는 <xref:System.Collections.Queue> 기본 용량을 합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Queue.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Queue" /> is read-only.</exception>
        <altmember cref="M:System.Collections.Queue.Clear" />
        <altmember cref="P:System.Collections.Queue.Count" />
      </Docs>
    </Member>
  </Members>
</Type>