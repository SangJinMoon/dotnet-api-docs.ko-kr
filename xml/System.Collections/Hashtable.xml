<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Hashtable.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac54c6adcdcf0768c2d073d568527998677360d621e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4c6adcdcf0768c2d073d568527998677360d621e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Collections.Hashtable">
          <source>Represents a collection of key/value pairs that are organized based on the hash code of the key.</source>
          <target state="translated">키의 해시 코드에 따라 구성된 키/값 쌍의 컬렉션을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Each element is a key/value pair stored in a <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph> object.</source>
          <target state="translated">각 요소에 저장 된 키/값 쌍은는 <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">키 일 수 없습니다 <ph id="ph1">`null`</ph>, 하지만 값이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The objects used as keys by a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are required to override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method (or the <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> interface) and the <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method (or the <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> interface).</source>
          <target state="translated">키로 사용 되는 개체는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 재정의 하는 데 필요한는 <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 메서드 (또는 <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> 인터페이스) 및 <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드 (또는 <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> 인터페이스).</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The implementation of both methods and interfaces must handle case sensitivity the same way; otherwise, the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> might behave incorrectly.</source>
          <target state="translated">두 메서드 및 인터페이스의 구현을 대/소문자 구분; 같은 방식으로 처리 해야 합니다. 그렇지 않은 경우는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 올바르게 작동할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>For example, when creating a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, you must use the <ph id="ph2">&lt;xref:System.Collections.CaseInsensitiveHashCodeProvider&gt;</ph> class (or any case-insensitive <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation) with the <ph id="ph4">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> class (or any case-insensitive <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> implementation).</source>
          <target state="translated">예를 들어, 만들 때는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>를 사용 해야 합니다는 <ph id="ph2">&lt;xref:System.Collections.CaseInsensitiveHashCodeProvider&gt;</ph> 클래스 (모든 대/소문자 구분 또는 <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> 구현)와 <ph id="ph4">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> 클래스 (모든 대/소문자 구분 또는 <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> 구현)입니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Furthermore, these methods must produce the same results when called with the same parameters while the key exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">또한 이러한 메서드는 키에 있는 동안 동일한 매개 변수를 사용 하 여 호출 될 때 동일한 결과 생성 해야 합니다는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>An alternative is to use a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor with an <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> parameter.</source>
          <target state="translated">대신 사용 하는 것을 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자는 <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>If key equality were simply reference equality, the inherited implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> would suffice.</source>
          <target state="translated">키가 같은지 여부 단순히 참조 일치의 상속 된 구현 된 경우 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 충분 합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Key objects must be immutable as long as they are used as keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">키 개체 변경 하지 않아야에서 키로 사용 하는 상태로 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>When an element is added to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the element is placed into a bucket based on the hash code of the key.</source>
          <target state="translated">요소에 추가 된 경우는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, 키의 해시 코드에 따라 버킷에 배치 됩니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Subsequent lookups of the key use the hash code of the key to search in only one particular bucket, thus substantially reducing the number of key comparisons required to find an element.</source>
          <target state="translated">요소를 찾는 데 필요한 키 비교 수가 상당히 감소 하나만 특정 버킷에 검색 하려면 키의 해시 코드를 사용 하는 키의 후속 조회 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The load factor of a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> determines the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율을 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 버킷과 요소의 최대 비율을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Smaller load factors cause faster average lookup times at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 부하 요인으로 인해 메모리 소모량이 증가 하면 더 빠르게 평균 조회 시간입니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The default load factor of 1.0 generally provides the best balance between speed and size.</source>
          <target state="translated">일반적으로 1.0의 기본 로드 비율 적절 한 속도와 크기를 제공합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>A different load factor can also be specified when the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is created.</source>
          <target state="translated">서로 다른 로드 비율 일 수도 있습니다 때 지정 되는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 만들어집니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the actual load factor of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> increases.</source>
          <target state="translated">요소에 추가 되는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>의 실제 로드 비율은 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 증가 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>When the actual load factor reaches the specified load factor, the number of buckets in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is automatically increased to the smallest prime number that is larger than twice the current number of <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율의 버킷 수에 도달 하면 때는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 현재 수의 두 배가 보다 큰 가장 작은 소수를 자동으로 증가 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 버킷입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Each key object in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must provide its own hash function, which can be accessed by calling <ph id="ph2">&lt;xref:System.Collections.Hashtable.GetHash%2A&gt;</ph>.</source>
          <target state="translated">각 주요 개체에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 호출 하 여 액세스할 수 있는 자체 해시 함수를 제공 해야 <ph id="ph2">&lt;xref:System.Collections.Hashtable.GetHash%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>However, any object implementing <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> can be passed to a <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, and that hash function is used for all objects in the table.</source>
          <target state="translated">그러나 구현 하는 개체 <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> 에 전달 될 수는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자 및 해시 함수는 테이블의 모든 개체에 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> can hold.</source>
          <target state="translated">용량을 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 요소의 수가는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 보유할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">요소에 추가 되는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라 합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
          <target state="translated">에 대 한 매우 큰 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체를 설정 하 여 64 비트 시스템의 2 십억 요소에 최대 용량을 늘릴 수는 <ph id="ph2">`enabled`</ph> 에 구성 요소의 특성 <ph id="ph3">`true`</ph> 런타임 환경에서 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`For Each`</ph> in Visual Basic) returns an object of the type of the elements in the collection.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> C# 언어의 (<ph id="ph2">`For Each`</ph> Visual basic에서) 컬렉션의 요소 형식의 개체를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Since each element of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is a key/value pair, the element type is not the type of the key or the type of the value.</source>
          <target state="translated">이후의 각 요소는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 는 키/값 쌍 요소 형식이 키의 형식 또는 값의 형식입니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Instead, the element type is <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph>.</source>
          <target state="translated">요소 형식이 대신 <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>For example:</source>
          <target state="translated">예:</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The <ph id="ph1">`foreach`</ph> statement is a wrapper around the enumerator, which only allows reading from, not writing to, the collection.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> 문에 열거자를 컬렉션에 쓰는 것부터 읽기 가능 주변 래퍼입니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">직렬화 및 역직렬화에 대 한 열거자 때문에 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 열거형 호출 하지 않고 계속 하려면 수 없으면, 다시 정렬 될 요소를 발생할 수 있습니다는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Because keys can be inherited and their behavior changed, their absolute uniqueness cannot be guaranteed by comparisons using the <ph id="ph1">&lt;xref:System.Type.Equals%2A&gt;</ph> method.</source>
          <target state="translated">키는 상속 될 수 때문에 동작을 변경할의 절대적인 고유성을 보장할 수 없습니다 사용한 비교는 <ph id="ph1">&lt;xref:System.Type.Equals%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The following example shows how to create, initialize and perform various functions to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and how to print out its keys and values.</source>
          <target state="translated">다음 예제를 만들고 초기화 하 고 다양 한 기능을 수행 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 및 해당 키와 값을 출력 하는 방법입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is thread safe for use by multiple reader threads and a single writing thread.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 스레드로부터 안전 하 게 여러 판독기 스레드 및 단일 쓰기 스레드에서 사용할 합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>It is thread safe for multi-thread use when only one of the threads perform write (update) operations, which allows for lock-free reads provided that the writers are serialized to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">그는 스레드로부터 안전만 스레드 중 하나 (업데이트) 쓰기 작업을 수행할 때 다중 스레드 사용에 대 한 기록기도 serialize 되는 읽기 잠금 없는 허용 하는 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>To support multiple writers all operations on the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> must be done through the wrapper returned by the <ph id="ph2">&lt;see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /&gt;</ph> method, provided that there are no threads reading the <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">여러 작성기 모든 작업을 지원 하기 위해는 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 에서 반환 되는 래퍼를 통해 수행 해야 합니다는 <ph id="ph2">&lt;see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /&gt;</ph> 읽는 스레드가 없는 제공 된 메서드는 <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="T:System.Collections.Hashtable">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the default initial capacity, load factor, hash code provider, and comparer.</source>
          <target state="translated">기본 초기 용량, 로드 비율, 해시 코드 공급자 및 비교자를 사용하여 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">용량 자동으로 증가 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">이 생성자는 o (1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> 개체로 복사할 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">지정한 사전의 요소를 새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체에 복사하여 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor, hash code provider, and comparer.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 기본 로드 비율, 해시 코드 공급자 및 비교자를 사용합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">새 요소의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 정렬 되는 열거자를 통해 반복 하는 순서는 <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> 개체와 함께 사용할 해시 코드 공급자와 비교자를 정의하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated">기본 해시 코드 공급자와 기본 비교자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자는 각 키의 <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> 구현이며 기본 비교자는 각 키의 <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the default initial capacity and load factor, and the specified <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">기본 초기 용량 및 로드 비율과 지정된 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체를 사용하여 <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">용량 자동으로 증가 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 해시 코드 공급자와 비교자 개체를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 에 사용 되는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에서 키로 사용 되는 개체는 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체는 재정의 하지 않아도 <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">이 생성자는 o (1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, and the default load factor, hash code provider, and comparer.</source>
          <target state="translated">지정된 초기 용량과 기본 로드 비율, 해시 코드 공급자 및 비교자를 사용하여 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`capacity`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> 개체로 복사할 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>과 함께 사용할 해시 코드 공급자와 비교자를 정의하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated">기본 해시 코드 공급자와 기본 비교자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자는 각 키의 <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> 구현이며 기본 비교자는 각 키의 <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">지정된 사전의 요소를 새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체에 복사하여 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor and the specified <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 기본 로드 비율과 지정된 <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> 개체를 사용합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 해시 코드 공급자와 비교자 개체를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 에 사용 되는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에서 키로 사용 되는 개체는 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체는 재정의 하지 않아도 <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">새 요소의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 정렬 되는 열거자를 통해 반복 하는 순서는 <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> 개체로 복사할 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과는 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">지정한 사전의 요소를 새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체에 복사하여 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor, and the default hash code provider and comparer.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 지정된 로드 비율과 기본 해시 코드 공급자 및 비교자를 사용합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">새 요소의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 정렬 되는 열거자를 통해 반복 하는 순서는 <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 0.1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 1.0보다 큽니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> 개체의 모든 키에 대한 해시 코드를 제공하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated">각 키의 <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> 구현인 기본 해시 코드 공급자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated">두 키가 같은지 여부를 확인하는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">각 키로 <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>를 구현한 기본 비교자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the default initial capacity and load factor, and the specified hash code provider and comparer.</source>
          <target state="translated">기본 초기 용량 및 로드 비율과 지정된 해시 코드 공급자 및 비교자를 사용하여 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">용량 자동으로 증가 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">이 생성자는 o (1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>과 함께 사용할 해시 코드 공급자와 비교자를 정의하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated">기본 해시 코드 공급자와 기본 비교자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자는 각 키의 <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> 구현이며 기본 비교자는 각 키의 <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity and <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>, and the default load factor.</source>
          <target state="translated">지정된 초기 용량 및 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>와 기본 로드 비율을 사용하여 <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 해시 코드 공급자와 비교자 개체를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 에 사용 되는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에서 키로 사용 되는 개체는 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> 재정의 하지 않아도 되는 <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">`capacity`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과는 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity and load factor, and the default hash code provider and comparer.</source>
          <target state="translated">지정된 초기 용량 및 로드 비율과 기본 해시 코드 공급자 및 비교자를 사용하여 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">`capacity`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 0.1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 1.0보다 큽니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is causing an overflow.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph>가 오버플로를 일으킬 수 있습니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object containing the information required to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> 개체를 serialize하는 데 필요한 정보가 들어 있는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> object containing the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>와 연결된 serialize된 스트림의 소스와 대상이 포함된 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>개체입니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class that is serializable using the specified <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> objects.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> 개체를 사용하여 serialize할 수 있는 <ph id="ph3">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">용량 자동으로 증가 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">직렬화 및 역직렬화에 대 한 열거자 때문에 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 열거형 호출 하지 않고 계속 하려면 수 없으면, 다시 정렬 될 요소를 발생할 수 있습니다는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> 개체로 복사할 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph>의 모든 키에 해시 코드를 제공하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated">각 키의 <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> 구현인 기본 해시 코드 공급자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated">두 키가 같은지 여부를 확인하는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">각 키로 <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>를 구현한 기본 비교자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">지정한 사전의 요소를 새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체에 복사하여 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor, and the specified hash code provider and comparer.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 기본 로드 비율과 지정된 해시 코드 공급자 및 비교자를 사용합니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This API is obsolete.</source>
          <target state="translated">이 API는 더 이상 사용되지 않습니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>For an alternative, see <ph id="ph1">&lt;see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" /&gt;</ph>.</source>
          <target state="translated">다른 방법을 보려면 <ph id="ph1">&lt;see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" /&gt;</ph>를 참조하십시오.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">새 요소의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 정렬 되는 열거자를 통해 반복 하는 순서는 <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> 개체로 복사할 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과는 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>과 함께 사용할 해시 코드 공급자와 비교자를 정의하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated">기본 해시 코드 공급자와 기본 비교자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자는 각 키의 <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> 구현이며 기본 비교자는 각 키의 <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">지정한 사전의 요소를 새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체에 복사하여 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor and <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 지정된 로드 비율 및 <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> 개체를 사용합니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 해시 코드 공급자와 비교자 개체를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 에 사용 되는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에서 키로 사용 되는 개체는 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체는 재정의 하지 않아도 <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">새 요소의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 정렬 되는 열거자를 통해 반복 하는 순서는 <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 0.1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 1.0보다 큽니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph>의 모든 키에 해시 코드를 제공하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated">각 키의 <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> 구현인 기본 해시 코드 공급자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated">두 키가 같은지 여부를 확인하는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">각 키로 <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>를 구현한 기본 비교자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, hash code provider, comparer, and the default load factor.</source>
          <target state="translated">지정된 초기 용량, 해시 코드 공급자 및 비교자와 기본 로드 비율을 사용하여 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">`capacity`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과는 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>과 함께 사용할 해시 코드 공급자와 비교자를 정의하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated">기본 해시 코드 공급자와 기본 비교자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자는 각 키의 <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> 구현이며 기본 비교자는 각 키의 <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, load factor, and <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">지정된 초기 용량, 로드 비율 및 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체를 사용하여 <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 해시 코드 공급자와 비교자 개체를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 에 사용 되는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에서 키로 사용 되는 개체는 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> 재정의 하지 않아도 되는 <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">`capacity`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 0.1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 1.0보다 큽니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> 개체로 복사할 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과는 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph>의 모든 키에 해시 코드를 제공하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated">각 키의 <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> 구현인 기본 해시 코드 공급자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated">두 키가 같은지 여부를 확인하는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">각 키로 <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>를 구현한 기본 비교자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">지정한 사전의 요소를 새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체에 복사하여 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor, hash code provider, and comparer.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 지정된 로드 비율, 해시 코드 공급자 및 비교자를 사용합니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">초기 용량 원본 사전의 요소 수로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">새 요소의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 정렬 되는 열거자를 통해 반복 하는 순서는 <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`d`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 0.1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 1.0보다 큽니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">결과는 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph>의 모든 키에 해시 코드를 제공하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated">각 키의 <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> 구현인 기본 해시 코드 공급자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated">두 키가 같은지 여부를 확인하는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">각 키로 <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>를 구현한 기본 비교자를 사용하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, load factor, hash code provider, and comparer.</source>
          <target state="translated">지정된 초기 용량, 로드 비율, 해시 코드 공급자 및 비교자를 사용하여 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">로드 비율은 버킷과 요소의 최대 비율입니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">1.0의 로드 비율은 속도와 크기 적절 합니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 해시 코드 공급자 키의의 구현인 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">비교자 두 키가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 비교자는 키의 구현의 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">`capacity`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 0.1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph>가 1.0보다 큽니다.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The key of the element to add.</source>
          <target state="translated">추가할 요소의 키입니다.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The value of the element to add.</source>
          <target state="translated">추가할 요소의 값입니다.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">값은 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>Adds an element with the specified key and value into the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">지정한 키와 값을 가지는 요소를 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 추가합니다.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">키 일 수 없습니다 <ph id="ph1">`null`</ph>, 하지만 값이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>An object that has no correlation between its state and its hash code value should typically not be used as the key.</source>
          <target state="translated">개체의 상태와 해시 코드 값 간에 상관 관계가 있는 일반적으로 쓰일 수 없습니다 키로 합니다.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>For example, String objects are better than StringBuilder objects for use as keys.</source>
          <target state="translated">예를 들어 문자열 개체는 키로 사용 하기 위해 StringBuilder 개체 보다 더 나은입니다.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property to add new elements by setting the value of a key that does not exist in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>; for example, <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</source>
          <target state="translated">사용할 수도 있습니다는 <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> 에 속성 키의 값을 설정 하 여 새 요소를 추가할 수 없습니다.는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>등 <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>However, if the specified key already exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, setting the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property overwrites the old value.</source>
          <target state="translated">그러나 지정된 된 키에 이미 있는 경우는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>설정는 <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> 속성 이전 값을 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> method does not modify existing elements.</source>
          <target state="translated">반면,는 <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> 메서드는 기존 요소를 수정 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> is less than the capacity of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, this method is an O(1) operation.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> 의 용량 보다 작은 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>,이 메서드는 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O 됩니다 용량을 새 요소로 적용로 늘려야 하는 경우 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The following example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 요소를 추가 하는 방법을 보여 줍니다.는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>An element with the same key already exists in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">같은 키를 가진 요소가 이미 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 있는 경우</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>이 읽기 전용인 경우</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>가 고정 크기입니다.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clear">
          <source>Removes all elements from the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에서 모든 요소를 제거합니다.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> is set to zero, and references to other objects from elements of the collection are also released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> 가 0으로 설정 하 고 컬렉션의 요소에 다른 개체에 대 한 참조도 해제 됩니다.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source>The capacity remains unchanged.</source>
          <target state="translated">용량 변경 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source>The following example shows how to clear the values of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">값을 지우는 방법을 보여 주는 다음 예제는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>이 읽기 전용인 경우</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>의 부분 복사본을 만듭니다.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>의 부분 복사본입니다.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">컬렉션의 단순 복사본은 참조 형식 또는 값 형식 참조에서 참조 하는 개체를 복사 하지 않습니다 여부는 컬렉션의 요소에만 복사 합니다.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
          <target state="translated">새 컬렉션에 대 한 참조는 원본 컬렉션에 대 한 참조를 가리키는 동일한 개체를 가리킵니다.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">반면, 요소를 복사 하는 컬렉션의 전체 복사본 및 뿐만 아니라 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목입니다.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> clone has the same count, the same capacity, the same <ph id="ph2">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation, and the same <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementation as the original <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 복사본은과 수, 용량, 동일한 <ph id="ph2">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> 구현 및 동일한 <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> 원래 구현 <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.comparer">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>에 사용할 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.comparer">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>에 사용할 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.comparer">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.comparer">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>.</source>
          <target state="translated">속성이 값으로 설정되었지만 <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>를 사용하여 해시 테이블을 만든 경우</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>The key to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에서 찾을 수 있는 키입니다.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains a specific key.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 특정 키가 들어 있는지 여부를 확인합니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains an element with the specified key; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>에 지정한 키가 있는 요소가 포함되어 있으면 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> implements <ph id="ph2">&lt;xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph>는 <ph id="ph2">&lt;xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType&gt;</ph>를 구현합니다.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>It behaves exactly as <ph id="ph1">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph>.</source>
          <target state="translated">와 동일 하 게 작동 <ph id="ph1">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 에 대 한 메서드 <ph id="ph3">`item`</ph> 항목이 있는지 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">.NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 의 메서드는 <ph id="ph3">`item`</ph> 컬렉션의 개체에 대 한 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>The following example shows how to determine whether the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> contains a specific element.</source>
          <target state="translated">다음 예제에서는 확인 하는 방법을 보여 줍니다. 여부는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 특정 요소를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>The key to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에서 찾을 수 있는 키입니다.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains a specific key.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 특정 키가 들어 있는지 여부를 확인합니다.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains an element with the specified key; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>에 지정한 키가 있는 요소가 포함되어 있으면 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>This method behaves exactly as <ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는과 동일 하 게 동작 <ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 에 대 한 메서드 <ph id="ph3">`item`</ph> 항목이 있는지 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">.NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 의 메서드는 <ph id="ph3">`item`</ph> 컬렉션의 개체에 대 한 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>The following example shows how to determine whether the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> contains a specific element.</source>
          <target state="translated">다음 예제에서는 확인 하는 방법을 보여 줍니다. 여부는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 특정 요소를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The value to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에서 찾을 값입니다.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">값은 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains a specific value.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 특정 값이 들어 있는지 여부를 확인합니다.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains an element with the specified <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see langword="true" /&gt;</ph>을 가진 요소가 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 포함되어 있으면 <ph id="ph3">&lt;paramref name="value" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The values of the elements of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are compared to the specified value using the <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">요소는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 사용 하 여 지정 된 값이 비교는 <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 에 대 한 메서드 <ph id="ph3">`item`</ph> 항목이 있는지 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">.NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 의 메서드는 <ph id="ph3">`item`</ph> 컬렉션의 개체에 대 한 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The following example shows how to determine whether the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> contains a specific element.</source>
          <target state="translated">다음 예제에서는 확인 하는 방법을 보여 줍니다. 여부는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 특정 요소를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the <ph id="ph2">&lt;see cref="T:System.Collections.DictionaryEntry" /&gt;</ph> objects copied from <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에서 복사한 <ph id="ph2">&lt;see cref="T:System.Collections.DictionaryEntry" /&gt;</ph> 개체의 대상인 1차원 <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 배열입니다.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에는 0부터 시작하는 인덱스가 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>배열<ept id="p1">&lt;/c&gt;</ept>에서 복사를 시작할 인덱스입니다. 이 인덱스는 0부터 시작합니다.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>Copies the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> elements to a one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> instance at the specified index.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 요소를 지정한 인덱스의 1차원 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> 인스턴스에 복사합니다.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">요소가 복사 되는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 열거자가 반복는 동일한 순서로 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>To copy only the keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use <ph id="ph2">`Hashtable.Keys.CopyTo`</ph>.</source>
          <target state="translated">에 있는 키를 복사 하는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>를 사용 하 여 <ph id="ph2">`Hashtable.Keys.CopyTo`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>To copy only the values in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use <ph id="ph2">`Hashtable.Values.CopyTo`</ph>.</source>
          <target state="translated">값만 복사 하는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>를 사용 하 여 <ph id="ph2">`Hashtable.Values.CopyTo`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The following example shows how to copy the list of keys or the list of values in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 키의 목록 또는 목록에 있는 값의 복사 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 로 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph>가 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">소스 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>의 요소 수가 대상 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph>부터 끝까지 사용 가능한 공간보다 큽니다.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">소스 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>의 형식을 대상 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 형식으로 자동 캐스팅할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Count">
          <source>Gets the number of key/value pairs contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 포함된 키/값 쌍의 수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Count">
          <source>The number of key/value pairs contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 포함된 키/값 쌍의 수입니다.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>에 사용할 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>에 사용할 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> includes both the comparer and the hash code provider.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 비교자 및 해시 코드 공급자를 모두 포함 합니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 에 사용 되는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 생성자에서 키로 사용 되는 개체는 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> 재정의 하지 않아도 되는 <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> and an <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">속성이 값으로 설정되었지만 <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>를 사용하여 해시 테이블을 만든 경우</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> that iterates through the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph>를 반복하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph>에 대한 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, C#]</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">@FSHO1@C# 언어의 <ph id="ph1">`foreach`</ph> 문(Visual Basic의 경우 <ph id="ph2">`for each`</ph>)은 열거자의 복잡성을 숨깁니다.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">그러므로 열거자를 직접 조작하는 대신 <ph id="ph1">`foreach`</ph>를 사용하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>을 실행하면 열거자가 이 위치로 복원됩니다.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">이 위치에서 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>는 정의되지 않습니다.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">따라서 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>의 값을 읽기 전에 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>에서는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 또는 <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>이 호출될 때까지 동일한 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>를 다음 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">열거자가 있는 경우이 위치에 대 한 후속 호출에서 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환할 수도 <ph id="ph2">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">마지막으로 호출 하는 경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>를 컬렉션의 첫째 요소에 다시 설정하려면 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>을 호출한 뒤 <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>를 호출해야 합니다.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">열거자는 컬렉션에 독점적으로 액세스할 수 있는 권한이 없으므로 컬렉션을 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">직렬화 및 역직렬화에 대 한 열거자 때문에 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 열거형 호출 하지 않고 계속 하려면 수 없으면, 다시 정렬 될 요소를 발생할 수 있습니다는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>The following example compares the use of <ph id="ph1">&lt;xref:System.Collections.Hashtable.GetEnumerator%2A&gt;</ph> and <ph id="ph2">`foreach`</ph> to enumerate the contents of a <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 사용 하는 비교 <ph id="ph1">&lt;xref:System.Collections.Hashtable.GetEnumerator%2A&gt;</ph> 및 <ph id="ph2">`foreach`</ph> 의 내용을 열거 하는 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> for which a hash code is to be returned.</source>
          <target state="translated">해시 코드가 반환될 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>Returns the hash code for the specified key.</source>
          <target state="translated">지정한 키의 해시 코드를 반환합니다.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>The hash code for <ph id="ph1">&lt;paramref name="key" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>의 해시 코드입니다.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>If the hash table was created with a specific <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation, this method uses that hash code provider; otherwise, it uses the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> implementation of <ph id="ph3">`key`</ph>.</source>
          <target state="translated">특정 해시 테이블을 만든 경우 <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> 구현에서이 메서드는 해당 해시 코드 공급자를 사용 합니다; 하 고 사용은 <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 구현의 <ph id="ph3">`key`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object containing the information required to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>를 serialize하는 데 필요한 정보가 포함된 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> object containing the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>와 연결된 serialize된 스트림의 소스와 대상이 포함된 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>개체입니다.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interface and returns the data needed to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> 인터페이스를 구현하고 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>을 serialize하는 데 필요한 데이터를 반환합니다.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The collection was modified.</source>
          <target state="translated">컬렉션이 수정되었습니다.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.hcp">
          <source>Gets or sets the object that can dispense hash codes.</source>
          <target state="translated">해시 코드를 분배할 수 있는 개체를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.hcp">
          <source>The object that can dispense hash codes.</source>
          <target state="translated">해시 코드를 분배할 수 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.hcp">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.hcp">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>.</source>
          <target state="translated">속성이 값으로 설정되었지만 <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>를 사용하여 해시 테이블을 만든 경우</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>의 크기가 고정되어 있는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>의 크기가 고정되어 있으면 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">기본값은 <ph id="ph1">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</source>
          <target state="translated">크기가 고정된 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가하거나 제거할 수 없지만 기존 요소는 수정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">크기가 고정된 된 컬렉션은 요소; 추가 및 제거를 방지 하는 래퍼가 지정 된 컬렉션 따라서를 추가 하거나 제거할 요소를 포함 하 여 내부 컬렉션을 변경 하는 경우 고정 크기 컬렉션에 해당 변경 내용을 반영 합니다.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>가 읽기 전용인지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>가 읽기 전용이면 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">기본값은 <ph id="ph1">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">읽기 전용 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가, 제거 또는 수정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 될 경우 읽기 전용 컬렉션 해당 변경 내용을 반영 합니다.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되면 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">기본값은 <ph id="ph1">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can support one writer and multiple readers concurrently.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 동시 지원할 수 있습니다 하나 기록기 및 다중 판독기입니다.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>To support multiple writers, all operations must be done through the wrapper returned by the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">반환 되는 래퍼를 통해 수행 해야 모든 작업을 지원 하기 위해 여러 작성기는 <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
          <target state="translated">다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> 열거 하는 동안:</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>The following example shows how to synchronize a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, determine if a <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> is synchronized, and use a synchronized <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">동기화 하는 방법을 보여 주는 다음 예제는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>를 결정 하는 경우는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 동기화 되 고 동기화를 사용 하 여 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The key whose value to get or set.</source>
          <target state="translated">가져오거나 설정할 값이 있는 키입니다.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>Gets or sets the value associated with the specified key.</source>
          <target state="translated">지정된 키에 연결된 값을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The value associated with the specified key.</source>
          <target state="translated">지정한 키와 연결된 값입니다.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>If the specified key is not found, attempting to get it returns <ph id="ph1">&lt;see langword="null" /&gt;</ph>, and attempting to set it creates a new element using the specified key.</source>
          <target state="translated">지정한 키가 없는 경우 해당 키를 가져오려고 시도하면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이 반환되고 해당 키를 설정하려고 시도하면 지정한 키를 사용하여 새 요소가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[key]`</ph>.</source>
          <target state="translated">이 속성은 <ph id="ph1">`myCollection[key]`</ph> 구문을 사용하여 컬렉션의 특정 요소에 액세스하는 기능을 제공합니다.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property to add new elements by setting the value of a key that does not exist in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>; for example, <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</source>
          <target state="translated">사용할 수도 있습니다는 <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> 에 속성 키의 값을 설정 하 여 새 요소를 추가할 수 없습니다.는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>등 <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>However, if the specified key already exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, setting the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property overwrites the old value.</source>
          <target state="translated">그러나 지정된 된 키에 이미 있는 경우는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>설정는 <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> 속성 이전 값을 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> method does not modify existing elements.</source>
          <target state="translated">반면,는 <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> 메서드는 기존 요소를 수정 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">키 일 수 없습니다 <ph id="ph1">`null`</ph>, 하지만 값이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>To distinguish between <ph id="ph1">`null`</ph> that is returned because the specified key is not found and <ph id="ph2">`null`</ph> that is returned because the value of the specified key is <ph id="ph3">`null`</ph>, use the <ph id="ph4">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> method or the <ph id="ph5">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph> method to determine if the key exists in the list.</source>
          <target state="translated">구분 하기 위해 <ph id="ph1">`null`</ph> 지정된 된 키를 찾을 수 없으므로 반환 되는 및 <ph id="ph2">`null`</ph> 지정된 된 키의 값은 반환 되는 <ph id="ph3">`null`</ph>를 사용 하 여는 <ph id="ph4">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> 메서드 또는 <ph id="ph5">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph> 여부를 확인 하는 메서드 키 목록에 있습니다.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
          <target state="translated">이 속성의 값을 검색 하 하는 것은 o (1) 연산입니다. o (1) 작업 이기도 속성을 설정 합니다.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The C# language uses the  keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.IList.Item%2A&gt;</ph> property.</source>
          <target state="translated">C# 언어의 키워드를 사용 하 여 구현 하는 대신 인덱서를 정의 하는 <ph id="ph1">&lt;xref:System.Collections.IList.Item%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
          <target state="translated">Visual Basic에서는 동일한 인덱싱 기능을 제공하는 <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph>을 기본 속성으로 구현합니다.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The property is set and the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated">속성이 설정되어 있으며 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>가 읽기 전용인 경우</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The property is set, <ph id="ph1">&lt;paramref name="key" /&gt;</ph> does not exist in the collection, and the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated">속성이 설정되어 있고 <ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 컬렉션에 없으며 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>의 크기가 고정된 경우</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to compare with <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>키<ept id="p1">&lt;/c&gt;</ept>와 비교할 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>The key in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> to compare with <bpt id="p1">&lt;c&gt;</bpt>item<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>항목<ept id="p1">&lt;/c&gt;</ept>과 비교할 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>의 키입니다.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>Compares a specific <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> with a specific key in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">특정 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>를 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>의 특정 키와 비교합니다.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> and <ph id="ph3">&lt;paramref name="key" /&gt;</ph> are equal; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="item" /&gt;</ph>과 <ph id="ph3">&lt;paramref name="key" /&gt;</ph>가 같으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>If the hash table was created with a specific <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation, this method uses that comparer; that is, <ph id="ph2">&lt;xref:System.Collections.IComparer.Compare%2A&gt;</ph> (<ph id="ph3">`item`</ph>, <ph id="ph4">`key`</ph>).</source>
          <target state="translated">특정 해시 테이블을 만든 경우 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 구현이이 메서드는 사용 되는 비교자; <ph id="ph2">&lt;xref:System.Collections.IComparer.Compare%2A&gt;</ph> (<ph id="ph3">`item`</ph>, <ph id="ph4">`key`</ph>).</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>Otherwise, it uses <ph id="ph1">`item.Equals(key)`</ph>.</source>
          <target state="translated">그렇지 않으면 사용 <ph id="ph1">`item.Equals(key)`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="item" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="item" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Keys">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>의 키를 포함하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>의 키를 포함하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>The order of the keys in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is unspecified, but it is the same order as the associated values in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> returned by the <ph id="ph3">&lt;xref:System.Collections.Hashtable.Values%2A&gt;</ph> method.</source>
          <target state="translated">에 있는 키의 순서는 <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> 지정 되어 있지에 연결 된 값과 순서가 동일 하지만 <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> 에서 반환 되는 <ph id="ph3">&lt;xref:System.Collections.Hashtable.Values%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>The returned <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is not a static copy; instead, the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> refers back to the keys in the original <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> 정적 복사 하지 않습니다; 대신는 <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> 원래에서 키를 다시 참조할 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>Therefore, changes to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> continue to be reflected in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">따라서 변경는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 계속에 반영 됩니다는 <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>The source of the deserialization event.</source>
          <target state="translated">deserialization 이벤트의 소스입니다.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interface and raises the deserialization event when the deserialization is complete.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> 인터페이스를 구현하고, deserialization이 완료되면 deserialization 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">직렬화 및 역직렬화에 대 한 열거자 때문에 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 열거형 호출 하지 않고 계속 하려면 수 없으면, 다시 정렬 될 요소를 발생할 수 있습니다는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object associated with the current <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is invalid.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>과 관련된 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> 개체가 잘못된 경우</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The key of the element to remove.</source>
          <target state="translated">제거할 요소의 키입니다.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>Removes the element with the specified key from the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에서 키가 지정된 요소를 제거합니다.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> does not contain an element with the specified key, the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> remains unchanged.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 지정된 키를 가진 요소가 포함 되지 않습니다는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 그대로 유지 됩니다.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw되지 않습니다.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The following example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">다음 예제에서 요소를 제거 하는 방법의 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>이 읽기 전용인 경우</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>가 고정 크기입니다.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> to synchronize.</source>
          <target state="translated">동기화할 <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Returns a synchronized (thread-safe) wrapper for the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 대해 동기화되어 스레드로부터 안전하게 보호되는 래퍼를 반환합니다.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>A synchronized (thread-safe) wrapper for the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 대해 동기화되어 스레드로부터 안전하게 보호되는 래퍼입니다.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method is thread safe for multiple readers and writers.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> 메서드는 스레드로부터 안전 하 게 여러 판독기와 작성기에 대 한 보호 합니다.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Furthermore, the synchronized wrapper ensures that there is only one writer writing at a time.</source>
          <target state="translated">또한 동기화 된 래퍼 한 작성기만 한 번에 작성 되는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
          <target state="translated">다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> 열거 하는 동안:</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The following example shows how to synchronize a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, determine if a <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> is synchronized, and use a synchronized <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">동기화 하는 방법을 보여 주는 다음 예제는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>를 결정 하는 경우는 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> 동기화 되 고 동기화를 사용 하 여 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source><ph id="ph1">&lt;paramref name="table" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="table" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 대한 액세스를 동기화하는 데 사용할 수 있는 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>에 대한 액세스를 동기화하는 데 사용할 수 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>To create a synchronized version of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">동기화 된 버전을 만들려면는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>를 사용 하 여는 <ph id="ph2">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>However, derived classes can provide their own synchronized version of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">하지만 파생된 클래스의 동기화 된 버전을 제공할 수 있습니다는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 를 사용 하는 <ph id="ph2">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, not directly on the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> .</source>
          <target state="translated">동기화 하는 코드에서 작업을 수행 해야는 <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> 의 <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>에서 직접는 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> 합니다.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">이렇게 하면 다른 개체에서 파생되는 컬렉션에 대해 적절한 작업이 수행됩니다.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">특히, 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 관리는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
          <target state="translated">다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> 열거 하는 동안:</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an enumerator that iterates through a collection.</source>
          <target state="translated">컬렉션을 반복하는 열거자를 반환합니다.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> that can be used to iterate through the collection.</source>
          <target state="translated">컬렉션에서 반복하는 데 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, C#]</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">@FSHO1@C# 언어의 <ph id="ph1">`foreach`</ph> 문(Visual Basic의 경우 <ph id="ph2">`for each`</ph>)은 열거자의 복잡성을 숨깁니다.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">그러므로 열거자를 직접 조작하는 대신 <ph id="ph1">`foreach`</ph>를 사용하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>을 실행하면 열거자가 이 위치로 복원됩니다.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>At this position, calling <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
          <target state="translated">이 위치에서, 호출 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">따라서 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>의 값을 읽기 전에 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>에서는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 또는 <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>이 호출될 때까지 동일한 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>를 다음 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">열거자가 있는 경우이 위치에 대 한 후속 호출에서 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환할 수도 <ph id="ph2">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, calling <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
          <target state="translated">마지막으로 호출 하는 경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph2">`false`</ph>호출, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>를 컬렉션의 첫째 요소에 다시 설정하려면 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>을 호출한 뒤 <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>를 호출해야 합니다.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator can be invalidated and the next call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">변경, 추가 하는 등 컬렉션을 수정 또는 삭제 요소에 열거자를 무효화 될 수 있습니다 및을 다음에 호출할 경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> throw는 <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If the collection is modified between <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the element that it is set to, even if the enumerator is already invalidated.</source>
          <target state="translated">사이 컬렉션이 수정 되는 경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> 열거자가 이미 무효로 되 었 하는 경우에 설정 하는 요소를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">열거자는 컬렉션에 독점적으로 액세스할 수 있는 권한이 없으므로 컬렉션을 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Values">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the values in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>의 값이 들어 있는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the values in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>의 값을 포함하는 <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>The order of the values in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is unspecified, but it is the same order as the associated keys in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> returned by the <ph id="ph3">&lt;xref:System.Collections.Hashtable.Keys%2A&gt;</ph> method.</source>
          <target state="translated">에 있는 값의 순서는 <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> 지정 되어 있지는 연결 된 키와 순서가 동일 하지만 <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> 에서 반환 되는 <ph id="ph3">&lt;xref:System.Collections.Hashtable.Keys%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>The returned <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is not a static copy; instead, the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> refers back to the values in the original <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> 정적 복사 하지 않습니다; 대신는 <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> 원래에서 값을 다시 참조 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>Therefore, changes to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> continue to be reflected in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">따라서 변경는 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 계속에 반영 됩니다는 <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>