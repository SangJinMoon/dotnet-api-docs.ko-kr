<Type Name="Hashtable" FullName="System.Collections.Hashtable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4c6adcdcf0768c2d073d568527998677360d621e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30370897" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Hashtable extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Hashtable" />
  <TypeSignature Language="VB.NET" Value="Public Class Hashtable&#xA;Implements ICloneable, IDeserializationCallback, IDictionary, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Hashtable : ICloneable, System::Collections::IDictionary, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>키의 해시 코드에 따라 구성된 키/값 쌍의 컬렉션을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 요소에 저장 된 키/값 쌍은는 <xref:System.Collections.DictionaryEntry> 개체입니다. 키 일 수 없습니다 `null`, 하지만 값이 될 수 있습니다.  
  
 키로 사용 되는 개체는 <xref:System.Collections.Hashtable> 재정의 하는 데 필요한는 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 메서드 (또는 <xref:System.Collections.IHashCodeProvider> 인터페이스) 및 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드 (또는 <xref:System.Collections.IComparer> 인터페이스). 두 메서드 및 인터페이스의 구현을 대/소문자 구분; 같은 방식으로 처리 해야 합니다. 그렇지 않은 경우는 <xref:System.Collections.Hashtable> 올바르게 작동할 수 있습니다. 예를 들어, 만들 때는 <xref:System.Collections.Hashtable>를 사용 해야 합니다는 <xref:System.Collections.CaseInsensitiveHashCodeProvider> 클래스 (모든 대/소문자 구분 또는 <xref:System.Collections.IHashCodeProvider> 구현)와 <xref:System.Collections.CaseInsensitiveComparer> 클래스 (모든 대/소문자 구분 또는 <xref:System.Collections.IComparer> 구현)입니다.  
  
 또한 이러한 메서드는 키에 있는 동안 동일한 매개 변수를 사용 하 여 호출 될 때 동일한 결과 생성 해야 합니다는 <xref:System.Collections.Hashtable>합니다. 대신 사용 하는 것을 <xref:System.Collections.Hashtable> 생성자는 <xref:System.Collections.IEqualityComparer> 매개 변수입니다. 키가 같은지 여부 단순히 참조 일치의 상속 된 구현 된 경우 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 및 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 충분 합니다.  
  
 키 개체 변경 하지 않아야에서 키로 사용 하는 상태로 <xref:System.Collections.Hashtable>합니다.  
  
 요소에 추가 된 경우는 <xref:System.Collections.Hashtable>, 키의 해시 코드에 따라 버킷에 배치 됩니다. 요소를 찾는 데 필요한 키 비교 수가 상당히 감소 하나만 특정 버킷에 검색 하려면 키의 해시 코드를 사용 하는 키의 후속 조회 합니다.  
  
 로드 비율을 <xref:System.Collections.Hashtable> 버킷과 요소의 최대 비율을 결정 합니다. 더 작은 부하 요인으로 인해 메모리 소모량이 증가 하면 더 빠르게 평균 조회 시간입니다. 일반적으로 1.0의 기본 로드 비율 적절 한 속도와 크기를 제공합니다. 서로 다른 로드 비율 일 수도 있습니다 때 지정 되는 <xref:System.Collections.Hashtable> 만들어집니다.  
  
 요소에 추가 되는 <xref:System.Collections.Hashtable>의 실제 로드 비율은 <xref:System.Collections.Hashtable> 증가 합니다. 실제 로드 비율이 지정된 된 로드 비율의 버킷 수에 도달 하면 때는 <xref:System.Collections.Hashtable> 현재 수의 두 배가 보다 큰 가장 작은 소수를 자동으로 증가 <xref:System.Collections.Hashtable> 버킷입니다.  
  
 각 주요 개체에는 <xref:System.Collections.Hashtable> 호출 하 여 액세스할 수 있는 자체 해시 함수를 제공 해야 <xref:System.Collections.Hashtable.GetHash%2A>합니다. 그러나 구현 하는 개체 <xref:System.Collections.IHashCodeProvider> 에 전달 될 수는 <xref:System.Collections.Hashtable> 생성자 및 해시 함수는 테이블의 모든 개체에 사용 됩니다.  
  
 용량을 <xref:System.Collections.Hashtable> 요소의 수가는 <xref:System.Collections.Hashtable> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.Hashtable>, 용량 자동으로 증가 하면 재할당을 통해 필요에 따라 합니다.  
  
 에 대 한 매우 큰 <xref:System.Collections.Hashtable> 개체를 설정 하 여 64 비트 시스템의 2 십억 요소에 최대 용량을 늘릴 수는 `enabled` 에 구성 요소의 특성 `true` 런타임 환경에서 합니다.  
  
 `foreach` C# 언어의 (`For Each` Visual basic에서) 컬렉션의 요소 형식의 개체를 반환 합니다. 이후의 각 요소는 <xref:System.Collections.Hashtable> 는 키/값 쌍 요소 형식이 키의 형식 또는 값의 형식입니다. 요소 형식이 대신 <xref:System.Collections.DictionaryEntry>합니다. 예:  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/remarks.cpp#01)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/remarks.cs#01)]
 [!code-vb[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/remarks.vb#01)]  
  
 `foreach` 문에 열거자를 컬렉션에 쓰는 것부터 읽기 가능 주변 래퍼입니다.  
  
 직렬화 및 역직렬화에 대 한 열거자 때문에 <xref:System.Collections.Hashtable> 열거형 호출 하지 않고 계속 하려면 수 없으면, 다시 정렬 될 요소를 발생할 수 있습니다는 <xref:System.Collections.IEnumerator.Reset%2A> 메서드.  
  
> [!NOTE]
>  키는 상속 될 수 때문에 동작을 변경할의 절대적인 고유성을 보장할 수 없습니다 사용한 비교는 <xref:System.Type.Equals%2A> 메서드.  
  
   
  
## Examples  
 다음 예제를 만들고 초기화 하 고 다양 한 기능을 수행 하는 방법을 보여 줍니다는 <xref:System.Collections.Hashtable> 및 해당 키와 값을 출력 하는 방법입니다.  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/hashtable_example.cpp#00)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/hashtable_example.cs#00)]
 [!code-vb[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/hashtable_example.vb#00)]
 [!code-powershell[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/powershell/VS_Snippets_CLR_System/system.collections.hashtable.class/ps/hashtable.ps1#00)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <see cref="T:System.Collections.Hashtable" /> 스레드로부터 안전 하 게 여러 판독기 스레드 및 단일 쓰기 스레드에서 사용할 합니다. 그는 스레드로부터 안전만 스레드 중 하나 (업데이트) 쓰기 작업을 수행할 때 다중 스레드 사용에 대 한 기록기도 serialize 되는 읽기 잠금 없는 허용 하는 <see cref="T:System.Collections.Hashtable" />합니다. 여러 작성기 모든 작업을 지원 하기 위해는 <see cref="T:System.Collections.Hashtable" /> 에서 반환 되는 래퍼를 통해 수행 해야 합니다는 <see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /> 읽는 스레드가 없는 제공 된 메서드는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.  
  
 컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</threadsafe>
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.IHashCodeProvider" />
    <altmember cref="M:System.Object.GetHashCode" />
    <altmember cref="M:System.Object.Equals(System.Object)" />
    <altmember cref="T:System.Collections.DictionaryEntry" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
    <altmember cref="T:System.Collections.IEqualityComparer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Hashtable" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>기본 초기 용량, 로드 비율, 해시 코드 공급자 및 비교자를 사용하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다. 용량 자동으로 증가 해야 하는 경우.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <xref:System.Collections.Hashtable> 개체입니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 이 생성자는 o (1) 연산입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">새 <see cref="T:System.Collections.IDictionary" /> 개체로 복사할 <see cref="T:System.Collections.Hashtable" /> 개체입니다.</param>
        <summary>지정한 사전의 요소를 새 <see cref="T:System.Collections.Hashtable" /> 개체에 복사하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 새 인스턴스를 초기화합니다. 새 <see cref="T:System.Collections.Hashtable" /> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 기본 로드 비율, 해시 코드 공급자 및 비교자를 사용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <xref:System.Collections.Hashtable> 개체입니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 새 요소의 <xref:System.Collections.Hashtable> 정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary> 개체입니다.  
  
 이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" /> 개체와 함께 사용할 해시 코드 공급자와 비교자를 정의하는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.  
  
 또는  
  
 기본 해시 코드 공급자와 기본 비교자를 사용하면 <see langword="null" />입니다. 기본 해시 코드 공급자는 각 키의 <see cref="M:System.Object.GetHashCode" /> 구현이며 기본 비교자는 각 키의 <see cref="M:System.Object.Equals(System.Object)" /> 구현입니다.</param>
        <summary>기본 초기 용량 및 로드 비율과 지정된 <see cref="T:System.Collections.Hashtable" /> 개체를 사용하여 <see cref="T:System.Collections.IEqualityComparer" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다. 용량 자동으로 증가 해야 하는 경우.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 <xref:System.Collections.IEqualityComparer> 해시 코드 공급자와 비교자 개체를 포함 합니다. 경우는 <xref:System.Collections.IEqualityComparer> 에 사용 되는 <xref:System.Collections.Hashtable> 생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable> 개체는 재정의 하지 않아도 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 및 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>합니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 <xref:System.Collections.IEqualityComparer> 조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.  
  
 이 생성자는 o (1) 연산입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Hashtable" /> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</param>
        <summary>지정된 초기 용량과 기본 로드 비율, 해시 코드 공급자 및 비교자를 사용하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable> 개체입니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>합니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 이 생성자는는 O (`n`) 작업, 여기서 `n` 은 `capacity`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" />가 0보다 작은 경우</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="d">새 <see cref="T:System.Collections.IDictionary" /> 개체로 복사할 <see cref="T:System.Collections.Hashtable" /> 개체입니다.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" />과 함께 사용할 해시 코드 공급자와 비교자를 정의하는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.  
  
 또는  
  
 기본 해시 코드 공급자와 기본 비교자를 사용하면 <see langword="null" />입니다. 기본 해시 코드 공급자는 각 키의 <see cref="M:System.Object.GetHashCode" /> 구현이며 기본 비교자는 각 키의 <see cref="M:System.Object.Equals(System.Object)" /> 구현입니다.</param>
        <summary>지정된 사전의 요소를 새 <see cref="T:System.Collections.Hashtable" /> 개체에 복사하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 새 인스턴스를 초기화합니다. 새 <see cref="T:System.Collections.Hashtable" /> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 기본 로드 비율과 지정된 <see cref="T:System.Collections.IEqualityComparer" /> 개체를 사용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 <xref:System.Collections.IEqualityComparer> 해시 코드 공급자와 비교자 개체를 포함 합니다. 경우는 <xref:System.Collections.IEqualityComparer> 에 사용 되는 <xref:System.Collections.Hashtable> 생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable> 개체는 재정의 하지 않아도 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 및 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>합니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 <xref:System.Collections.IEqualityComparer> 조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.  
  
 새 요소의 <xref:System.Collections.Hashtable> 정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary> 개체입니다.  
  
 이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="d">새 <see cref="T:System.Collections.IDictionary" /> 개체로 복사할 <see cref="T:System.Collections.Hashtable" /> 개체입니다.</param>
        <param name="loadFactor">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다. 결과는 버킷과 요소의 최대 비율입니다.</param>
        <summary>지정한 사전의 요소를 새 <see cref="T:System.Collections.Hashtable" /> 개체에 복사하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 새 인스턴스를 초기화합니다. 새 <see cref="T:System.Collections.Hashtable" /> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 지정된 로드 비율과 기본 해시 코드 공급자 및 비교자를 사용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <xref:System.Collections.Hashtable> 개체입니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 새 요소의 <xref:System.Collections.Hashtable> 정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary> 개체입니다.  
  
 이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" />가 0.1보다 작습니다.  
  
 또는  
  
 <paramref name="loadFactor" />가 1.0보다 큽니다.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" /> 개체의 모든 키에 대한 해시 코드를 제공하는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.  
  
 또는  
  
 각 키의 <see cref="M:System.Object.GetHashCode" /> 구현인 기본 해시 코드 공급자를 사용하면 <see langword="null" />입니다.</param>
        <param name="comparer">두 키가 같은지 여부를 확인하는 데 사용할 <see cref="T:System.Collections.IComparer" /> 개체입니다.  
  
 또는  
  
 각 키로 <see cref="M:System.Object.Equals(System.Object)" />를 구현한 기본 비교자를 사용하면 <see langword="null" />입니다.</param>
        <summary>기본 초기 용량 및 로드 비율과 지정된 해시 코드 공급자 및 비교자를 사용하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다. 용량 자동으로 증가 해야 하는 경우.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <xref:System.Collections.Hashtable> 개체입니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.  
  
 이 생성자는 o (1) 연산입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Hashtable" /> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" />과 함께 사용할 해시 코드 공급자와 비교자를 정의하는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.  
  
 또는  
  
 기본 해시 코드 공급자와 기본 비교자를 사용하면 <see langword="null" />입니다. 기본 해시 코드 공급자는 각 키의 <see cref="M:System.Object.GetHashCode" /> 구현이며 기본 비교자는 각 키의 <see cref="M:System.Object.Equals(System.Object)" /> 구현입니다.</param>
        <summary>지정된 초기 용량 및 <see cref="T:System.Collections.Hashtable" />와 기본 로드 비율을 사용하여 <see cref="T:System.Collections.IEqualityComparer" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable> 개체입니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 <xref:System.Collections.IEqualityComparer> 해시 코드 공급자와 비교자 개체를 포함 합니다. 경우는 <xref:System.Collections.IEqualityComparer> 에 사용 되는 <xref:System.Collections.Hashtable> 생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable> 재정의 하지 않아도 되는 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 및 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>합니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 <xref:System.Collections.IEqualityComparer> 조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.  
  
 이 생성자는는 O (`n`) 작업, 여기서 `n` 는 `capacity` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" />가 0보다 작은 경우</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Hashtable" /> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</param>
        <param name="loadFactor">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다. 결과는 버킷과 요소의 최대 비율입니다.</param>
        <summary>지정된 초기 용량 및 로드 비율과 기본 해시 코드 공급자 및 비교자를 사용하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable> 개체입니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>합니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 이 생성자는는 O (`n`) 작업, 여기서 `n` 는 `capacity` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" />가 0보다 작은 경우  
  
 또는  
  
 <paramref name="loadFactor" />가 0.1보다 작습니다.  
  
 또는  
  
 <paramref name="loadFactor" />가 1.0보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="capacity" />가 오버플로를 일으킬 수 있습니다.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Hashtable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체를 serialize하는 데 필요한 정보가 들어 있는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />와 연결된 serialize된 스트림의 소스와 대상이 포함된 <see cref="T:System.Collections.Hashtable" />개체입니다.</param>
        <summary>지정된 <see cref="T:System.Collections.Hashtable" /> 및 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체를 사용하여 serialize할 수 있는 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 해시 테이블의 용량은 최적의 로드 비율에 따라 해시 테이블 버킷 수를 계산 하는 데 사용 됩니다. 용량 자동으로 증가 해야 하는 경우.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <xref:System.Collections.Hashtable> 개체입니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 이 생성자는는 O (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>합니다.  
  
 직렬화 및 역직렬화에 대 한 열거자 때문에 <xref:System.Collections.Hashtable> 열거형 호출 하지 않고 계속 하려면 수 없으면, 다시 정렬 될 요소를 발생할 수 있습니다는 <xref:System.Collections.IEnumerator.Reset%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">새 <see cref="T:System.Collections.IDictionary" /> 개체로 복사할 <see cref="T:System.Collections.Hashtable" /> 개체입니다.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" />의 모든 키에 해시 코드를 제공하는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.  
  
 또는  
  
 각 키의 <see cref="M:System.Object.GetHashCode" /> 구현인 기본 해시 코드 공급자를 사용하면 <see langword="null" />입니다.</param>
        <param name="comparer">두 키가 같은지 여부를 확인하는 데 사용할 <see cref="T:System.Collections.IComparer" /> 개체입니다.  
  
 또는  
  
 각 키로 <see cref="M:System.Object.Equals(System.Object)" />를 구현한 기본 비교자를 사용하면 <see langword="null" />입니다.</param>
        <summary>지정한 사전의 요소를 새 <see cref="T:System.Collections.Hashtable" /> 개체에 복사하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 새 인스턴스를 초기화합니다. 새 <see cref="T:System.Collections.Hashtable" /> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 기본 로드 비율과 지정된 해시 코드 공급자 및 비교자를 사용합니다. 이 API는 더 이상 사용되지 않습니다. 다른 방법을 보려면 <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />를 참조하십시오.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <xref:System.Collections.Hashtable> 개체입니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.  
  
 새 요소의 <xref:System.Collections.Hashtable> 정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary> 개체입니다.  
  
 이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="d">새 <see cref="T:System.Collections.IDictionary" /> 개체로 복사할 <see cref="T:System.Collections.Hashtable" /> 개체입니다.</param>
        <param name="loadFactor">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다. 결과는 버킷과 요소의 최대 비율입니다.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" />과 함께 사용할 해시 코드 공급자와 비교자를 정의하는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.  
  
 또는  
  
 기본 해시 코드 공급자와 기본 비교자를 사용하면 <see langword="null" />입니다. 기본 해시 코드 공급자는 각 키의 <see cref="M:System.Object.GetHashCode" /> 구현이며 기본 비교자는 각 키의 <see cref="M:System.Object.Equals(System.Object)" /> 구현입니다.</param>
        <summary>지정한 사전의 요소를 새 <see cref="T:System.Collections.Hashtable" /> 개체에 복사하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 새 인스턴스를 초기화합니다. 새 <see cref="T:System.Collections.Hashtable" /> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 지정된 로드 비율 및 <see cref="T:System.Collections.IEqualityComparer" /> 개체를 사용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 <xref:System.Collections.IEqualityComparer> 해시 코드 공급자와 비교자 개체를 포함 합니다. 경우는 <xref:System.Collections.IEqualityComparer> 에 사용 되는 <xref:System.Collections.Hashtable> 생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable> 개체는 재정의 하지 않아도 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 및 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>합니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 <xref:System.Collections.IEqualityComparer> 조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.  
  
 새 요소의 <xref:System.Collections.Hashtable> 정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary> 개체입니다.  
  
 이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" />가 0.1보다 작습니다.  
  
 또는  
  
 <paramref name="loadFactor" />가 1.0보다 큽니다.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(int, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Hashtable" /> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" />의 모든 키에 해시 코드를 제공하는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.  
  
 또는  
  
 각 키의 <see cref="M:System.Object.GetHashCode" /> 구현인 기본 해시 코드 공급자를 사용하면 <see langword="null" />입니다.</param>
        <param name="comparer">두 키가 같은지 여부를 확인하는 데 사용할 <see cref="T:System.Collections.IComparer" /> 개체입니다.  
  
 또는  
  
 각 키로 <see cref="M:System.Object.Equals(System.Object)" />를 구현한 기본 비교자를 사용하면 <see langword="null" />입니다.</param>
        <summary>지정된 초기 용량, 해시 코드 공급자 및 비교자와 기본 로드 비율을 사용하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable> 개체입니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>합니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.  
  
 이 생성자는는 O (`n`) 작업, 여기서 `n` 는 `capacity` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" />가 0보다 작은 경우</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Hashtable" /> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</param>
        <param name="loadFactor">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다. 결과는 버킷과 요소의 최대 비율입니다.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" />과 함께 사용할 해시 코드 공급자와 비교자를 정의하는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.  
  
 또는  
  
 기본 해시 코드 공급자와 기본 비교자를 사용하면 <see langword="null" />입니다. 기본 해시 코드 공급자는 각 키의 <see cref="M:System.Object.GetHashCode" /> 구현이며 기본 비교자는 각 키의 <see cref="M:System.Object.Equals(System.Object)" /> 구현입니다.</param>
        <summary>지정된 초기 용량, 로드 비율 및 <see cref="T:System.Collections.Hashtable" /> 개체를 사용하여 <see cref="T:System.Collections.IEqualityComparer" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable> 개체입니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 <xref:System.Collections.IEqualityComparer> 해시 코드 공급자와 비교자 개체를 포함 합니다. 경우는 <xref:System.Collections.IEqualityComparer> 에 사용 되는 <xref:System.Collections.Hashtable> 생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable> 재정의 하지 않아도 되는 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 및 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>합니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 <xref:System.Collections.IEqualityComparer> 조회 대/소문자 구분 문자열 등의 시나리오를 사용 합니다.  
  
 이 생성자는는 O (`n`) 작업, 여기서 `n` 는 `capacity` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" />가 0보다 작은 경우  
  
 또는  
  
 <paramref name="loadFactor" />가 0.1보다 작습니다.  
  
 또는  
  
 <paramref name="loadFactor" />가 1.0보다 큽니다.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">새 <see cref="T:System.Collections.IDictionary" /> 개체로 복사할 <see cref="T:System.Collections.Hashtable" /> 개체입니다.</param>
        <param name="loadFactor">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다. 결과는 버킷과 요소의 최대 비율입니다.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" />의 모든 키에 해시 코드를 제공하는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.  
  
 또는  
  
 각 키의 <see cref="M:System.Object.GetHashCode" /> 구현인 기본 해시 코드 공급자를 사용하면 <see langword="null" />입니다.</param>
        <param name="comparer">두 키가 같은지 여부를 확인하는 데 사용할 <see cref="T:System.Collections.IComparer" /> 개체입니다.  
  
 또는  
  
 각 키로 <see cref="M:System.Object.Equals(System.Object)" />를 구현한 기본 비교자를 사용하면 <see langword="null" />입니다.</param>
        <summary>지정한 사전의 요소를 새 <see cref="T:System.Collections.Hashtable" /> 개체에 복사하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 새 인스턴스를 초기화합니다. 새 <see cref="T:System.Collections.Hashtable" /> 개체는 복사된 요소 수와 같은 초기 용량을 갖고 있고 지정된 로드 비율, 해시 코드 공급자 및 비교자를 사용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량 원본 사전의 요소 수로 설정 됩니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자의 <xref:System.Collections.Hashtable> 개체입니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.  
  
 새 요소의 <xref:System.Collections.Hashtable> 정렬 되는 열거자를 통해 반복 하는 순서는 <xref:System.Collections.IDictionary> 개체입니다.  
  
 이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `d` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" />가 0.1보다 작습니다.  
  
 또는  
  
 <paramref name="loadFactor" />가 1.0보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(int, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Hashtable" /> 개체가 처음에 포함할 수 있는 대략적인 요소 수입니다.</param>
        <param name="loadFactor">최고의 성능을 제공하는 기본값으로 곱한 0.1에서 1.0 사이의 수입니다. 결과는 버킷과 요소의 최대 비율입니다.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" />의 모든 키에 해시 코드를 제공하는 <see cref="T:System.Collections.Hashtable" /> 개체입니다.  
  
 또는  
  
 각 키의 <see cref="M:System.Object.GetHashCode" /> 구현인 기본 해시 코드 공급자를 사용하면 <see langword="null" />입니다.</param>
        <param name="comparer">두 키가 같은지 여부를 확인하는 데 사용할 <see cref="T:System.Collections.IComparer" /> 개체입니다.  
  
 또는  
  
 각 키로 <see cref="M:System.Object.Equals(System.Object)" />를 구현한 기본 비교자를 사용하면 <see langword="null" />입니다.</param>
        <summary>지정된 초기 용량, 로드 비율, 해시 코드 공급자 및 비교자를 사용하여 <see cref="T:System.Collections.Hashtable" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행 된 <xref:System.Collections.Hashtable> 개체입니다. 용량이 자동으로 로드 비율에 따라 필요에 따라 증가 합니다.  
  
 로드 비율은 버킷과 요소의 최대 비율입니다. 더 작은 로드 비율이 증가 한 메모리 소비 하더라도 빠른 조회를 의미합니다. 1.0의 로드 비율은 속도와 크기 적절 합니다.  
  
 실제 로드 비율이 지정된 된 로드 비율에 도달 하면 현재 버킷 수가 두 번 보다 큰 가장 작은 소수로 버킷 수가 자동으로 증가 합니다.  
  
 키에 대 한 해시 코드를 분배 하는 해시 코드 공급자는 <xref:System.Collections.Hashtable>합니다. 기본 해시 코드 공급자 키의의 구현인 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 비교자 두 키가 같은지 여부를 결정 합니다. 모든 키에는 <xref:System.Collections.Hashtable> 고유 해야 합니다. 기본 비교자는 키의 구현의 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 사용자 지정 해시 코드 공급자와 사용자 지정 비교자는 대/소문자 구분 문자열 조회 같은 시나리오를 지원 합니다.  
  
 이 생성자는는 O (`n`) 작업, 여기서 `n` 는 `capacity` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 해시 테이블을 다른 <xref:System.Collections.Hashtable> 생성자에 같은 요소가 각각 포함 하는 경우에의 해시 테이블의 동작 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" />가 0보다 작은 경우  
  
 또는  
  
 <paramref name="loadFactor" />가 0.1보다 작습니다.  
  
 또는  
  
 <paramref name="loadFactor" />가 1.0보다 큽니다.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">추가할 요소의 키입니다.</param>
        <param name="value">추가할 요소의 값입니다. 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>지정한 키와 값을 가지는 요소를 <see cref="T:System.Collections.Hashtable" />에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 키 일 수 없습니다 `null`, 하지만 값이 될 수 있습니다.  
  
 개체의 상태와 해시 코드 값 간에 상관 관계가 있는 일반적으로 쓰일 수 없습니다 키로 합니다. 예를 들어 문자열 개체는 키로 사용 하기 위해 StringBuilder 개체 보다 더 나은입니다.  
  
 사용할 수도 있습니다는 <xref:System.Collections.Hashtable.Item%2A> 에 속성 키의 값을 설정 하 여 새 요소를 추가할 수 없습니다.는 <xref:System.Collections.Hashtable>등 `myCollection["myNonexistentKey"] = myValue`합니다. 그러나 지정된 된 키에 이미 있는 경우는 <xref:System.Collections.Hashtable>설정는 <xref:System.Collections.Hashtable.Item%2A> 속성 이전 값을 덮어씁니다. 반면,는 <xref:System.Collections.Hashtable.Add%2A> 메서드는 기존 요소를 수정 하지 않습니다.  
  
 경우 <xref:System.Collections.Hashtable.Count%2A> 의 용량 보다 작은 <xref:System.Collections.Hashtable>,이 메서드는 o (1) 작업입니다. 이 메서드는 O 됩니다 용량을 새 요소로 적용로 늘려야 하는 경우 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 요소를 추가 하는 방법을 보여 줍니다.는 <xref:System.Collections.Hashtable>합니다.  
  
 [!code-cpp[Classic Hashtable.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">같은 키를 가진 요소가 이미 <see cref="T:System.Collections.Hashtable" />에 있는 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" />이 읽기 전용인 경우  
  
 또는  
  
 <see cref="T:System.Collections.Hashtable" />가 고정 크기입니다.</exception>
        <altmember cref="M:System.Collections.Hashtable.Remove(System.Object)" />
        <altmember cref="P:System.Collections.Hashtable.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Hashtable" />에서 모든 요소를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Count%2A> 가 0으로 설정 하 고 컬렉션의 요소에 다른 개체에 대 한 참조도 해제 됩니다. 용량 변경 되지 않습니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>합니다.  
  
   
  
## Examples  
 값을 지우는 방법을 보여 주는 다음 예제는 <xref:System.Collections.Hashtable>합니다.  
  
 [!code-cpp[Classic Hashtable.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" />이 읽기 전용인 경우</exception>
        <altmember cref="M:System.Collections.IDictionary.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Hashtable" />의 부분 복사본을 만듭니다.</summary>
        <returns>
          <see cref="T:System.Collections.Hashtable" />의 부분 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션의 단순 복사본은 참조 형식 또는 값 형식 참조에서 참조 하는 개체를 복사 하지 않습니다 여부는 컬렉션의 요소에만 복사 합니다. 새 컬렉션에 대 한 참조는 원본 컬렉션에 대 한 참조를 가리키는 동일한 개체를 가리킵니다.  
  
 반면, 요소를 복사 하는 컬렉션의 전체 복사본 및 뿐만 아니라 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목입니다.  
  
 <xref:System.Collections.Hashtable> 복사본은과 수, 용량, 동일한 <xref:System.Collections.IHashCodeProvider> 구현 및 동일한 <xref:System.Collections.IComparer> 원래 구현 <xref:System.Collections.Hashtable>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="comparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IComparer comparer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.comparer" />
      <MemberSignature Language="VB.NET" Value="Protected Property comparer As IComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IComparer ^ comparer { System::Collections::IComparer ^ get(); void set(System::Collections::IComparer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use KeyComparer properties.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.IComparer" />에 사용할 <see cref="T:System.Collections.Hashtable" />를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Collections.IComparer" />에 사용할 <see cref="T:System.Collections.Hashtable" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">속성이 값으로 설정되었지만 <see cref="T:System.Collections.IEqualityComparer" />를 사용하여 해시 테이블을 만든 경우</exception>
        <altmember cref="T:System.Collections.IComparer" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Collections.Hashtable" />에서 찾을 수 있는 키입니다.</param>
        <summary>
          <see cref="T:System.Collections.Hashtable" />에 특정 키가 들어 있는지 여부를 확인합니다.</summary>
        <returns>
          <see langword="true" />에 지정한 키가 있는 요소가 포함되어 있으면 <see cref="T:System.Collections.Hashtable" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Contains%2A>는 <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>를 구현합니다. 와 동일 하 게 작동 <xref:System.Collections.Hashtable.ContainsKey%2A>합니다.  
  
 이 메서드는 o (1) 작업.  
  
 컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 에 대 한 메서드 `item` 항목이 있는지 여부를 확인 합니다. .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 확인 하는 방법을 보여 줍니다. 여부는 <xref:System.Collections.Hashtable> 특정 요소를 포함 합니다.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Collections.Hashtable" />에서 찾을 수 있는 키입니다.</param>
        <summary>
          <see cref="T:System.Collections.Hashtable" />에 특정 키가 들어 있는지 여부를 확인합니다.</summary>
        <returns>
          <see langword="true" />에 지정한 키가 있는 요소가 포함되어 있으면 <see cref="T:System.Collections.Hashtable" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는과 동일 하 게 동작 <xref:System.Collections.Hashtable.Contains%2A>합니다.  
  
 이 메서드는 o (1) 작업.  
  
 컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 에 대 한 메서드 `item` 항목이 있는지 여부를 확인 합니다. .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 확인 하는 방법을 보여 줍니다. 여부는 <xref:System.Collections.Hashtable> 특정 요소를 포함 합니다.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Collections.Hashtable.Contains(System.Object)" />
        <altmember cref="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Collections.Hashtable" />에서 찾을 값입니다. 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>
          <see cref="T:System.Collections.Hashtable" />에 특정 값이 들어 있는지 여부를 확인합니다.</summary>
        <returns>
          지정된 <see langword="true" />을 가진 요소가 <see cref="T:System.Collections.Hashtable" />에 포함되어 있으면 <paramref name="value" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소는 <xref:System.Collections.Hashtable> 사용 하 여 지정 된 값이 비교는 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>합니다.  
  
 컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 에 대 한 메서드 `item` 항목이 있는지 여부를 확인 합니다. .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 확인 하는 방법을 보여 줍니다. 여부는 <xref:System.Collections.Hashtable> 특정 요소를 포함 합니다.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" />에서 복사한 <see cref="T:System.Collections.DictionaryEntry" /> 개체의 대상인 1차원 <see cref="T:System.Collections.Hashtable" /> 배열입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex">
          <c>배열</c>에서 복사를 시작할 인덱스입니다. 이 인덱스는 0부터 시작합니다.</param>
        <summary>
          <see cref="T:System.Collections.Hashtable" /> 요소를 지정한 인덱스의 1차원 <see cref="T:System.Array" /> 인스턴스에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소가 복사 되는 <xref:System.Array> 열거자가 반복는 동일한 순서로 <xref:System.Collections.Hashtable>합니다.  
  
 에 있는 키를 복사 하는 <xref:System.Collections.Hashtable>를 사용 하 여 `Hashtable.Keys.CopyTo`합니다.  
  
 값만 복사 하는 <xref:System.Collections.Hashtable>를 사용 하 여 `Hashtable.Values.CopyTo`합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 키의 목록 또는 목록에 있는 값의 복사 하는 방법을 보여 줍니다는 <xref:System.Collections.Hashtable> 로 <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />가 다차원 배열인 경우  
  
 또는  
  
 소스 <see cref="T:System.Collections.Hashtable" />의 요소 수가 대상 <paramref name="array" />의 <paramref name="arrayIndex" />부터 끝까지 사용 가능한 공간보다 큽니다.</exception>
        <exception cref="T:System.InvalidCastException">소스 <see cref="T:System.Collections.Hashtable" />의 형식을 대상 <paramref name="array" />의 형식으로 자동 캐스팅할 수 없습니다.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.Hashtable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Hashtable" />에 포함된 키/값 쌍의 수를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.Hashtable" />에 포함된 키/값 쌍의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property EqualityComparer As IEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IEqualityComparer ^ EqualityComparer { System::Collections::IEqualityComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.IEqualityComparer" />에 사용할 <see cref="T:System.Collections.Hashtable" />를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.IEqualityComparer" />에 사용할 <see cref="T:System.Collections.Hashtable" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.IEqualityComparer> 비교자 및 해시 코드 공급자를 모두 포함 합니다. 경우는 <xref:System.Collections.IEqualityComparer> 에 사용 되는 <xref:System.Collections.Hashtable> 생성자에서 키로 사용 되는 개체는 <xref:System.Collections.Hashtable> 재정의 하지 않아도 되는 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 및 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">속성이 값으로 설정되었지만 <see cref="T:System.Collections.IHashCodeProvider" /> 및 <see cref="T:System.Collections.IComparer" />를 사용하여 해시 테이블을 만든 경우</exception>
        <altmember cref="T:System.Collections.Comparer" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IDictionaryEnumerator" />를 반복하는 <see cref="T:System.Collections.Hashtable" />를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" />에 대한 <see cref="T:System.Collections.Hashtable" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 @FSHO1@C# 언어의 `foreach` 문(Visual Basic의 경우 `for each`)은 열거자의 복잡성을 숨깁니다.  그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다.  이 위치에서 <xref:System.Collections.IEnumerator.Current%2A>는 정의되지 않습니다. 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A>의 값을 읽기 전에 <xref:System.Collections.IEnumerator.Current%2A>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.  
  
 <xref:System.Collections.IEnumerator.Current%2A>에서는 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A>이 호출될 때까지 동일한 개체를 반환합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.IEnumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 독점적으로 액세스할 수 있는 권한이 없으므로 컬렉션을 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 이 메서드는 o (1) 작업.  
  
 직렬화 및 역직렬화에 대 한 열거자 때문에 <xref:System.Collections.Hashtable> 열거형 호출 하지 않고 계속 하려면 수 없으면, 다시 정렬 될 요소를 발생할 수 있습니다는 <xref:System.Collections.IEnumerator.Reset%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 비교 <xref:System.Collections.Hashtable.GetEnumerator%2A> 및 `foreach` 의 내용을 열거 하는 <xref:System.Collections.Hashtable>합니다.  
  
 [!code-cpp[Classic Hashtable Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Hashtable Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable Example/CS/source2.cs#2)]
 [!code-vb[Classic Hashtable Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetHash">
      <MemberSignature Language="C#" Value="protected virtual int GetHash (object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 GetHash(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetHash(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetHash (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int GetHash(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">해시 코드가 반환될 <see cref="T:System.Object" />입니다.</param>
        <summary>지정한 키의 해시 코드를 반환합니다.</summary>
        <returns>
          <paramref name="key" />의 해시 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 특정 해시 테이블을 만든 경우 <xref:System.Collections.IHashCodeProvider> 구현에서이 메서드는 해당 해시 코드 공급자를 사용 합니다; 하 고 사용은 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 구현의 `key`합니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="key" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" />를 serialize하는 데 필요한 정보가 포함된 <see cref="T:System.Collections.Hashtable" /> 개체입니다.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />와 연결된 serialize된 스트림의 소스와 대상이 포함된 <see cref="T:System.Collections.Hashtable" />개체입니다.</param>
        <summary>
          <see cref="T:System.Runtime.Serialization.ISerializable" /> 인터페이스를 구현하고 <see cref="T:System.Collections.Hashtable" />을 serialize하는 데 필요한 데이터를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">컬렉션이 수정되었습니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="hcp">
      <MemberSignature Language="C#" Value="protected System.Collections.IHashCodeProvider hcp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IHashCodeProvider hcp" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.hcp" />
      <MemberSignature Language="VB.NET" Value="Protected Property hcp As IHashCodeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IHashCodeProvider ^ hcp { System::Collections::IHashCodeProvider ^ get(); void set(System::Collections::IHashCodeProvider ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use EqualityComparer property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IHashCodeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해시 코드를 분배할 수 있는 개체를 가져오거나 설정합니다.</summary>
        <value>해시 코드를 분배할 수 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">속성이 값으로 설정되었지만 <see cref="T:System.Collections.IEqualityComparer" />를 사용하여 해시 테이블을 만든 경우</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Hashtable" />의 크기가 고정되어 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />의 크기가 고정되어 있으면 <see cref="T:System.Collections.Hashtable" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 크기가 고정된 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가하거나 제거할 수 없지만 기존 요소는 수정할 수 있습니다.  
  
 크기가 고정된 된 컬렉션은 요소; 추가 및 제거를 방지 하는 래퍼가 지정 된 컬렉션 따라서를 추가 하거나 제거할 요소를 포함 하 여 내부 컬렉션을 변경 하는 경우 고정 크기 컬렉션에 해당 변경 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Hashtable" />가 읽기 전용인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />가 읽기 전용이면 <see cref="T:System.Collections.Hashtable" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 읽기 전용 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가, 제거 또는 수정할 수 없습니다.  
  
 읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 될 경우 읽기 전용 컬렉션 해당 변경 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Hashtable" />에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되면 <see cref="T:System.Collections.Hashtable" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Collections.Hashtable> 동시 지원할 수 있습니다 하나 기록기 및 다중 판독기입니다. 반환 되는 래퍼를 통해 수행 해야 모든 작업을 지원 하기 위해 여러 작성기는 <xref:System.Collections.Hashtable.Synchronized%2A> 메서드.  
  
 컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.Hashtable.SyncRoot%2A> 열거 하는 동안:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
   
  
## Examples  
 동기화 하는 방법을 보여 주는 다음 예제는 <xref:System.Collections.Hashtable>를 결정 하는 경우는 <xref:System.Collections.Hashtable> 동기화 되 고 동기화를 사용 하 여 <xref:System.Collections.Hashtable>합니다.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">가져오거나 설정할 값이 있는 키입니다.</param>
        <summary>지정된 키에 연결된 값을 가져오거나 설정합니다.</summary>
        <value>지정한 키와 연결된 값입니다. 지정한 키가 없는 경우 해당 키를 가져오려고 시도하면 <see langword="null" />이 반환되고 해당 키를 설정하려고 시도하면 지정한 키를 사용하여 새 요소가 만들어집니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 `myCollection[key]` 구문을 사용하여 컬렉션의 특정 요소에 액세스하는 기능을 제공합니다.  
  
 사용할 수도 있습니다는 <xref:System.Collections.Hashtable.Item%2A> 에 속성 키의 값을 설정 하 여 새 요소를 추가할 수 없습니다.는 <xref:System.Collections.Hashtable>등 `myCollection["myNonexistentKey"] = myValue`합니다. 그러나 지정된 된 키에 이미 있는 경우는 <xref:System.Collections.Hashtable>설정는 <xref:System.Collections.Hashtable.Item%2A> 속성 이전 값을 덮어씁니다. 반면,는 <xref:System.Collections.Hashtable.Add%2A> 메서드는 기존 요소를 수정 하지 않습니다.  
  
 키 일 수 없습니다 `null`, 하지만 값이 될 수 있습니다. 구분 하기 위해 `null` 지정된 된 키를 찾을 수 없으므로 반환 되는 및 `null` 지정된 된 키의 값은 반환 되는 `null`를 사용 하 여는 <xref:System.Collections.Hashtable.Contains%2A> 메서드 또는 <xref:System.Collections.Hashtable.ContainsKey%2A> 여부를 확인 하는 메서드 키 목록에 있습니다.  
  
 이 속성의 값을 검색 하 하는 것은 o (1) 연산입니다. o (1) 작업 이기도 속성을 설정 합니다.  
  
 C# 언어의 키워드를 사용 하 여 구현 하는 대신 인덱서를 정의 하는 <xref:System.Collections.IList.Item%2A> 속성입니다. Visual Basic에서는 동일한 인덱싱 기능을 제공하는 <xref:System.Collections.Hashtable.Item%2A>을 기본 속성으로 구현합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">속성이 설정되어 있으며 <see cref="T:System.Collections.Hashtable" />가 읽기 전용인 경우  
  
 또는  
  
 속성이 설정되어 있고 <paramref name="key" />가 컬렉션에 없으며 <see cref="T:System.Collections.Hashtable" />의 크기가 고정된 경우</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="KeyEquals">
      <MemberSignature Language="C#" Value="protected virtual bool KeyEquals (object item, object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool KeyEquals(object item, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function KeyEquals (item As Object, key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool KeyEquals(System::Object ^ item, System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <c>키</c>와 비교할 <see cref="T:System.Object" />입니다.</param>
        <param name="key">
          <c>항목</c>과 비교할 <see cref="T:System.Collections.Hashtable" />의 키입니다.</param>
        <summary>특정 <see cref="T:System.Object" />를 <see cref="T:System.Collections.Hashtable" />의 특정 키와 비교합니다.</summary>
        <returns>
          <paramref name="item" />과 <paramref name="key" />가 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 특정 해시 테이블을 만든 경우 <xref:System.Collections.IComparer> 구현이이 메서드는 사용 되는 비교자; <xref:System.Collections.IComparer.Compare%2A> (`item`, `key`). 그렇지 않으면 사용 `item.Equals(key)`합니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="key" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" />의 키를 포함하는 <see cref="T:System.Collections.Hashtable" />을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" />의 키를 포함하는 <see cref="T:System.Collections.Hashtable" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 있는 키의 순서는 <xref:System.Collections.ICollection> 지정 되어 있지에 연결 된 값과 순서가 동일 하지만 <xref:System.Collections.ICollection> 에서 반환 되는 <xref:System.Collections.Hashtable.Values%2A> 메서드.  
  
 반환 된 <xref:System.Collections.ICollection> 정적 복사 하지 않습니다; 대신는 <xref:System.Collections.ICollection> 원래에서 키를 다시 참조할 <xref:System.Collections.Hashtable>합니다. 따라서 변경는 <xref:System.Collections.Hashtable> 계속에 반영 됩니다는 <xref:System.Collections.ICollection>합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Values" />
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">deserialization 이벤트의 소스입니다.</param>
        <summary>
          <see cref="T:System.Runtime.Serialization.ISerializable" /> 인터페이스를 구현하고, deserialization이 완료되면 deserialization 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Hashtable.Count%2A>합니다.  
  
 직렬화 및 역직렬화에 대 한 열거자 때문에 <xref:System.Collections.Hashtable> 열거형 호출 하지 않고 계속 하려면 수 없으면, 다시 정렬 될 요소를 발생할 수 있습니다는 <xref:System.Collections.IEnumerator.Reset%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">현재 <see cref="T:System.Runtime.Serialization.SerializationInfo" />과 관련된 <see cref="T:System.Collections.Hashtable" /> 개체가 잘못된 경우</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">제거할 요소의 키입니다.</param>
        <summary>
          <see cref="T:System.Collections.Hashtable" />에서 키가 지정된 요소를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Collections.Hashtable> 지정된 키를 가진 요소가 포함 되지 않습니다는 <xref:System.Collections.Hashtable> 그대로 유지 됩니다. 예외가 throw되지 않습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 예제에서 요소를 제거 하는 방법의 <xref:System.Collections.Hashtable>합니다.  
  
 [!code-cpp[Classic Hashtable.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" />이 읽기 전용인 경우  
  
 또는  
  
 <see cref="T:System.Collections.Hashtable" />가 고정 크기입니다.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Hashtable Synchronized(class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (table As Hashtable) As Hashtable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Hashtable ^ Synchronized(System::Collections::Hashtable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="table">동기화할 <see cref="T:System.Collections.Hashtable" />입니다.</param>
        <summary>
          <see cref="T:System.Collections.Hashtable" />에 대해 동기화되어 스레드로부터 안전하게 보호되는 래퍼를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Hashtable" />에 대해 동기화되어 스레드로부터 안전하게 보호되는 래퍼입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Synchronized%2A> 메서드는 스레드로부터 안전 하 게 여러 판독기와 작성기에 대 한 보호 합니다. 또한 동기화 된 래퍼 한 작성기만 한 번에 작성 되는지 확인 합니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.Hashtable.SyncRoot%2A> 열거 하는 동안:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 동기화 하는 방법을 보여 주는 다음 예제는 <xref:System.Collections.Hashtable>를 결정 하는 경우는 <xref:System.Collections.Hashtable> 동기화 되 고 동기화를 사용 하 여 <xref:System.Collections.Hashtable>합니다.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="table" />가 <see langword="null" />인 경우</exception>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Hashtable" />에 대한 액세스를 동기화하는 데 사용할 수 있는 개체를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.Hashtable" />에 대한 액세스를 동기화하는 데 사용할 수 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동기화 된 버전을 만들려면는 <xref:System.Collections.Hashtable>를 사용 하 여는 <xref:System.Collections.Hashtable.Synchronized%2A> 메서드. 하지만 파생된 클래스의 동기화 된 버전을 제공할 수 있습니다는 <xref:System.Collections.Hashtable> 를 사용 하는 <xref:System.Collections.Hashtable.SyncRoot%2A> 속성입니다. 동기화 하는 코드에서 작업을 수행 해야는 <xref:System.Collections.Hashtable.SyncRoot%2A> 의 <xref:System.Collections.Hashtable>에서 직접는 <xref:System.Collections.Hashtable> 합니다. 이렇게 하면 다른 개체에서 파생되는 컬렉션에 대해 적절한 작업이 수행됩니다. 특히, 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 관리는 <xref:System.Collections.Hashtable> 개체입니다.  
  
 컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.Hashtable.SyncRoot%2A> 열거 하는 동안:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
        <returns>컬렉션에서 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 @FSHO1@C# 언어의 `foreach` 문(Visual Basic의 경우 `for each`)은 열거자의 복잡성을 숨깁니다.  그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다. 이 위치에서, 호출 <xref:System.Collections.IEnumerator.Current%2A> 예외를 throw 합니다. 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A>의 값을 읽기 전에 <xref:System.Collections.IEnumerator.Current%2A>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.  
  
 <xref:System.Collections.IEnumerator.Current%2A>에서는 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A>이 호출될 때까지 동일한 개체를 반환합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`호출, <xref:System.Collections.IEnumerator.Current%2A> 예외를 throw 합니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 변경, 추가 하는 등 컬렉션을 수정 또는 삭제 요소에 열거자를 무효화 될 수 있습니다 및을 다음에 호출할 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A> throw는 <xref:System.InvalidOperationException>합니다. 사이 컬렉션이 수정 되는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 및 <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> 열거자가 이미 무효로 되 었 하는 경우에 설정 하는 요소를 반환 합니다.  
  
 열거자는 컬렉션에 독점적으로 액세스할 수 있는 권한이 없으므로 컬렉션을 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" />의 값이 들어 있는 <see cref="T:System.Collections.Hashtable" />을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" />의 값을 포함하는 <see cref="T:System.Collections.Hashtable" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 있는 값의 순서는 <xref:System.Collections.ICollection> 지정 되어 있지는 연결 된 키와 순서가 동일 하지만 <xref:System.Collections.ICollection> 에서 반환 되는 <xref:System.Collections.Hashtable.Keys%2A> 메서드.  
  
 반환 된 <xref:System.Collections.ICollection> 정적 복사 하지 않습니다; 대신는 <xref:System.Collections.ICollection> 원래에서 값을 다시 참조 <xref:System.Collections.Hashtable>합니다. 따라서 변경는 <xref:System.Collections.Hashtable> 계속에 반영 됩니다는 <xref:System.Collections.ICollection>합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>