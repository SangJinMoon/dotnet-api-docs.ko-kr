<Type Name="DictionaryBase" FullName="System.Collections.DictionaryBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="65985fb884fc3e9f8ea0e99a2fb18bb6607c9a63" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30370827" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class DictionaryBase : System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit DictionaryBase extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.DictionaryBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DictionaryBase&#xA;Implements IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class DictionaryBase abstract : System::Collections::IDictionary" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>강력한 형식의 키/값 쌍 컬렉션에 대한 <see langword="abstract" /> 기본 클래스를 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# 언어 (각각에 대해 Visual basic에서)의 컬렉션에 있는 요소 형식의 개체를 반환합니다. 이후의 각 요소는 <xref:System.Collections.DictionaryBase> 는 키/값 쌍 요소 형식이 키의 형식 또는 값의 형식입니다. 요소 형식이 대신 <xref:System.Collections.DictionaryEntry>합니다.  
  
 `foreach` 문에 열거자를 컬렉션에 쓰는 것부터 읽기 가능 주변 래퍼입니다.  
  
> [!NOTE]
>  키는 상속 될 수 때문에 동작을 변경할의 절대적인 고유성을 보장할 수 없습니다 사용한 비교는 <xref:System.Type.Equals%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 한 <xref:System.String.Length%2A> 5 자 이하로 합니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>공용 정적 (<see langword="Shared" /> Visual basic에서)이 형식의 멤버는 스레드로부터 안전 합니다. 인터페이스 멤버는 스레드로부터 안전하지 않습니다.  
  
 이 구현에 대 한 동기화 (스레드로부터 안전한 지) 래퍼를 제공 하지 않습니다는 <see cref="T:System.Collections.DictionaryBase" />, 파생 된 클래스의 동기화 된 고유 버전을 만들 수 있지만 <see cref="T:System.Collections.DictionaryBase" /> 를 사용 하는 <see cref="P:System.Collections.ICollection.SyncRoot" /> 속성입니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</threadsafe>
    <block subset="none" type="overrides">
      <para>이 기본 클래스는 쉽게 강력한 형식의 사용자 지정 컬렉션을 만들 수 있도록 제공 됩니다. 구현자는 직접 만드는 대신이 기본 클래스를 확장 하는 것이 좋습니다.  
  
 이 기본 클래스의 멤버 보호 되 고 파생된 클래스를 통해 사용 하기에 적합 합니다.</para>
    </block>
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="N:System.Collections.Generic" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DictionaryBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DictionaryBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 o (1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스의 콘텐츠를 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.DictionaryBase.Count%2A> 가 0으로 설정 하 고 컬렉션의 요소에 다른 개체에 대 한 참조도 해제 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.DictionaryBase.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> 인스턴스에서 복사된 <see cref="T:System.Collections.DictionaryEntry" /> 개체의 대상인 1차원 <see cref="T:System.Collections.DictionaryBase" />입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="index">
          <c>배열</c>에서 복사를 시작할 인덱스입니다. 이 인덱스는 0부터 시작합니다.</param>
        <summary>지정한 인덱스에서 1차원 <see cref="T:System.Collections.DictionaryBase" />에 <see cref="T:System.Array" /> 엔트리를 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소가 복사 되는 <xref:System.Array> 열거자가 반복는 동일한 순서로 <xref:System.Collections.DictionaryBase>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.DictionaryBase.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />가 다차원 배열인 경우  
  
 또는  
  
 소스 <see cref="T:System.Collections.DictionaryBase" />의 요소 수가 대상 <paramref name="array" />의 <paramref name="index" />부터 끝까지 사용 가능한 공간보다 큽니다.</exception>
        <exception cref="T:System.InvalidCastException">소스 <see cref="T:System.Collections.DictionaryBase" />의 형식을 대상 <paramref name="array" />의 형식으로 자동 캐스팅할 수 없습니다.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.DictionaryBase.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에 포함된 요소의 수를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에 포함된 요소의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Dictionary { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에 포함된 요소의 목록을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.IDictionary" /> 인스턴스 자체를 나타내는 <see cref="T:System.Collections.DictionaryBase" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 한 <xref:System.String.Length%2A> 5 자 이하로 합니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> 인스턴스를 반복하는 <see cref="T:System.Collections.DictionaryBase" />를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에 대한 <see cref="T:System.Collections.IDictionaryEnumerator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @FSHO1@C# 언어의 `foreach` 문(Visual Basic의 경우 `for each`)은 열거자의 복잡성을 숨깁니다.  그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다.  이 위치에서 <xref:System.Collections.IEnumerator.Current%2A>는 정의되지 않습니다. 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A>의 값을 읽기 전에 <xref:System.Collections.IEnumerator.Current%2A>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.  
  
 <xref:System.Collections.IEnumerator.Current%2A>에서는 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A>이 호출될 때까지 동일한 개체를 반환합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.IEnumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 한 <xref:System.String.Length%2A> 5 자 이하로 합니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="InnerHashtable">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable InnerHashtable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Hashtable InnerHashtable" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.InnerHashtable" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property InnerHashtable As Hashtable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Hashtable ^ InnerHashtable { System::Collections::Hashtable ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에 포함된 요소의 목록을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.Hashtable" /> 인스턴스 자체를 나타내는 <see cref="T:System.Collections.DictionaryBase" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClear">
      <MemberSignature Language="C#" Value="protected virtual void OnClear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnClear" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClear ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스의 내용을 지우기 전에 추가로 사용자 지정 프로세스를 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 기본 구현 컬렉션을 지울 전에 동작을 수행 하는 파생된 클래스에서 재정의 하는 데 사용 됩니다.  
  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 메서드의 기본 구현 하는 o (1) 작업입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드를 내부에서 모든 요소를 삭제 하기 전에 수행 해야 하는 프로세스를 정의 하는 데 사용 <see cref="T:System.Collections.Hashtable" />합니다. 이 메서드를 정의 하 여 구현자 기능을 추가할 수 상속 된 메서드를 다른 모든 메서드를 재정의 하지 않고 있습니다.  
  
 <see cref="M:System.Collections.DictionaryBase.OnClear" /> 표준 지우기 동작 전에 호출 되 고 <see cref="M:System.Collections.DictionaryBase.OnClearComplete" /> 표준 지우기 동작 후에 호출 됩니다.  
  
 예를 들어 구현자 삭제 작업으로 전역 Clear의에서 특정 요소를 제외할 수 있습니다.</para>
        </block>
        <altmember cref="M:System.Collections.DictionaryBase.OnClearComplete" />
        <altmember cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnClearComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnClearComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClearComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnClearComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClearComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClearComplete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스의 내용을 지운 후에 추가로 사용자 지정 프로세스를 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 기본 구현 컬렉션의 선택을 취소 한 후 작업을 수행할 수는 파생된 클래스에서 재정의 하는 데 사용 됩니다.  
  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 메서드의 기본 구현 하는 o (1) 작업입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드를 내부에서 모든 요소를 삭제 한 후 수행 해야 하는 프로세스를 정의 하는 데 사용 <see cref="T:System.Collections.Hashtable" />합니다. 이 메서드를 정의 하 여 구현자 기능을 추가할 수 상속 된 메서드를 다른 모든 메서드를 재정의 하지 않고 있습니다.  
  
 <see cref="M:System.Collections.DictionaryBase.OnClear" /> 표준 지우기 동작 전에 호출 되 고 <see cref="M:System.Collections.DictionaryBase.OnClearComplete" /> 표준 지우기 동작 후에 호출 됩니다.</para>
        </block>
        <altmember cref="M:System.Collections.DictionaryBase.OnClear" />
        <altmember cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnGet">
      <MemberSignature Language="C#" Value="protected virtual object OnGet (object key, object currentValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object OnGet(object key, object currentValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnGet(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnGet (key As Object, currentValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ OnGet(System::Object ^ key, System::Object ^ currentValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="currentValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">가져올 요소의 키입니다.</param>
        <param name="currentValue">
          <c>키</c>와 연관된 요소의 현재 값입니다.</param>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에서 지정한 키와 값이 있는 요소를 가져옵니다.</summary>
        <returns>지정된 키와 값의 요소를 포함하는 <see cref="T:System.Object" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 기본 구현에서는 반환 `currentValue`합니다. 것은 지정된 된 요소를 검색할 때 추가 동작을 수행 하려면 파생된 클래스에서 재정의 됩니다.  
  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 메서드의 기본 구현 하는 o (1) 작업입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드를 기본의 표준 동작을 실행할 때 수행 해야 하는 프로세스를 정의 하는 데 사용 <see cref="T:System.Collections.Hashtable" />합니다. 이 메서드를 정의 하 여 구현자 기능을 추가할 수 상속 된 메서드를 다른 모든 메서드를 재정의 하지 않고 있습니다.  
  
 <see cref="M:System.Collections.DictionaryBase.OnGet(System.Object,System.Object)" /> 내부에서 검색 한 값을 반환 하기 전에 수행할 프로세스를 지정 하는 데 사용할 수 <see cref="T:System.Collections.Hashtable" />합니다. 예를 들어 구현자 수 다른 형식으로 반환 하기 전에 값을 캐스팅 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInsert">
      <MemberSignature Language="C#" Value="protected virtual void OnInsert (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInsert(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInsert (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInsert(System::Object ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">삽입할 요소의 키입니다.</param>
        <param name="value">삽입할 요소의 값입니다.</param>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에 새 요소를 삽입하기 전에 추가로 사용자 지정 프로세스를 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 기본 구현 지정된 된 요소를 삽입 하기 전에 몇 가지 작업을 수행 하는 파생된 클래스에서 재정의 하는 데 사용 됩니다.  
  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 메서드의 기본 구현 하는 o (1) 작업입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 한 <xref:System.String.Length%2A> 5 자 이하로 합니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드를 내부에 요소를 삽입 하기 전에 수행 해야 하는 프로세스를 정의 하는 데 사용 <see cref="T:System.Collections.Hashtable" />합니다. 이 메서드를 정의 하 여 구현자 기능을 추가할 수 상속 된 메서드를 다른 모든 메서드를 재정의 하지 않고 있습니다.  
  
 <see cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" /> 표준 Insert 동작 전에 호출 되 고 <see cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" /> 표준 삽입 동작 후에 호출 됩니다.  
  
 예를 들어 구현자에 삽입할 수 있는 개체 형식을 제한할 수는 <see cref="T:System.Collections.Hashtable" />합니다.</para>
        </block>
        <altmember cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnInsertComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInsertComplete (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInsertComplete(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInsertComplete (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInsertComplete(System::Object ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">삽입할 요소의 키입니다.</param>
        <param name="value">삽입할 요소의 값입니다.</param>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에 새 요소를 삽입한 후에 추가로 사용자 지정 프로세스를 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 기본 구현 지정된 된 요소를 삽입 한 후 작업을 수행할 수는 파생된 클래스에서 재정의 하는 데 사용 됩니다.  
  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 메서드의 기본 구현 하는 o (1) 작업입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드를 내부에 요소를 삽입 한 후 수행 해야 하는 프로세스를 정의 하는 데 사용 <see cref="T:System.Collections.Hashtable" />합니다. 이 메서드를 정의 하 여 구현자 기능을 추가할 수 상속 된 메서드를 다른 모든 메서드를 재정의 하지 않고 있습니다.  
  
 <see cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" /> 표준 Insert 동작 전에 호출 되 고 <see cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" /> 표준 삽입 동작 후에 호출 됩니다.</para>
        </block>
        <altmember cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnRemove">
      <MemberSignature Language="C#" Value="protected virtual void OnRemove (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemove(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemove (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemove(System::Object ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">제거할 요소의 키입니다.</param>
        <param name="value">제거할 요소의 값입니다.</param>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에서 요소를 제거하기 전에 추가로 사용자 지정 프로세스를 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 기본 구현 지정된 된 요소를 제거 하기 전에 몇 가지 작업을 수행 하는 파생된 클래스에서 재정의 하는 데 사용 됩니다.  
  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 메서드의 기본 구현 하는 o (1) 작업입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 한 <xref:System.String.Length%2A> 5 자 이하로 합니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드를 내부에서 요소를 제거 하기 전에 수행 해야 하는 프로세스를 정의 하는 데 사용 <see cref="T:System.Collections.Hashtable" />합니다. 이 메서드를 정의 하 여 구현자 기능을 추가할 수 상속 된 메서드를 다른 모든 메서드를 재정의 하지 않고 있습니다.  
  
 <see cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" /> 표준 제거 동작 전에 호출 되 고 <see cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" /> 표준 제거 동작 후에 호출 됩니다.  
  
 구현자 항상 예외를 throw 하 여 요소의 제거를 방지할 수 예를 들어 <see cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />합니다.</para>
        </block>
        <altmember cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnClear" />
      </Docs>
    </Member>
    <Member MemberName="OnRemoveComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveComplete (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveComplete(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveComplete (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveComplete(System::Object ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">제거할 요소의 키입니다.</param>
        <param name="value">제거할 요소의 값입니다.</param>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에서 요소를 제거한 후에 추가로 사용자 지정 프로세스를 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 기본 구현 지정된 된 요소를 제거한 후 작업을 수행할 수는 파생된 클래스에서 재정의 하는 데 사용 됩니다.  
  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 메서드의 기본 구현 하는 o (1) 작업입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드를 내부에서 요소를 제거한 후 수행 해야 하는 프로세스를 정의 하는 데 사용 <see cref="T:System.Collections.Hashtable" />합니다. 이 메서드를 정의 하 여 구현자 기능을 추가할 수 상속 된 메서드를 다른 모든 메서드를 재정의 하지 않고 있습니다.  
  
 <see cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" /> 표준 제거 동작 전에 호출 되 고 <see cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" /> 표준 제거 동작 후에 호출 됩니다.</para>
        </block>
        <altmember cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnClearComplete" />
      </Docs>
    </Member>
    <Member MemberName="OnSet">
      <MemberSignature Language="C#" Value="protected virtual void OnSet (object key, object oldValue, object newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSet(object key, object oldValue, object newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSet (key As Object, oldValue As Object, newValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSet(System::Object ^ key, System::Object ^ oldValue, System::Object ^ newValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="oldValue" Type="System.Object" />
        <Parameter Name="newValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">찾을 요소의 키입니다.</param>
        <param name="oldValue">
          <c>키</c>와 연관된 요소의 이전 값입니다.</param>
        <param name="newValue">
          <c>키</c>와 연관된 요소의 새 값입니다.</param>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에 값을 설정하기 전에 추가로 사용자 지정 프로세스를 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 기본 구현 지정된 된 요소를 설정 하기 전에 몇 가지 작업을 수행 하는 파생된 클래스에서 재정의 하는 데 사용 됩니다.  
  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 메서드의 기본 구현 하는 o (1) 작업입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 한 <xref:System.String.Length%2A> 5 자 이하로 합니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드를 내부에 지정된 된 요소를 설정 하기 전에 수행 해야 하는 프로세스를 정의 하는 데 사용 <see cref="T:System.Collections.Hashtable" />합니다. 이 메서드를 정의 하 여 구현자 기능을 추가할 수 상속 된 메서드를 다른 모든 메서드를 재정의 하지 않고 있습니다.  
  
 <see cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" /> 표준 설정 동작 전에 호출 되 고 <see cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" /> 표준 설정 동작 후에 호출 됩니다.  
  
 예를 들어 내부에서 검사를 수행 하 여 어떤 값을 덮어쓸 수 구현자를 제한할 수 <see cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />합니다.</para>
        </block>
        <altmember cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnSetComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSetComplete (object key, object oldValue, object newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetComplete(object key, object oldValue, object newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetComplete (key As Object, oldValue As Object, newValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetComplete(System::Object ^ key, System::Object ^ oldValue, System::Object ^ newValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="oldValue" Type="System.Object" />
        <Parameter Name="newValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">찾을 요소의 키입니다.</param>
        <param name="oldValue">
          <c>키</c>와 연관된 요소의 이전 값입니다.</param>
        <param name="newValue">
          <c>키</c>와 연관된 요소의 새 값입니다.</param>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 인스턴스에 값을 설정한 후에 추가로 사용자 지정 프로세스를 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 기본 구현 지정한 요소를 설정한 후 작업을 수행할 수는 파생된 클래스에서 재정의 하는 데 사용 됩니다.  
  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 메서드의 기본 구현 하는 o (1) 작업입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드를 지정된 된 요소는 기본 설정 후에 수행 해야 하는 프로세스를 정의 하는 데 사용 <see cref="T:System.Collections.Hashtable" />합니다. 이 메서드를 정의 하 여 구현자 기능을 추가할 수 상속 된 메서드를 다른 모든 메서드를 재정의 하지 않고 있습니다.  
  
 <see cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" /> 표준 설정 동작 전에 호출 되 고 <see cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" /> 표준 설정 동작 후에 호출 됩니다.</para>
        </block>
        <altmember cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnValidate">
      <MemberSignature Language="C#" Value="protected virtual void OnValidate (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidate(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidate (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidate(System::Object ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">유효성을 검사할 요소의 키입니다.</param>
        <param name="value">유효성을 검사할 요소의 값입니다.</param>
        <summary>지정한 키와 값을 가지는 요소의 유효성을 검사할 때 추가로 사용자 지정 프로세스를 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 기본 구현 지정된 된 요소의 유효성을 검사할 때 특별 한 조치를 수행 하는 파생된 클래스에서 재정의 하는 데 사용 됩니다.  
  
 반환 된 인스턴스에만 On * 메서드가 호출 되는 <xref:System.Collections.DictionaryBase.Dictionary%2A> 속성에 의해 반환 되는 인스턴스는 없지만 <xref:System.Collections.DictionaryBase.InnerHashtable%2A> 속성.  
  
 이 메서드의 기본 구현 하는 o (1) 작업입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 한 <xref:System.String.Length%2A> 5 자 이하로 합니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드를 기본의 표준 동작을 실행할 때 수행 해야 하는 프로세스를 정의 하는 데 사용 <see cref="T:System.Collections.Hashtable" />합니다. 이 메서드를 정의 하 여 구현자 기능을 추가할 수 상속 된 메서드를 다른 모든 메서드를 재정의 하지 않고 있습니다.  
  
 <see cref="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" /> 용도 컬렉션에 허용 되는 개체의 형식 제한 합니다. 기본 구현은 방지 <see langword="null" /> 에 추가 또는 제거의 기본 <see cref="T:System.Collections.Hashtable" />합니다.</para>
        </block>
        <altmember cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 개체에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.DictionaryBase" /> 개체에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Collections.DictionaryBase> 개체 동기화 되지 않습니다. 파생된 클래스의 동기화 된 버전을 제공할 수 있습니다는 <xref:System.Collections.DictionaryBase> 클래스 사용은 <xref:System.Collections.ICollection.SyncRoot%2A> 속성입니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.ICollection.SyncRoot%2A> 열거 하는 동안 속성입니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/source2.cpp#3)]
 [!code-csharp[System.Collections.DictionaryBase#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/source2.cs#3)]
 [!code-vb[System.Collections.DictionaryBase#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/source2.vb#3)]  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 개체에 대한 액세스를 동기화하는 데 사용할 수 있는 개체를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.DictionaryBase" /> 개체에 대한 액세스를 동기화하는 데 사용할 수 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스의 동기화 된 버전을 제공할 수 있습니다는 <xref:System.Collections.DictionaryBase> 클래스 사용은 <xref:System.Collections.ICollection.SyncRoot%2A> 속성입니다. 동기화 하는 코드에서 작업을 수행 해야는 <xref:System.Collections.ICollection.SyncRoot%2A> 속성은 <xref:System.Collections.DictionaryBase> 개체에 대해 직접는 <xref:System.Collections.DictionaryBase> 개체입니다. 이렇게 하면 다른 개체에서 파생되는 컬렉션에 대해 적절한 작업이 수행됩니다. 특히, 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 관리는 <xref:System.Collections.DictionaryBase> 개체입니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.ICollection.SyncRoot%2A> 열거 하는 동안 속성입니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/source2.cpp#3)]
 [!code-csharp[System.Collections.DictionaryBase#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/source2.cs#3)]
 [!code-vb[System.Collections.DictionaryBase#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/source2.vb#3)]  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">추가할 요소의 키입니다.</param>
        <param name="value">추가할 요소의 값입니다.</param>
        <summary>지정한 키와 값을 가지는 요소를 <see cref="T:System.Collections.DictionaryBase" />에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 개체의 상태와 해시 코드 값 간에 상관 관계가 있는 일반적으로 쓰일 수 없습니다 키로 합니다. 예를 들어 <xref:System.String> 개체는 보다 나은 <xref:System.Text.StringBuilder> 키로 사용할 개체입니다.  
  
 사용할 수도 있습니다는 <xref:System.Collections.IDictionary.Item%2A> 에 속성 키의 값을 설정 하 여 새 요소를 추가할 수 없습니다.는 <xref:System.Collections.DictionaryBase>등 `myCollection["myNonexistentKey"] = myValue`합니다. 그러나 지정된 된 키에 이미 있는 경우는 <xref:System.Collections.DictionaryBase>설정는 <xref:System.Collections.IDictionary.Item%2A> 속성 이전 값을 덮어씁니다. 반면,는 <xref:System.Collections.IDictionary.Add%2A> 메서드는 기존 요소를 수정 하지 않습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 한 <xref:System.String.Length%2A> 5 자 이하로 합니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">같은 키를 가진 요소가 이미 <see cref="T:System.Collections.DictionaryBase" />에 있는 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.DictionaryBase" />이 읽기 전용인 경우  
  
 또는  
  
 <see cref="T:System.Collections.DictionaryBase" />가 고정 크기입니다.</exception>
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Collections.DictionaryBase" />에서 찾을 수 있는 키입니다.</param>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" />에 특정 키가 들어 있는지 여부를 확인합니다.</summary>
        <returns>
          <see langword="true" />에 지정한 키가 있는 요소가 포함되어 있으면 <see cref="T:System.Collections.DictionaryBase" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 o (1) 작업.  
  
 컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 에 대 한 메서드 `key` 확인 하려면 여부 `item` 존재 합니다. .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `key` 컬렉션의 개체에 대 한 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 한 <xref:System.String.Length%2A> 5 자 이하로 합니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 개체의 크기가 고정되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.DictionaryBase" /> 개체의 크기가 고정되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션 크기가 고정된 된 컬렉션 만들어지기는 하지만 기존 요소를 수정할 수는 다음에 추가 하거나 제거할 요소의 수 없습니다.  
  
 크기가 고정된 된 컬렉션은 요소; 추가 및 제거를 방지 하는 래퍼가 지정 된 컬렉션 따라서를 추가 하거나 제거할 요소를 포함 하 여 내부 컬렉션을 변경 하는 경우 고정 크기 컬렉션에 해당 변경 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" /> 개체가 읽기 전용인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.DictionaryBase" /> 개체가 읽기 전용이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 읽기 전용 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가, 제거 또는 수정할 수 없습니다.  
  
 읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 될 경우 읽기 전용 컬렉션 해당 변경 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IDictionary.Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">가져오거나 설정할 값이 있는 키입니다.</param>
        <summary>지정된 키에 연결된 값을 가져오거나 설정합니다.</summary>
        <value>지정한 키와 연결된 값입니다. 지정한 키가 없는 경우 해당 키를 가져오려고 시도하면 <see langword="null" />이 반환되고 해당 키를 설정하려고 시도하면 지정한 키를 사용하여 새 요소가 만들어집니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 `myCollection[key]` 구문을 사용하여 컬렉션의 특정 요소에 액세스하는 기능을 제공합니다.  
  
 사용할 수도 있습니다는 <xref:System.Collections.IDictionary.Item%2A> 에 속성 키의 값을 설정 하 여 새 요소를 추가할 수 없습니다.는 <xref:System.Collections.DictionaryBase>등 `myCollection["myNonexistentKey"] = myValue`합니다. 그러나 지정된 된 키에 이미 있는 경우는 <xref:System.Collections.DictionaryBase>설정는 <xref:System.Collections.IDictionary.Item%2A> 속성 이전 값을 덮어씁니다. 반면,는 <xref:System.Collections.IDictionary.Add%2A> 메서드는 기존 요소를 수정 하지 않습니다.  
  
 이 속성의 값을 검색 하 하는 것은 o (1) 연산입니다. o (1) 작업 이기도 속성을 설정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 한 <xref:System.String.Length%2A> 5 자 이하로 합니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">속성이 설정되어 있으며 <see cref="T:System.Collections.DictionaryBase" />가 읽기 전용인 경우  
  
 또는  
  
 속성이 설정되어 있고 <paramref name="key" />가 컬렉션에 없으며 <see cref="T:System.Collections.DictionaryBase" />의 크기가 고정된 경우</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System.Collections.IDictionary.Keys { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> 개체의 키가 포함된 <see cref="T:System.Collections.DictionaryBase" /> 개체를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> 개체의 키가 포함된 <see cref="T:System.Collections.DictionaryBase" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 있는 키의 순서는 <xref:System.Collections.ICollection> 개체가 지정 되어 있지만에 연결 된 값과 순서가 동일는 <xref:System.Collections.ICollection> 에서 반환 된 개체는 <xref:System.Collections.IDictionary.Values%2A> 속성입니다.  
  
 반환 된 <xref:System.Collections.ICollection> 정적 복사 하지 않습니다; 대신는 <xref:System.Collections.ICollection> 원래에서 키를 다시 참조할 <xref:System.Collections.DictionaryBase> 개체입니다. 따라서 변경는 <xref:System.Collections.DictionaryBase> 계속 반영 됩니다 반환 된 <xref:System.Collections.ICollection>합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 <xref:System.String.Length%2A> 5 자 이하로 속성입니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.IDictionary.Values" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">제거할 요소의 키입니다.</param>
        <summary>
          <see cref="T:System.Collections.DictionaryBase" />에서 키가 지정된 요소를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Collections.DictionaryBase> 지정된 키를 가진 요소가 포함 되지 않습니다는 <xref:System.Collections.DictionaryBase> 그대로 유지 됩니다. 예외가 throw되지 않습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 한 <xref:System.String.Length%2A> 5 자 이하로 합니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.DictionaryBase" />이 읽기 전용인 경우  
  
 또는  
  
 <see cref="T:System.Collections.DictionaryBase" />가 고정 크기입니다.</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System.Collections.IDictionary.Values { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> 개체의 값이 포함된 <see cref="T:System.Collections.DictionaryBase" /> 개체를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> 개체의 값이 포함된 <see cref="T:System.Collections.DictionaryBase" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 있는 값의 순서는 <xref:System.Collections.ICollection> 개체가 지정 되어 있지만에 연결 된 키와 순서가 동일는 <xref:System.Collections.ICollection> 에서 반환 된 개체는 <xref:System.Collections.IDictionary.Keys%2A> 속성입니다.  
  
 반환 된 <xref:System.Collections.ICollection> 정적 복사 하지 않습니다; 대신는 <xref:System.Collections.ICollection> 원래에서 값을 다시 참조 <xref:System.Collections.DictionaryBase> 개체입니다. 따라서 변경는 <xref:System.Collections.DictionaryBase> 계속 반영 됩니다 반환 된 <xref:System.Collections.ICollection>합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 <xref:System.Collections.DictionaryBase> 클래스 및 해당 구현을의 사전을 만드는 데 사용 하 여 <xref:System.String> 키와 값이 있는 <xref:System.String.Length%2A> 5 자 이하로 속성입니다.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.IDictionary.Keys" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IEnumerator" />를 반복하는 <see cref="T:System.Collections.DictionaryBase" />를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" />에 대한 <see cref="T:System.Collections.DictionaryBase" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @FSHO1@C# 언어의 `foreach` 문(Visual Basic의 경우 `for each`)은 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다. 이 위치에서, 호출 <xref:System.Collections.IEnumerator.Current%2A> 예외를 throw 합니다. 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A>의 값을 읽기 전에 <xref:System.Collections.IEnumerator.Current%2A>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.  
  
 <xref:System.Collections.IEnumerator.Current%2A>에서는 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A>이 호출될 때까지 동일한 개체를 반환합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`호출, <xref:System.Collections.IEnumerator.Current%2A> 예외를 throw 합니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 변경, 추가 하는 등 컬렉션을 수정 하거나 요소를 삭제 하면 열거자가 더 유효 하지 않으며을 다음에 호출할 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A> throw는 <xref:System.InvalidOperationException>합니다. 사이 컬렉션이 수정 되는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 및 <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> 열거자가 이미 무효로 되 었 하는 경우에 설정 하는 요소를 반환 합니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
  </Members>
</Type>