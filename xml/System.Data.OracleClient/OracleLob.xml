<Type Name="OracleLob" FullName="System.Data.OracleClient.OracleLob">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6be87030aa2b6ac0bc0096d828340ab9fc994868" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37676414" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OracleLob extends System.IO.Stream implements class System.Data.SqlTypes.INullable, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.OracleClient.OracleLob" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OracleLob&#xA;Inherits Stream&#xA;Implements ICloneable, INullable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OracleLob sealed : System::IO::Stream, ICloneable, System::Data::SqlTypes::INullable" />
  <TypeSignature Language="F#" Value="type OracleLob = class&#xA;    inherit Stream&#xA;    interface ICloneable&#xA;    interface IDisposable&#xA;    interface INullable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.OracleClient</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.SqlTypes.INullable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a large object binary (<see langword="LOB" />) data type stored on an Oracle server. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob> 에서 다른는 <xref:System.Data.OracleClient.OracleBFile> 는 데이터는 운영 체제의 물리적 파일 대신 서버에 저장 됩니다. 달리 읽기 / 쓰기 개체 일 수도 있습니다는 <xref:System.Data.OracleClient.OracleBFile>에 항상 읽기 전용입니다.  
  
 <xref:System.Data.OracleClient.OracleLob> 다음 중 하나일 수 있습니다 <xref:System.Data.OracleClient.OracleType> 데이터 형식입니다.  
  
|OracleType 데이터 형식|설명|  
|--------------------------|-----------------|  
|`Blob`|Oracle `BLOB` 4 기가바이트 (GB)의 최대 크기를 사용 하 여 이진 데이터를 포함 하는 데이터 형식입니다. 매핑되는 <xref:System.Array> 형식의 <xref:System.Byte>합니다.|  
|`Clob`|Oracle `CLOB` 4GB의 최대 크기를 사용 하 여 서버의 기본 문자를 기준으로 문자 데이터를 포함 하는 데이터 형식을 설정 합니다. 에 매핑됩니다 <xref:System.String>합니다.|  
|`NClob`|Oracle `NCLOB` 국가별 문자 4GB의 최대 크기를 사용 하 여 서버의 집합을 기반으로 문자 데이터를 포함 하는 데이터 형식입니다. 에 매핑됩니다 <xref:System.String>합니다.|  
  
 .NET 응용 프로그램 개발자는 Oracle을 검색할 수 있습니다 `LOB` 와 같은 기본.NET 데이터 형식으로 값 <xref:System.Array> 형식의 <xref:System.Byte> 하 고 <xref:System.String>, 또는 특수화 된 <xref:System.Data.OracleClient.OracleLob> 데이터 형식입니다. 합니다 <xref:System.Data.OracleClient.OracleLob> 클래스에서 데이터를 읽고 쓰는 Oracle에서 지 원하는 `LOB` Oracle 데이터베이스에서.  
  
 다음의 주요 특성은는 <xref:System.Data.OracleClient.OracleLob> 기본.NET 데이터 형식에서 구분 하는 데이터 형식:  
  
-   Oracle을 검색 한 후 `LOB` Oracle 데이터베이스에서 값을 <xref:System.Data.OracleClient.OracleLob> 클래스를 변경할 수 있습니다는 `LOB` 열려 있는 트랜잭션이 및 변경 데이터를 데이터베이스로 직접 반영 됩니다. Oracle을 검색 하는 경우 `LOB` 값을 <xref:System.Array> 형식의 <xref:System.Byte> 또는 <xref:System.String> 및이 배열에 업데이트 변경 내용을 데이터베이스에 반영 되지 않습니다.  
  
-   사용 하는 경우는 <xref:System.Data.OracleClient.OracleLob> 청크를 액세스 하는 클래스는 `LOB` 값만 해당 청크는 Oracle 데이터베이스에서 클라이언트에 전달 합니다. 사용 하는 경우는 <xref:System.Data.OracleClient.OracleDataReader.GetChars%2A> 청크를 액세스 하는 방법을 `LOB` 값, 값의 전체 내용을 Oracle 데이터베이스에서 클라이언트에 전달 합니다.  
  
 가져올는 <xref:System.Data.OracleClient.OracleLob> 개체를 호출 합니다 <xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A> 메서드.  
  
 생성할 수 있습니다는 <xref:System.Data.OracleClient.OracleLob> 이 형식을 사용 하 여 NULL입니다.  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 이 방법은 테스트 하는 데 주로 사용 됩니다 여부는 `LOB` 이 예제와 같이 null 인 경우 서버에서 반환:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 NULL `LOB` 는 0 바이트 비슷하게 `LOB` 한다는 점에서 <xref:System.Data.OracleClient.OracleLob.Read%2A> 성공 하 고 항상 0 바이트를 반환 합니다.  
  
 선택 하는 `LOB` null 값이 포함 된 열을 반환 합니다 <xref:System.Data.OracleClient.OracleLob.Null>합니다.  
  
 임시 얻기 전에 트랜잭션을 시작 해야 `LOB`합니다. 이 고, 그렇지는 <xref:System.Data.OracleClient.OracleDataReader> 이후에 데이터를 얻지 실패할 수 있습니다.  
  
 임시 열 수도 있습니다 `LOB` DBMS_LOB를 호출 하 여 Oracle에서. CREATETEMPORARY 시스템 저장 프로시저 및 바인딩은 `LOB` 매개 변수를 출력 합니다. 클라이언트 쪽에서는 임시 `LOB` 테이블 기반 처럼 `LOB`합니다. 예를 들어 임시 업데이트 `LOB`, 트랜잭션에서 묶어야 합니다.  
  
 다음 C# 예제에서는 임시를 여는 방법을 보여 줍니다 `LOB`합니다.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
byte[] tempbuff = new byte[10000];  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
> [!NOTE]
>  상속 된 <xref:System.IO.Stream.WriteByte%2A> 문자 데이터를 사용 하는 경우 메서드가 실패 및 <xref:System.InvalidOperationException> throw 됩니다. 대신 <xref:System.Data.OracleClient.OracleLob.Write%2A> 메서드를 사용합니다.  
>   
>  임시 `LOB`닫히면 연결이 닫혀만 있지만 풀링을 사용 하며 부하를 임시 `LOB`s를 닫지 마세요. 임시 삭제 하 여 해결할 수 있습니다 `LOB`를 호출 하 여 `tempLob.Dispose()`입니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Data.OracleClient.OracleLob source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Data.OracleClient.OracleLob source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (source As OracleLob)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Data::OracleClient::OracleLob ^ source);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Data.OracleClient.OracleLob -&gt; unit" Usage="oracleLob.Append source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="source">The <see langword="LOB" /> from which to append data.</param>
        <summary>Appends data from the specified <see langword="LOB" /> to the current <see langword="LOB" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 쓸 합니다 `LOB`를 검색 해야 합니다는 `LOB` SQL SELECT 문을에 FOR UPDATE 절을 사용 하 여 시작 된 로컬 트랜잭션 있어야 합니다.  
  
 모든 데이터 원본의 `LOB` 현재 끝에 추가 `LOB`합니다. 둘 다의 위치 `LOB` 평가 하거나이 프로세스 중에 변경 됩니다.  
  
 기본 데이터 형식이 항상 같아야 합니다. 예를 들어에서 추가 하는 경우는 <xref:System.Data.OracleClient.OracleType.NClob>, 대상 <xref:System.Data.OracleClient.OracleLob> 수도 있어야는 <xref:System.Data.OracleClient.OracleType.NClob>.  
  
> [!NOTE]
>  이 릴리스에서 쓰기 작업에는 읽기 전용 `LOB` 성공할 수 있지만 업데이트 하지 않습니다는 `LOB` 서버의 합니다. 그러나이 경우의 로컬 복사본이 `LOB` 업데이트 됩니다. 따라서 나중에 읽기 작업에는 <xref:System.Data.OracleClient.OracleLob> 개체 쓰기 작업의 결과 반환할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> is null.</exception>
        <exception cref="T:System.InvalidOperationException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginBatch">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prevents server-side triggers from firing while performing multiple write operations.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch();" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : unit -&gt; unit" Usage="oracleLob.BeginBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prevents server-side triggers from firing while performing multiple read operations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 열립니다는 `LOB` 에서 <xref:System.Data.OracleClient.OracleLobOpenMode.ReadOnly> 모드 이므로 합니다 `LOB` 읽을 수만 있습니다에서 해당 호출 될 때까지, 기록 되지 <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>. 쓰기를 일괄 처리를 수행 하는 `LOB`, 호출 <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> 사용 하 여 <xref:System.Data.OracleClient.OracleLobOpenMode.ReadWrite>입니다.  
  
 호출 <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> Oracle를 throw 하는 한 번 이상 동일한 트랜잭션 내에서 현재 "ORA-22293: 동일한 트랜잭션에서 열려 LOB" 오류입니다. 또한 가져와야 하는 경우에 `LOB` 다른를 사용 하 여 <xref:System.Data.OracleClient.OracleDataReader>를 원래 호출자가 호출 되지를 <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> 메서드를 같은 오류가 생성 됩니다. 따라서 호출 해야 합니다는 <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> 마쳤으면 메서드를 사용 하 여는 <xref:System.Data.OracleClient.OracleLob>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch(valuetype System.Data.OracleClient.OracleLobOpenMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch (mode As OracleLobOpenMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch(System::Data::OracleClient::OracleLobOpenMode mode);" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : System.Data.OracleClient.OracleLobOpenMode -&gt; unit" Usage="oracleLob.BeginBatch mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.OracleClient.OracleLobOpenMode" />
      </Parameters>
      <Docs>
        <param name="mode">Mode (one of the <see cref="T:System.Data.OracleClient.OracleLobOpenMode" /> values) in which the <see langword="LOB" /> can be accessed between this <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" /> call and the corresponding <see cref="M:System.Data.OracleClient.OracleLob.EndBatch" /> call.</param>
        <summary>Prevents server-side triggers from firing while performing multiple read and write operations in the specified access mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 쓸 합니다 `LOB`를 검색 해야 합니다는 `LOB` SQL SELECT 문을에 FOR UPDATE 절을 사용 하 여 시작 된 로컬 트랜잭션 있어야 합니다.  
  
 호출 <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> Oracle를 throw 하는 한 번 이상 동일한 트랜잭션 내에서 현재 "ORA-22293: 동일한 트랜잭션에서 열려 LOB" 오류입니다. 또한 가져와야 하는 경우에 `LOB` 다른를 사용 하 여 <xref:System.Data.OracleClient.OracleDataReader>를 원래 호출자가 호출 되지를 <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> 메서드를 같은 오류가 생성 됩니다. 따라서 호출 해야 합니다는 <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> 마쳤으면 메서드를 사용 하 여는 <xref:System.Data.OracleClient.OracleLob>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.OracleClient.OracleLob.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see langword="LOB" /> stream can be read.</summary>
        <value>
          <see langword="true" /> 경우는 <see langword="LOB" /> 스트림이 읽기를 그렇지 않으면 지원 <see langword="false" /> 경우는 <see langword="LOB" /> 닫히거나 삭제 합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether forward and backward seek operations can be performed.</summary>
        <value>
          <see langword="false" /> 경우는 <see langword="LOB" /> 닫히거나 삭제 된, 그렇지 않으면 <see langword="true" />합니다. 항상 <see langword="true" /> 에 대 한 <see cref="F:System.Data.OracleClient.OracleLob.Null" />합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Always returns true, regardless of whether the <see langword="LOB" /> supports writing or not.</summary>
        <value>항상 반환 <see langword="true" />여부에 관계 없이 열거나 삭제는 <see langword="LOB" /> 쓰기를 지원 합니다 <see langword="false" /> 경우를 <see langword="LOB" /> 닫히거나 삭제 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 쓸 합니다 `LOB`를 검색 해야 합니다는 `LOB` SQL SELECT 문을에 FOR UPDATE 절을 사용 하 여 시작 해야 합니다는 로컬 트랜잭션을.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkSize">
      <MemberSignature Language="C#" Value="public int ChunkSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChunkSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChunkSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChunkSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ChunkSize : int" Usage="System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating the minimum number of bytes to retrieve from or send to the server during a read/write operation.</summary>
        <value>바이트 검색 하거나 보낼 최소 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 값을 <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> 속성은.NET Framework Data Provider for Oracle의 설정이 아닙니다. 대신 호출 인터페이스 OCI (Oracle)에 서버와 통신할 때 사용 하는 값입니다. 사용 하 여 <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> 되도록 클라이언트 쪽 청크 크기가 같아야 합니다. 읽기 또는 쓰기를 더 작은 청크로 데이터를 캐시 하지 않습니다 하 고 전체 패킷 수신 되거나 전송 되지 때문에 서버에 없는 최적화 왕복이 발생 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="oracleLob.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Data.OracleClient.OracleLob" /> object that references the same Oracle <see langword="LOB" /> as the original <see cref="T:System.Data.OracleClient.OracleLob" /> object.</summary>
        <returns>A new <see cref="T:System.Data.OracleClient.OracleLob" /> object that references the same Oracle <see langword="LOB" /> as the original <see cref="T:System.Data.OracleClient.OracleLob" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 속성 <xref:System.Data.OracleClient.OracleLob> 개체는 처음에 원래 개체의 동일한 값을 갖습니다. 그러나 후 합니다 <xref:System.Data.OracleClient.OracleLob.Clone%2A> 완료 되 면 각 <xref:System.Data.OracleClient.OracleLob> 개체는 다른 별개입니다. 예를 들어,의 값을 변경 합니다 <xref:System.Data.OracleClient.OracleLob.Position%2A> 속성을 원래 <xref:System.Data.OracleClient.OracleLob> 의 값을 변경 하지 않습니다 <xref:System.Data.OracleClient.OracleLob.Position%2A> 복사본에서.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="oracleLob.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.OracleClient.OracleConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As OracleConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleConnection ^ Connection { System::Data::OracleClient::OracleConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.OracleClient.OracleConnection" Usage="System.Data.OracleClient.OracleLob.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Data.OracleClient.OracleConnection" /> used by this instance of the <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>데이터 소스와의 연결입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob -&gt; int64" Usage="oracleLob.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="destination">The destination <see cref="T:System.Data.OracleClient.OracleLob" />.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 데이터 형식이 항상 같아야 합니다. 예를 들어에서 복사 하는 경우는 <xref:System.Data.OracleClient.OracleType.NClob>, 대상 <xref:System.Data.OracleClient.OracleLob> 수도 있어야는 <xref:System.Data.OracleClient.OracleType.NClob>합니다.  
  
 대상 끝을 넘어 대상 오프셋 인지 `LOB`, `LOB` 데이터가 복사 되는 확장 되었습니다. 끝 사이의 간격을 `LOB` 끝 대상 오프셋에 대 한 0으로 채워서 및 `BLOB` 데이터 형식 및 공간 `CLOB` 및 `NCLOB` 데이터 형식입니다.  
  
 쓸 합니다 `LOB`를 검색 해야 합니다는 `LOB` SQL SELECT 문을에 FOR UPDATE 절을 사용 하 여 시작 된 로컬 트랜잭션 있어야 합니다.  
  
> [!NOTE]
>  이 릴리스에서 쓰기 작업에는 읽기 전용 `LOB` 성공할 수도 있지만 업데이트할는 `LOB` 서버의 합니다. 그러나이 경우의 로컬 복사본이 `LOB` 업데이트 됩니다. 따라서 나중에 읽기 작업에는 <xref:System.Data.OracleClient.OracleLob> 개체 쓰기 작업의 결과 반환할 수 있습니다.  
>   
>  합니다 `CopyTo` 메서드는 대상의 내용을 지우지 않을 `OracleLob` 복사 작업을 수행 하기 전에 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is null.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination, int64 destinationOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob, destinationOffset As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination, long destinationOffset);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob * int64 -&gt; int64" Usage="oracleLob.CopyTo (destination, destinationOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination">The destination <see cref="T:System.Data.OracleClient.OracleLob" /></param>
        <param name="destinationOffset">The offset to which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number of bytes.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" /> with the specified amount of data.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 데이터 형식이 항상 같아야 합니다. 예를 들어에서 복사 하는 경우는 <xref:System.Data.OracleClient.OracleType.NClob>, 대상 <xref:System.Data.OracleClient.OracleLob> 수도 있어야는 <xref:System.Data.OracleClient.OracleType.NClob>합니다.  
  
 대상 끝을 넘어 대상 오프셋 인지 `LOB`, `LOB` 데이터가 복사 되는 확장 되었습니다. 끝 사이의 공백을 `LOB` 및 대상 오프셋 끝 다음에 대해 0이 채워집니다 `BLOB` 데이터 형식 및 공간 `CLOB` 및 `NCLOB` 데이터 형식입니다.  
  
 쓸 합니다 `LOB`를 검색 해야 합니다는 `LOB` SQL SELECT 문을에 FOR UPDATE 절을 사용 하 여 시작 된 로컬 트랜잭션 있어야 합니다.  
  
> [!NOTE]
>  이 릴리스에서 쓰기 작업에는 읽기 전용 `LOB` 성공할 수 있지만 업데이트 하지 않습니다는 `LOB` 서버의 합니다. 그러나이 경우의 로컬 복사본이 `LOB` 업데이트 됩니다. 따라서 나중에 읽기 작업에는 <xref:System.Data.OracleClient.OracleLob> 개체 쓰기 작업의 결과 반환할 수 있습니다.  
>   
>  합니다 `CopyTo` 메서드는 대상의 내용을 지우지 않을 `OracleLob` 복사 작업을 수행 하기 전에 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is full.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="destinationOffset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  A value specified in the <paramref name="destinationOffset" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.  -or-  You must specify <see langword="CLOB" /> and <see langword="NCLOB" /> data types as an even number of bytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(int64 sourceOffset, class System.Data.OracleClient.OracleLob destination, int64 destinationOffset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (sourceOffset As Long, destination As OracleLob, destinationOffset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(long sourceOffset, System::Data::OracleClient::OracleLob ^ destination, long destinationOffset, long amount);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : int64 * System.Data.OracleClient.OracleLob * int64 * int64 -&gt; int64" Usage="oracleLob.CopyTo (sourceOffset, destination, destinationOffset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceOffset" Type="System.Int64" />
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceOffset">The offset from which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="destination">The destination <see langword="OracleLob" /><see cref="N:System.Data.OracleClient" />.</param>
        <param name="destinationOffset">The destination offset to which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="amount">The quantity of data, in bytes, to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" /> with the specified amount of data, and the source offset.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 데이터 형식이 항상 같아야 합니다. 예를 들어에서 복사 하는 경우는 <xref:System.Data.OracleClient.OracleType.NClob>, 대상 <xref:System.Data.OracleClient.OracleLob> 수도 있어야는 <xref:System.Data.OracleClient.OracleType.NClob>합니다.  
  
 대상 끝을 넘어 대상 오프셋 인지 `LOB`, `LOB` 데이터가 복사 되는 확장 되었습니다. 끝 사이의 공백을 `LOB` 및 대상 오프셋 끝 다음에 대해 0이 채워집니다 `BLOB` 데이터 형식 및 공간 `CLOB` 및 `NCLOB` 데이터 형식입니다.  
  
 쓸 합니다 `LOB`를 검색 해야 합니다는 `LOB` SQL SELECT 문을에 FOR UPDATE 절을 사용 하 여 시작 된 로컬 트랜잭션 있어야 합니다.  
  
> [!NOTE]
>  이 릴리스에서 쓰기 작업에는 읽기 전용 `LOB` 성공할 수 있지만 업데이트 하지 않습니다는 `LOB` 서버의 합니다. 그러나이 경우의 로컬 복사본이 `LOB` 업데이트 됩니다. 따라서 나중에 읽기 작업에는 <xref:System.Data.OracleClient.OracleLob> 개체 쓰기 작업의 결과 반환할 수 있습니다.  
>   
>  합니다 `CopyTo` 메서드는 대상의 내용을 지우지 않을 `OracleLob` 복사 작업을 수행 하기 전에 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is full.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="amount" />, <paramref name="sourceOffset" />, or <paramref name="destinationOffset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  A value specified in the <paramref name="amount" />, <paramref name="sourceOffset" />, or <paramref name="destinationOffset" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="oracleLob.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="oracleLob.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBatch">
      <MemberSignature Language="C#" Value="public void EndBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.EndBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBatch();" />
      <MemberSignature Language="F#" Value="member this.EndBatch : unit -&gt; unit" Usage="oracleLob.EndBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Allows server-side triggers to resume firing after performing multiple write operations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출을 <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> 메서드를 시작 하기 전에 쓰기 작업을 <xref:System.Data.OracleClient.OracleLob>입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Erase">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erases data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase();" />
      <MemberSignature Language="F#" Value="member this.Erase : unit -&gt; int64" Usage="oracleLob.Erase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erases all data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes erased.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> 데이터를 잘라내지 않습니다. 합니다 `LOB` 길이 대 한 동일 하 게 유지는 `BLOB` 데이터 형식, 삭제 된 데이터는 0x00 바뀝니다. `CLOB` 및 `NCLOB` 데이터 형식 공백으로 바뀝니다.  
  
 쓸 합니다 `LOB`를 검색 해야 합니다는 `LOB` SQL SELECT 문을에 FOR UPDATE 절을 사용 하 여 시작 된 로컬 트랜잭션 있어야 합니다.  
  
> [!NOTE]
>  이 릴리스에서 쓰기 작업에는 읽기 전용 `LOB` 성공할 수 있지만 업데이트 하지 않습니다는 `LOB` 서버의 합니다. 그러나이 경우의 로컬 복사본이 `LOB` 업데이트 됩니다. 따라서 나중에 읽기 작업에는 <xref:System.Data.OracleClient.OracleLob> 개체 쓰기 작업의 결과 반환할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase (long offset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase(int64 offset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase (offset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase(long offset, long amount);" />
      <MemberSignature Language="F#" Value="member this.Erase : int64 * int64 -&gt; int64" Usage="oracleLob.Erase (offset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">The offset from which to erase. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="amount">The quantity of data, in bytes, to erase. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Erases the specified amount of data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes erased.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값의 합계를 `offset` 하 고 `amount` 매개 변수 크기 보다 클 수는 <xref:System.Data.OracleClient.OracleLob>. 그러나 따라서 반환한 보다 큰 값을 지정 합니다 <xref:System.Data.OracleClient.OracleLob.Length%2A> 속성이 성공 하면 <xref:System.Data.OracleClient.OracleLob.Erase%2A> 의 끝에만 삭제는 <xref:System.Data.OracleClient.OracleLob>합니다. (음수 값이 전달 하는 경우에 마찬가지로 `offset`, <xref:System.Data.OracleClient.OracleLob.Erase%2A> 는 성공 하지만의 시작 부분부터만 지웁니다는 <xref:System.Data.OracleClient.OracleLob>.) 이 동작은 다릅니다 합니다 <xref:System.Data.OracleClient.OracleLob.Read%2A> 하 고 <xref:System.Data.OracleClient.OracleLob.Write%2A> 메서드 및 제공 하 여 지정 된 값에서 모든 데이터를 지울 수 있다는 장점이 `offset` 실제 크기를 확인 하기 위해 서버를 추가로 왕복 하지 않고 합니다.  
  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> 데이터를 잘라내지 않습니다. 합니다 `LOB` 길이 대 한 동일 하 게 유지는 `BLOB` 데이터 형식, 삭제 된 데이터는 0x00 바뀝니다. `CLOB` 및 `NCLOB` 데이터 형식 공백으로 바뀝니다.  
  
 쓸 합니다 `LOB`를 검색 해야 합니다는 `LOB` SQL SELECT 문을에 FOR UPDATE 절을 사용 하 여 시작 된 로컬 트랜잭션 있어야 합니다.  
  
> [!NOTE]
>  이 릴리스에서 쓰기 작업에는 읽기 전용 `LOB` 성공할 수 있지만 업데이트 하지 않습니다는 `LOB` 서버의 합니다. 그러나이 경우의 로컬 복사본이 `LOB` 업데이트 됩니다. 따라서 나중에 읽기 작업에는 <xref:System.Data.OracleClient.OracleLob> 개체 쓰기 작업의 결과 반환할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="oracleLob.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Not currently supported.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 릴리스에서이 메서드가 작동 하지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBatched">
      <MemberSignature Language="C#" Value="public bool IsBatched { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBatched" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBatched As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBatched { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBatched : bool" Usage="System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether an application called the <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" /> method.</summary>
        <value>
          <see langword="true" /> 응용 프로그램에서 호출 되는 경우는 <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" /> 메서드를이 고 그렇지 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oracle 8.0.5 Oracle 서버를 사용 하는 경우 "ORA-00600: 내부 오류 코드" 예외가 throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNull" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNull : bool" Usage="System.Data.OracleClient.OracleLob.IsNull" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.SqlTypes.INullable.IsNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Data.OracleClient.OracleLob" /> is a <see cref="F:System.Data.OracleClient.OracleBFile.Null" /> stream.</summary>
        <value>
          <see langword="true" /> 경우는 <see cref="T:System.Data.OracleClient.OracleLob" /> 되는 <see cref="F:System.Data.OracleClient.OracleBFile.Null" /> 스트림에 고, 그렇지 <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Data.OracleClient.OracleLob" /> is a temporary <see langword="LOB" />.</summary>
        <value>
          <see langword="true" /> 경우는 <see cref="T:System.Data.OracleClient.OracleLob" /> 임시 <see langword="LOB" />, 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 예제에서는 임시를 만드는 방법 `LOB`합니다.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.OracleClient.OracleLob.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that returns the size of the <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>크기는 <see cref="T:System.Data.OracleClient.OracleLob" /> (바이트)에서입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 크기는 <xref:System.Data.OracleClient.OracleLob> 항상 모든 데이터 형식에 대 한 바이트 단위로 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="LobType">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleType LobType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.OracleClient.OracleType LobType" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.LobType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LobType As OracleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleType LobType { System::Data::OracleClient::OracleType get(); };" />
      <MemberSignature Language="F#" Value="member this.LobType : System.Data.OracleClient.OracleType" Usage="System.Data.OracleClient.OracleLob.LobType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that returns the <see langword="LOB" /> data type.</summary>
        <value>중 하나는 <see cref="T:System.Data.OracleClient.OracleType" /><see langword="LOB" /> 데이터 형식입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob> 다음 중 하나일 수 있습니다 <xref:System.Data.OracleClient.OracleType> 데이터 형식입니다.  
  
|OracleType 데이터 형식|설명|  
|--------------------------|-----------------|  
|`Blob`|Oracle `BLOB` 4gb의 최대 크기를 사용 하 여 이진 데이터를 포함 하는 데이터 형식입니다. 매핑되는 <xref:System.Array> 형식의 <xref:System.Byte>합니다.|  
|`Clob`|Oracle `CLOB` 4gb의 최대 크기를 사용 하 여 서버의 기본 문자를 기준으로 문자 데이터를 포함 하는 데이터 형식을 설정 합니다. 에 매핑됩니다 <xref:System.String>합니다.|  
|`NClob`|Oracle `NCLOB` 국가별 문자 4gb의 최대 크기를 사용 하 여 서버의 집합을 기반으로 문자 데이터를 포함 하는 데이터 형식입니다. 에 매핑됩니다 <xref:System.String>합니다.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.Data.OracleClient.OracleLob Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.OracleClient.OracleLob Null" />
      <MemberSignature Language="DocId" Value="F:System.Data.OracleClient.OracleLob.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As OracleLob " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::OracleClient::OracleLob ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.Data.OracleClient.OracleLob" Usage="System.Data.OracleClient.OracleLob.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleLob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents a null <see cref="T:System.Data.OracleClient.OracleLob" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 생성할 수 있습니다는 <xref:System.Data.OracleClient.OracleLob> 이 형식을 사용 하 여 NULL입니다.  
  
```  
OracleLob myLob = OracleLOB.Null;  
```  
  
 이 방법은 테스트 하는 데 주로 사용 됩니다 여부는 `LOB` 이 예제와 같이 null 인 경우 서버에서 반환:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 NULL `LOB` 는 0 바이트 비슷하게 `LOB` 한다는 점에서 <xref:System.Data.OracleClient.OracleLob.Read%2A> 성공 하 고 항상 0 바이트를 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.OracleClient.OracleLob.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current read position in the <see cref="T:System.Data.OracleClient.OracleLob" /> stream.</summary>
        <value>내의 현재 위치를 <see cref="T:System.Data.OracleClient.OracleLob" /> 스트림 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스트림이 가져오거나 설정할 위치 검색을 지원 해야 합니다. 사용 된 <xref:System.Data.OracleClient.OracleLob.CanSeek%2A> 스트림이 검색을 지원 하는지 여부를 결정 하는 속성입니다.  
  
 스트림의 길이 초과 하는 위치 검색을 지원 합니다. 홀수 바이트 위치에 대 한 하려는 `CLOB` 및 `NCLOB` 데이터 형식 에서도 지원 됩니다. 자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Data.OracleClient.OracleLob.Read%2A> 속성입니다.  
  
 <xref:System.Data.OracleClient.OracleLob.Position%2A> 속성 않습니다를 추적 하지는 소비 된 생략 되었거나 스트림을 또는 둘 다에서 바이트 수입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="oracleLob.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c>) replaced by the bytes read from the current source.</param>
        <param name="offset">The zero-based byte offset in <c>buffer</c> at which to begin storing the data read from the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="count">The maximum number of bytes to be read from the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Reads a sequence of bytes from the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream and advances the position within the stream by the number of bytes read.</summary>
        <returns>The total number of bytes read into the buffer. This may be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.OracleClient.OracleLob.Read%2A> 메서드는 최대 읽습니다 `count` 현재에서 바이트 스트리밍하 고 저장 합니다 `buffer` 부터 `offset`합니다. 스트림 내의 현재 위치는; 읽은 바이트 수 만큼 앞 그러나 예외가 발생 하는 경우 스트림 내의 현재 위치 변경 되지 않습니다. <xref:System.Data.OracleClient.OracleLob.Read%2A> 읽은 바이트 수를 반환 합니다. 위치가 스트림의 맨 끝에 현재 있는 경우에 반환 값은 0으로 지정 합니다. <xref:System.Data.OracleClient.OracleLob.Read%2A> 데이터가 없는 이벤트 최소한 1 바이트의 데이터를 읽을 수 있을 때까지 차단 됩니다.<xref:System.Data.OracleClient.OracleLob.Read%2A> 읽기를 시도 하는 경우 0을 반환 합니다는 `LOB` 끝날 때 현재 위치에 표시 되는 경우 `LOB`합니다. <xref:System.Data.OracleClient.OracleLob.Read%2A> 요청 된 것 보다 개 이하의 바이트가 스트림의 끝에 도달 하지 않은 경우에 반환할 수 있습니다.  
  
 모든.NET Framework Data Provider for Oracle 처리 `CLOB` 고 `NCLOB` 유니코드 데이터입니다. 따라서에 액세스할 때 `CLOB` 고 `NCLOB` 데이터 형식이 항상 처리 하는 각 문자는 2 바이트는 바이트 수입니다. 예를 들어 세 개의 문자가 포함 된 텍스트 문자열로로 저장 됩니다는 `NCLOB` 여기서는 문자 집합은 문자당 4 바이트가 고 수행한 Oracle 서버에는 `Read` 작업 이지만 6 바이트로 문자열의 길이 지정 서버에서 12 바이트로 저장 합니다.  
  
 다음 C# 예제에서는 읽는 방법을 보여 줍니다. <xref:System.Data.OracleClient.OracleLob> 개체입니다.  
  
```  
public static void ReadLobExample(OracleCommand command)  
{  
   int actual = 0;  
  
   //Select some data.  
   // Table Schema:  
   //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";  
   //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain the LOBs (all 3 varieties).  
      OracleLob BLOB = reader.GetOracleLob(1);  
      OracleLob CLOB  = reader.GetOracleLob(2);  
      OracleLob NCLOB = reader.GetOracleLob(3);  
  
      //Example - Reading binary data (in chunks).  
      byte[] buffer = new byte[100];  
      while((actual = BLOB.Read(buffer, 0, buffer.Length)) >0)  
         Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") => " + actual);  
  
      //Example - Reading CLOB/NCLOB data (in chunks).  
      //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).  
      //However, because the OracleLob object inherits directly from the.NET stream object,   
      //all the existing classes that manipluate streams can also be used. For example, the   
      //.NET StreamReader makes converting the raw bytes into actual characters easier.  
      StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);  
      char[] cbuffer = new char[100];  
      while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)  
         Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") => " + actual);  
  
      //Example - Reading data (all at once).  
      //You could use StreamReader.ReadToEnd to obtain all the string data,or simply  
      //call OracleLob.Value to obtain a contiguous allocation of all the data.  
      Console.WriteLine(NCLOB.LobType + ".Value => " + NCLOB.Value);  
   }  
}  
```  
  
 생성할 수 있습니다는 <xref:System.Data.OracleClient.OracleLob> 이 형식을 사용 하 여 NULL입니다.  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 이 방법은 테스트 하는 데 주로 사용 됩니다 여부는 `LOB` 다음 예제와 같이 null 인 경우 서버에서 반환 합니다.  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 NULL `LOB` 는 0 바이트 비슷하게 `LOB` 한다는 점에서 <xref:System.Data.OracleClient.OracleLob.Read%2A> 성공 하 고 항상 0 바이트를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in the <paramref name="offset" /> or <paramref name="count" /> parameter is not positive.  -or-  The sum of the offset and count parameters is larger than the buffer length.  -or-  A value specified in the <paramref name="amount" /> or <paramref name="offset" /> parameter is less than zero or greater than 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="oracleLob.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">A byte offset relative to origin. If <c>offset</c> is negative, the new position precedes the position specified by <c>origin</c> by the number of bytes specified by <c>offset</c>. If <c>offset</c> is zero, the new position is the position specified by <c>origin</c>. If <c>offset</c> is positive, the new position follows the position specified by <c>origin</c> by the number of bytes specified by <c>offset</c>.</param>
        <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position.</param>
        <summary>Sets the position on the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream.</summary>
        <returns>The new position within the current stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `offset` 가 음수인 경우 새 위치 앞에 야 하 여 지정 된 위치 `origin` 으로 지정 된 바이트 수 만큼 `offset`입니다. 하는 경우 `offset` 가 0 이면 새 위치에 지정 된 위치 여야 합니다. `origin`합니다. 하는 경우 `offset` 이 양수인 경우 새 위치에 지정 된 위치를 따라야 `origin` 으로 지정 된 바이트 수 만큼 `offset`입니다.  
  
 스트림의 길이 초과 하는 위치 검색을 지원 합니다. 홀수 바이트 위치에 대 한 하려는 `CLOB` 및 `NCLOB` 데이터 형식 에서도 지원 됩니다. 자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Data.OracleClient.OracleLob.Read%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="origin" /> parameter does not contain a valid value.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The resulting position is beyond the length of the value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Data.OracleClient.OracleLob" /> object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="oracleLob.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The desired length of the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream in bytes. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Sets the length of the <see cref="T:System.Data.OracleClient.OracleLob" /> stream to a value less than the current length.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 길이 높이기 위해는 <xref:System.Data.OracleClient.OracleLob> stream 실패 하 고 반환 "메시지: ORA-22926: trim 길이가 현재 LOB 값의 길이 보다 크면 지정 된" Oracle 서버에서.  
  
 스트림이 쓰기와 검색을 모두 지원 해야 <xref:System.Data.OracleClient.OracleLob.SetLength%2A> 함수입니다.  
  
 모든.NET Framework Data Provider for Oracle 처리 `CLOB` 고 `NCLOB` 유니코드 데이터입니다. 따라서에 액세스할 때 `CLOB` 고 `NCLOB` 데이터 형식이 항상 처리 하는 각 문자는 2 바이트는 바이트 수입니다. 예를 들어 세 개의 문자가 포함 된 텍스트 문자열로로 저장 됩니다는 `NCLOB` 여기서는 문자 집합은 문자당 4 바이트가 고 수행한 Oracle 서버에는 `SetLength` 작업 이지만 6 바이트로 문자열의 길이 지정 서버에서 12 바이트로 저장 합니다.  
  
 쓸 합니다 `LOB`를 검색 해야 합니다는 `LOB` SQL SELECT 문을에 FOR UPDATE 절을 사용 하 여 시작 된 로컬 트랜잭션 있어야 합니다.  
  
> [!NOTE]
>  한 쓰기 작업에는 읽기 전용 `LOB` 성공할 수 있지만 업데이트 하지 않습니다는 `LOB` 서버의 합니다. 그러나이 경우의 로컬 복사본이 `LOB` 업데이트 됩니다. 따라서 나중에 읽기 작업에는 <xref:System.Data.OracleClient.OracleLob> 개체 쓰기 작업의 결과 반환할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="value" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.  -or-  A value specified in the <paramref name="value" /> parameter is less than zero or greater than 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Data.OracleClient.OracleLob.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the common language runtime stream value equivalent of the underlying value.</summary>
        <value>에 대 한 <see cref="F:System.Data.OracleClient.OracleType.Blob" />, 형식 배열을 <see langword="Byte[]" />합니다. 에 대 한 <see cref="F:System.Data.OracleClient.OracleType.Clob" /> 하 고 <see cref="F:System.Data.OracleClient.OracleType.NClob" />, <see langword="String" />합니다. Null 데이터용 <see cref="T:System.DBNull" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 <xref:System.Data.OracleClient.OracleType.Blob> 데이터 형식 <xref:System.Data.OracleClient.OracleLob.Value%2A> 형식의 연속 배열로 전체 기본 데이터를 반환 합니다. `Byte[]`합니다. 에 대 한 <xref:System.Data.OracleClient.OracleType.Clob> 하 고 <xref:System.Data.OracleClient.OracleType.NClob> 데이터 형식 <xref:System.Data.OracleClient.OracleLob.Value%2A> 모든 데이터를 반환 합니다는 `String` 데이터 형식입니다. Null 데이터용 <xref:System.Data.OracleClient.OracleLob.Value%2A> 반환 <xref:System.DBNull>합니다. 반환된 된 값을 비교 하 여 구분할 수 있습니다 빈 데이터 간의 데이터 및 데이터를 null입니다.  
  
> [!NOTE]
>  사용 하는 이점은 `LOB` 데이터 형식의 많은 양의 데이터를 청크로 클라이언트에서 검색 하는 기능입니다. 그러나 사용 하는 경우 <xref:System.Data.OracleClient.OracleLob.Value%2A>에 대 한 모든 데이터를 가져와야 합니다 `LOB` 를 응용 프로그램의 오버 헤드를 크게 높일 수 있는 하나의 연속적인 청크로 열입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="oracleLob.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of bytes. This method copies the number of bytes specified in <c>count</c> from <c>buffer</c> to the current stream.</param>
        <param name="offset">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="count">The number of bytes to be written to the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Writes a sequence of bytes to the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream, and advances the current position within this stream by the number of bytes written.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 쓰기 작업이 성공한 경우 스트림 내의 위치 쓴 바이트 수 만큼 이동 합니다. 예외가 발생 하는 스트림 내의 위치에 그대로 유지 됩니다.  
  
 끝을 넘어 작성 `LOB` 수 있으며 확장는 `LOB` 쓴 바이트 수입니다.  
  
 모든.NET Framework Data Provider for Oracle 처리 `CLOB` 고 `NCLOB` 유니코드 데이터입니다. 따라서에 액세스할 때 `CLOB` 고 `NCLOB` 데이터 형식이 항상 처리 하는 각 문자는 2 바이트는 바이트 수입니다. 예를 들어 세 개의 문자가 포함 된 텍스트 문자열로로 저장 됩니다는 `NCLOB` 여기서는 문자 집합은 문자당 4 바이트가 고 수행한 Oracle 서버에는 `Write` 작업 이지만 6 바이트로 문자열의 길이 지정 서버에서 12 바이트로 저장 합니다.  
  
 쓸 합니다 `LOB`를 검색 해야 합니다는 `LOB` SQL SELECT 문을에 FOR UPDATE 절을 사용 하 여 시작 된 로컬 트랜잭션 있어야 합니다.  
  
 다음 C# 예제를 작성 하는 방법을 보여 줍니다 <xref:System.Data.OracleClient.OracleLob> 개체입니다.  
  
```  
public static void WriteLobExample(OracleCommand command)  
{  
   //Note: Updating LOB data requires a transaction.  
   command.Transaction = command.Connection.BeginTransaction();  
   //Select some data.  
   //    Table Schema:  
   //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";  
   //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain both LOBs.  
      OracleLob BLOB1    = reader.GetOracleLob(1);  
      OracleLob BLOB2    = reader.GetOracleLob(2);  
      //Perform any desired operations on the LOB, (read, position, and so on).  
      //...  
      //Example - Writing binary data (directly to the backend).  
      //To write, you can use any of the stream classes, or write raw binary data using   
      //the OracleLob write method. Writing character vs. binary is the same;  
      //however note that character is always in terms of Unicode byte counts  
      //(for example: even number of bytes - 2 bytes for every Unicode character).  
      byte[] buffer = new byte[100];  
      buffer[0] = 0xCC;  
      buffer[1] = 0xDD;  
      BLOB1.Write(buffer, 0, 2);  
      BLOB1.Position = 0;  
      Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) => " + BLOB1.Value);  
  
      //Example - Copying data into another LOB.  
      long actual = BLOB1.CopyTo(BLOB2);  
      Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") => " + actual);  
  
      //Commit the transaction now that everything succeeded.  
      //Note: On error, Transaction.Dispose is called (from the using statement)  
      //and will automatically roll-back the pending transaction.  
      command.Transaction.Commit();  
   }  
}  
```  
  
> [!NOTE]
>  한 쓰기 작업에는 읽기 전용 `LOB` 성공할 수 있지만 업데이트 하지 않습니다는 `LOB` 서버의 합니다. 그러나이 경우의 로컬 복사본이 `LOB` 업데이트 됩니다. 따라서 나중에 읽기 작업에는 <xref:System.Data.OracleClient.OracleLob> 개체 쓰기 작업의 결과 반환할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in the <paramref name="offset" /> or <paramref name="count" /> parameter is not positive.  -or-  The sum of the <paramref name="offset" /> and <paramref name="count" /> parameters is larger than the <paramref name="buffer" /> length.  -or-  A value specified in the <paramref name="count" /> or <paramref name="offset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  You must specify <see langword="CLOB" /> and <see langword="NCLOB" /> data types as an even number of bytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="oracleLob.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The byte to write to the stream.</param>
        <summary>Writes a byte to the current position in the <see cref="T:System.Data.OracleClient.OracleLob" /> stream, and advances the position within the stream by one byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 쓰기 작업이 성공한 경우 스트림 내의 위치 1 바이트씩 앞으로 이동 합니다. 예외가 발생 하는 스트림 내의 위치에 그대로 유지 됩니다.  
  
 끝을 넘어 작성 합니다 `LOB` 수 있으며 확장는 `LOB` 1 바이트씩 합니다.  
  
 쓸 합니다 `LOB`를 검색 해야 합니다는 `LOB` SQL SELECT 문을에 FOR UPDATE 절을 사용 하 여 시작 된 로컬 트랜잭션 있어야 합니다.  
  
> [!NOTE]
>  한 쓰기 작업에는 읽기 전용 `LOB` 성공할 수 있지만 업데이트 하지 않습니다는 `LOB` 서버의 합니다. 그러나이 경우의 로컬 복사본이 `LOB` 업데이트 됩니다. 따라서 나중에 읽기 작업에는 <xref:System.Data.OracleClient.OracleLob> 개체 쓰기 작업의 결과 반환할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>