<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DynamicObject.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5048b7221c8f650af7e40e1fc748386ee05216b4b.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">048b7221c8f650af7e40e1fc748386ee05216b4b</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Dynamic.DynamicObject">
          <source>Provides a base class for specifying dynamic behavior at run time.</source>
          <target state="translated">런타임에 동적 동작을 지정하기 위한 기본 클래스를 제공합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Dynamic.DynamicObject">
          <source>This class must be inherited from; you cannot instantiate it directly.</source>
          <target state="translated">이 클래스는 상속되어야 하며, 직접 인스턴스화할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>The <ph id="ph1">`DynamicObject`</ph> class enables you to define which operations can be performed on dynamic objects and how to perform those operations.</source>
          <target state="translated"><ph id="ph1">`DynamicObject`</ph> 클래스를 사용 하면 동적 개체에서 수행할 수 있는 작업 및 이러한 작업을 수행 하는 방법을 정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For example, you can define what happens when you try to get or set an object property, call a method, or perform standard mathematical operations such as addition and multiplication.</source>
          <target state="translated">예를 들어 get 또는 개체 속성을 설정, 메서드 호출 또는 더하기, 곱하기 등 표준 수치 연산을 수행 하려고 할 때 수행 되는 작업을 정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>This class can be useful if you want to create a more convenient protocol for a library.</source>
          <target state="translated">이 클래스는 라이브러리에 대 한 보다 편리한 프로토콜을 만들려는 경우에 유용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For example, if users of your library have to use syntax like <ph id="ph1">`Scriptobj.SetProperty("Count", 1)`</ph>, you can provide the ability to use much simpler syntax, like <ph id="ph2">`scriptobj.Count = 1`</ph>.</source>
          <target state="translated">예를 들어, 라이브러리의 사용자가 같은 구문을 사용 해야 하는 경우 <ph id="ph1">`Scriptobj.SetProperty("Count", 1)`</ph>, like 훨씬 간단한 구문을 사용 하는 기능을 제공할 수 있습니다 <ph id="ph2">`scriptobj.Count = 1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>You cannot directly create an instance of the <ph id="ph1">`DynamicObject`</ph> class.</source>
          <target state="translated">인스턴스를 직접 만들 수는 <ph id="ph1">`DynamicObject`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>To implement the dynamic behavior, you may want to inherit from the <ph id="ph1">`DynamicObject`</ph> class and override necessary methods.</source>
          <target state="translated">동적 동작을 구현 하려면에서 상속 하려는 <ph id="ph1">`DynamicObject`</ph> 클래스 및 필요한 메서드를 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For example, if you need only operations for setting and getting properties, you can override just the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods.</source>
          <target state="translated">예를 들어 한 설정 및 속성을 가져오기에 대 한 작업이 필요한 경우 재정의할 수 있습니다만 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>In C#, to enable dynamic behavior for instances of classes derived from the <ph id="ph1">`DynamicObject`</ph> class, you must use the <ph id="ph2">`dynamic`</ph> keyword.</source>
          <target state="translated">C#에서는에서 파생 된 클래스의 인스턴스에 대해 동적 동작을 사용 하도록는 <ph id="ph1">`DynamicObject`</ph> 사용 해야 클래스는 <ph id="ph2">`dynamic`</ph> 키워드입니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For more information, see <bpt id="p1">[</bpt>Using Type dynamic<ept id="p1">](~/docs/csharp/programming-guide/types/using-type-dynamic.md)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>dynamic 형식 사용<ept id="p1">](~/docs/csharp/programming-guide/types/using-type-dynamic.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>In Visual Basic, dynamic operations are supported by late binding.</source>
          <target state="translated">Visual Basic에서 런타임에 바인딩하여 동적 작업은 지원 됩니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For more information, see <bpt id="p1">[</bpt>Early and Late Binding<ept id="p1">](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>초기 바인딩 및 런타임에 바인딩<ept id="p1">](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>The following code example demonstrates how to create an instance of a class that is derived from the <ph id="ph1">`DynamicObject`</ph> class.</source>
          <target state="translated">다음 코드 예제에서 파생 된 클래스의 인스턴스를 만드는 방법을 보여 줍니다는 <ph id="ph1">`DynamicObject`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>You can also add your own members to classes derived from the <ph id="ph1">`DynamicObject`</ph> class.</source>
          <target state="translated">파생 된 클래스에 직접 구성원을 추가할 수도 있습니다는 <ph id="ph1">`DynamicObject`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>If your class defines properties and also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method, the dynamic language runtime (DLR) first uses the language binder to look for a static definition of a property in the class.</source>
          <target state="translated">클래스의 속성 정의 재정의 하는 경우는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 메서드, 동적 언어 런타임 (DLR) 먼저를 사용 하 여 언어 바인더 클래스의 속성에 대 한 정적 정의 찾습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>If there is no such property, the DLR calls the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method.</source>
          <target state="translated">이러한 속성이 없으면 DLR 호출는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>The <ph id="ph1">`DynamicObject`</ph> class implements the DLR interface <ph id="ph2">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph>, which enables you to share instances of the <ph id="ph3">`DynamicObject`</ph> class between languages that support the DLR interoperability model.</source>
          <target state="translated"><ph id="ph1">`DynamicObject`</ph> DLR 인터페이스를 구현 하는 클래스 <ph id="ph2">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph>의 인스턴스를 공유할 수 있습니다는 <ph id="ph3">`DynamicObject`</ph> DLR 상호 운용성 모델을 지 원하는 언어 간 클래스입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For example, you can create an instance of the <ph id="ph1">`DynamicObject`</ph> class in C# and then pass it to an IronPython function.</source>
          <target state="translated">예를 들어의 인스턴스를 만들 수 있습니다는 <ph id="ph1">`DynamicObject`</ph> C#에서 클래스 및 IronPython 함수에 전달 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For more information, see <bpt id="p1">[</bpt>Dynamic Language Runtime Overview<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>동적 언어 런타임 개요<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>If you have a simple scenario in which you need an object that can only add and remove members at run time but that does not need to define specific operations and does not have static members, use the <ph id="ph1">&lt;xref:System.Dynamic.ExpandoObject&gt;</ph> class.</source>
          <target state="translated">필요한 개체를 특정 작업을 정의 및 않습니다 하지 정적 멤버만, 사용 하 여 필요 하지 않은 있지만만 추가 하 고 런타임 시 멤버를 제거할 수 있는 간단한 시나리오가 있는 경우는 <ph id="ph1">&lt;xref:System.Dynamic.ExpandoObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>If you have a more advanced scenario in which you need to define how dynamic objects participate in the interoperability protocol, or you need to manage DLR fast dynamic dispatch caching, create your own implementation of the <ph id="ph1">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> interface.</source>
          <target state="translated">동적 개체를 상호 운용성 프로토콜에 참여 하거나 DLR 동적 디스패치 캐싱을 관리 해야 할 방법을 정의 해야 하는 좀 더 고급 시나리오를 사용 하도록 설정한 경우의 구현을 만듭니다는 <ph id="ph1">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>Assume that you want to provide alternative syntax for accessing values in a dictionary, so that instead of writing <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> in Visual Basic), you can write <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</source>
          <target state="translated">쓰기는 대신의 사전에 값에 액세스 하기 위한 대체 구문을 제공 해야 한다고 가정해 보십시오 <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> Visual basic에서)를 작성할 수 있습니다 <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>Also, you want this syntax to be case-insensitive, so that <ph id="ph1">`sampleDictionary.Text`</ph> is equivalent to <ph id="ph2">`sampleDictionary.text`</ph>.</source>
          <target state="translated">이 구문은 대/소문자 구분, 원하는 또한 있도록 <ph id="ph1">`sampleDictionary.Text`</ph> 같습니다 <ph id="ph2">`sampleDictionary.text`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicDictionary`</ph> class, which is derived from the <ph id="ph2">`DynamicObject`</ph> class.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`DynamicDictionary`</ph> 에서 파생 된 클래스는 <ph id="ph2">`DynamicObject`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>The <ph id="ph1">`DynamicDictionary`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs, and overrides the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to support the new syntax.</source>
          <target state="translated"><ph id="ph1">`DynamicDictionary`</ph> 의 개체를 포함 하는 클래스는 <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> 유형 (<ph id="ph3">`Dictionary(Of String, Object)`</ph> Visual Basic의) 키-값 쌍 및 재정의 저장 하는 <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> 새 구문을 지 원하는 메서드를 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>It also provides a <ph id="ph1">`Count`</ph> property, which shows how many dynamic properties the dictionary contains.</source>
          <target state="translated">또한 제공 된 <ph id="ph1">`Count`</ph> 속성을 보여 주 수 동적 속성 사전에 포함 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For more examples, see <bpt id="p1">[</bpt>Creating Wrappers with DynamicObject<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=169008)</ept> on the C# Frequently Asked Questions blog.</source>
          <target state="translated">더 많은 예제를 참조 하십시오. <bpt id="p1">[</bpt>DynamicObject와 래퍼를 만드는<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=169008)</ept> C# 질문과 대답 블로그.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>Enables derived types to initialize a new instance of the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> type.</source>
          <target state="translated">파생 형식이 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 형식의 새 인스턴스를 초기화할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>You cannot directly create an instance of the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">인스턴스를 직접 만들 수는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>To implement dynamic behavior, you have to inherit from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class and override necessary methods.</source>
          <target state="translated">상속할 필요가 동적 동작을 구현 하려면는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 및 필요한 메서드를 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>In C#, to enable dynamic behavior for instances of the classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class, you must use the <ph id="ph2">`dynamic`</ph> keyword.</source>
          <target state="translated">C#에서는에서 파생 된 클래스의 인스턴스에 대해 동적 동작을 사용 하도록는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 사용 해야 클래스는 <ph id="ph2">`dynamic`</ph> 키워드입니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>For more information, see <bpt id="p1">[</bpt>Using Type dynamic<ept id="p1">](~/docs/csharp/programming-guide/types/using-type-dynamic.md)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>dynamic 형식 사용<ept id="p1">](~/docs/csharp/programming-guide/types/using-type-dynamic.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>In Visual Basic, dynamic operations are supported by late binding.</source>
          <target state="translated">Visual Basic에서 런타임에 바인딩하여 동적 작업은 지원 됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>For more information, see <bpt id="p1">[</bpt>Early and Late Binding<ept id="p1">](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>초기 바인딩 및 런타임에 바인딩<ept id="p1">](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>The following code example demonstrates how to create an instance of classes that are derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">다음 코드 예제에서 파생 된 클래스의 인스턴스를 만드는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
          <source>Returns the enumeration of all dynamic member names.</source>
          <target state="translated">모든 동적 멤버 이름의 열거형을 반환합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
          <source>A sequence that contains dynamic member names.</source>
          <target state="translated">동적 멤버 이름이 들어 있는 시퀀스입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
          <source>This method exists for debugging purposes only.</source>
          <target state="translated">이 메서드는 디버깅 목적 으로만 존재 합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
          <source>The expression that represents <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> to dispatch to the dynamic virtual methods.</source>
          <target state="translated">동적 가상 메서드에 디스패치할 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph>를 나타내는 식입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
          <source>Provides a <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> that dispatches to the dynamic virtual methods.</source>
          <target state="translated">동적 가상 메서드에 디스패치할 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph>를 제공합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
          <source>The object can be encapsulated inside another <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> to provide custom behavior for individual actions.</source>
          <target state="translated">개체를 다른 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> 내에 캡슐화하여 개별 작업에 대해 사용자 지정 동작을 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
          <source>This method supports the Dynamic Language Runtime infrastructure for language implementers and it is not intended to be used directly from your code.</source>
          <target state="translated">이 메서드는 언어 구현자에 대한 동적 언어 런타임 인프라를 지원하며 사용자 코드에서 직접 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
          <source>An object of the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> 형식의 개체입니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Provides information about the binary operation.</source>
          <target state="translated">이항 연산에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Operation<ept id="p1">&lt;/c&gt;</ept> property returns an <ph id="ph1">&lt;see cref="T:System.Linq.Expressions.ExpressionType" /&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>binder.Operation<ept id="p1">&lt;/c&gt;</ept> 속성에서 <ph id="ph1">&lt;see cref="T:System.Linq.Expressions.ExpressionType" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sum = first + second<ept id="p1">&lt;/c&gt;</ept> statement, where <bpt id="p2">&lt;c&gt;</bpt>first<ept id="p2">&lt;/c&gt;</ept> and <bpt id="p3">&lt;c&gt;</bpt>second<ept id="p3">&lt;/c&gt;</ept> are derived from the <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>binder.Operation<ept id="p4">&lt;/c&gt;</ept> returns <bpt id="p5">&lt;c&gt;</bpt>ExpressionType.Add<ept id="p5">&lt;/c&gt;</ept>.</source>
          <target state="translated">예를 들어, <bpt id="p1">&lt;c&gt;</bpt>합계 = 첫 번째 + 두 번째<ept id="p1">&lt;/c&gt;</ept> 문의 경우 여기서 <bpt id="p2">&lt;c&gt;</bpt>첫 번째<ept id="p2">&lt;/c&gt;</ept> 및 <bpt id="p3">&lt;c&gt;</bpt>두 번째<ept id="p3">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> 클래스에서 파생됩니다. <bpt id="p4">&lt;c&gt;</bpt>binder.Operation<ept id="p4">&lt;/c&gt;</ept>은 <bpt id="p5">&lt;c&gt;</bpt>ExpressionType.Add<ept id="p5">&lt;/c&gt;</ept>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The right operand for the binary operation.</source>
          <target state="translated">이항 연산의 오른쪽 피연산자입니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sum = first + second<ept id="p1">&lt;/c&gt;</ept> statement, where <bpt id="p2">&lt;c&gt;</bpt>first<ept id="p2">&lt;/c&gt;</ept> and <bpt id="p3">&lt;c&gt;</bpt>second<ept id="p3">&lt;/c&gt;</ept> are derived from the <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>arg<ept id="p4">&lt;/c&gt;</ept> is equal to <bpt id="p5">&lt;c&gt;</bpt>second<ept id="p5">&lt;/c&gt;</ept>.</source>
          <target state="translated">예를 들어, <bpt id="p1">&lt;c&gt;</bpt>합계 = 첫 번째 + 두 번째<ept id="p1">&lt;/c&gt;</ept> 문의 경우 여기서 <bpt id="p2">&lt;c&gt;</bpt>첫 번째<ept id="p2">&lt;/c&gt;</ept> 및 <bpt id="p3">&lt;c&gt;</bpt>두 번째<ept id="p3">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> 클래스에서 파생됩니다. <bpt id="p4">&lt;c&gt;</bpt>arg<ept id="p4">&lt;/c&gt;</ept>는 <bpt id="p5">&lt;c&gt;</bpt>두 번째<ept id="p5">&lt;/c&gt;</ept>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The result of the binary operation.</source>
          <target state="translated">이항 연산의 결과입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Provides implementation for binary operations.</source>
          <target state="translated">이항 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as addition and multiplication.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 더하기와 곱하기 같은 연산의 동적 동작을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how binary operations should be performed for a dynamic object.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 동적 개체에 대 한 이진 연산을 수행 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>This method is called when you have binary operations such as addition or multiplication.</source>
          <target state="translated">이 메서드는 더하기 나 빼기와 같은 이진 작업이 있을 때 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>For example, if the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> method is overridden, it is automatically invoked for statements like <ph id="ph2">`sum = first + second`</ph> or <ph id="ph3">`multiply = first*second`</ph>, where <ph id="ph4">`first`</ph> is derived from the <ph id="ph5">`DynamicObject`</ph> class.</source>
          <target state="translated">예를 들어 경우는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> 메서드는, 같은 문에 대해 자동으로 호출 <ph id="ph2">`sum = first + second`</ph> 또는 <ph id="ph3">`multiply = first*second`</ph>여기서 <ph id="ph4">`first`</ph> 에서 파생 되는 <ph id="ph5">`DynamicObject`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>You can get information about the type of the binary operation by using the <ph id="ph1">`Operation`</ph> property of the <ph id="ph2">`binder`</ph> parameter.</source>
          <target state="translated">사용 하 여 이진 작업의 형식에 대 한 정보를 읽을 수는 <ph id="ph1">`Operation`</ph> 속성은 <ph id="ph2">`binder`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>If your dynamic object is used only in C# and Visual Basic, the <ph id="ph1">`binder.Operation`</ph> property can have one of the following values from the <ph id="ph2">&lt;xref:System.Linq.Expressions.ExpressionType&gt;</ph> enumeration.</source>
          <target state="translated">C# 및 Visual Basic의 경우에 동적 개체가 사용 되는 경우는 <ph id="ph1">`binder.Operation`</ph> 속성에서 다음 값 중 하나일 수 있습니다는 <ph id="ph2">&lt;xref:System.Linq.Expressions.ExpressionType&gt;</ph> 열거형입니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>However, in other languages such as IronPython or IronRuby, you can have other values.</source>
          <target state="translated">그러나, IronPython, IronRuby 등 다른 언어로 다른 값을 가질 수 있습니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Value</source>
          <target state="translated">값</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>C#</source>
          <target state="translated">C#</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Visual Basic</source>
          <target state="translated">Visual Basic</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An addition operation without overflow checking, for numeric operands.</source>
          <target state="translated">숫자 피연산자에 대 한 오버플로 검사 하지 않고 더하기 연산입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An addition compound assignment operation without overflow checking, for numeric operands.</source>
          <target state="translated">숫자 피연산자에 대 한 오버플로 검사 하지 않고 더하기 복합 할당 작업.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise <ph id="ph1">`AND`</ph> operation.</source>
          <target state="translated">비트 <ph id="ph1">`AND`</ph> 작업 합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise <ph id="ph1">`AND`</ph> compound assignment operation.</source>
          <target state="translated">비트 <ph id="ph1">`AND`</ph> 복합 할당 연산입니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An arithmetic division operation.</source>
          <target state="translated">산술 나누기 연산을 합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An arithmetic division compound assignment operation.</source>
          <target state="translated">산술 나누기 복합 할당 작업입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise <ph id="ph1">`XOR`</ph> operation.</source>
          <target state="translated">비트 <ph id="ph1">`XOR`</ph> 작업 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise <ph id="ph1">`XOR`</ph> compound assignment operation.</source>
          <target state="translated">비트 <ph id="ph1">`XOR`</ph> 복합 할당 연산입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A "greater than" comparison.</source>
          <target state="translated">"보다 큼" 비교 합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A "greater than or equal to" comparison.</source>
          <target state="translated">"보다 크거나" 비교 합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise left-shift operation.</source>
          <target state="translated">비트 왼쪽 시프트 연산입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise left-shift compound assignment operation.</source>
          <target state="translated">비트 왼쪽 시프트 복합 할당 작업입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A "less than" comparison.</source>
          <target state="translated">"보다 작음" 비교 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A "less than or equal to" comparison.</source>
          <target state="translated">"보다 작거나 같음" 비교 합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An arithmetic remainder operation.</source>
          <target state="translated">산술 나머지 연산을 합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An arithmetic remainder compound assignment operation.</source>
          <target state="translated">산술 나머지 복합 할당 작업입니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A multiplication operation without overflow checking, for numeric operands.</source>
          <target state="translated">숫자 피연산자에 대 한 오버플로 검사 하지 않는 곱하기 작업.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A multiplication compound assignment operation without overflow checking, for numeric operands.</source>
          <target state="translated">숫자 피연산자에 대 한 오버플로 검사 하지 않는 곱하기 복합 할당 작업.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An inequality comparison.</source>
          <target state="translated">다름 비교 합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise or logical <ph id="ph1">`OR`</ph> operation.</source>
          <target state="translated">비트 또는 논리 <ph id="ph1">`OR`</ph> 작업 합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise or logical <ph id="ph1">`OR`</ph> compound assignment.</source>
          <target state="translated">비트 또는 논리 <ph id="ph1">`OR`</ph> 복합 할당 합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A mathematical operation of raising a number to a power.</source>
          <target state="translated">숫자의 제곱을 구하는 동작 수학 연산입니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise right-shift operation.</source>
          <target state="translated">비트 오른쪽 시프트 연산입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise right-shift compound assignment operation.</source>
          <target state="translated">비트 오른쪽 시프트 복합 할당 작업입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A subtraction operation without overflow checking, for numeric operands.</source>
          <target state="translated">숫자 피연산자에 대 한 오버플로 검사 하지 않는 빼기 작업.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A subtraction compound assignment operation without overflow checking, for numeric operands.</source>
          <target state="translated">숫자 피연산자에 대 한 오버플로 검사 하지 않는 빼기 복합 할당 작업.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>To implement <ph id="ph1">`OrElse`</ph> (<ph id="ph2">`a || b`</ph>) and <ph id="ph3">`AndAlso`</ph> (<ph id="ph4">`a &amp;&amp; b`</ph>) operations for dynamic objects in C#, you may want to implement both the <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> method and the <ph id="ph6">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> method.</source>
          <target state="translated">구현 하려면 <ph id="ph1">`OrElse`</ph> (<ph id="ph2">`a || b`</ph>) 및 <ph id="ph3">`AndAlso`</ph> (<ph id="ph4">`a &amp;&amp; b`</ph>) C# 동적 개체에 대 한 작업을 만들려는 경우 둘 다 구현는 <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> 메서드 및 <ph id="ph6">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The <ph id="ph1">`OrElse`</ph> operation consists of the unary <ph id="ph2">`IsTrue`</ph> operation and the binary <ph id="ph3">`Or`</ph> operation.</source>
          <target state="translated"><ph id="ph1">`OrElse`</ph> 단항 연산 과정은 <ph id="ph2">`IsTrue`</ph> 작업 및 이진 <ph id="ph3">`Or`</ph> 작업 합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The <ph id="ph1">`Or`</ph> operation is performed only if the result of the <ph id="ph2">`IsTrue`</ph> operation is <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`Or`</ph> 경우에 작업이 수행의 결과 <ph id="ph2">`IsTrue`</ph> 작업이 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The <ph id="ph1">`AndAlso`</ph> operation consists of the unary <ph id="ph2">`IsFalse`</ph> operation and the binary <ph id="ph3">`And`</ph> operation.</source>
          <target state="translated"><ph id="ph1">`AndAlso`</ph> 단항 연산 과정은 <ph id="ph2">`IsFalse`</ph> 작업 및 이진 <ph id="ph3">`And`</ph> 작업 합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The <ph id="ph1">`And`</ph> operation is performed only if the result of the <ph id="ph2">`IsFalse`</ph> operation is <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`And`</ph> 경우에 작업이 수행의 결과 <ph id="ph2">`IsFalse`</ph> 작업이 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Assume that you need a data structure to store textual and numeric representations of numbers, and you want to define basic mathematical operations such as addition and subtraction for such data.</source>
          <target state="translated">숫자의 텍스트 및 숫자 표현을 저장 하는 데이터 구조를 필요 하 고 더하기 및 빼기에 이러한 데이터에 대 한 같은 기본 수치 연산을 정의 하려는 가정 합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicNumber`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`DynamicNumber`</ph> 에서 파생 된 클래스는 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source><ph id="ph1">`DynamicNumber`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> method to enable mathematical operations.</source>
          <target state="translated"><ph id="ph1">`DynamicNumber`</ph> 재정의 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> 메서드 수학 연산을 사용할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>It also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access to the elements.</source>
          <target state="translated">또한 재정의 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> 요소에 액세스할 수 있도록 하는 메서드.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>In this example, only addition and subtraction operations are supported.</source>
          <target state="translated">이 예제에서는 더하기 및 빼기 작업 에서만 지원 됩니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>If you try to write a statement like <ph id="ph1">`resultNumber = firstNumber*secondNumber`</ph>, a run-time exception is thrown.</source>
          <target state="translated">같은 문을 작성 하려는 경우 <ph id="ph1">`resultNumber = firstNumber*secondNumber`</ph>, 런타임에 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>Provides information about the conversion operation.</source>
          <target state="translated">변환 연산에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Type<ept id="p1">&lt;/c&gt;</ept> property provides the type to which the object must be converted.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>binder.Type<ept id="p1">&lt;/c&gt;</ept> 속성은 개체가 변환되어야 하는 형식을 제공합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>For example, for the statement <bpt id="p1">&lt;c&gt;</bpt>(String)sampleObject<ept id="p1">&lt;/c&gt;</ept> in C# (<bpt id="p2">&lt;c&gt;</bpt>CType(sampleObject, Type)<ept id="p2">&lt;/c&gt;</ept> in Visual Basic), where <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> is an instance of the class derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>binder.Type<ept id="p4">&lt;/c&gt;</ept> returns the <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> type.</source>
          <target state="translated">예를 들어 C#에서 <bpt id="p1">&lt;c&gt;</bpt>(String)sampleObject<ept id="p1">&lt;/c&gt;</ept>(Visual Basic에서 <bpt id="p2">&lt;c&gt;</bpt>CType(sampleObject, Type)<ept id="p2">&lt;/c&gt;</ept>) 문의 경우 여기서 <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스의 인스턴스입니다. <bpt id="p4">&lt;c&gt;</bpt>binder.Type<ept id="p4">&lt;/c&gt;</ept>은 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> 형식을 반환합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Explicit<ept id="p1">&lt;/c&gt;</ept> property provides information about the kind of conversion that occurs.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>binder.Explicit<ept id="p1">&lt;/c&gt;</ept> 속성은 발생하는 변환의 종류에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>It returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> for explicit conversion and <ph id="ph2">&lt;see langword="false" /&gt;</ph> for implicit conversion.</source>
          <target state="translated">명시적 변환의 경우 <ph id="ph1">&lt;see langword="true" /&gt;</ph>를 반환하고, 암시적 변환의 경우 <ph id="ph2">&lt;see langword="false" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>The result of the type conversion operation.</source>
          <target state="translated">형식 변환 연산의 결과입니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>Provides implementation for type conversion operations.</source>
          <target state="translated">형식 변환 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations that convert an object from one type to another.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 개체를 한 형식에서 다른 형식으로 변환하는 연산의 동적 동작을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how a type conversion should be performed for a dynamic object.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 동적 개체에 대 한 형식 변환을 수행 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>In C#, if this method is overridden, it is automatically invoked when you have an explicit or implicit conversion, as shown in the code example below.</source>
          <target state="translated">C#에서는이 메서드를 재정의 하는 경우 자동으로 호출 됩니다는 명시적 또는 암시적 변환을 있으면 아래 코드 예제에 표시 된 대로.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>In Visual Basic, only explicit conversion is supported.</source>
          <target state="translated">Visual Basic의 경우 명시적 변환은 지원 됩니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>If you override this method, you call it by using the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A&gt;</ph> or <ph id="ph2">&lt;xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A&gt;</ph> functions.</source>
          <target state="translated">사용 하 여 호출이 메서드를 재정의 하는 경우는 <ph id="ph1">&lt;xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A&gt;</ph> 함수입니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>Assume that you need a data structure to store textual and numeric representations of numbers, and you want to define conversions of this data structure to strings and integers.</source>
          <target state="translated">문자열 및 정수에 변환 이러한 데이터 구조를 정의 하려면 및 숫자의 텍스트 및 숫자 표현을 저장 하는 데이터 구조 된다고 가정 합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicNumber`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`DynamicNumber`</ph> 에서 파생 된 클래스는 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source><ph id="ph1">`DynamicNumber`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryConvert%2A&gt;</ph> method to enable type conversion.</source>
          <target state="translated"><ph id="ph1">`DynamicNumber`</ph> 재정의 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryConvert%2A&gt;</ph> 메서드 형식 변환을 사용할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>It also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access to the data elements.</source>
          <target state="translated">또한 재정의 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> 데이터 요소에 액세스할 수 있도록 하는 메서드.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>In this example, only conversion to strings and integers is supported.</source>
          <target state="translated">이 예제에서는 문자열 및 정수에 변환만 지원 됩니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>If you try to convert an object to any other type, a run-time exception is thrown.</source>
          <target state="translated">개체를 다른 형식으로 변환 하려고 하면 런타임 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>Provides information about the initialization operation.</source>
          <target state="translated">초기화 연산에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>The arguments that are passed to the object during initialization.</source>
          <target state="translated">초기화하는 동안 개체에 전달되는 인수입니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>new SampleType(100)<ept id="p1">&lt;/c&gt;</ept> operation, where <bpt id="p2">&lt;c&gt;</bpt>SampleType<ept id="p2">&lt;/c&gt;</ept> is the type derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept> is equal to 100.</source>
          <target state="translated">예를 들어 <bpt id="p1">&lt;c&gt;</bpt>새 SampleType(100)<ept id="p1">&lt;/c&gt;</ept> 작업의 경우 여기서 <bpt id="p2">&lt;c&gt;</bpt>SampleType<ept id="p2">&lt;/c&gt;</ept>은 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생되는 형식입니다. <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept>는 100과 같습니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>The result of the initialization.</source>
          <target state="translated">초기화의 결과입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>Provides the implementation for operations that initialize a new instance of a dynamic object.</source>
          <target state="translated">동적 개체의 새 인스턴스를 초기화하는 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>This method is not intended for use in C# or Visual Basic.</source>
          <target state="translated">이 메서드는 C# 또는 Visual Basic에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how a new instance of the dynamic object should be initialized.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 동적 개체의 새 인스턴스를 초기화 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>C# and Visual Basic compilers never emit code to use this method because they do not support first-class types.</source>
          <target state="translated">C# 및 Visual Basic 컴파일러는 첫 번째 클래스 형식을 지원 하지 않기 때문에이 메서드를 사용 하는 코드를 내보냅니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>This method is intended for languages that support the initialization of dynamic objects by using syntax like <ph id="ph1">`dynamic new`</ph>.</source>
          <target state="translated">이 메서드를 같은 구문을 사용 하 여 동적 개체의 초기화를 지 원하는 언어에 사용 <ph id="ph1">`dynamic new`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>Provides information about the deletion.</source>
          <target state="translated">삭제에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>The indexes to be deleted.</source>
          <target state="translated">삭제할 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>Provides the implementation for operations that delete an object by index.</source>
          <target state="translated">인덱스별로 개체를 삭제하는 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>This method is not intended for use in C# or Visual Basic.</source>
          <target state="translated">이 메서드는 C# 또는 Visual Basic에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how a value that has a specified index should be deleted.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스는 지정 된 인덱스를 포함 하는 값을 삭제 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>C# and Visual Basic compilers never emit code to use this method because they do not support this kind of operation.</source>
          <target state="translated">C# 및 Visual Basic 컴파일러는 이런이 종류의 작업을 지원 하지 않으므로이 메서드를 사용 하는 코드를 내보냅니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>This method is intended for languages that support syntax for deleting objects by index, such as <ph id="ph1">`del sampleObject[1,2]`</ph> in Python.</source>
          <target state="translated">인덱스로 같은 개체를 삭제 하기 위한 구문을 지 원하는 언어에이 메서드를 사용 하는 <ph id="ph1">`del sampleObject[1,2]`</ph> Python에서 합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>Provides information about the deletion.</source>
          <target state="translated">삭제에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>Provides the implementation for operations that delete an object member.</source>
          <target state="translated">개체 멤버를 삭제하는 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>This method is not intended for use in C# or Visual Basic.</source>
          <target state="translated">이 메서드는 C# 또는 Visual Basic에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how an object member should be deleted.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 개체 멤버를 삭제 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>When this method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 재정의 되지 않은 언어의 런타임 바인더 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>C# and Visual Basic compilers never emit code to use this method because they do not support this kind of operation.</source>
          <target state="translated">C# 및 Visual Basic 컴파일러는 이런이 종류의 작업을 지원 하지 않으므로이 메서드를 사용 하는 코드를 내보냅니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>This method is intended for languages that support syntax for deleting members, such as <ph id="ph1">`del sampleObject.SampleMember`</ph> in Python.</source>
          <target state="translated">이 메서드를 같은 멤버를 삭제 하기 위한 구문을 지 원하는 언어에 사용 <ph id="ph1">`del sampleObject.SampleMember`</ph> Python에서 합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>Provides information about the operation.</source>
          <target state="translated">연산에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>The indexes that are used in the operation.</source>
          <target state="translated">연산에 사용되는 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3]<ept id="p1">&lt;/c&gt;</ept> operation in C# (<bpt id="p2">&lt;c&gt;</bpt>sampleObject(3)<ept id="p2">&lt;/c&gt;</ept> in Visual Basic), where <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>indexes[0]<ept id="p4">&lt;/c&gt;</ept> is equal to 3.</source>
          <target state="translated">예를 들어 C#에서 <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3]<ept id="p1">&lt;/c&gt;</ept>(Visual Basic에서 <bpt id="p2">&lt;c&gt;</bpt>sampleObject(3)<ept id="p2">&lt;/c&gt;</ept>) 작업의 경우 여기서 <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> 클래스에서 파생됩니다. <bpt id="p4">&lt;c&gt;</bpt>indexes[0]<ept id="p4">&lt;/c&gt;</ept>은 3과 같습니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>The result of the index operation.</source>
          <target state="translated">인덱스 연산의 결과입니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>Provides the implementation for operations that get a value by index.</source>
          <target state="translated">인덱스별로 값을 가져오는 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for indexing operations.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 인덱싱 연산의 동적 동작을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>(In most cases, a run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how getting a value by index should be performed for a dynamic object.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 인덱스로 값을 가져올 수행 되는 방식을 동적 개체에 대해 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>(In most cases, a run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>If this method is overridden, it is automatically invoked when you have an operation like <ph id="ph1">`sampleObject[3]`</ph> in C# or <ph id="ph2">`sampleObject(3)`</ph> in Visual Basic, where <ph id="ph3">`sampleObject`</ph> is derived from the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">같은 작업이 있을 때 자동으로 호출 됩니다이 메서드를 재정의 하는 경우 <ph id="ph1">`sampleObject[3]`</ph> C# 또는 <ph id="ph2">`sampleObject(3)`</ph> Visual Basic, where에서 <ph id="ph3">`sampleObject`</ph> 에서 파생 되는 <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>Assume that you want to create an object in which properties can be accessed either by names such as <ph id="ph1">`Property0`</ph>, <ph id="ph2">`Property1`</ph>, and so on, or by index, so that, for example, <ph id="ph3">`sampleObject.Property0`</ph> is equivalent to <ph id="ph4">`sampleObject[0]`</ph> in C# or <ph id="ph5">`sampleObject(0)`</ph> in Visual Basic.</source>
          <target state="translated">가정와 같은 이름을 사용 하거나 액세스할 속성 될 수 있는 개체를 만들 것인지 <ph id="ph1">`Property0`</ph>, <ph id="ph2">`Property1`</ph>등의 또는 인덱스 별로 있도록, 예를 들어 <ph id="ph3">`sampleObject.Property0`</ph> 과 같습니다 <ph id="ph4">`sampleObject[0]`</ph> C# 또는 <ph id="ph5">`sampleObject(0)`</ph> Visual Basic의 합니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`SampleDynamicObject`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`SampleDynamicObject`</ph> 에서 파생 된 클래스는 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>The <ph id="ph1">`SampleDynamicObject`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs.</source>
          <target state="translated"><ph id="ph1">`SampleDynamicObject`</ph> 의 개체를 포함 하는 클래스는 <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> 형식 (<ph id="ph3">`Dictionary(Of String, Object)`</ph> Visual basic에서) 키-값 쌍을 저장 하 합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">`SampleDynamicObject`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TrySetIndex%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TryGetIndex%2A&gt;</ph> methods to enable access by index.</source>
          <target state="translated"><ph id="ph1">`SampleDynamicObject`</ph> 재정의 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TrySetIndex%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TryGetIndex%2A&gt;</ph> 메서드 인덱스로 액세스할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access by property name.</source>
          <target state="translated">재정의 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> 메서드 속성 이름으로 액세스할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Provides information about the object that called the dynamic operation.</source>
          <target state="translated">동적 연산을 호출한 개체에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> property provides the name of the member on which the dynamic operation is performed.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> 속성은 동적 연산이 수행된 멤버의 이름을 제공합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>Console.WriteLine(sampleObject.SampleProperty)<ept id="p1">&lt;/c&gt;</ept> statement, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is an instance of the class derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept> returns "SampleProperty".</source>
          <target state="translated">예를 들어 <bpt id="p1">&lt;c&gt;</bpt>Console.WriteLine(sampleObject.SampleProperty)<ept id="p1">&lt;/c&gt;</ept> 문의 경우 여기서 <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스의 인스턴스입니다. <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept>은 "SampleProperty"를 반환합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> property specifies whether the member name is case-sensitive.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> 속성은 멤버 이름이 대/소문자를 구분하는지 여부를 지정합니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>The result of the get operation.</source>
          <target state="translated">가져오기 연산의 결과입니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>For example, if the method is called for a property, you can assign the property value to <bpt id="p1">&lt;c&gt;</bpt>result<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">예를 들어 속성에 대한 메서드가 호출되면 <bpt id="p1">&lt;c&gt;</bpt>결과<ept id="p1">&lt;/c&gt;</ept>에 속성 값을 할당할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Provides the implementation for operations that get member values.</source>
          <target state="translated">멤버 값을 가져오는 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as getting a value for a property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 속성 값 가져오기와 같은 연산의 동적 동작을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>(In most cases, a run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how operations that get member values should be performed for a dynamic object.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 멤버 값을 가져오는 작업을 동적 개체에 대해 수행 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>(In most cases, a run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>This method is called when you have statements like <ph id="ph1">`Console.WriteLine(sampleObject.SampleProperty)`</ph>, where <ph id="ph2">`sampleObject`</ph> is an instance of the class derived from the <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">이 메서드는 같은 문이 있으면 <ph id="ph1">`Console.WriteLine(sampleObject.SampleProperty)`</ph>여기서 <ph id="ph2">`sampleObject`</ph> 에서 파생 된 클래스의 인스턴스가 <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>You can also add your own members to classes derived from the <ph id="ph1">`DynamicObject`</ph> class.</source>
          <target state="translated">파생 된 클래스에 직접 구성원을 추가할 수도 있습니다는 <ph id="ph1">`DynamicObject`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>If your class defines properties and also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method, the dynamic language runtime (DLR) first uses the language binder to look for a static definition of a property in the class.</source>
          <target state="translated">클래스의 속성 정의 재정의 하는 경우는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 메서드, 동적 언어 런타임 (DLR) 먼저를 사용 하 여 언어 바인더 클래스의 속성에 대 한 정적 정의 찾습니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>If there is no such property, the DLR calls the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method.</source>
          <target state="translated">이러한 속성이 없으면 DLR 호출는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Assume that you want to provide alternative syntax for accessing values in a dictionary, so that instead of writing <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> in Visual Basic), you can write <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</source>
          <target state="translated">쓰기는 대신의 사전에 값에 액세스 하기 위한 대체 구문을 제공 해야 한다고 가정해 보십시오 <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> Visual basic에서)를 작성할 수 있습니다 <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Also, this syntax must be case-insensitive, so that <ph id="ph1">`sampleDictionary.Text`</ph> is equivalent to <ph id="ph2">`sampleDictionary.text`</ph>.</source>
          <target state="translated">또한이 구문은 대/소문자를 구분 해야 있도록 <ph id="ph1">`sampleDictionary.Text`</ph> 같습니다 <ph id="ph2">`sampleDictionary.text`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicDictionary`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`DynamicDictionary`</ph> 에서 파생 된 클래스는 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>The <ph id="ph1">`DynamicDictionary`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs, and overrides the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to support the new syntax.</source>
          <target state="translated"><ph id="ph1">`DynamicDictionary`</ph> 의 개체를 포함 하는 클래스는 <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> 유형 (<ph id="ph3">`Dictionary(Of String, Object)`</ph> Visual Basic의) 키-값 쌍 및 재정의 저장 하는 <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> 새 구문을 지 원하는 메서드를 합니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>It also provides a <ph id="ph1">`Count`</ph> property, which shows how many dynamic properties the dictionary contains.</source>
          <target state="translated">또한 제공 된 <ph id="ph1">`Count`</ph> 속성을 보여 주 수 동적 속성 사전에 포함 합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>Provides information about the invoke operation.</source>
          <target state="translated">호출 연산에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>The arguments that are passed to the object during the invoke operation.</source>
          <target state="translated">호출 연산을 수행하는 동안 개체에 전달되는 인수입니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sampleObject(100)<ept id="p1">&lt;/c&gt;</ept> operation, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept> is equal to 100.</source>
          <target state="translated">예를 들어 <bpt id="p1">&lt;c&gt;</bpt>sampleObject(100)<ept id="p1">&lt;/c&gt;</ept> 작업의 경우 여기서 <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생됩니다. <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept>은 100과 같습니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>The result of the object invocation.</source>
          <target state="translated">개체 호출의 결과입니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>Provides the implementation for operations that invoke an object.</source>
          <target state="translated">개체를 호출하는 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as invoking an object or a delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 개체 또는 대리자 호출과 같은 연산의 동적 동작을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how operations that invoke an object should be performed for a dynamic object.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 개체를 호출 하는 작업을 동적 개체에 대해 수행 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>(In most cases, a run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>If this method is overridden, it is automatically invoked when you have an operation like <ph id="ph1">`sampleObject(100)`</ph>, where <ph id="ph2">`sampleObject`</ph> is derived from the <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">같은 작업이 있을 때 자동으로 호출 됩니다이 메서드를 재정의 하는 경우 <ph id="ph1">`sampleObject(100)`</ph>여기서 <ph id="ph2">`sampleObject`</ph> 에서 파생 되는 <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>The operation for invoking an object is supported in C# but not in Visual Basic.</source>
          <target state="translated">C#에서 있지만 Visual Basic에는 없는 개체를 호출 하기 위한 작업은 지원 됩니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>The Visual Basic compiler never emits code to use this method, and the Visual Basic language does not support syntax like <ph id="ph1">`sampleObject(100)`</ph>.</source>
          <target state="translated">Visual Basic 컴파일러에서이 메서드를 사용 하는 코드를 생성 하지 및 Visual Basic 언어 구문과 비슷한 구문을 지원 하지 않습니다 <ph id="ph1">`sampleObject(100)`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>Assume that you need a data structure to store textual and numeric representations of numbers.</source>
          <target state="translated">숫자를 나타내는 텍스트 및 숫자를 저장 하는 데이터 구조 된다고 가정 합니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>You want to be able to specify the value for each property individually and also to be able to initialize all properties in a single statement.</source>
          <target state="translated">각 속성에 대 한 값을 개별적으로 지정 하 고 단일 문에서 모든 속성을 초기화할 수 있게 되기를 원하는 합니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicNumber`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`DynamicNumber`</ph> 에서 파생 된 클래스는 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">`DynamicNumber`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryInvoke%2A&gt;</ph> method to enable initialization of all properties at one time.</source>
          <target state="translated"><ph id="ph1">`DynamicNumber`</ph> 재정의 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryInvoke%2A&gt;</ph> 메서드를 한 번에 모든 속성의 초기화를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>It also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access to individual object properties.</source>
          <target state="translated">또한 재정의 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> 개별 개체 속성에 액세스할 수 있도록 하는 메서드.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Provides information about the dynamic operation.</source>
          <target state="translated">동적 연산에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> property provides the name of the member on which the dynamic operation is performed.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> 속성은 동적 연산이 수행된 멤버의 이름을 제공합니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>For example, for the statement <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleMethod(100)<ept id="p1">&lt;/c&gt;</ept>, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is an instance of the class derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept> returns "SampleMethod".</source>
          <target state="translated">예를 들어 <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleMethod(100)<ept id="p1">&lt;/c&gt;</ept> 문의 경우 여기서 <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스의 인스턴스입니다. <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept>은 "SampleMethod"를 반환합니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> property specifies whether the member name is case-sensitive.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> 속성은 멤버 이름이 대/소문자를 구분하는지 여부를 지정합니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The arguments that are passed to the object member during the invoke operation.</source>
          <target state="translated">호출 연산을 수행하는 동안 개체 멤버에 전달되는 인수입니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>For example, for the statement <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleMethod(100)<ept id="p1">&lt;/c&gt;</ept>, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept> is equal to 100.</source>
          <target state="translated">예를 들어 <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleMethod(100)<ept id="p1">&lt;/c&gt;</ept> 문의 경우 여기서 <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생됩니다. <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept>은 100과 같습니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The result of the member invocation.</source>
          <target state="translated">멤버 호출의 결과입니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Provides the implementation for operations that invoke a member.</source>
          <target state="translated">멤버를 호출하는 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as calling a method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 메서드 호출과 같은 연산의 동적 동작을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how operations that invoke an object member should be performed for a dynamic object.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 개체 멤버를 호출 하는 작업을 동적 개체에 대해 수행 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>If this method is overridden, it is automatically invoked when you perform an operation like <ph id="ph1">`sampleObject.SampleMethod(100)`</ph>, where <ph id="ph2">`sampleObject`</ph> is derived from the <ph id="ph3">`DynamicObject`</ph> class.</source>
          <target state="translated">같은 작업을 수행 하는 경우 자동으로 호출 됩니다이 메서드를 재정의 하는 경우 <ph id="ph1">`sampleObject.SampleMethod(100)`</ph>여기서 <ph id="ph2">`sampleObject`</ph> 에서 파생 되는 <ph id="ph3">`DynamicObject`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>You can also add your own methods to classes that are derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">파생 된 클래스에 메서드를 추가할 수도 있습니다는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>For example, if you override the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> method, the dynamic dispatch system first attempts to determine whether the specified method exists in the class.</source>
          <target state="translated">예를 들어, 재정의 하는 경우는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> 메서드를 동적 디스패치 시스템이 지정된 된 메서드는 클래스에 존재 하는지 확인 하려면 먼저 시도 합니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>If it does not find the method, it uses the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> implementation.</source>
          <target state="translated">사용 하는 메서드를 찾지 못하면 경우는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> 구현 합니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>This method does not support <ph id="ph1">`ref`</ph> and <ph id="ph2">`out`</ph> parameters.</source>
          <target state="translated">이 방법은 지원 하지 않습니다 <ph id="ph1">`ref`</ph> 및 <ph id="ph2">`out`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>All parameters in the <ph id="ph1">`args`</ph> array are passed by value.</source>
          <target state="translated">모든 매개 변수에 <ph id="ph1">`args`</ph> 배열 값으로 전달 됩니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Assume that you want to provide alternative syntax for accessing values in a dictionary, so that instead of writing <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> in Visual Basic), you can write <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</source>
          <target state="translated">쓰기는 대신의 사전에 값에 액세스 하기 위한 대체 구문을 제공 해야 한다고 가정해 보십시오 <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> Visual basic에서)를 작성할 수 있습니다 <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Also, you want to be able to call all the standard dictionary methods on this dictionary.</source>
          <target state="translated">또한이 사전에서 모든 표준 사전 메서드를 호출할 수 있게 되기를 원하는 합니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicDictionary`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`DynamicDictionary`</ph> 에서 파생 된 클래스는 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The <ph id="ph1">`DynamicDictionary`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs.</source>
          <target state="translated"><ph id="ph1">`DynamicDictionary`</ph> 의 개체를 포함 하는 클래스는 <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> 형식 (<ph id="ph3">`Dictionary(Of String, Object)`</ph> Visual basic에서) 키-값 쌍을 저장 하 합니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> method to support methods of the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> class and overrides the <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to support the new syntax.</source>
          <target state="translated">재정의 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> 의 메서드를 지원 하기 위해 메서드에 <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> 클래스 및 재정의 <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 및 <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> 새 구문을 지 원하는 메서드를 합니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>It also provides a <ph id="ph1">`Print`</ph> method, which prints out all dictionary keys and values.</source>
          <target state="translated">또한 제공는 <ph id="ph1">`Print`</ph> 메서드를 모든 사전 키와 값을 출력 합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>Provides information about the operation.</source>
          <target state="translated">연산에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>The indexes that are used in the operation.</source>
          <target state="translated">연산에 사용되는 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3] = 10<ept id="p1">&lt;/c&gt;</ept> operation in C# (<bpt id="p2">&lt;c&gt;</bpt>sampleObject(3) = 10<ept id="p2">&lt;/c&gt;</ept> in Visual Basic), where <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>indexes[0]<ept id="p4">&lt;/c&gt;</ept> is equal to 3.</source>
          <target state="translated">예를 들어 C#에서 <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3] = 10<ept id="p1">&lt;/c&gt;</ept>(Visual Basic에서 <bpt id="p2">&lt;c&gt;</bpt>sampleObject(3) = 10<ept id="p2">&lt;/c&gt;</ept>) 작업의 경우 여기서 <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생됩니다. <bpt id="p4">&lt;c&gt;</bpt>indexes[0]<ept id="p4">&lt;/c&gt;</ept>은 3과 같습니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>The value to set to the object that has the specified index.</source>
          <target state="translated">지정된 인덱스를 가진 개체로 설정할 값입니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3] = 10<ept id="p1">&lt;/c&gt;</ept> operation in C# (<bpt id="p2">&lt;c&gt;</bpt>sampleObject(3) = 10<ept id="p2">&lt;/c&gt;</ept> in Visual Basic), where <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>value<ept id="p4">&lt;/c&gt;</ept> is equal to 10.</source>
          <target state="translated">예를 들어 C#에서 <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3] = 10<ept id="p1">&lt;/c&gt;</ept>(Visual Basic에서 <bpt id="p2">&lt;c&gt;</bpt>sampleObject(3) = 10<ept id="p2">&lt;/c&gt;</ept>) 작업의 경우 여기서 <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생됩니다. <bpt id="p4">&lt;c&gt;</bpt>값<ept id="p4">&lt;/c&gt;</ept>은 10과 같습니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>Provides the implementation for operations that set a value by index.</source>
          <target state="translated">인덱스별로 값을 설정하는 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations that access objects by a specified index.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 지정된 인덱스별로 개체에 액세스하는 연산의 동적 동작을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>(In most cases, a language-specific run-time exception is thrown.</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how operations that access an object by index should be performed for a dynamic object.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 동적 개체에 대 한 개체 인덱스로 액세스 하는 작업이 수행 되는 방식을 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>If this method is overridden, it is automatically invoked when you have an operation like <ph id="ph1">`sampleObject[3] = 10`</ph> in C# or <ph id="ph2">`sampleObject(3) = 10`</ph> in Visual Basic, where <ph id="ph3">`sampleObject`</ph> is derived from the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">같은 작업이 있을 때 자동으로 호출 됩니다이 메서드를 재정의 하는 경우 <ph id="ph1">`sampleObject[3] = 10`</ph> C# 또는 <ph id="ph2">`sampleObject(3) = 10`</ph> Visual Basic, where에서 <ph id="ph3">`sampleObject`</ph> 에서 파생 되는 <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>Assume that you want to create an object in which properties can be accessed either by names such as <ph id="ph1">`Property0`</ph>, <ph id="ph2">`Property1`</ph>, and so on, or by index, so that, for example, <ph id="ph3">`sampleObject.Property0`</ph> is equivalent to <ph id="ph4">`sampleObject[0]`</ph> in C# or <ph id="ph5">`sampleObject(0)`</ph> in Visual Basic.</source>
          <target state="translated">가정와 같은 이름을 사용 하거나 액세스할 속성 될 수 있는 개체를 만들 것인지 <ph id="ph1">`Property0`</ph>, <ph id="ph2">`Property1`</ph>등의 또는 인덱스 별로 있도록, 예를 들어 <ph id="ph3">`sampleObject.Property0`</ph> 과 같습니다 <ph id="ph4">`sampleObject[0]`</ph> C# 또는 <ph id="ph5">`sampleObject(0)`</ph> Visual Basic의 합니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>The following code example demonstrates the <ph id="ph1">`SampleDynamicObject`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`SampleDynamicObject`</ph> 에서 파생 된 클래스는 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>The <ph id="ph1">`SampleDynamicObject`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs.</source>
          <target state="translated"><ph id="ph1">`SampleDynamicObject`</ph> 의 개체를 포함 하는 클래스는 <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> 형식 (<ph id="ph3">`Dictionary(Of String, Object)`</ph> Visual basic에서) 키-값 쌍을 저장 하 합니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source><ph id="ph1">`SampleDynamicObject`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TrySetIndex%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TryGetIndex%2A&gt;</ph> methods to enable access by index.</source>
          <target state="translated"><ph id="ph1">`SampleDynamicObject`</ph> 재정의 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TrySetIndex%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TryGetIndex%2A&gt;</ph> 메서드 인덱스로 액세스할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access by property name.</source>
          <target state="translated">재정의 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> 메서드 속성 이름으로 액세스할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Provides information about the object that called the dynamic operation.</source>
          <target state="translated">동적 연산을 호출한 개체에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> property provides the name of the member to which the value is being assigned.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> 속성은 값이 할당될 멤버의 이름을 제공합니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>For example, for the statement <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleProperty = "Test"<ept id="p1">&lt;/c&gt;</ept>, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is an instance of the class derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept> returns "SampleProperty".</source>
          <target state="translated">예를 들어 <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleProperty = "Test"<ept id="p1">&lt;/c&gt;</ept> 문의 경우 여기서 <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스의 인스턴스입니다. <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept>은 "SampleProperty"를 반환합니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> property specifies whether the member name is case-sensitive.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> 속성은 멤버 이름이 대/소문자를 구분하는지 여부를 지정합니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>The value to set to the member.</source>
          <target state="translated">멤버에 설정할 값입니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>For example, for <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleProperty = "Test"<ept id="p1">&lt;/c&gt;</ept>, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is an instance of the class derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, the <bpt id="p3">&lt;c&gt;</bpt>value<ept id="p3">&lt;/c&gt;</ept> is "Test".</source>
          <target state="translated">예를 들어 <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleProperty = "Test"<ept id="p1">&lt;/c&gt;</ept>의 경우 여기서 <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스의 인스턴스입니다. <bpt id="p3">&lt;c&gt;</bpt>값<ept id="p3">&lt;/c&gt;</ept>은 "Test"를 반환합니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Provides the implementation for operations that set member values.</source>
          <target state="translated">멤버 값을 설정하는 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as setting a value for a property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 속성 값 설정과 같은 연산의 동적 동작을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how operations that set a value to a member should be performed for a dynamic object.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 멤버에 값을 설정 하는 작업 동적 개체에 대해 수행 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>This method is called when you have statements like <ph id="ph1">`sampleObject.SampleProperty = "Test"`</ph>, where <ph id="ph2">`sampleObject`</ph> is an instance of the class that is derived from the <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">이 메서드는 같은 문이 있으면 <ph id="ph1">`sampleObject.SampleProperty = "Test"`</ph>여기서 <ph id="ph2">`sampleObject`</ph> 에서 파생 된 클래스의 인스턴스가 <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>You can also add your own members to classes derived from the <ph id="ph1">`DynamicObject`</ph> class.</source>
          <target state="translated">파생 된 클래스에 직접 구성원을 추가할 수도 있습니다는 <ph id="ph1">`DynamicObject`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>If your class defines properties and also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method, the dynamic language runtime (DLR) first uses the language binder to look for a static definition of a property in the class.</source>
          <target state="translated">클래스의 속성 정의 재정의 하는 경우는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 메서드, 동적 언어 런타임 (DLR) 먼저를 사용 하 여 언어 바인더 클래스의 속성에 대 한 정적 정의 찾습니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>If there is no such property, the DLR calls the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method.</source>
          <target state="translated">이러한 속성이 없으면 DLR 호출는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Assume that you want to provide alternative syntax for accessing values in a dictionary, so that instead of writing <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> in Visual Basic), you can write <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</source>
          <target state="translated">쓰기는 대신의 사전에 값에 액세스 하기 위한 대체 구문을 제공 해야 한다고 가정해 보십시오 <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> Visual basic에서)를 작성할 수 있습니다 <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Also, this syntax must be case-insensitive, so that <ph id="ph1">`sampleDictionary.Text`</ph> is equivalent to <ph id="ph2">`sampleDictionary.text`</ph>.</source>
          <target state="translated">또한이 구문은 대/소문자를 구분 해야 있도록 <ph id="ph1">`sampleDictionary.Text`</ph> 같습니다 <ph id="ph2">`sampleDictionary.text`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicDictionary`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`DynamicDictionary`</ph> 에서 파생 된 클래스는 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>The <ph id="ph1">`DynamicDictionary`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs, and overrides the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to support the new syntax.</source>
          <target state="translated"><ph id="ph1">`DynamicDictionary`</ph> 의 개체를 포함 하는 클래스는 <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> 유형 (<ph id="ph3">`Dictionary(Of String, Object)`</ph> Visual Basic의) 키-값 쌍 및 재정의 저장 하는 <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> 새 구문을 지 원하는 메서드를 합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>It also provides a <ph id="ph1">`Count`</ph> property, which shows how many dynamic properties the dictionary contains.</source>
          <target state="translated">또한 제공 된 <ph id="ph1">`Count`</ph> 속성을 보여 주 수 동적 속성 사전에 포함 합니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Provides information about the unary operation.</source>
          <target state="translated">단항 연산에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Operation<ept id="p1">&lt;/c&gt;</ept> property returns an <ph id="ph1">&lt;see cref="T:System.Linq.Expressions.ExpressionType" /&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>binder.Operation<ept id="p1">&lt;/c&gt;</ept> 속성에서 <ph id="ph1">&lt;see cref="T:System.Linq.Expressions.ExpressionType" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>negativeNumber = -number<ept id="p1">&lt;/c&gt;</ept> statement, where <bpt id="p2">&lt;c&gt;</bpt>number<ept id="p2">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>binder.Operation<ept id="p3">&lt;/c&gt;</ept> returns "Negate".</source>
          <target state="translated">예를 들어 <bpt id="p1">&lt;c&gt;</bpt>negativeNumber = -number<ept id="p1">&lt;/c&gt;</ept> 문의 경우 여기서 <bpt id="p2">&lt;c&gt;</bpt>번호<ept id="p2">&lt;/c&gt;</ept>는 <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> 클래스에서 파생됩니다. <bpt id="p3">&lt;c&gt;</bpt>binder.Operation<ept id="p3">&lt;/c&gt;</ept>은 "Negate"를 반환합니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The result of the unary operation.</source>
          <target state="translated">단항 연산의 결과입니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Provides implementation for unary operations.</source>
          <target state="translated">단항 연산에 대한 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as negation, increment, or decrement.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 부정, 증가 또는 감소와 같은 연산의 동적 동작을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업에 성공하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">이 메서드가 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how unary operations should be performed for a dynamic object.</source>
          <target state="translated">클래스에서 파생 되는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스 동적 개체에 대 한 단항 연산을 수행 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">대부분의 경우 언어별 런타임 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>This method is called when you have unary operations such as negation, increment, or decrement.</source>
          <target state="translated">이 메서드는 부정, 증분, 같은 단항 연산 했거나 감소 시킬 때 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>For example, if the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> method is overridden, this method is automatically invoked for statements like <ph id="ph2">`negativeNumber = -number`</ph>, where <ph id="ph3">`number`</ph> is derived from the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">예를 들어 경우는 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> 메서드는,이 메서드는 같은 문에 대해에 자동으로 호출 됩니다 <ph id="ph2">`negativeNumber = -number`</ph>여기서 <ph id="ph3">`number`</ph> 에서 파생 되는 <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>You can get information about the type of the unary operation by using the <ph id="ph1">`Operation`</ph> property of the <ph id="ph2">`binder`</ph> parameter.</source>
          <target state="translated">사용 하 여 단항 연산의 유형에 대 한 정보를 가져올 수 있습니다는 <ph id="ph1">`Operation`</ph> 의 속성은 <ph id="ph2">`binder`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>If your dynamic object is used only in C# and Visual Basic, the <ph id="ph1">`binder.Operation`</ph> property can have one of the following values from the <ph id="ph2">&lt;xref:System.Linq.Expressions.ExpressionType&gt;</ph> enumeration.</source>
          <target state="translated">C# 및 Visual Basic의 경우에 동적 개체가 사용 되는 경우는 <ph id="ph1">`binder.Operation`</ph> 속성에서 다음 값 중 하나일 수 있습니다는 <ph id="ph2">&lt;xref:System.Linq.Expressions.ExpressionType&gt;</ph> 열거형입니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>However, in other languages such as IronPython or IronRuby, you can have other values.</source>
          <target state="translated">그러나, IronPython, IronRuby 등 다른 언어로 다른 값을 가질 수 있습니다.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Value</source>
          <target state="translated">값</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>C#</source>
          <target state="translated">C#</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Visual Basic</source>
          <target state="translated">Visual Basic</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A unary decrement operation.</source>
          <target state="translated">단항 감소 작업입니다.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A unary increment operation.</source>
          <target state="translated">단항 증가 연산입니다.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>An arithmetic negation.</source>
          <target state="translated">산술 부정입니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A logical negation.</source>
          <target state="translated">논리 부정입니다.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A ones complement.</source>
          <target state="translated">구성을 보완 합니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A false condition value.</source>
          <target state="translated">False 조건 값입니다.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A true condition value.</source>
          <target state="translated">True 조건이 값입니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A unary plus.</source>
          <target state="translated">단항 더하기입니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>To implement <ph id="ph1">`OrElse`</ph> (<ph id="ph2">`a || b`</ph>) and <ph id="ph3">`AndAlso`</ph> (<ph id="ph4">`a &amp;&amp; b`</ph>) operations for dynamic objects in C#, you may want to implement both the <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> method and the <ph id="ph6">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> method.</source>
          <target state="translated">구현 하려면 <ph id="ph1">`OrElse`</ph> (<ph id="ph2">`a || b`</ph>) 및 <ph id="ph3">`AndAlso`</ph> (<ph id="ph4">`a &amp;&amp; b`</ph>) C# 동적 개체에 대 한 작업을 만들려는 경우 둘 다 구현는 <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> 메서드 및 <ph id="ph6">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The <ph id="ph1">`OrElse`</ph> operation consists of the unary <ph id="ph2">`IsTrue`</ph> operation and the binary <ph id="ph3">`Or`</ph> operation.</source>
          <target state="translated"><ph id="ph1">`OrElse`</ph> 단항 연산 과정은 <ph id="ph2">`IsTrue`</ph> 작업 및 이진 <ph id="ph3">`Or`</ph> 작업 합니다.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The <ph id="ph1">`Or`</ph> operation is performed only if the result of the <ph id="ph2">`IsTrue`</ph> operation is <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`Or`</ph> 경우에 작업이 수행의 결과 <ph id="ph2">`IsTrue`</ph> 작업이 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The <ph id="ph1">`AndAlso`</ph> operation consists of the unary <ph id="ph2">`IsFalse`</ph> operation and the binary <ph id="ph3">`And`</ph> operation.</source>
          <target state="translated"><ph id="ph1">`AndAlso`</ph> 단항 연산 과정은 <ph id="ph2">`IsFalse`</ph> 작업 및 이진 <ph id="ph3">`And`</ph> 작업 합니다.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The <ph id="ph1">`And`</ph> operation is performed only if the result of the <ph id="ph2">`IsFalse`</ph> operation is <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`And`</ph> 경우에 작업이 수행의 결과 <ph id="ph2">`IsFalse`</ph> 작업이 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Assume that you need a data structure to store textual and numeric representations of numbers, and you want to define a mathematical negation operation for such data.</source>
          <target state="translated">이러한 데이터에 대 한 산술 부정 연산을 정의 하려는 및 숫자의 텍스트 및 숫자 표현을 저장 하는 데이터 구조 된다고 가정 합니다.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicNumber`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`DynamicNumber`</ph> 에서 파생 된 클래스는 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source><ph id="ph1">`DynamicNumber`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> method to enable the mathematical negation operation.</source>
          <target state="translated"><ph id="ph1">`DynamicNumber`</ph> 재정의 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> 메서드 산술 부정 연산을 사용할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Is also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access to the elements.</source>
          <target state="translated">재정의 이기도 <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> 요소에 액세스할 수 있도록 하는 메서드.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>In this example, only the mathematical negation operation is supported.</source>
          <target state="translated">이 예제에서는 산술 부정 연산은 지원 됩니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>If you try to write a statement like <ph id="ph1">`negativeNumber = +number`</ph>, a run-time exception occurs.</source>
          <target state="translated">같은 문을 작성 하려는 경우 <ph id="ph1">`negativeNumber = +number`</ph>, 런타임 예외가 발생 합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>