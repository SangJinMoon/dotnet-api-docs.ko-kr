<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1d09a8a36ecb9900234c91bab02a146b88a0f72a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36471956" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>복소수를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복소수는 실수 부분과 허수 부분을 구성 하는입니다. 복소수 z 보통 z 형태로 작성 = x + yi, 여기서 *x* 및 *y* 는 실시간 숫자 및 *i* 는 속성이 있는 허수 단위 *i* <sup>2</sup> =-1입니다. 복소수의 실수 부분으로 표시 됩니다 *x*, 고 있는 복소수의 허수 부분으로 표현 됩니다 *y*합니다.  
  
 <xref:System.Numerics.Complex> 데카르트 좌표계 (real 가공)을 사용 하 여 형식 인스턴스화 및 복소수를 조작 하는 경우. 복소수는 복합 평면의 라고 하는 2 차원 좌표 시스템의 요소로 나타낼 수 있습니다. X 축 (가로 축)에 있는 복소수의 실수 부분 놓이고 허수 부분 (세로 축) y 축에 배치 됩니다.  
  
 복합 평면의 중에 표현할 수 있습니다를 사용 하 여 극좌표 형 좌표계, 극좌표에서의 절대 값에 따라, 점을 두 숫자의 특징은:  
  
-   크기에 원점 으로부터 점의 거리입니다 (즉, 0, 0, 또는 x 축과 y 축 교차 하는 지점)입니다.  
  
-   단계는 실제 축과 지점에는 원본에서 가져온 선 사이의 각도입니다.  
  
## <a name="instantiating-a-complex-number"></a>복소수 인스턴스화  
 다음 방법 중 하나를 복소수로 값을 할당할 수 있습니다.  
  
-   두 전달 하 여 <xref:System.Double> 해당 생성자에는 값입니다. 첫 번째 값 있는 복소수의 실수 부분을 나타내고 두 번째 값 허수 부분을 나타냅니다. 이러한 값 2 차원 데카르트 좌표계에 복잡 한 수의 위치를 나타냅니다.  
  
-   정적을 호출 하 여 (`Shared` Visual basic에서) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> 극좌표에서 복소수를 만드는 메서드를 합니다.  
  
-   할당 하 여 한 <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, 또는 <xref:System.Double> 값을 <xref:System.Numerics.Complex> 개체입니다. 복소수의 실수 부분은 되 고 허수 부분이 0입니다.  
  
-   캐스팅 (C#) 또는 변환 (Visual Basic의 경우)으로 <xref:System.Decimal> 또는 <xref:System.Numerics.BigInteger> 값을 한 <xref:System.Numerics.Complex> 개체입니다. 복소수의 실수 부분은 되 고 허수 부분이 0입니다.  
  
-   메서드 또는 연산자에서 반환 되는 복소수를 할당 하 여 한 <xref:System.Numerics.Complex> 개체입니다. 예를 들어 <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> 복잡 한 숫자는 두 개의 복소수의 합계를 반환 하는 정적 메서드는 및 <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> 연산자는 두 개의 복소수를 추가 하 고 결과 반환 합니다.  
  
 다음 예제에서는 5 개의 복소수에 값을 할당 방법은 각를 보여 줍니다.  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a>복소수를 사용 하 여 작업  
 <xref:System.Numerics.Complex> .NET Framework의 구조는 다음과 같은 기능을 제공 하는 멤버를 포함 합니다.  
  
-   두 복소수가 같은지 여부를 비교 하는 메서드.  
  
-   복소수에 산술 연산을 수행 하는 연산자입니다. <xref:System.Numerics.Complex> 연산자를 사용 하 여 더하기, 빼기, 곱하기, 나누기, 및 단항 부정 연산자 복소수를 수행할 수 있습니다.  
  
-   복소수에서 다른 숫자 작업을 수행 하는 메서드. 4 개의 기본 산술 연산을 복소수의 지정한 지 수, 된 복소수의 제곱근을 복소수의 절대 값을 가져옵니다.  
  
-   복소수에서 삼각 작업을 수행 하는 메서드. 예를 들어 복잡 한 수로 표시 된 각도의 탄젠트 값을 계산할 수 있습니다.  
  
 때문에 <xref:System.Numerics.Complex.Real%2A> 및 <xref:System.Numerics.Complex.Imaginary%2A> 속성이 읽기 전용인 지, 기존 값을 수정할 수 없습니다 <xref:System.Numerics.Complex> 개체입니다.  작업을 수행 하는 모든 메서드는 <xref:System.Numerics.Complex> 숫자, 해당 반환 값 형식이 면 <xref:System.Numerics.Complex>, 새 반환 <xref:System.Numerics.Complex> 번호입니다.  
  
## <a name="precision-and-complex-numbers"></a>전체 자릿수와 복소수  
 복소수의 실수 및 허수 부분 두 개의 배정밀도 부동 소수점 값으로 표현 됩니다. 즉 <xref:System.Numerics.Complex> 배정밀도 부동 소수점 값을 같은 값을 숫자 작업 결과 정밀도 떨어질 수 있습니다. 즉의 같음 비교 <xref:System.Numerics.Complex> 값 정밀도의 손실 두 값 사이의 차이가 있는 경우에 실패할 수 있습니다. 자세한 내용은 <xref:System.Double>을 참조하세요.  
  
 예를 들어 숫자의 로그에 지 수 연산을 수행 하면 원래 번호가 반환 해야 합니다. 그러나 경우에 따라 부동 소수점 값의 자릿수 손실이 발생할 수 두 값 간에 약간의 차이가 다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 마찬가지로, 다음 예제에서는의 제곱근을 계산 하는 <xref:System.Numerics.Complex> 숫자, 32 비트 및 IA64 버전의.NET Framework에서 조금 다른 결과 생성 합니다.  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a>복소수, 무한대 및 NaN  
 복소수의 실수 및 허수 부분으로 표현 됩니다 <xref:System.Double> 값입니다. 범위의 외에도 <xref:System.Double.MinValue?displayProperty=nameWithType> 를 <xref:System.Double.MaxValue?displayProperty=nameWithType>, 복소수 또는 허수 부분의 값을 가질 수 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType>합니다. <xref:System.Double.PositiveInfinity?displayProperty=nameWithType><xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 및 <xref:System.Double.NaN?displayProperty=nameWithType> 모두 산술 또는 삼각 하는 모든 작업에 전파 합니다.  
  
 다음 예에서으로 나누기 <xref:System.Numerics.Complex.Zero> 둘 다 실수 및 허수 부분으로 이루어진는 복소수를 생성 <xref:System.Double.NaN?displayProperty=nameWithType>합니다. 결과적으로,이 값으로 곱하기를 수행도 생성 복소수는 실수 및 허수 부분으로 이루어진 <xref:System.Double.NaN?displayProperty=nameWithType>합니다. 마찬가지로,의 범위를 오버플로 하는 곱하기를 수행 된 <xref:System.Double> 실수부 복소수를 생성 하는 형식 <xref:System.Double.NaN?displayProperty=nameWithType> 허수부 이며 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 실수부 복소수 반환 나누기가 복소수를 수행 하면 이후에 <xref:System.Double.NaN?displayProperty=nameWithType> 허수부 이며 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 복소수는 유효 하지 않도록 또는 범위를 오버플로 하는 수치 연산에서 <xref:System.Double> 데이터 형식은 예외를 throw 하지 않습니다. 대신, 반환 되는 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType> 다음과 같은 경우:  
  
-   0 리턴으로으로 양의 숫자를 나누기 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.  
  
-   상한은 오버플로 하는 모든 작업은 <xref:System.Double> 데이터 형식 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.  
  
-   음수 0 리턴으로 나누기 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.  
  
-   하 한 범위를 오버플로 하는 모든 작업은 <xref:System.Double> 데이터 형식 반환 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.  
  
-   0으로 나누기 반환 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.  
  
-   해당 값은 피연산자에서 수행 하는 모든 작업 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType> 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType>특정 작업에 따라 합니다.  
  
 이 메서드가 수행 하는 모든 중간 계산에 적용 되도록 note 합니다. 예를 들어 곱셈 `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` 는 수식을 사용 하 여 (ac-bd) + (ad + bc) i. 곱셈의 결과로 생성 되는 실수 구성 요소에 대 한 계산 식이 9e308 평가 * 2.5-9e308 * 3.5. 이 식의 각 중간 곱하기 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, 및를 빼는 시도 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 에서 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 반환 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.  
  
## <a name="formatting-a-complex-number"></a>복소수 서식 지정  
 기본적으로 복잡 한 수의 문자열 표현 형식은 `(` *실제* `,` *허수*`)`여기서 *실제* 및 *허수* 의 문자열 표현은 <xref:System.Double> 복소수의 실수 및 허수 구성 요소를 구성 하는 값입니다. 오버 로드는 <xref:System.Numerics.Complex.ToString%2A> 메서드 이러한의 문자열 표현 사용자 지정할 수 있도록 <xref:System.Double> 값을 특정 문화권의 서식 지정 규칙을 반영 하거나를 표준 또는 사용자 지정 숫자에 정의 된 특정 형식에 표시 하려면 서식 문자열입니다. (자세한 내용은 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
 복잡 한 수의 문자열 표현을 표현 하는 일반적인 방법 중 하나는 a + bi, 여기서는 복소수의 실수 구성 요소 이며 b는 복소수의 허수 구성 요소입니다. 전기 공학 복소수 가장 일반적으로으로 표시 되는 + bj 합니다. 이 두 형식 중 하나에 복잡 한 수의 문자열 표현을 반환할 수 있습니다. 이 수행 하려면 사용자 지정 형식 공급자를 구현 하 여 정의 된 <xref:System.ICustomFormatter> 및 <xref:System.IFormatProvider> 인터페이스 및 호출 합니다는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 메서드.  
  
 다음 예제에서는 정의 `ComplexFormatter` 형식에서 문자열로 복소수를 나타내는 클래스 a + bi 또는 + bj 합니다.  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 다음 예제에서는 다음이 사용자 지정 포맷터를 사용 하 여 복잡 한 수의 문자열 표현을 표시 합니다.  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">복소수의 실수 부분입니다.</param>
        <param name="imaginary">복소수의 허수 부분입니다.</param>
        <summary>지정된 실수 값과 허수 값을 사용하여 <see cref="T:System.Numerics.Complex" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `real` 또는 `imaginary` 인수는 명시적 캐스트를 필요로 하는 데이터 형식인 경우 정밀도 떨어질 수 <xref:System.Double>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 복소수를 인스턴스화하고 더하기, 빼기, 곱하기 및 나누기 연산에서 사용 하 여 합니다.  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>복소수의 절대 값 또는 크기를 가져옵니다.</summary>
        <returns>
          <paramref name="value" />의 절대값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복소수의 절대 값은 해당 <xref:System.Numerics.Complex.Magnitude%2A> 속성입니다. 숫자는 실수의 절대값을 + bi 다음과 같이 계산 됩니다.  
  
-   경우 b = 0 이면 결과 0입니다.  
  
-   경우는 > b, 결과는 *<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).  
  
-   경우 b > a, 결과 b * <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).  
  
 절대 값의 계산 결과 오버플로가 발생 하는 경우 메서드 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다. 경우는 <xref:System.Numerics.Complex.Real%2A> 또는 <xref:System.Numerics.Complex.Imaginary%2A> 속성은 <xref:System.Double.NaN?displayProperty=nameWithType> 다른 속성이 고 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 나 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 메서드가 반환 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예에서는 복소수의 절대값을 계산 하 고이의 값에 해당 하는 <xref:System.Numerics.Complex.Magnitude%2A> 속성입니다.  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">코사인을 나타내는 복소수입니다.</param>
        <summary>지정된 복소수의 아크코사인인 각도를 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 아크코사인인 각도인, 라디안 단위로 측정됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Acos%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Acos%2A?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 <xref:System.Numerics.Complex.Acos%2A> 메서드는 다음 수식을 사용 합니다.  
  
 (-<xref:System.Numerics.Complex.ImaginaryOne>) * <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` * `value`)))    
  
   
  
## Examples  
 다음 예제는 <xref:System.Numerics.Complex.Acos%2A> 메서드. 반환 된 값을 전달 해당 표시는 <xref:System.Numerics.Complex.Acos%2A> 메서드를는 <xref:System.Numerics.Complex.Cos%2A> 메서드 반환 원래 <xref:System.Numerics.Complex> 값입니다.  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">더할 첫 번째 복소수입니다.</param>
        <param name="right">더할 두 번째 복소수입니다.</param>
        <summary>두 개의 복소수를 더한 후 결과를 반환합니다.</summary>
        <returns>
          <paramref name="left" />와 <paramref name="right" />의 합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복잡 한 추가 a + bi, 번호 및 두 번째 복소수입니다, c + di를 다음과 같은 형식을 사용 합니다.  
  
 (a + c) + (b + d) i.  
  
 구성 요소의 값은 메서드 호출 결과 또는 허수 구성 요소에서 오버플로가 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.  
  
 사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수는 <xref:System.Numerics.Complex.Add%2A> 메서드 복소수를 사용 하 여 추가 수행 하도록 합니다.  
  
   
  
## Examples  
 다음 예제 복소수가 사용 하 여 추가입니다.  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>지정된 복소수의 아크사인인 각도를 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 아크사인인 각도입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Asin%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Asin%2A?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 <xref:System.Numerics.Complex.Asin%2A> 메서드는 다음 수식을 사용 합니다.  
  
 -<xref:System.Numerics.Complex.ImaginaryOne> * <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> * 값 + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -값 * 값))    
  
   
  
## Examples  
 다음 예제는 <xref:System.Numerics.Complex.Asin%2A> 메서드. 반환 된 값을 전달 해당 표시는 <xref:System.Numerics.Complex.Asin%2A> 메서드를는 <xref:System.Numerics.Complex.Sin%2A> 메서드 반환 원래 <xref:System.Numerics.Complex> 값입니다.  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>지정된 복소수의 아크탄젠트인 각도를 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 아크탄젠트인 각도입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Atan%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Atan%2A?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 <xref:System.Numerics.Complex.Atan%2A> 메서드는 다음 수식을 사용 합니다.  
  
 <xref:System.Numerics.Complex.ImaginaryOne> 새 / 복합 (2.0, 0.0)) * (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> * 값)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne * 값)   
  
   
  
## Examples  
 다음 예제는 <xref:System.Numerics.Complex.Atan%2A> 메서드. 반환 된 값을 전달 해당 표시는 <xref:System.Numerics.Complex.Atan%2A> 메서드를는 <xref:System.Numerics.Complex.Tan%2A> 메서드 반환 원래 <xref:System.Numerics.Complex> 값입니다.  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>복소수의 켤레 복소수를 계산한 후 결과를 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 켤레 복소수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복소수의 켤레 허수 구성 요소; 부호 반전 즉, 허수 구성 요소에 단항 부정 연산자를 적용합니다. 경우는 + bi는 복소수, 켤레 복소수는 a-bi 합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 복소수의 켤레 복소수를 표시합니다.  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>지정된 복소수의 코사인을 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 코사인입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Cos%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Cos%2A?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 <xref:System.Numerics.Complex.Cos%2A> 메서드는 복소수의 코사인을 계산 하는 다음 수식을 사용 a + bi:  
  
 (<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))  
  
   
  
## Examples  
 다음 예제는 <xref:System.Numerics.Complex.Acos%2A> 메서드. 반환 된 값을 전달 해당 표시는 <xref:System.Numerics.Complex.Acos%2A> 메서드를는 <xref:System.Numerics.Complex.Cos%2A> 메서드 반환 원래 <xref:System.Numerics.Complex> 값입니다.  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>지정된 복소수의 하이퍼볼릭 코사인을 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 쌍곡선 코사인입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Cosh%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Cosh%2A?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 <xref:System.Numerics.Complex.Cosh%2A> 메서드 복소수의 쌍 곡 코사인을 계산 하는 다음 수식을 사용 a + bi:  
  
 (<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">나눌 복소수입니다.</param>
        <param name="divisor">값을 나눌 복소수입니다.</param>
        <summary>한 복소수를 다른 복소수로 나눈 후 결과를 반환합니다.</summary>
        <returns>나누기의 몫입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복소수를 나누기는 두 번째 복소수입니다, 숫자, c + di를 하 여 bi 형식은 +:  
  
 ((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i  
  
 몫 계산 또는 허수 구성 요소에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.  
  
 <xref:System.Numerics.Complex.Divide%2A> 메서드를 사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수 있습니다. 해당 동작은 나누기 나누기 연산자를 사용 하는 것과 같습니다.  
  
   
  
## Examples  
 다음 예제 복소수가 배열의 각 요소에 의해 복소수를 나눕니다.  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>두 복소수가 같은지 여부를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">비교할 복소수입니다.</param>
        <summary>현재 인스턴스와 지정된 복소수의 값이 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>이 복소수와 <paramref name="value" />가 동일한 값을 가지면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드는 <xref:System.IEquatable%601> 에 대 한 구현을 <xref:System.Numerics.Complex> 구조입니다. 성능이 약간 보다 더 나은 <xref:System.Numerics.Complex.Equals%28System.Object%29> 메서드는 매개 변수를 복소수로 변환할 필요가 없기 때문에 있습니다.  
  
 두 복소수의 실수 부분 같은지 및 허수 부분이 경우 같습니다. <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 다음 식으로는 것과 같습니다.  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>사용 하 여는 <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> 주의 해 서 사용 하 여 메서드 명백히 같은 두 개의 값 때문에 간주 될 수 있습니다 정밀도 실수 및 허수 구성 요소 차이 같지 않은 것입니다. 다음 예제에서는 <c>(3.33333, 0.142857)</c> 및 <c>(10/3, 1/7)</c> 같지 않습니다.  [! code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [! code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  권장 방법은 두 값 간의 차이 허용 가능한 오차를 정의 하는 것 (같은. 값의 실수 및 허수 구성 요소 중 하나의 01%) 값이 같은지를 비교 하는 대신 합니다. 두 값 간의 차이의 절대 값 보다 작거나 동일한 경우 차이점은 정밀도의 차이로 인해 발생 가능성이 며 따라서 값 않습니다과 같아야 합니다. 다음 예제에서는이 방법의 사용 하 여 이전 코드 예제에서는 동일 하지 않은 것으로 확인 하는 두 개의 복소수 값을 비교 합니다. 동일한 두 개의 복소수를 찾습니다.  [! code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [! code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">비교할 개체입니다.</param>
        <summary>현재 인스턴스와 지정된 개체의 값이 같은지를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="obj" /> 매개 변수가 <see cref="T:System.Numerics.Complex" /> 개체이거나 <see cref="T:System.Numerics.Complex" /> 개체로 암시적 변환이 가능한 형식이고 해당 값이 현재 <see cref="T:System.Numerics.Complex" /> 개체의 값과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두 복소수의 실수 부분 같은지 및 허수 부분이 경우 같습니다. <xref:System.Numerics.Complex.Equals%28System.Object%29> 다음 식으로는 것과 같습니다.  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 경우는 `obj` 매개 변수가 않습니다는 <xref:System.Numerics.Complex> 개체를 변환 하는 암시적 변환을 정의 된 데이터 형식이 <xref:System.Numerics.Complex.Equals%28System.Object%29> 메서드 변환 `obj` 에 <xref:System.Numerics.Complex> 실제 부분은 의값과같은개체`obj`고 비교를 수행 하기 전에 가상 부분은 0입니다. 다음 예는 복소수와 배정밀도 부동 소수점 값이 같은지를 검색 하 여이 보여줍니다.  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>사용 하 여는 <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> 주의 해 서 사용 하 여 메서드 명백히 같은 두 개의 값 때문에 간주 될 수 있습니다 정밀도 실수 및 허수 구성 요소 차이 같지 않은 것입니다. 문제가 경우 더욱 두드러집니다 수 <paramref name="obj" /> 으로 변환 해야는 <see cref="T:System.Double" /> 비교를 수행 하기 전에. 다음 예제에서는 같은 것으로 표시 되는 실수 부분이 복소수를 비교는 <see cref="T:System.Single" /> 하를 사용 하 여 값 <see cref="T:System.Single" /> 값입니다. 같음에 대 한 비교를 반환 하는 출력에서 볼 수 있듯이 <see langword="False" />합니다.  [! code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [! code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  권장 방법은 두 값 간의 차이 허용 가능한 오차를 정의 하는 것 (같은. 값의 실수 및 허수 구성 요소 중 하나의 01%) 값이 같은지를 비교 하는 대신 합니다. 두 값 간의 차이의 절대 값 보다 작거나 동일한 경우 차이점은 정밀도의 차이로 인해 발생 가능성이 며 따라서 값 않습니다과 같아야 합니다. 다음 예제에서는이 방법의 사용 하 여 이전 코드 예제에서는 동일 하지 않은 것으로 발견 하는 두 값을 비교 합니다. 이제 동일한 것으로 검색 합니다.  [! code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [! code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">거듭제곱을 지정하는 복소수입니다.</param>
        <summary>
          <see langword="e" />를 복소수로 지정된 지수만큼 거듭제곱하여 반환합니다.</summary>
        <returns>
          <see langword="e" />의 <paramref name="value" />승입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Numerics.Complex.Pow%2A> 메서드를 다른 밑의 거듭제곱을 계산 합니다.  
  
 <xref:System.Numerics.Complex.Exp%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Exp%2A?displayProperty=nameWithType> 실수에 대 한 메서드. <xref:System.Numerics.Complex.Exp%2A> 역함수 값은 <xref:System.Numerics.Complex.Log%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Numerics.Complex.Exp%2A> 메서드. 정밀도 부족 어느 정도 허용 하므로, 있다고 표시는 <xref:System.Double> 에서 반환 된 값을 전달 하는 데이터 형식으로는 <xref:System.Numerics.Complex.Log%2A> 메서드를는 <xref:System.Numerics.Complex.Exp%2A> 메서드가 원래 반환 <xref:System.Numerics.Complex> 값입니다.  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">원점(x축과 y축의 교차점)에서 숫자까지의 거리인 크기입니다.</param>
        <param name="phase">선에서 가로 축까지의 각도인 위상으로서, 라디안 단위로 측정됩니다.</param>
        <summary>점의 극좌표를 사용하여 복소수를 만듭니다.</summary>
        <returns>복소수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드를 만드는 데 극좌표를 기반으로 복잡 한 횟수입니다.  
  
 반환 값 복합 평면에 있는 점의의 여러 표현 있기 때문에 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드 정규화 됩니다. 크기는 양수 이면로 표준화 및 단계는 값의 범위에로 표준화<xref:System.Math.PI> 를 <xref:System.Math.PI>합니다. 결과 값으로는 <xref:System.Numerics.Complex.Phase%2A> 및 <xref:System.Numerics.Complex.Magnitude%2A> 결과 복잡 한 수의 속성의 원래 값과 같지 않을 수 있습니다는 `magnitude` 및 `phase` 매개 변수입니다.  
  
 값도 라디안으로 변환 하기에 대 한는 `phase` 곱합니다 매개 변수  <xref:System.Math.PI?displayProperty=nameWithType> /180입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 복소수를 인스턴스화하기 위한 메서드를 극좌표를 기반으로 하며 값을 표시 한 다음 해당 <xref:System.Numerics.Complex.Magnitude%2A> 및 <xref:System.Numerics.Complex.Phase%2A> 속성입니다.  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Numerics.Complex" /> 개체에 대한 해시 코드를 반환합니다.</summary>
        <returns>부호 있는 32비트 정수 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Numerics.Complex" /> 개체의 허수 구성 요소를 가져옵니다.</summary>
        <value>복소수의 허수 구성 요소입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복소수 a + bi, <xref:System.Numerics.Complex.Imaginary%2A> 속성 b의 값을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열을 인스턴스화합니다 <xref:System.Numerics.Complex> 형태로 각 실수 및 허수 구성 요소를 표시 하 고 개체 a + bi 합니다.  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>0과 같은 실수와 1과 같은 허수를 포함하는 새 <see cref="T:System.Numerics.Complex" /> 인스턴스를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제는 <xref:System.Numerics.Complex> 를 사용 하 여 값의 <xref:System.Numerics.Complex.ImaginaryOne> 속성입니다. 다음을 호출 하 여 인스턴스화될 다른 값이이 값을 비교는 <xref:System.Numerics.Complex> 실수부 0 및 1과 같은 가상 부분이 생성자입니다. 예제의 출력에서 볼 수 있듯이 두 값이 동일 합니다.  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>복소수의 로그를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>지정된 복소수의 자연(밑 <see langword="e" />) 로그를 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 자연(밑 <see langword="e" />) 로그입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Numerics.Complex.Log%2A> 메서드. 정밀도 부족 어느 정도 허용 하므로, 있다고 표시는 <xref:System.Double> 에서 반환 된 값을 전달 하는 데이터 형식으로는 <xref:System.Numerics.Complex.Log%2A> 메서드를는 <xref:System.Numerics.Complex.Exp%2A> 메서드가 원래 반환 <xref:System.Numerics.Complex> 값입니다.  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <param name="baseValue">로그의 밑입니다.</param>
        <summary>지정된 밑을 사용하여 지정된 복소수의 로그를 반환합니다.</summary>
        <returns>밑이 <paramref name="value" />인 <paramref name="baseValue" />의 로그입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>밑이 10인 지정된 복소수의 로그를 반환합니다.</summary>
        <returns>밑이 10인 <paramref name="value" />의 로그입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Log10%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Log10%2A?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>복소수의 크기 또는 절대 값을 가져옵니다.</summary>
        <value>현재 인스턴스의 크기입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Magnitude%2A> 속성은 복잡 한 수의 절대 값에 해당 합니다. 원점 (x 축과 데카르트 좌표계에 y 축의 교차점)에서 복소수를 나타내는 2 차원 점 거리를 지정 합니다. 절대 값은 다음과 같이 계산 됩니다.  
  
 &#124;a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(한 *는 + b * b)  
  
 절대 값의 계산 결과 오버플로가 발생 하는 경우이 속성 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.  
  
 <xref:System.Numerics.Complex.Magnitude%2A> 및 <xref:System.Numerics.Complex.Phase%2A> 속성 극좌표 형 좌표계에서 복소수를 나타내는 점 위치를 정의 합니다.  
  
 호출 하 여 데카르트 좌표 대신 극좌표를 기반으로 복잡 한 횟수를 인스턴스화할 수 있습니다는 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드.  
  
   
  
## Examples  
 다음 예에서는 복소수의 절대값을 계산 하 고이의 값에 해당 하는 <xref:System.Numerics.Complex.Magnitude%2A> 속성입니다.  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">곱할 첫 번째 복소수입니다.</param>
        <param name="right">곱할 두 번째 복소수입니다.</param>
        <summary>두 복소수의 곱을 반환합니다.</summary>
        <returns>
          <paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 곱입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복잡 한 곱하기 a + bi, 번호 및 두 번째 복소수입니다, c + di를 다음과 같은 형식을 사용 합니다.  
  
 (ac-bd) + (ad + bc) i  
  
 되 면 곱셈 또는 허수 구성 요소에서 오버플로가, 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.  
  
 <xref:System.Numerics.Complex.Multiply%2A> 메서드는 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 구현 합니다. 해당 동작은 곱셈 연산자를 사용 하는 곱하기와 동일 합니다.  
  
   
  
## Examples  
 다음 예제 복소수가 배열의 각 요소에 의해 복소수 합니다.  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>지정된 복소수의 덧셈 역원을 반환합니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 <see cref="P:System.Numerics.Complex.Real" /> 및 <see cref="P:System.Numerics.Complex.Imaginary" /> 구성 요소에 -1을 곱한 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복소수의 덧셈 역 원을 값을 생성 하는 복소수입니다 <xref:System.Numerics.Complex> 원래 복소수에 추가 된 경우. 이 메서드는 원래 복소수의 실수 및 허수 구성 요소는-1을 곱한 복소수를 반환 합니다.  
  
 <xref:System.Numerics.Complex.Negate%2A> 메서드는 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 구현 합니다. 해당 동작은 동일 하는 단항 부정 연산자를 사용 하 여 부정 <xref:System.Numerics.Complex.op_UnaryNegation%2A>합니다.  
  
   
  
## Examples  
 다음 예제 복소수가의 배열에 있는 각 요소의 덧셈 역함수를 가져옵니다.  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>1과 같은 실수와 0과 같은 허수를 포함하는 새 <see cref="T:System.Numerics.Complex" /> 인스턴스를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제는 <xref:System.Numerics.Complex> 를 사용 하 여 값의 <xref:System.Numerics.Complex.One> 속성입니다. 다음을 호출 하 여 인스턴스화될 다른 값이이 값을 비교는 <xref:System.Numerics.Complex> 실수부 1 및 0과 같은 가상 부분이 생성자입니다. 예제의 출력에서 볼 수 있듯이 두 값이 동일 합니다.  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">더할 첫 번째 값입니다.</param>
        <param name="right">더할 두 번째 값입니다.</param>
        <summary>두 복소수를 더합니다.</summary>
        <returns>
          <paramref name="left" />와 <paramref name="right" />의 합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Addition%2A> 메서드 복소수에 대 한 추가 작업을 정의 합니다. 다음과 같은 코드 수 있습니다.  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 복잡 한 추가 a + bi, 번호 및 두 번째 복소수입니다, c + di를 다음과 같은 형식을 사용 합니다.  
  
 (a + c) + (b + d) i  
  
 메서드 호출 결과 또는 허수 구성 요소에서 오버플로가 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Add%2A> 메서드 대신 합니다.  
  
 이 연산자는 해당 하는 방법은 <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>  
  
## Examples  
 다음 예제 복소수가 사용 하 여 추가입니다.  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">나눌 대상 값입니다.</param>
        <param name="right">나눌 값입니다.</param>
        <summary>지정된 복소수를 다른 지정된 복소수로 나눕니다.</summary>
        <returns>
          <paramref name="left" />를 <paramref name="right" />로 나눈 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Division%2A> 메서드 복소수에 대 한 나누기 연산을 정의 합니다. 다음과 같은 코드 수 있습니다.  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 복잡 한 나누기 a + bi, 번호 및 두 번째 복소수입니다, c + di를 다음과 같은 형식을 사용 합니다.  
  
 ((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i  
  
 되 면 나누기 또는 허수 구성 요소에서 오버플로가, 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.  
  
 사용자 지정 연산자 및 연산자 오버 로드를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Divide%2A> 메서드 대신 합니다.  
  
 이 연산자는 해당 하는 방법은 <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 복소수입니다.</param>
        <param name="right">비교할 두 번째 복소수입니다.</param>
        <summary>두 복소수가 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Equality%2A> 같음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.Complex> 값입니다. 다음과 같은 코드 수 있습니다.  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드 대신 합니다.  
  
 두 복소수의 실수 부분 같은지 및 허수 부분이 경우 같습니다. <xref:System.Numerics.Complex.op_Equality%2A> 다음 식으로는 것과 같습니다.  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 즉, 전체 자릿수에 사용 되는 차이가 있으므로 분명히 동일한 두 개의 복소수 간주할 수 같지 않은 note 합니다. 자세한 내용 및 가능한 해결 방법에 대 한 참조는 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드.  
  
 이 연산자는 해당 하는 방법은 <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Numerics.Complex" /> 개체와 다른 형식 간의 명시적 변환을 정의합니다.</summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>
          <see cref="T:System.Decimal" /> 값을 복소수로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns>
          <paramref name="value" />와 일치하는 실수 구성 요소와 0과 일치하는 허수 구성 요소가 있는 복소수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명시적 변환 연산자 정의 형식으로 변환 될 수 있는 한 <xref:System.Numerics.Complex> 개체입니다. 데이터 손실을 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 않습니다. 캐스팅 연산자 (C#) 또는 변환 함수는 경우에 변환을 실행 대신 (같은 `CType` Visual basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.

 변환은 <xref:System.Decimal> 값 복소수의 실수 부분을 하므로 정밀도 손실 될 수 있습니다는 <xref:System.Double>, 복소수의 형식인 <xref:System.Numerics.Complex.Real%2A> 속성을 보다 적은 유효 자릿수에는 <xref:System.Decimal>합니다.



## Examples
 다음 예제에서는 명시적으로 변환 <xref:System.Decimal> 값을 <xref:System.Numerics.Complex> 값입니다.

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>
          <see cref="T:System.Numerics.BigInteger" /> 값을 복소수로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns>
          <paramref name="value" />와 일치하는 실수 구성 요소와 0과 일치하는 허수 구성 요소가 있는 복소수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명시적 변환 연산자 정의 형식으로 변환 될 수 있는 한 <xref:System.Numerics.Complex> 개체입니다. 데이터 손실을 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 않습니다. 캐스팅 연산자 (C#) 또는 변환 함수는 경우에 변환을 실행 대신 (같은 `CType` Visual basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.

 변환은 <xref:System.Numerics.BigInteger> 값 복소수의 실수 부분을 하므로 정밀도 손실 될 수 있습니다는 <xref:System.Double>, 복소수의 형식인 <xref:System.Numerics.Complex.Real%2A> 속성을 보다 적은 유효 자릿수에는 <xref:System.Numerics.BigInteger>합니다.

 변환이 실패 한 경우 때문에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다.이 <xref:System.Double> 형식, 작업을 throw 하지 않습니다는 <xref:System.OverflowException>합니다. 대신 경우 `value` 는 보다 작은 <xref:System.Double.MinValue>, 결과 복잡 한 숫자와는 <xref:System.Numerics.Complex.Real%2A> 속성 값이 같지 <xref:System.Double.NegativeInfinity>합니다. 경우 `value` 보다 크면 <xref:System.Double.MaxValue>, 결과 복잡 한 숫자와는 <xref:System.Numerics.Complex.Real%2A> 속성 값이 같지 <xref:System.Double.PositiveInfinity>합니다.



## Examples
 다음 예제에서는 명시적으로 변환 <xref:System.Numerics.BigInteger> 값을 <xref:System.Numerics.Complex> 값입니다.

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Numerics.Complex" /> 개체와 다른 형식 간의 암시적 변환을 정의합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>부호 없는 바이트를 복소수로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자는 컴파일러가 자동으로 변환할 수 형식 정의 <xref:System.Numerics.Complex> 없는 명시적 캐스팅 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출할 개체입니다. 확대 변환 데이터가 손실 되지를 throw 하지 않습니다는 <xref:System.OverflowException>합니다.

 이 오버 로드를 사용 하면 컴파일러에서 변환할 때 처리 있습니다는 <xref:System.Byte> 를 다음 예제와 같이 복소수로 값입니다. 변환의 결과 실수부 같으면 복소수는 <xref:System.Byte> 값과 허수 부분은 0입니다.

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>배정밀도 부동 소수점 숫자를 복소수로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자는 컴파일러가 자동으로 변환할 수 형식 정의 <xref:System.Numerics.Complex> 없는 명시적 캐스팅 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출할 개체입니다. 확대 변환 데이터가 손실 되지를 throw 하지 않습니다는 <xref:System.OverflowException>합니다.

 이 오버 로드를 사용 하면 컴파일러에서 변환할 때 처리 있습니다는 <xref:System.Double> 를 다음 예제와 같이 복소수로 값입니다. 변환의 결과 실수부 같으면 복소수는 <xref:System.Double> 값과 허수 부분은 0입니다.

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>부호 있는 16비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자는 컴파일러가 자동으로 변환할 수 형식 정의 <xref:System.Numerics.Complex> 없는 명시적 캐스팅 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출할 개체입니다. 확대 변환 데이터가 손실 되지를 throw 하지 않습니다는 <xref:System.OverflowException>합니다.

 이 오버 로드를 사용 하면 컴파일러를 변환할 때 부호 있는 16 비트 정수를 복소수로, 다음 예제와 같이 처리 있습니다. 변환의 결과 실수부가 부호 있는 16 비트 정수 같지 및 허수 부분이 0과 같은 복소수 note 합니다.

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>부호 있는 32비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자는 컴파일러가 자동으로 변환할 수 형식 정의 <xref:System.Numerics.Complex> 없는 명시적 캐스팅 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출할 개체입니다. 확대 변환 데이터가 손실 되지를 throw 하지 않습니다는 <xref:System.OverflowException>합니다.

 이 오버 로드를 사용 하면 컴파일러를 변환할 때 부호 있는 32 비트 정수를 복소수로, 다음 예제와 같이 처리 있습니다. 변환의 결과 실수부가 부호 있는 32 비트 정수 같지 및 허수 부분이 0과 같은 복소수 note 합니다.

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>부호 있는 64비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자는 컴파일러가 자동으로 변환할 수 형식 정의 <xref:System.Numerics.Complex> 없는 명시적 캐스팅 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출할 개체입니다. 확대 변환 데이터가 손실 되지를 throw 하지 않습니다는 <xref:System.OverflowException>합니다.

 이 오버 로드를 사용 하면 컴파일러를 변환할 때 부호 있는 64 비트 정수를 복소수로, 다음 예제와 같이 처리 있습니다. 변환의 결과 실수부가 부호 있는 64 비트 정수 같지 및 허수 부분이 0과 같은 복소수 note 합니다.

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>부호 있는 바이트를 복소수로 변환하는 암시적 변환을 정의합니다.  이 API는 CLS 규격이 아닙니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자는 컴파일러가 자동으로 변환할 수 형식 정의 <xref:System.Numerics.Complex> 없는 명시적 캐스팅 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출할 개체입니다. 확대 변환 데이터가 손실 되지를 throw 하지 않습니다는 <xref:System.OverflowException>합니다.

 이 오버 로드를 사용 하면 컴파일러를 변환할 때 부호 있는 바이트를 복소수로, 다음 예제와 같이 처리 있습니다. 변환의 결과 실수부 부호 있는 바이트 고 허수 부분이 0과 같은 복소수 note 합니다.

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>단정밀도 부동 소수점 숫자를 복소수로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자는 컴파일러가 자동으로 변환할 수 형식 정의 <xref:System.Numerics.Complex> 없는 명시적 캐스팅 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출할 개체입니다. 확대 변환 데이터가 손실 되지를 throw 하지 않습니다는 <xref:System.OverflowException>합니다.

 이 오버 로드를 사용 하면 컴파일러에서 변환할 때 처리 있습니다는 <xref:System.Single> 를 다음 예제와 같이 복소수로 값입니다. 변환의 결과 실수부 같으면 복소수는 <xref:System.Single> 값과 허수 부분은 0입니다.

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>부호 없는 16비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.  이 API는 CLS 규격이 아닙니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자는 컴파일러가 자동으로 변환할 수 형식 정의 <xref:System.Numerics.Complex> 없는 명시적 캐스팅 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출할 개체입니다. 확대 변환 데이터가 손실 되지를 throw 하지 않습니다는 <xref:System.OverflowException>합니다.

 이 오버 로드를 사용 하면 컴파일러를 변환할 때 부호 없는 16 비트 정수를 복소수로, 다음 예제와 같이 처리 있습니다. 변환의 결과 실수부가 부호 없는 16 비트 정수 같지 및 허수 부분이 0과 같은 복소수 note 합니다.

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>부호 없는 32비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.  이 API는 CLS 규격이 아닙니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자는 컴파일러가 자동으로 변환할 수 형식 정의 <xref:System.Numerics.Complex> 없는 명시적 캐스팅 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출할 개체입니다. 확대 변환 데이터가 손실 되지를 throw 하지 않습니다는 <xref:System.OverflowException>합니다.

 이 오버 로드를 사용 하면 컴파일러를 변환할 때 부호 없는 32 비트 정수를 복소수로, 다음 예제와 같이 처리 있습니다. 변환의 결과 실수부가 부호 없는 32 비트 정수 같지 및 허수 부분이 0과 같은 복소수 note 합니다.

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">복소수로 변환할 값입니다.</param>
        <summary>부호 없는 64비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.  이 API는 CLS 규격이 아닙니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자는 컴파일러가 자동으로 변환할 수 형식 정의 <xref:System.Numerics.Complex> 없는 명시적 캐스팅 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출할 개체입니다. 확대 변환 데이터가 손실 되지를 throw 하지 않습니다는 <xref:System.OverflowException>합니다.

 이 오버 로드를 사용 하면 컴파일러를 변환할 때 부호 없는 64 비트 정수를 복소수로, 다음 예제와 같이 처리 있습니다. 변환의 결과 실수부가 부호 없는 64 비트 정수 같지 및 허수 부분이 0과 같은 복소수 note 합니다.

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>두 복소수가 다른지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Equality%2A> 메서드 복소수를 같지 않음 연산자는 작업을 정의 합니다. 다음과 같은 코드 수 있습니다.  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출 하 여 같지 않음을 테스트할 수는 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드 고 값을 반전 합니다.  
  
 즉, 전체 자릿수에 사용 되는 차이가 있으므로 분명히 동일한 두 개의 복소수 간주할 수 같지 않은 note 합니다. 반환 하는 비교 메서드를 구현 하는 한 가지 가능한 해결 방법은 `true` 복소수의 두 실수 및 허수 부분 간의 차이 특정 임계값을 초과 하는 경우에 (같은.의 또는 허수 구성 요소 값의 0.1% 중 하나는 복소수)입니다. 자세한 내용은 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드를 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">곱할 첫 번째 값입니다.</param>
        <param name="right">곱할 두 번째 값입니다.</param>
        <summary>지정된 두 복소수를 곱합니다.</summary>
        <returns>
          <paramref name="left" />와 <paramref name="right" />의 곱입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Multiply%2A> 메서드 복소수에 대 한 곱하기 연산자의 작업을 정의 합니다. 다음과 같은 코드 수 있습니다.  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 복잡 한 곱하기 a + bi, 번호 및 두 번째 복소수입니다, c + di를 다음과 같은 형식을 사용 합니다.  
  
 (ac-bd) + (ad + bc) i  
  
 되 면 곱셈 또는 허수 구성 요소에서 오버플로가, 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Multiply%2A> 메서드 대신 합니다.  
  
 이 연산자는 해당 하는 방법은 <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">뺄 대상 값(피감수)입니다.</param>
        <param name="right">뺄 값(감수)입니다.</param>
        <summary>한 복소수에서 다른 복소수를 뺍니다.</summary>
        <returns>
          <paramref name="right" />에서 <paramref name="left" />를 뺀 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Subtraction%2A> 메서드 복소수에 대 한 빼기 연산자는 작업을 정의 합니다. 다음과 같은 코드 수 있습니다.  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 메서드 호출 결과 또는 허수 구성 요소에서 오버플로가 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.  
  
 복소수, c +에서 다른 복소수 di의 빼기는 bi 형식은 +:  
  
 (a-c) + (b-d) i  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Subtract%2A> 메서드 대신 합니다.  
  
 이 연산자는 해당 하는 방법은 <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">부정할 값입니다.</param>
        <summary>지정된 복소수의 덧셈 역원을 반환합니다.</summary>
        <returns>
          <paramref name="value" /> 매개 변수의 <see cref="P:System.Numerics.Complex.Real" /> 및 <see cref="P:System.Numerics.Complex.Imaginary" /> 구성 요소에 -1을 곱한 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_UnaryNegation%2A> 메서드 복소수에 대 한 단항 부정 (덧셈 역 원을) 연산자의 작업을 정의 합니다. 다음과 같은 코드 수 있습니다.  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 값을 생성 하는 결과 복소수 <xref:System.Numerics.Complex> 0 (영)는 원래 복소수의에 추가 됩니다. 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Negate%2A> 메서드 대신 합니다.  
  
 이 연산자는 해당 하는 방법은 <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>복소수의 위상을 가져옵니다.</summary>
        <value>복소수의 위상(라디안 단위)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복소수는 bi, 단계에서로 계산 됩니다 + <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, 한).  
  
 복소수는 복합 평면의 데카르트 좌표 또는 극좌표를 식별할 수 있습니다. 복소수의 위상 (인수) 복소수를 나타내는 지점으로의 원점 (x 축과 y 축의 교차점)에서 결정 실제 축으로 각도입니다. 크기 (나타내는 <xref:System.Numerics.Complex.Magnitude%2A> 속성)은 복잡 한 수로 표현 되는 지점에는 원점 거리입니다.  
  
 호출 하 여 데카르트 좌표 대신 극좌표를 기반으로 복잡 한 횟수를 인스턴스화할 수 있습니다는 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드.  
  
 단계에서 라디안에서 각도로 변환, 하려면 180으로 곱하면 /<xref:System.Math.PI?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 복소수를 인스턴스화하기 위한 메서드를 해당 극좌표를 기반으로 하며의 값을 표시 한 다음 해당 <xref:System.Numerics.Complex.Magnitude%2A> 및 <xref:System.Numerics.Complex.Phase%2A> 속성입니다.  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 복소수를 지정된 지수만큼 거듭제곱하여 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">지수만큼 거듭제곱할 복소수입니다.</param>
        <param name="power">거듭제곱을 지정하는 배정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 복소수를 배정밀도 부동 소수점 숫자로 지정된 지수만큼 거듭제곱하여 반환합니다.</summary>
        <returns>복소수 <paramref name="value" />를 지수 <paramref name="power" />만큼 거듭제곱한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`가 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>이면 메서드에서 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>을 반환합니다. 다른 값에 대 한 경우 `power` 은 0으로, 메서드가 반환 <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, 경우에 한 `power` 이 1 이면 반환 `value`합니다.  
  
 에 해당 하는이 메서드는 <xref:System.Math.Pow%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.  
  
   
  
## Examples  
 다음 예제에서는 해당 값의 범위를-1에서 10 복소수와 지 수를 사용 하 여 지 수를 보여 줍니다.  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">지수만큼 거듭제곱할 복소수입니다.</param>
        <param name="power">거듭제곱을 지정하는 복소수입니다.</param>
        <summary>지정된 복소수를 복소수로 지정된 지수만큼 거듭제곱하여 반환합니다.</summary>
        <returns>복소수 <paramref name="value" />를 지수 <paramref name="power" />만큼 거듭제곱한 값입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Numerics.Complex" /> 개체의 실수 구성 요소를 가져옵니다.</summary>
        <value>복소수의 실수 구성 요소입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복소수 a + bi, <xref:System.Numerics.Complex.Real%2A> 속성의 값을 반환 된 합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열을 인스턴스화합니다 <xref:System.Numerics.Complex> 형태로 각 실수 및 허수 구성 요소를 표시 하 고 개체 a + bi 합니다.  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>복소수의 역수를 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 역수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 숫자의 역 수 *x* 숫자인 *y* 여기서 *x* 곱한 *y* 1을 생성 합니다. 복소수의 역 복소수를 생성 하는 <xref:System.Numerics.Complex.One?displayProperty=nameWithType> 두 숫자를 곱할 때. 역 a + bi 복소수는 나타내는 경우 식으로 나타납니다는 / (한<sup>2</sup>+ b<sup>2</sup>) +-b / (한<sup>2</sup> + b<sup>2</sup>).  
  
 값이 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, 메서드가 반환 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>합니다. 그렇지 않으면 식의 결과 반환 <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Numerics.Complex.Reciprocal%2A> 메서드를 여러 복소수의 역 수 값을 계산 합니다. 복소수의 역 곱한 결과 방법도 보여 줍니다 <xref:System.Numerics.Complex.One?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>지정된 복소수의 사인을 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 사인입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Sin%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Sin%2A?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 <xref:System.Numerics.Complex.Sin%2A> 메서드는 복소수의 사인을 계산 하는 다음 수식을 사용 a + bi:  
  
 (<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))  
  
   
  
## Examples  
 다음 예제는 <xref:System.Numerics.Complex.Sin%2A> 메서드. 반환 된 값을 전달 해당 표시는 <xref:System.Numerics.Complex.Asin%2A> 메서드를는 <xref:System.Numerics.Complex.Sin%2A> 메서드 반환 원래 <xref:System.Numerics.Complex> 값입니다.  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>지정된 복소수의 하이퍼볼릭 사인을 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 쌍곡선 사인입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Sinh%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Sinh%2A?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 <xref:System.Numerics.Complex.Sinh%2A> 메서드 복소수의 쌍 곡 사인을 계산 하는 다음 수식을 사용 a + bi:  
  
 (<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>지정된 복소수의 제곱근을 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 제곱근입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복소수의 제곱근 `value` 다음 수식을 사용 하 여 계산 됩니다.  
  
 <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)   
  
 <xref:System.Numerics.Complex.Sqrt%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">뺄 대상 값(피감수)입니다.</param>
        <param name="right">뺄 값(감수)입니다.</param>
        <summary>한 복소수에서 다른 복소수를 뺀 후 결과를 반환합니다.</summary>
        <returns>
          <paramref name="right" />에서 <paramref name="left" />를 뺀 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복소수, c +에서 다른 복소수 di의 빼기는 bi 형식은 +:  
  
 (a-c) + (b-d) i  
  
 메서드 호출 결과 또는 허수 구성 요소에서 오버플로가 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.  
  
 사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수는 <xref:System.Numerics.Complex.Subtract%2A> 복소수를 사용 하 여 빼기를 수행 하는 메서드.  
  
   
  
## Examples  
 다음 예제에서는 복소수에서 배열에 각 복소수를 뺍니다.  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>지정된 복소수의 탄젠트를 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 접선입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Tan%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Tan%2A?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 <xref:System.Numerics.Complex.Tan%2A> 메서드는 복소수의 탄젠트를 계산 하는 다음 수식을 사용 `value`:  
  
 <xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)  
  
   
  
## Examples  
 다음 예제는 <xref:System.Numerics.Complex.Tan%2A> 메서드. 반환 된 값을 전달 해당 표시는 <xref:System.Numerics.Complex.Atan%2A> 메서드를는 <xref:System.Numerics.Complex.Tan%2A> 메서드 반환 원래 <xref:System.Numerics.Complex> 값입니다.  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">복소수입니다.</param>
        <summary>지정된 복소수의 하이퍼볼릭 탄젠트를 반환합니다.</summary>
        <returns>
          <paramref name="value" />의 쌍곡선 접선입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Tanh%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Tanh%2A?displayProperty=nameWithType> 실수에 대 한 메서드.  
  
 <xref:System.Numerics.Complex.Tanh%2A> 메서드 복소수의 쌍 곡 탄젠트를 계산 하는 다음 수식을 사용 `value`:  
  
 <xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>복소수 값을 해당하는 문자열 표현으로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</summary>
        <returns>현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 데카르트 좌표를 사용 하 여 폼의 수를 표시 하는 복잡 한 수의 기본 문자열 표현을 `(` *는* `,` *b*`)`여기서 *는* 있는 복소수의 실수 부분에는 및 *b* 복소수의 합니다. 둘 다 *는* 및 *b* 일반 서식 지정자 ("G")와 현재 시스템 문화권의 규칙을 사용 하 여 지정 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 여러 복잡 한 숫자의 문자열 표현을 표시합니다. 출력 영어-미국 ("EN-US") 문화권,이 경우 현재 시스템 문화권의 서식 지정 규칙을 사용 합니다.  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 문화권별 서식 정보를 사용하여 현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</summary>
        <returns>
          <paramref name="provider" />에서 지정한 형식에 따른 현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 데카르트 좌표를 사용 하 여 폼의 수를 표시 하는이 메서드에서 반환 된 복잡 한 수의 문자열 표현을 `(` *는* `,` *b*`)`, 여기서 *는* 있는 복소수의 실수 부분에는 및 *b* 복소수의 합니다. 둘 다 *는* 및 *b* 일반 서식 지정자 ("G")와에 정의 된 문화권의 규칙을 사용 하 여 서식이 지정 된 `provider`합니다.  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현 합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 실수 및 허수 반환된 된 문자열에는 형식에 대 한 문화권별 정보를 제공 하는 개체입니다. 경우 `provider` 은 `null`, 사용 하 여 반환 된 문자열의 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.  
  
 `provider` 매개 변수는 다음 중 하나일 수 있습니다.  
  
-   A <xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다  
  
-   <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
-   구현 하는 사용자 지정 개체는 <xref:System.IFormatProvider> 인터페이스입니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 여러 복잡 한 숫자의 문자열 표현을 표시합니다. 결과 영어-미국 ("EN-US") 및 프랑스어-프랑스 ("FR-FR") 문화권의 서식 지정 규칙을 사용합니다.  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">표준 또는 사용자 지정 숫자 서식 문자열입니다.</param>
        <summary>실수와 허수 부분에 대해 지정된 서식을 사용하여 현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</summary>
        <returns>현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 데카르트 좌표를 사용 하 여 폼의 수를 표시 하는이 메서드에서 반환 된 복잡 한 수의 문자열 표현을 `(` *는* `,` *b*`)`, 여기서 *는* 있는 복소수의 실수 부분에는 및 *b* 복소수의 합니다. 둘 다 *는* 및 *b* 로 지정 된 형식 문자열을 사용 하 여 서식이 지정 된 `format`합니다. `format` 매개 변수는 모든 유효한 표준 숫자 형식 지정자, 또는 사용자 지정 숫자 서식 지정자의 조합이 될 수 있습니다. 경우 `format` 같은지를 <xref:System.String.Empty?displayProperty=nameWithType> 아니거나 `null`, 복소수의 실수 및 허수 부분 일반 형식 지정자 ("G")로 지정 됩니다. 경우 `format` 다른 값을 메서드가 throw 한 <xref:System.FormatException>합니다.  
  
 .NET Framework에서는 다음 항목에서 자세히 설명 하는 광범위 한 서식 지정 지원을 제공 합니다.  
  
-   숫자 형식 문자열에 대 한 자세한 내용은 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   .NET Framework에서 형식 지정 하는 방법에 대 한 자세한 내용은 참조 [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 반환된 된 문자열의 형식은 따라 결정 됩니다는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다. 에 따라는 `format` 매개 변수를이 개체는 음수 기호, 그룹 구분 기호는 소수점 기호는 출력 문자열에 등의 기호를 제어 합니다. 현재 문화권이 아닌 문화권에 대 한 서식 지정 정보를 제공 하려면 호출는 <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> 오버 로드 합니다.  
  
   
  
## Examples  
 다음 예제에서는 복소수를 초기화 합니다. 여러 표준 형식 문자열을 사용 하 여 표시 합니다.  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" />은 유효한 서식 문자열이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">표준 또는 사용자 지정 숫자 서식 문자열입니다.</param>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>실수와 허수 부분에 대해 지정된 서식과 문화권별 서식 정보를 사용하여 현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</summary>
        <returns>
          <paramref name="format" /> 및 <paramref name="provider" />에서 지정한 형식에 따른 현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 데카르트 좌표를 사용 하 여 폼의 수를 표시 하는이 메서드에서 반환 된 복잡 한 수의 문자열 표현을 `(` *는* `,` *b*`)`, 여기서 *는* 있는 복소수의 실수 부분에는 및 *b* 복소수의 합니다. 둘 다 *는* 및 *b* 로 지정 된 형식 문자열을 사용 하 여 서식이 지정 된 `format`합니다. `format` 매개 변수는 모든 유효한 표준 숫자 형식 지정자, 또는 사용자 지정 숫자 서식 지정자의 조합이 될 수 있습니다. 경우 `format` 같은지를 <xref:System.String.Empty?displayProperty=nameWithType> 아니거나 `null`, 복소수의 실수 및 허수 부분 일반 형식 지정자 ("G")로 지정 됩니다. 경우 `format` 다른 값을 메서드가 throw 한 <xref:System.FormatException>합니다.  
  
 .NET Framework에서는 다음 항목에서 자세히 설명 하는 광범위 한 서식 지정 지원을 제공 합니다.  
  
-   숫자 형식 문자열에 대 한 자세한 내용은 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   .NET Framework에서 형식 지정 하는 방법에 대 한 자세한 내용은 참조 [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현 합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 실수 및 허수 반환된 된 문자열에는 형식에 대 한 문화권별 정보를 제공 하는 개체입니다. 에 따라는 `format` 매개 변수를이 개체는 음수 기호, 그룹 구분 기호는 소수점 기호는 출력 문자열에 등의 기호를 제어 합니다. 경우 `provider` 은 `null`, 사용 하 여 반환 된 문자열의 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.  
  
 `provider` 매개 변수는 다음 중 하나일 수 있습니다.  
  
-   A <xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다  
  
-   <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
-   구현 하는 사용자 지정 개체는 <xref:System.IFormatProvider> 인터페이스입니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 복소수를 배열을 만들고 각각 여러 표준 형식 문자열을 사용 하 여 표시와 <xref:System.Globalization.CultureInfo> 영어-미국 ("EN-US") 및 프랑스어-프랑스 ("FR-FR") 문화권을 나타내는 개체입니다.  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" />은 유효한 서식 문자열이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>0과 같은 실수와 0과 같은 허수를 포함하는 새 <see cref="T:System.Numerics.Complex" /> 인스턴스를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Zero> 비교할 속성은 가장 자주 사용 되는 <xref:System.Numerics.Complex> 값을 0입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Numerics.Complex> 를 사용 하 여 값의 <xref:System.Numerics.Complex.Zero> 속성입니다. 다음을 호출 하 여 인스턴스화될 다른 값이이 값을 비교는 <xref:System.Numerics.Complex> 실수부 0, 0과 같은 허수 부분에 대 한 생성자입니다. 예제의 출력에서 볼 수 있듯이 두 값이 동일 합니다.  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>