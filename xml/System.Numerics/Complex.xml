<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="45aed4a95edff1e825b957b2993f72dc022d64ea" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39754210" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="66bb5-101">복소수를 나타냅니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="66bb5-101">Represents a complex number.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-102">복소수는 실수 부분과 허수 부분이 구성 하는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="66bb5-103">복소수 z z 형태로 일반적으로 기록 됩니다 = x + yi, 여기서 *x* 및 *y* 실수에는 및 *합니까* 는 속성이 있는 허수 단위 *i* <sup>2</sup> =-1입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="66bb5-104">복소수의 실수 부분으로 표시 됩니다 *x*, 및 복소수의 허수 부분으로 나타납니다. *y*합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="66bb5-105"><xref:System.Numerics.Complex> 데카르트 좌표계 (real의 경우 허수부)을 사용 하 여 형식을 인스턴스화하고 복소수를 조작 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="66bb5-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="66bb5-106">복소수의 복합 평면의 이라고 하는 2 차원 좌표 시스템에서는 지점으로 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="66bb5-107">복소수의 실수 부분을 x 축 (가로 축)에 놓이고 허수 부분을 y 축 (세로 축)에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="66bb5-108">해당 절대 값을 기준으로 사용 하 여 극좌표 형 좌표계, 극좌표에서 복합 평면의 시점 표현할 수도 있습니다, 그리고 지점 두 숫자의 특징은:</span><span class="sxs-lookup"><span data-stu-id="66bb5-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="66bb5-109">원본에서 요소의 거리는 해당 크기 (즉, 0, 0, 또는 x 축 및 y 축 교차 하는 지점)입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-109">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="66bb5-110">단계는 실수 축을 지점 원본에서 그린 선 사이의 각도입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-110">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="66bb5-111">복소수의 인스턴스화</span><span class="sxs-lookup"><span data-stu-id="66bb5-111">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="66bb5-112">다음 방법 중 하나를 복소수로 값을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-112">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="66bb5-113">두 개를 전달 하 여 <xref:System.Double> 생성자에는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-113">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="66bb5-114">첫 번째 값은 복소수의 실수부를 나타내고 두 번째 값의 허수 부분을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-114">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="66bb5-115">이러한 값 2 차원 데카르트 좌표계에 복잡 한 수의 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-115">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="66bb5-116">정적 호출 하 여 (`Shared` Visual basic에서) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> 극좌표에서 복소수를 만드는 방법.</span><span class="sxs-lookup"><span data-stu-id="66bb5-116">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="66bb5-117">할당 하 여는 <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, 또는 <xref:System.Double> 값을 <xref:System.Numerics.Complex> 개체.</span><span class="sxs-lookup"><span data-stu-id="66bb5-117">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="66bb5-118">값은 복소수의 실수부 되며 허수 부분에는 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-118">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="66bb5-119">캐스팅 (C#) 또는 변환 (Visual Basic)를 <xref:System.Decimal> 또는 <xref:System.Numerics.BigInteger> 값을 <xref:System.Numerics.Complex> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-119">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="66bb5-120">값은 복소수의 실수부 되며 허수 부분에는 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-120">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="66bb5-121">메서드 또는 연산자에서 반환 되는 복소수를 할당 하 여를 <xref:System.Numerics.Complex> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-121">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="66bb5-122">예를 들어 <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> 합계인 두 복소수는 복소수를 반환 하는 정적 메서드는 및 <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> 두 복소수를 더 추가 하 고 결과 반환 하는 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-122">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="66bb5-123">다음 예제에서는 각 복소수에 값을 할당 하는 5 가지를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-123">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="66bb5-124">복소수를 사용 하 여 작업</span><span class="sxs-lookup"><span data-stu-id="66bb5-124">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="66bb5-125"><xref:System.Numerics.Complex> .NET Framework의 구조는 다음과 같은 기능을 제공 하는 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-125">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="66bb5-126">두 복소수가 같은지 여부를 비교 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-126">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="66bb5-127">복소수에서 산술 연산을 수행 하는 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-127">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="66bb5-128"><xref:System.Numerics.Complex> 연산자를 사용 하 여 더하기, 빼기, 곱하기, 나누기 및 단항 부정 연산자 복소수를 사용 하 여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-128"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="66bb5-129">복소수에 숫자 다른 작업을 수행 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-129">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="66bb5-130">네 개의 기본 산술 연산자 외에도 지정 된 거듭제곱 복소수의 복합 숫자의 제곱근을 구합니다를 복소수의 절대 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-130">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="66bb5-131">복소수에서 삼각 연산을 수행 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-131">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="66bb5-132">예를 들어, 복소수를 나타내는 각도의 탄젠트를 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-132">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="66bb5-133">때문에 합니다 <xref:System.Numerics.Complex.Real%2A> 하 고 <xref:System.Numerics.Complex.Imaginary%2A> 속성은 읽기 전용, 기존 값을 수정할 수 없습니다. <xref:System.Numerics.Complex> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-133">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="66bb5-134">작업을 수행 하는 모든 메서드는 <xref:System.Numerics.Complex> 반환 값 형식인 경우 숫자 <xref:System.Numerics.Complex>, 새 반환 <xref:System.Numerics.Complex> 수입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-134">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="66bb5-135">전체 자릿수와 복소수</span><span class="sxs-lookup"><span data-stu-id="66bb5-135">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="66bb5-136">복소수의 실수와 허수 부분 두 배정밀도 부동 소수점 값으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-136">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="66bb5-137">즉 <xref:System.Numerics.Complex> 배정밀도 부동 소수점 값을 같은 값을 숫자 작업의 결과로 정밀도 떨어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-137">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="66bb5-138">이 엄격한 의미의 같음 비교 <xref:System.Numerics.Complex> 값 정밀도 손실로 인해 두 값 간의 차이점은 경우에 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-138">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="66bb5-139">자세한 내용은 <xref:System.Double>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="66bb5-139">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="66bb5-140">예를 들어, 숫자의 로그에 지 수 연산을 수행 원본 수를 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-140">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="66bb5-141">그러나 경우에 따라 부동 소수점 값의 정밀도 손실이 발생할 수 있습니다 두 값 간에 약간의 차이가 다음 예제와 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-141">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="66bb5-142">마찬가지로, 다음 예제에서는의 제곱근을 계산 하는 한 <xref:System.Numerics.Complex> 번호, 32 비트 및 IA64 버전의.NET Framework에서 약간 다른 결과 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-142">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="66bb5-143">복소수, 무한대 및 NaN</span><span class="sxs-lookup"><span data-stu-id="66bb5-143">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="66bb5-144">복소수의 실수와 허수 부분으로 표시 됩니다 <xref:System.Double> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-144">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="66bb5-145">이르는 하는 것 외에도 <xref:System.Double.MinValue?displayProperty=nameWithType> 하 <xref:System.Double.MaxValue?displayProperty=nameWithType>, 또는 허수 부분 복소수 값을 가질 수 있습니다 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-145">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="66bb5-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>를 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 및 <xref:System.Double.NaN?displayProperty=nameWithType> 모두 산술 또는 삼각 작업에 전파 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="66bb5-147">다음 예에서 나누기 <xref:System.Numerics.Complex.Zero> 복소수의 실수부와 허수부 둘 다 생성 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-147">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="66bb5-148">결과적으로,이 값을 사용 하 여 곱하기를 수행 합니다. 또한 생성 복소수의 실수부와 허수부는 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-148">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="66bb5-149">마찬가지로, 범위를 오버플로 하는 곱하기를 수행 합니다 <xref:System.Double> 복소수의 실수부를 생성 하는 형식 <xref:System.Double.NaN?displayProperty=nameWithType> 허수부 이며 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-149">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="66bb5-150">복소수의 실수부 반환 이후에이 복소수와 나누기를 수행 <xref:System.Double.NaN?displayProperty=nameWithType> 허수부 이며 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-150">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="66bb5-151">잘못 된 또는 범위를 오버플로 하는 복소수를 사용 하 여 수학 연산을 <xref:System.Double> 데이터 형식 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-151">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="66bb5-152">대신, 반환 된 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType> 다음 조건:</span><span class="sxs-lookup"><span data-stu-id="66bb5-152">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="66bb5-153">0 반환 하 여 양수의 나누기 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-153">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="66bb5-154">상한을 오버플로 하는 모든 작업은 <xref:System.Double> 데이터 형식 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-154">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="66bb5-155">음수를 0 개 반환의 나누기 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-155">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="66bb5-156">하 한 범위를 오버플로 하는 모든 작업은 <xref:System.Double> 데이터 형식 반환 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-156">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="66bb5-157">0으로 나누기 반환 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-157">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="66bb5-158">해당 값은 피연산자에 대해 수행 되는 모든 작업 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType> 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>에 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType>특정 작업에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-158">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="66bb5-159">메서드에 의해 수행 된 모든 중간 계산에 적용 되도록이 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-159">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="66bb5-160">예를 들어, 곱하기가 `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` 수식을 사용 (ac-bd) + (ad + bc) i.</span><span class="sxs-lookup"><span data-stu-id="66bb5-160">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="66bb5-161">곱하기의 결과 실수 구성 요소에 대 한 계산 식 9e308 평가 * 2.5-9e308 * 3.5.</span><span class="sxs-lookup"><span data-stu-id="66bb5-161">The calculation of the real component that results from the multiplication evaluates the expression 9e308 * 2.5 - 9e308 * 3.5.</span></span> <span data-ttu-id="66bb5-162">이 식의 각 중간 곱하기 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, 및 뺄 시도 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 에서 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 반환 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-162">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="66bb5-163">복합 숫자의 서식을 지정</span><span class="sxs-lookup"><span data-stu-id="66bb5-163">Formatting a Complex Number</span></span>  
 <span data-ttu-id="66bb5-164">기본적으로 복합 숫자의 문자열 표현 형식은 `(` *real* `,` *허수*`)`여기서 *실제* 및 *허수* 의 문자열 표현은 <xref:System.Double> 복소수의 실수와 허수 구성 요소를 구성 하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-164">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="66bb5-165">일부 오버 로드는 <xref:System.Numerics.Complex.ToString%2A> 메서드 다음의 문자열 표현 사용자 지정할 수 있도록 <xref:System.Double> 값을 특정 문화권의 서식 규칙을 반영 하거나 표준 또는 사용자 지정 숫자를 정의한 특정 형식으로 표시 서식 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-165">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="66bb5-166">(자세한 내용은 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="66bb5-166">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="66bb5-167">복합 숫자의 문자열 표현을 표현 하는 일반적인 방법 중 하나는 a + bi 여기서는 복소수의 실수 구성 요소 이며 b 복소수의 허수 구성 요소.</span><span class="sxs-lookup"><span data-stu-id="66bb5-167">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="66bb5-168">전기공학, 복소수 일반적으로 표시 되는 + bj 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-168">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="66bb5-169">이러한 두 형식 중 하나에서 복합 숫자의 문자열 표현을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-169">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="66bb5-170">이 위해 사용자 지정 형식 공급자를 구현 하 여 정의 합니다 <xref:System.ICustomFormatter> 및 <xref:System.IFormatProvider> 인터페이스 및 다음 호출을 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-170">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="66bb5-171">다음 예제에서는 정의 `ComplexFormatter` 중 하나의 형식인 문자열로 복소수를 나타내는 클래스 a + bi 또는 + bj 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-171">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="66bb5-172">다음 예제에서는 다음이 사용자 지정 포맷터를 사용 하 여 복합 숫자의 문자열 표현을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-172">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">
          <span data-ttu-id="66bb5-173">복소수의 실수 부분입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-173">The real part of the complex number.</span>
          </span>
        </param>
        <param name="imaginary">
          <span data-ttu-id="66bb5-174">복소수의 허수 부분입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-174">The imaginary part of the complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-175">지정된 실수 값과 허수 값을 사용하여 <see cref="T:System.Numerics.Complex" /> 구조체의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-175">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-176">합니다 `real` 또는 `imaginary` 명시적 캐스트를 필요로 하는 데이터 형식인 경우 인수 정밀도 떨어지는 <xref:System.Double>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-176">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-177">다음 예제에서는 두 개의 복소수를 인스턴스화하고 더하기, 빼기, 곱하기 및 나누기 연산에서 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-177">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-178">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-178">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-179">복소수의 절대 값 또는 크기를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-179">Gets the absolute value (or magnitude) of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-180">
            <paramref name="value" />의 절대값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-180">The absolute value of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-181">복소수의 절대 값은 해당 <xref:System.Numerics.Complex.Magnitude%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-181">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="66bb5-182">숫자는 실수의 절대값을 + bi는 다음과 같이 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-182">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="66bb5-183">경우 b = 0 이면 결과 0입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-183">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="66bb5-184">경우는 > b, 결과는 \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="66bb5-184">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="66bb5-185">경우 b > 인 결과 b는 \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="66bb5-185">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="66bb5-186">절대값 계산 결과로 오버플로가 발생을 메서드 반환 하거나 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-186">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="66bb5-187">경우는 <xref:System.Numerics.Complex.Real%2A> 또는 <xref:System.Numerics.Complex.Imaginary%2A> 속성은 <xref:System.Double.NaN?displayProperty=nameWithType> 다른 속성은 모두 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 나 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 메서드가 반환 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-187">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-188">다음 예제는 복소수의 절대값을 계산 하 고의 값에 해당 하는 방법을 보여 줍니다는 <xref:System.Numerics.Complex.Magnitude%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-188">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-189">코사인을 나타내는 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-189">A complex number that represents a cosine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-190">지정된 복소수의 아크코사인인 각도를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-190">Returns the angle that is the arc cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-191">
            <paramref name="value" />의 아크코사인인 각도인, 라디안 단위로 측정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-191">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-192">합니다 <xref:System.Numerics.Complex.Acos%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Acos%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-192">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="66bb5-193"><xref:System.Numerics.Complex.Acos%2A> 메서드는 다음 수식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-193">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="66bb5-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="66bb5-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="66bb5-195">다음 예제는 <xref:System.Numerics.Complex.Acos%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-195">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="66bb5-196">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Acos%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Cos%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="66bb5-196">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="66bb5-197">더할 첫 번째 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-197">The first complex number to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="66bb5-198">더할 두 번째 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-198">The second complex number to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-199">두 개의 복소수를 더한 후 결과를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-199">Adds two complex numbers and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-200">
            <paramref name="left" />와 <paramref name="right" />의 합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-200">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-201">복잡 한 추가 a + bi, 번호 및 두 번째 복소수, c + di를 다음 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-201">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="66bb5-202">(a + c) + (b + d) i.</span><span class="sxs-lookup"><span data-stu-id="66bb5-202">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="66bb5-203">요소의 값은 메서드 호출 결과 또는 허수 구성 요소에서 오버플로가 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-203">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="66bb5-204">사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수는 <xref:System.Numerics.Complex.Add%2A> 복소수를 사용 하 여 추가 수행 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-204">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-205">다음 예제에서는 복소수를 사용 하 여 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-205">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-206">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-206">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-207">지정된 복소수의 아크사인인 각도를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-207">Returns the angle that is the arc sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-208">
            <paramref name="value" />의 아크사인인 각도입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-208">The angle which is the arc sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-209">합니다 <xref:System.Numerics.Complex.Asin%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Asin%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-209">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="66bb5-210"><xref:System.Numerics.Complex.Asin%2A> 메서드는 다음 수식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-210">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="66bb5-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* 값 + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -값 \* 값))</span><span class="sxs-lookup"><span data-stu-id="66bb5-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="66bb5-212">다음 예제는 <xref:System.Numerics.Complex.Asin%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-212">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="66bb5-213">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Asin%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Sin%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="66bb5-213">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-214">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-214">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-215">지정된 복소수의 아크탄젠트인 각도를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-215">Returns the angle that is the arc tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-216">
            <paramref name="value" />의 아크탄젠트인 각도입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-216">The angle that is the arc tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-217">합니다 <xref:System.Numerics.Complex.Atan%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Atan%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-217">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="66bb5-218"><xref:System.Numerics.Complex.Atan%2A> 메서드는 다음 수식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-218">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="66bb5-219"><xref:System.Numerics.Complex.ImaginaryOne> / 새 복합 (2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* 값)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* 값)</span><span class="sxs-lookup"><span data-stu-id="66bb5-219"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="66bb5-220">다음 예제는 <xref:System.Numerics.Complex.Atan%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-220">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="66bb5-221">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Atan%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Tan%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="66bb5-221">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-222">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-222">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-223">복소수의 켤레 복소수를 계산한 후 결과를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-223">Computes the conjugate of a complex number and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-224">
            <paramref name="value" />의 켤레 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-224">The conjugate of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-225">복소수의 켤레 복소수 허수 구성 요소 부호 반전 즉, 허수 구성 요소에 단항 부정 연산자를 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-225">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="66bb5-226">경우는 + bi는 복소수의 켤레 복소수는, a – bi 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-226">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-227">다음 예제에서는 두 복소수의 켤레 복소수를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-227">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-228">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-228">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-229">지정된 복소수의 코사인을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-229">Returns the cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-230">
            <paramref name="value" />의 코사인입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-230">The cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-231">합니다 <xref:System.Numerics.Complex.Cos%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Cos%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-231">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="66bb5-232"><xref:System.Numerics.Complex.Cos%2A> 메서드 다음 수식을 사용 하 여 복소수의 코사인을 계산 a + bi:</span><span class="sxs-lookup"><span data-stu-id="66bb5-232">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="66bb5-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="66bb5-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-234">다음 예제는 <xref:System.Numerics.Complex.Acos%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-234">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="66bb5-235">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Acos%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Cos%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="66bb5-235">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-236">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-236">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-237">지정된 복소수의 하이퍼볼릭 코사인을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-237">Returns the hyperbolic cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-238">
            <paramref name="value" />의 쌍곡선 코사인입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-238">The hyperbolic cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-239">합니다 <xref:System.Numerics.Complex.Cosh%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Cosh%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-239">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="66bb5-240"><xref:System.Numerics.Complex.Cosh%2A> 메서드는 다음 수식을 사용 하 여 복소수의 쌍 곡 코사인을 계산 a + bi:</span><span class="sxs-lookup"><span data-stu-id="66bb5-240">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="66bb5-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="66bb5-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">
          <span data-ttu-id="66bb5-242">나눌 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-242">The complex number to be divided.</span>
          </span>
        </param>
        <param name="divisor">
          <span data-ttu-id="66bb5-243">값을 나눌 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-243">The complex number to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-244">한 복소수를 다른 복소수로 나눈 후 결과를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-244">Divides one complex number by another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-245">나누기의 몫입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-245">The quotient of the division.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-246">복합 숫자의 나누기를 bi, 두 번째 복소수, 수, c + di를 형식은 +:</span><span class="sxs-lookup"><span data-stu-id="66bb5-246">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="66bb5-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="66bb5-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="66bb5-248">몫의 계산 결과 또는 허수 구성 요소에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-248">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="66bb5-249"><xref:System.Numerics.Complex.Divide%2A> 메서드를 사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-249">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="66bb5-250">해당 동작 나누기는 나누기 연산자를 사용 하는 것과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-250">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-251">다음 예제에서는 복소수를 배열의 각 요소에 의해 복소수를 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-251">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-252">두 복소수가 같은지 여부를 나타내는 값을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-252">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-253">비교할 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-253">The complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-254">현재 인스턴스와 지정된 복소수의 값이 같은지 여부를 나타내는 값을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-254">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-255">이 복소수와 <paramref name="value" />가 동일한 값을 가지면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-255">
              <see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-256"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드를 제공 합니다 <xref:System.IEquatable%601> 구현에 대 한는 <xref:System.Numerics.Complex> 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-256">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="66bb5-257">성능이 약간 보다 <xref:System.Numerics.Complex.Equals%28System.Object%29> 메서드 복소수의 매개 변수를 변환할 필요가 없기 때문에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-257">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="66bb5-258">두 복소수는 해당 실수 부분도 같으면 해당 허수 부분도 동일한 경우 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-258">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="66bb5-259"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드는 다음 식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-259">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="66bb5-260">
            <para>사용 된 <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> 메서드를 주의 해 서 되므로 두 값을 명백히 같은 간주할 수 실수 및 허수 구성 요소 정밀도 차이 같지 않은 합니다. 다음 예제를 보고 하는 <c>(3.33333, 0.142857)</c> 하 고 <c>(10/3, 1/7)</c> 같지 않습니다.  [! 코드 csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [! 코드 vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)] 방법은 허용 되는 여백 차이 정의 하는 것이 좋습니다 하나 두 값 (같은. 값 실수 및 허수 구성 요소 중 하나의.01%)의 값이 같은지를 비교 하는 대신 합니다. 두 값 간의 차이의 절대값 보다 작거나 동일한 경우 차이 정밀도에 차이가 있기 때문일 가능성이 않으며, 따라서 값과 같아야 합니다. 다음 예에서는 같지 않은 것으로 이전 코드 예제에 있는 두 복소수 값을 비교할이 기법을 사용 합니다. 같아야 두 복소수를 찾습니다.  [! 코드 csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [! 코드 vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-260">
              <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.  [!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal. The following example uses this technique to compare the two complex values that the previous code example found to be unequal. It finds the two complex numbers to be equal.  [!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="66bb5-261">비교할 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-261">The object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-262">현재 인스턴스와 지정된 개체의 값이 같은지를 나타내는 값을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-262">Returns a value that indicates whether the current instance and a specified object have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-263">
            <paramref name="obj" /> 매개 변수가 <see cref="T:System.Numerics.Complex" /> 개체이거나 <see cref="T:System.Numerics.Complex" /> 개체로 암시적 변환이 가능한 형식이고 해당 값이 현재 <see cref="T:System.Numerics.Complex" /> 개체의 값과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-263">
              <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-264">두 복소수는 해당 실수 부분도 같으면 해당 허수 부분도 동일한 경우 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-264">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="66bb5-265"><xref:System.Numerics.Complex.Equals%28System.Object%29> 메서드는 다음 식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-265">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="66bb5-266">경우는 `obj` 매개 변수가 아닙니다를 <xref:System.Numerics.Complex> 개체를 변환 하는 암시적 변환을 정의 되는 데이터 형식이 <xref:System.Numerics.Complex.Equals%28System.Object%29> 메서드 변환 `obj` 에 <xref:System.Numerics.Complex> 실수부 의값과같은개체`obj`고 비교를 수행 하기 전에 허수 부분이 0입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-266">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="66bb5-267">다음 예제에서는이 복소수와 배정밀도 부동 소수점 값이 같음을 검색 하 여 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-267">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="66bb5-268">
            <para>사용 된 <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> 메서드를 주의 해 서 되므로 두 값을 명백히 같은 간주할 수 실수 및 허수 구성 요소 정밀도 차이 같지 않은 합니다. 문제 경우 더욱 두드러집니다 수 <paramref name="obj" /> 으로 변환 되어야 합니다는 <see cref="T:System.Double" /> 비교를 수행 하기 전에 합니다. 다음 예제에서는 비교 복소수의 실수 부분이 같은 것으로 표시 됩니다는 <see cref="T:System.Single" /> 값이 점을 <see cref="T:System.Single" /> 값입니다. 같음 비교를 반환 하는 출력에서 볼 수 있듯이 <see langword="False" />합니다.  [! 코드 csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [! 코드 vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)] 방법은 허용 되는 둘 사이의 차이점 여백을 정의 하는 것이 좋습니다 하나 값 (같은. 값 실수 및 허수 구성 요소 중 하나의.01%)의 값이 같은지를 비교 하는 대신 합니다. 두 값 간의 차이의 절대값 보다 작거나 동일한 경우 차이 정밀도에 차이가 있기 때문일 가능성이 않으며, 따라서 값과 같아야 합니다. 다음 예제는 이전 코드 예제에서는 서로 다른 두 값을 비교 하려면이 기술을 사용 합니다. 이제 같아야 하기를 찾습니다.  [! 코드 csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [! 코드 vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-268">
              <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison. The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value. As the output shows, the comparison for equality returns <see langword="False" />.  [!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal. The following example uses this technique to compare the two values that the previous code example found to be unequal. It now finds them to be equal.  [!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-269">거듭제곱을 지정하는 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-269">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-270">
            <see langword="e" />를 복소수로 지정된 지수만큼 거듭제곱하여 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-270">Returns <see langword="e" /> raised to the power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-271">
            <see langword="e" />의 <paramref name="value" />승입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-271">The number <see langword="e" /> raised to the power <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-272">사용 된 <xref:System.Numerics.Complex.Pow%2A> 다른 밑의 승수를 계산 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-272">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="66bb5-273">합니다 <xref:System.Numerics.Complex.Exp%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Exp%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-273">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="66bb5-274"><xref:System.Numerics.Complex.Exp%2A> 역 수는 <xref:System.Numerics.Complex.Log%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-274"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-275">다음 예제는 <xref:System.Numerics.Complex.Exp%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-275">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="66bb5-276">정밀도 부족에 대 한 일부 여유를 보여 줍니다는 <xref:System.Double> 데이터 형식으로 반환 하는 값을 전달 합니다 <xref:System.Numerics.Complex.Log%2A> 메서드를를 <xref:System.Numerics.Complex.Exp%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="66bb5-276">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">
          <span data-ttu-id="66bb5-277">원점(x축과 y축의 교차점)에서 숫자까지의 거리인 크기입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-277">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span>
          </span>
        </param>
        <param name="phase">
          <span data-ttu-id="66bb5-278">선에서 가로 축까지의 각도인 위상으로서, 라디안 단위로 측정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-278">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-279">점의 극좌표를 사용하여 복소수를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-279">Creates a complex number from a point's polar coordinates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-280">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-280">A complex number.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-281"><xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드 극좌표를 기반으로 복잡 한 횟수를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-281">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="66bb5-282">반환 값은 복합 평면에서 점의 여러 표현 되므로 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드 정규화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-282">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="66bb5-283">크기는 양수 하도록 표준화 되 고 단계-범위의 값으로 정규화 됩니다<xref:System.Math.PI> 에 <xref:System.Math.PI>입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-283">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="66bb5-284">결과적으로 값을 <xref:System.Numerics.Complex.Phase%2A> 및 <xref:System.Numerics.Complex.Magnitude%2A> 결과 복소수 속성의 원래 값을 같지 않을 수 있습니다 합니다 `magnitude` 및 `phase` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-284">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="66bb5-285">에 대 한 라디안으로 각도에서 값을 변환 하는 `phase` 매개 변수를 곱합니다  <xref:System.Math.PI?displayProperty=nameWithType> /180입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-285">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-286">다음 예제에서는 합니다 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 복소수를 인스턴스화하기 위한 메서드를 극좌표를 기반으로 하며 값을 표시 한 다음 해당 <xref:System.Numerics.Complex.Magnitude%2A> 및 <xref:System.Numerics.Complex.Phase%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-286">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-287">현재 <see cref="T:System.Numerics.Complex" /> 개체에 대한 해시 코드를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-287">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-288">부호 있는 32비트 정수 해시 코드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-288">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-289">현재 <see cref="T:System.Numerics.Complex" /> 개체의 허수 구성 요소를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-289">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="66bb5-290">복소수의 허수 구성 요소입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-290">The imaginary component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-291">복소수 a + bi는 <xref:System.Numerics.Complex.Imaginary%2A> 속성 b의 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-291">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-292">다음 예제에서는의 배열을 인스턴스화하고 <xref:System.Numerics.Complex> 개체 형태로 각 실수 및 허수 구성 요소를 표시 및 a + bi 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-292">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-293">0과 같은 실수와 1과 같은 허수를 포함하는 새 <see cref="T:System.Numerics.Complex" /> 인스턴스를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-293">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="66bb5-294">다음 예제에서는 한 <xref:System.Numerics.Complex> 사용 하 여 값을 <xref:System.Numerics.Complex.ImaginaryOne> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-294">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="66bb5-295">그런 다음이 값을 호출 하 여 인스턴스화된 다른 값을 비교 합니다 <xref:System.Numerics.Complex> 0 실수부는 실수부와 허수부 하나를 사용 하 여 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-295">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="66bb5-296">예제의 출력에서 볼 수 있듯이 두 값이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-296">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-297">복소수의 로그를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-297">Returns the logarithm of a complex number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-298">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-298">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-299">지정된 복소수의 자연(밑 <see langword="e" />) 로그를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-299">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-300">
            <paramref name="value" />의 자연(밑 <see langword="e" />) 로그입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-300">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-301">합니다 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-301">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-302">다음 예제는 <xref:System.Numerics.Complex.Log%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-302">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="66bb5-303">정밀도 부족에 대 한 일부 여유를 보여 줍니다는 <xref:System.Double> 데이터 형식으로 반환 하는 값을 전달 합니다 <xref:System.Numerics.Complex.Log%2A> 메서드를를 <xref:System.Numerics.Complex.Exp%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="66bb5-303">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-304">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-304">A complex number.</span>
          </span>
        </param>
        <param name="baseValue">
          <span data-ttu-id="66bb5-305">로그의 밑입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-305">The base of the logarithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-306">지정된 밑을 사용하여 지정된 복소수의 로그를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-306">Returns the logarithm of a specified complex number in a specified base.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-307">밑이 <paramref name="value" />인 <paramref name="baseValue" />의 로그입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-307">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-308">합니다 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-308">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-309">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-309">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-310">밑이 10인 지정된 복소수의 로그를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-310">Returns the base-10 logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-311">밑이 10인 <paramref name="value" />의 로그입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-311">The base-10 logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-312">합니다 <xref:System.Numerics.Complex.Log10%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Log10%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-312">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-313">복소수의 크기 또는 절대 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-313">Gets the magnitude (or absolute value) of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="66bb5-314">현재 인스턴스의 크기입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-314">The magnitude of the current instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-315"><xref:System.Numerics.Complex.Magnitude%2A> 속성은 복합 숫자의 절대 값과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-315">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="66bb5-316">원점 (x 축과 데카르트 좌표계에 y 축 교차)에서 복소수의 표시 되는 2 차원 점을 거리를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-316">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="66bb5-317">절대 값을 다음과 같이 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-317">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="66bb5-318">&#124;a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(한 *는 + b * b)</span><span class="sxs-lookup"><span data-stu-id="66bb5-318">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)</span></span>  
  
 <span data-ttu-id="66bb5-319">절대 값의 계산 결과에서 오버플로가 발생 하는 경우이 속성이 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-319">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="66bb5-320"><xref:System.Numerics.Complex.Magnitude%2A> 하며 <xref:System.Numerics.Complex.Phase%2A> 속성 복소수의 극좌표 형 좌표 시스템을 나타내는 지점의 위치를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-320">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="66bb5-321">호출 하 여 데카르트 좌표 대신 극좌표를 기반으로 복잡 한 횟수를 인스턴스화할 수 있습니다는 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-321">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-322">다음 예제는 복소수의 절대값을 계산 하 고의 값에 해당 하는 방법을 보여 줍니다는 <xref:System.Numerics.Complex.Magnitude%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-322">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="66bb5-323">곱할 첫 번째 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-323">The first complex number to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="66bb5-324">곱할 두 번째 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-324">The second complex number to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-325">두 복소수의 곱을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-325">Returns the product of two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-326">
            <paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 곱입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-326">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-327">복잡 한 곱셈 a + bi, 번호 및 두 번째 복소수, c + di를 다음 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-327">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="66bb5-328">(ac-bd) + (ad + bc) i</span><span class="sxs-lookup"><span data-stu-id="66bb5-328">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="66bb5-329">곱셈 결과 또는 허수 구성 요소에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-329">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="66bb5-330"><xref:System.Numerics.Complex.Multiply%2A> 메서드는 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-330">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="66bb5-331">해당 동작은 곱셈 연산자를 사용 하는 곱하기 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-331">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-332">다음 예제에서는 복소수를 배열의 각 요소에 의해 복소수 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-332">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-333">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-333">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-334">지정된 복소수의 덧셈 역원을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-334">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-335">
            <paramref name="value" /> 매개 변수의 <see cref="P:System.Numerics.Complex.Real" /> 및 <see cref="P:System.Numerics.Complex.Imaginary" /> 구성 요소에 -1을 곱한 결과입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-335">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-336">복소수의 덧셈 역 원을 값을 생성 하는 복소수 <xref:System.Numerics.Complex> 경우 원래 복소수에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-336">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="66bb5-337">이 메서드는 원래 복소수의 실수와 허수 구성 요소는-1을 곱한 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-337">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="66bb5-338"><xref:System.Numerics.Complex.Negate%2A> 메서드는 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-338">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="66bb5-339">해당 동작은 동일 단항 부정 연산자를 사용 하는 부정 <xref:System.Numerics.Complex.op_UnaryNegation%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-339">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-340">다음 예제에서는 복합 숫자의 배열에 있는 각 요소의 덧셈 역 원을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-340">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-341">1과 같은 실수와 0과 같은 허수를 포함하는 새 <see cref="T:System.Numerics.Complex" /> 인스턴스를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-341">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="66bb5-342">다음 예제에서는 한 <xref:System.Numerics.Complex> 사용 하 여 값을 <xref:System.Numerics.Complex.One> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-342">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="66bb5-343">그런 다음이 값을 호출 하 여 인스턴스화된 다른 값을 비교 합니다 <xref:System.Numerics.Complex> 실수부 1, 0을 허수 부분을 사용 하 여 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-343">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="66bb5-344">예제의 출력에서 볼 수 있듯이 두 값이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-344">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="66bb5-345">더할 첫 번째 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-345">The first value to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="66bb5-346">더할 두 번째 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-346">The second value to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-347">두 복소수를 더합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-347">Adds two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-348">
            <paramref name="left" />와 <paramref name="right" />의 합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-348">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-349"><xref:System.Numerics.Complex.op_Addition%2A> 메서드 복소수에 대 한 추가 작업을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-349">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="66bb5-350">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-350">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="66bb5-351">복잡 한 추가 a + bi, 번호 및 두 번째 복소수, c + di를 다음 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-351">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="66bb5-352">(a + c) + (b + d) i</span><span class="sxs-lookup"><span data-stu-id="66bb5-352">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="66bb5-353">메서드 호출 결과 또는 허수 구성 요소 중 하나에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-353">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="66bb5-354">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Add%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-354">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="66bb5-355">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="66bb5-355">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="66bb5-356">다음 예제에서는 복소수를 사용 하 여 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-356">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="66bb5-357">나눌 대상 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-357">The value to be divided.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="66bb5-358">나눌 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-358">The value to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-359">지정된 복소수를 다른 지정된 복소수로 나눕니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-359">Divides a specified complex number by another specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-360">
            <paramref name="left" />를 <paramref name="right" />로 나눈 결과입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-360">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-361"><xref:System.Numerics.Complex.op_Division%2A> 메서드 복소수는 나누기 연산을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-361">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="66bb5-362">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-362">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="66bb5-363">복잡 한의 부서 번호, a + bi, 하며 두 번째 복소수, c + di를 다음 형식:</span><span class="sxs-lookup"><span data-stu-id="66bb5-363">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="66bb5-364">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="66bb5-364">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="66bb5-365">나누기 결과 또는 허수 구성 요소에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-365">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="66bb5-366">사용자 지정 연산자 및 연산자 오버 로드를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Divide%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-366">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="66bb5-367">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="66bb5-367">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="66bb5-368">비교할 첫 번째 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-368">The first complex number to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="66bb5-369">비교할 두 번째 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-369">The second complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-370">두 복소수가 같은지 여부를 나타내는 값을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-370">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-371">
            <paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-371">
              <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-372">합니다 <xref:System.Numerics.Complex.op_Equality%2A> 메서드 정의 작업에 대 한 같음 연산자의 <xref:System.Numerics.Complex> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-372">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="66bb5-373">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-373">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="66bb5-374">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-374">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="66bb5-375">두 복소수는 해당 실수 부분도 같으면 해당 허수 부분도 동일한 경우 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-375">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="66bb5-376"><xref:System.Numerics.Complex.op_Equality%2A> 메서드는 다음 식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-376">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="66bb5-377">전체 자릿수의 차이점으로 인해 분명히 동일한 두 복소수 간주 될 수 있습니다 같지 않은 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-377">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="66bb5-378">자세한 내용 및 가능한 해결 방법에 대 한 참조를 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-378">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="66bb5-379">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="66bb5-379">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-380">
            <see cref="T:System.Numerics.Complex" /> 개체와 다른 형식 간의 명시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-380">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-381">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-381">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-382">
            <see cref="T:System.Decimal" /> 값을 복소수로 변환하는 명시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-382">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-383">
            <paramref name="value" />와 일치하는 실수 구성 요소와 0과 일치하는 허수 구성 요소가 있는 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-383">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-384">명시적 변환 연산자를 변환할 수 있는 형식 정의 <xref:System.Numerics.Complex> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-384">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="66bb5-385">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="66bb5-385">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="66bb5-386">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-386">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="66bb5-387">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-387">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="66bb5-388">변환을 <xref:System.Decimal> 복소수의 실수 부분 값 하므로 정밀도 손실 될 수 있습니다를 <xref:System.Double>, 복소수의 형식인 <xref:System.Numerics.Complex.Real%2A> 속성 보다 유효 자릿수가 적어 짐에 <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="66bb5-388">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="66bb5-389">다음 예제에서는 명시적 변환 <xref:System.Decimal> 값을 <xref:System.Numerics.Complex> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-389">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-390">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-390">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-391">
            <see cref="T:System.Numerics.BigInteger" /> 값을 복소수로 변환하는 명시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-391">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-392">
            <paramref name="value" />와 일치하는 실수 구성 요소와 0과 일치하는 허수 구성 요소가 있는 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-392">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-393">명시적 변환 연산자를 변환할 수 있는 형식 정의 <xref:System.Numerics.Complex> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-393">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="66bb5-394">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="66bb5-394">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="66bb5-395">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-395">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="66bb5-396">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-396">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="66bb5-397">변환을 <xref:System.Numerics.BigInteger> 복소수의 실수 부분 값 하므로 정밀도 손실 될 수 있습니다를 <xref:System.Double>, 복소수의 형식인 <xref:System.Numerics.Complex.Real%2A> 속성 보다 유효 자릿수가 적어 짐에 <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="66bb5-397">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="66bb5-398">변환이 성공한 경우 때문에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다 합니다 <xref:System.Double> 형식 작업을 throw 하지 않습니다는 <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="66bb5-398">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="66bb5-399">대신 경우 `value` 는 보다 작은 <xref:System.Double.MinValue>, 결과 있는 복소수를 <xref:System.Numerics.Complex.Real%2A> 속성 값 <xref:System.Double.NegativeInfinity>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-399">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="66bb5-400">경우 `value` 보다 크면 <xref:System.Double.MaxValue>, 결과 있는 복소수를 <xref:System.Numerics.Complex.Real%2A> 속성 값 <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="66bb5-400">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="66bb5-401">다음 예제에서는 명시적 변환 <xref:System.Numerics.BigInteger> 값을 <xref:System.Numerics.Complex> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-401">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-402">
            <see cref="T:System.Numerics.Complex" /> 개체와 다른 형식 간의 암시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-402">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-403">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-403">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-404">부호 없는 바이트를 복소수로 변환하는 암시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-404">Defines an implicit conversion of an unsigned byte to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-405">
            <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-405">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-406">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-406">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="66bb5-407">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-407">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="66bb5-408">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Byte> 다음 예와 같이 복소수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-408">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="66bb5-409">변환의 결과 복소수의 실수 부분을 해당 값과 같음는 <xref:System.Byte> 값 및 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-409">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-410">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-410">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-411">배정밀도 부동 소수점 숫자를 복소수로 변환하는 암시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-411">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-412">
            <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-412">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-413">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-413">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="66bb5-414">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-414">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="66bb5-415">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Double> 다음 예와 같이 복소수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-415">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="66bb5-416">변환의 결과 복소수의 실수 부분을 해당 값과 같음는 <xref:System.Double> 값 및 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-416">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-417">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-417">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-418">부호 있는 16비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-418">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-419">
            <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-419">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-420">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-420">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="66bb5-421">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-421">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="66bb5-422">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 있는 16 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="66bb5-422">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="66bb5-423">Note 변환의 결과 복소수의 실수부 부호 있는 16 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-423">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-424">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-424">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-425">부호 있는 32비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-425">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-426">
            <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-426">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-427">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-427">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="66bb5-428">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-428">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="66bb5-429">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 있는 32 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="66bb5-429">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="66bb5-430">Note 변환의 결과 복소수의 실수부 부호 있는 32 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-430">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-431">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-431">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-432">부호 있는 64비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-432">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-433">
            <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-433">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-434">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-434">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="66bb5-435">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-435">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="66bb5-436">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 있는 64 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="66bb5-436">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="66bb5-437">Note 변환의 결과 복소수의 실수부 부호 있는 64 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-437">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-438">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-438">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-439">부호 있는 바이트를 복소수로 변환하는 암시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-439">Defines an implicit conversion of a signed byte to a complex number.</span>
          </span>
          <span data-ttu-id="66bb5-440">이 API는 CLS 규격이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-440">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-441">
            <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-441">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-442">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-442">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="66bb5-443">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-443">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="66bb5-444">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 있는 바이트의 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="66bb5-444">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="66bb5-445">Note 변환의 결과 복소수의 실수부를 부호 있는 바이트로 같은지 및 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-445">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-446">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-446">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-447">단정밀도 부동 소수점 숫자를 복소수로 변환하는 암시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-447">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-448">
            <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-448">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-449">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-449">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="66bb5-450">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-450">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="66bb5-451">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Single> 다음 예와 같이 복소수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-451">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="66bb5-452">변환의 결과 복소수의 실수 부분을 해당 값과 같음는 <xref:System.Single> 값 및 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-452">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-453">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-453">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-454">부호 없는 16비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-454">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="66bb5-455">이 API는 CLS 규격이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-455">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-456">
            <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-456">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-457">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-457">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="66bb5-458">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-458">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="66bb5-459">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 없는 16 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="66bb5-459">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="66bb5-460">Note 변환의 결과 복소수의 실수부 부호 없는 16 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-460">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-461">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-461">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-462">부호 없는 32비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-462">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="66bb5-463">이 API는 CLS 규격이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-463">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-464">
            <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-464">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-465">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-465">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="66bb5-466">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-466">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="66bb5-467">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 없는 32 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="66bb5-467">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="66bb5-468">Note 변환의 결과 복소수의 실수부 부호 없는 32 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-468">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-469">복소수로 변환할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-469">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-470">부호 없는 64비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-470">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="66bb5-471">이 API는 CLS 규격이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-471">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-472">
            <paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-472">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-473">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-473">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="66bb5-474">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-474">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="66bb5-475">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 없는 64 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="66bb5-475">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="66bb5-476">Note 변환의 결과 복소수의 실수부 부호 없는 64 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-476">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="66bb5-477">비교할 첫 번째 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-477">The first value to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="66bb5-478">비교할 두 번째 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-478">The second value to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-479">두 복소수가 다른지 여부를 나타내는 값을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-479">Returns a value that indicates whether two complex numbers are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-480">
            <paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-480">
              <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-481"><xref:System.Numerics.Complex.op_Equality%2A> 메서드 복소수를 같지 않음 연산자의 작업을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-481">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="66bb5-482">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-482">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="66bb5-483">사용자 지정 연산자를 지원 하지 않는 언어를 호출 하 여 같지 않은지 테스트할 수는 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드 및 해당 값을 반전 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-483">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="66bb5-484">전체 자릿수의 차이점으로 인해 분명히 동일한 두 복소수 간주 될 수 있습니다 같지 않은 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-484">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="66bb5-485">해결 방법 중 하나를 반환 하는 비교 메서드를 구현 하는 `true` 복소수의 실수부 및 허수부 두 부분 간의 차이 특정 임계값을 초과 하는 경우에 (같은.의 실제 또는 허수 구성 요소 값의 0.1% 하나는 복소수)입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-485">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="66bb5-486">자세한 내용은 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="66bb5-486">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="66bb5-487">곱할 첫 번째 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-487">The first value to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="66bb5-488">곱할 두 번째 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-488">The second value to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-489">지정된 두 복소수를 곱합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-489">Multiplies two specified complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-490">
            <paramref name="left" />와 <paramref name="right" />의 곱입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-490">The product of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-491"><xref:System.Numerics.Complex.op_Multiply%2A> 메서드 복소수에 대 한 곱하기 연산자의 작업을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-491">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="66bb5-492">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-492">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="66bb5-493">복잡 한 곱셈 a + bi, 번호 및 두 번째 복소수, c + di를 다음 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-493">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="66bb5-494">(ac-bd) + (ad + bc) i</span><span class="sxs-lookup"><span data-stu-id="66bb5-494">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="66bb5-495">곱셈 결과 또는 허수 구성 요소에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-495">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="66bb5-496">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Multiply%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-496">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="66bb5-497">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="66bb5-497">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="66bb5-498">뺄 대상 값(피감수)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-498">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="66bb5-499">뺄 값(감수)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-499">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-500">한 복소수에서 다른 복소수를 뺍니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-500">Subtracts a complex number from another complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-501">
            <paramref name="right" />에서 <paramref name="left" />를 뺀 결과입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-501">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-502"><xref:System.Numerics.Complex.op_Subtraction%2A> 메서드 복소수는 빼기 연산자 연산을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-502">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="66bb5-503">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-503">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="66bb5-504">메서드 호출 결과 또는 허수 구성 요소 중 하나에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-504">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="66bb5-505">복소수, c +에서 다른 복소수 di의 빼기는 bi 형식은 +:</span><span class="sxs-lookup"><span data-stu-id="66bb5-505">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="66bb5-506">(a-c) + (b-d) i</span><span class="sxs-lookup"><span data-stu-id="66bb5-506">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="66bb5-507">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Subtract%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-507">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="66bb5-508">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="66bb5-508">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-509">부정할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-509">The value to negate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-510">지정된 복소수의 덧셈 역원을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-510">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-511">
            <paramref name="value" /> 매개 변수의 <see cref="P:System.Numerics.Complex.Real" /> 및 <see cref="P:System.Numerics.Complex.Imaginary" /> 구성 요소에 -1을 곱한 결과입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-511">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-512"><xref:System.Numerics.Complex.op_UnaryNegation%2A> 메서드 복소수에 대 한 단항 부정 연산자 (덧셈 역 원을) 연산자의 작업을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-512">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="66bb5-513">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-513">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="66bb5-514">값을 생성 하는 결과 복소수 <xref:System.Numerics.Complex> 0 (영) 원래 복소수에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-514">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="66bb5-515">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Negate%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-515">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="66bb5-516">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="66bb5-516">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-517">복소수의 위상을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-517">Gets the phase of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="66bb5-518">복소수의 위상(라디안 단위)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-518">The phase of a complex number, in radians.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-519">복소수를 bi, 단계로 계산 됩니다 + <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b는).</span><span class="sxs-lookup"><span data-stu-id="66bb5-519">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="66bb5-520">복소수의 복합 평면의 데카르트 좌표 또는 극좌표를 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-520">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="66bb5-521">복소수의 위상 (인수) 복소수를 나타내는 지점으로의 원점 (x 축과 y 축의 교차점)에서 그린 선의 실제 축 각도입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-521">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="66bb5-522">크기 (나타내는 <xref:System.Numerics.Complex.Magnitude%2A> 속성)는 복잡 한 수로 표현 되는 지점으로의 원점 거리입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-522">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="66bb5-523">호출 하 여 데카르트 좌표 대신 극좌표를 기반으로 복잡 한 횟수를 인스턴스화할 수 있습니다는 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-523">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="66bb5-524">변환할 단계 라디안에서 각도도로 곱한 180 /<xref:System.Math.PI?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-524">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-525">다음 예제에서는 합니다 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 복소수를 인스턴스화하기 위한 메서드를 해당 극좌표를 기반으로 하며 값을 표시 한 다음 해당 <xref:System.Numerics.Complex.Magnitude%2A> 및 <xref:System.Numerics.Complex.Phase%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-525">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-526">지정된 복소수를 지정된 지수만큼 거듭제곱하여 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-526">Returns a specified complex number raised to a specified power.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-527">지수만큼 거듭제곱할 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-527">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="66bb5-528">거듭제곱을 지정하는 배정밀도 부동 소수점 숫자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-528">A double-precision floating-point number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-529">지정된 복소수를 배정밀도 부동 소수점 숫자로 지정된 지수만큼 거듭제곱하여 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-529">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-530">복소수 <paramref name="value" />를 지수 <paramref name="power" />만큼 거듭제곱한 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-530">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-531">`value`가 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>이면 메서드에서 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-531">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="66bb5-532">다른 값에 대 한 경우 `power` 은 0으로, 메서드가 반환 <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, 경우에 `power` 이 1 이면 반환 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-532">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="66bb5-533">에 해당 하는이 메서드는 <xref:System.Math.Pow%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-533">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-534">다음 예제에서는 해당 값의 범위를-1에서 10 복소수와 지 수를 사용 하 여 지 수를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-534">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-535">지수만큼 거듭제곱할 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-535">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="66bb5-536">거듭제곱을 지정하는 복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-536">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-537">지정된 복소수를 복소수로 지정된 지수만큼 거듭제곱하여 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-537">Returns a specified complex number raised to a power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-538">복소수 <paramref name="value" />를 지수 <paramref name="power" />만큼 거듭제곱한 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-538">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-539">현재 <see cref="T:System.Numerics.Complex" /> 개체의 실수 구성 요소를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-539">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="66bb5-540">복소수의 실수 구성 요소입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-540">The real component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-541">복소수 a + bi는 <xref:System.Numerics.Complex.Real%2A> 속성의 값을 반환을 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-541">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-542">다음 예제에서는의 배열을 인스턴스화하고 <xref:System.Numerics.Complex> 개체 형태로 각 실수 및 허수 구성 요소를 표시 및 a + bi 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-542">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-543">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-543">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-544">복소수의 역수를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-544">Returns the multiplicative inverse of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-545">
            <paramref name="value" />의 역수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-545">The reciprocal of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-546">역 수 또는 숫자의 역 *x* 숫자인 *y* 여기서 *x* 곱한 *y* 1을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-546">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="66bb5-547">복소수의 역 수는 생성 하는 복소수 <xref:System.Numerics.Complex.One?displayProperty=nameWithType> 때 두 숫자를 곱합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-547">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="66bb5-548">식에서 역 a + bi 복소수의 표현 하는 경우 표시 됩니다는 / (을<sup>2</sup>+ b<sup>2</sup>) +-b / (을<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="66bb5-548">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="66bb5-549">값이 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, 메서드가 반환 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-549">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="66bb5-550">그렇지 않으면 식의 결과 반환 <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-550">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-551">다음 예제에서는 <xref:System.Numerics.Complex.Reciprocal%2A> 여러 복소수의 역 수 값을 계산 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-551">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="66bb5-552">복합 숫자의 역 수를 곱한 결과 방법도 보여 줍니다 <xref:System.Numerics.Complex.One?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-552">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-553">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-553">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-554">지정된 복소수의 사인을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-554">Returns the sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-555">
            <paramref name="value" />의 사인입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-555">The sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-556">합니다 <xref:System.Numerics.Complex.Sin%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Sin%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-556">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="66bb5-557"><xref:System.Numerics.Complex.Sin%2A> 메서드는 다음 수식을 사용 하 여 복소수의 사인을 계산 a + bi:</span><span class="sxs-lookup"><span data-stu-id="66bb5-557">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="66bb5-558">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="66bb5-558">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-559">다음 예제는 <xref:System.Numerics.Complex.Sin%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-559">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="66bb5-560">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Asin%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Sin%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="66bb5-560">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-561">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-561">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-562">지정된 복소수의 하이퍼볼릭 사인을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-562">Returns the hyperbolic sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-563">
            <paramref name="value" />의 쌍곡선 사인입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-563">The hyperbolic sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-564">합니다 <xref:System.Numerics.Complex.Sinh%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Sinh%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-564">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="66bb5-565"><xref:System.Numerics.Complex.Sinh%2A> 메서드는 다음 수식을 사용 하 여 복소수의 쌍 곡 사인을 계산 a + bi:</span><span class="sxs-lookup"><span data-stu-id="66bb5-565">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="66bb5-566">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="66bb5-566">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-567">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-567">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-568">지정된 복소수의 제곱근을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-568">Returns the square root of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-569">
            <paramref name="value" />의 제곱근입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-569">The square root of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-570">복소수의 제곱근 `value` 다음 수식을 사용 하 여 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-570">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="66bb5-571"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span><span class="sxs-lookup"><span data-stu-id="66bb5-571"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="66bb5-572">합니다 <xref:System.Numerics.Complex.Sqrt%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-572">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="66bb5-573">뺄 대상 값(피감수)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-573">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="66bb5-574">뺄 값(감수)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-574">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-575">한 복소수에서 다른 복소수를 뺀 후 결과를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-575">Subtracts one complex number from another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-576">
            <paramref name="right" />에서 <paramref name="left" />를 뺀 결과입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-576">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-577">복소수, c +에서 다른 복소수 di의 빼기는 bi 형식은 +:</span><span class="sxs-lookup"><span data-stu-id="66bb5-577">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="66bb5-578">(a-c) + (b-d) i</span><span class="sxs-lookup"><span data-stu-id="66bb5-578">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="66bb5-579">메서드 호출 결과 또는 허수 구성 요소 중 하나에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-579">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="66bb5-580">사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수는 <xref:System.Numerics.Complex.Subtract%2A> 복소수를 사용 하 여 빼기를 수행 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-580">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-581">다음 예제에서는 복소수에서 배열에 각 복소수를 뺍니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-581">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-582">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-582">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-583">지정된 복소수의 탄젠트를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-583">Returns the tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-584">
            <paramref name="value" />의 접선입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-584">The tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-585">합니다 <xref:System.Numerics.Complex.Tan%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Tan%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-585">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="66bb5-586">합니다 <xref:System.Numerics.Complex.Tan%2A> 메서드는 다음 수식을 사용 하 여 복소수의 탄젠트를 계산할 `value`:</span><span class="sxs-lookup"><span data-stu-id="66bb5-586">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="66bb5-587"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="66bb5-587"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-588">다음 예제는 <xref:System.Numerics.Complex.Tan%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-588">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="66bb5-589">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Atan%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Tan%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="66bb5-589">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="66bb5-590">복소수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-590">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-591">지정된 복소수의 하이퍼볼릭 탄젠트를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-591">Returns the hyperbolic tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-592">
            <paramref name="value" />의 쌍곡선 접선입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-592">The hyperbolic tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-593">합니다 <xref:System.Numerics.Complex.Tanh%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Tanh%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="66bb5-593">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="66bb5-594">합니다 <xref:System.Numerics.Complex.Tanh%2A> 메서드는 다음 수식을 사용 하 여 복소수의 쌍 곡 탄젠트를 계산 `value`:</span><span class="sxs-lookup"><span data-stu-id="66bb5-594">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="66bb5-595"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="66bb5-595"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-596">복소수 값을 해당하는 문자열 표현으로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-596">Converts the value of a complex number to its equivalent string representation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-597">현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-597">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-598">현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-598">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-599">데카르트 좌표를 사용 하 여 폼의 수를 표시 하는 복소수의 기본 문자열 표현을 `(` *는* `,` *b*`)`여기서 *는* 되는 복소수의 실수부 및 *b* 복소수의 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-599">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="66bb5-600">둘 다 *는* 하 고 *b* 일반 서식 지정자 ("G") 및 현재 시스템 문화권의 규칙을 사용 하 여 서식이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-600">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-601">다음 예제에서는 여러 복합 숫자의 문자열 표현을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-601">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="66bb5-602">영어-미국 ("EN-US") 문화권에는,이 경우 현재 시스템 문화권의 서식 규칙을 사용 하는 출력입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-602">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="66bb5-603">문화권별 서식 지정 정보를 제공하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-603">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-604">지정된 문화권별 서식 정보를 사용하여 현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-604">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-605">
            <paramref name="provider" />에서 지정한 형식에 따른 현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-605">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-606">데카르트 좌표를 사용 하 여 폼의 수를 표시 하는이 메서드에서 반환 된 복잡 한 숫자의 문자열 표현을 `(` *는* `,` *b*`)`, 여기서 *는* 되는 복소수의 실수부 및 *b* 복소수의 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-606">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="66bb5-607">둘 다 *를* 하 고 *b* 일반 서식 지정자 ("G") 및 정의한 문화권의 규칙을 사용 하 여 포맷 된 `provider`합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-607">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="66bb5-608">합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-608">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="66bb5-609">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 실수 및 허수 반환된 된 문자열에서 형식에 대 한 문화권별 형식 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-609">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="66bb5-610">경우 `provider` 됩니다 `null`, 반환된 된 문자열을 사용 하 여 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-610">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="66bb5-611">`provider` 매개 변수는 다음 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-611">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="66bb5-612"><xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체</span><span class="sxs-lookup"><span data-stu-id="66bb5-612">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="66bb5-613"><xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-613">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="66bb5-614">구현 하는 사용자 지정 개체를 <xref:System.IFormatProvider> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-614">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="66bb5-615">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-615">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-616">다음 예제에서는 여러 복합 숫자의 문자열 표현을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-616">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="66bb5-617">결과 영어-미국 ("EN-US") 및 프랑스어-프랑스 ("FR-FR") 문화권의 서식 규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-617">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="66bb5-618">표준 또는 사용자 지정 숫자 서식 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-618">A standard or custom numeric format string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-619">실수와 허수 부분에 대해 지정된 서식을 사용하여 현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-619">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-620">현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-620">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-621">데카르트 좌표를 사용 하 여 폼의 수를 표시 하는이 메서드에서 반환 된 복잡 한 숫자의 문자열 표현을 `(` *는* `,` *b*`)`, 여기서 *는* 되는 복소수의 실수부 및 *b* 복소수의 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-621">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="66bb5-622">둘 다 *는* 하 고 *b* 는 지정 된 형식 문자열을 사용 하 여 서식이 지정 `format`합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-622">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="66bb5-623">`format` 매개 변수는 모든 유효한 표준 숫자 서식 지정자 또는 사용자 지정 숫자 서식 지정자의 임의 조합 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-623">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="66bb5-624">경우 `format` 값과 같음 <xref:System.String.Empty?displayProperty=nameWithType> 아니거나 `null`, 복소수의 실수와 허수 부분 일반 서식 지정자 ("G")로 포맷 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-624">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="66bb5-625">하는 경우 `format` 다른 값을 메서드가 throw를 <xref:System.FormatException>입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-625">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="66bb5-626">다음 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:</span><span class="sxs-lookup"><span data-stu-id="66bb5-626">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="66bb5-627">숫자 형식 문자열에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-627">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="66bb5-628">.NET Framework의 형식에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-628">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="66bb5-629">반환된 된 문자열의 형식은 의해 결정 되는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-629">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="66bb5-630">에 따라는 `format` 매개 변수를이 개체는 출력 문자열에 소수점 기호가 음수 기호, 그룹 구분 기호 등 기호를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-630">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="66bb5-631">현재 문화권이 아닌 문화권에 대 한 서식 지정 정보를 제공 하려면 호출을 <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-631">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-632">다음 예제에서는 복소수를 초기화 하 고 몇 가지 표준 형식 문자열을 사용 하 여 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-632">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="66bb5-633">
            <paramref name="format" />은 유효한 서식 문자열이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-633">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="66bb5-634">표준 또는 사용자 지정 숫자 서식 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-634">A standard or custom numeric format string.</span>
          </span>
        </param>
        <param name="provider">
          <span data-ttu-id="66bb5-635">문화권별 서식 지정 정보를 제공하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-635">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="66bb5-636">실수와 허수 부분에 대해 지정된 서식과 문화권별 서식 정보를 사용하여 현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-636">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="66bb5-637">
            <paramref name="format" /> 및 <paramref name="provider" />에서 지정한 형식에 따른 현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-637">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-638">데카르트 좌표를 사용 하 여 폼의 수를 표시 하는이 메서드에서 반환 된 복잡 한 숫자의 문자열 표현을 `(` *는* `,` *b*`)`, 여기서 *는* 되는 복소수의 실수부 및 *b* 복소수의 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-638">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="66bb5-639">둘 다 *는* 하 고 *b* 는 지정 된 형식 문자열을 사용 하 여 서식이 지정 `format`합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-639">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="66bb5-640">`format` 매개 변수는 모든 유효한 표준 숫자 서식 지정자 또는 사용자 지정 숫자 서식 지정자의 임의 조합 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-640">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="66bb5-641">경우 `format` 값과 같음 <xref:System.String.Empty?displayProperty=nameWithType> 아니거나 `null`, 복소수의 실수와 허수 부분 일반 서식 지정자 ("G")로 포맷 됩니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-641">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="66bb5-642">하는 경우 `format` 다른 값을 메서드가 throw를 <xref:System.FormatException>입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-642">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="66bb5-643">다음 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:</span><span class="sxs-lookup"><span data-stu-id="66bb5-643">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="66bb5-644">숫자 형식 문자열에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-644">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="66bb5-645">.NET Framework의 형식에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-645">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="66bb5-646">합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-646">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="66bb5-647">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 실수 및 허수 반환된 된 문자열에서 형식에 대 한 문화권별 형식 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-647">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="66bb5-648">에 따라는 `format` 매개 변수를이 개체는 출력 문자열에 소수점 기호가 음수 기호, 그룹 구분 기호 등 기호를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-648">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="66bb5-649">경우 `provider` 됩니다 `null`, 반환된 된 문자열을 사용 하 여 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-649">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="66bb5-650">`provider` 매개 변수는 다음 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-650">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="66bb5-651"><xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체</span><span class="sxs-lookup"><span data-stu-id="66bb5-651">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="66bb5-652"><xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-652">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="66bb5-653">구현 하는 사용자 지정 개체를 <xref:System.IFormatProvider> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-653">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="66bb5-654">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-654">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-655">다음 예제에서는 복소수를 배열을 만들고 표시 하는 몇 가지 표준 형식 문자열을 사용 하 여 각 뿐만 <xref:System.Globalization.CultureInfo> 영어-미국 ("EN-US") 및 프랑스어-프랑스 ("FR-FR") 문화권을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-655">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="66bb5-656">
            <paramref name="format" />은 유효한 서식 문자열이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-656">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="66bb5-657">0과 같은 실수와 0과 같은 허수를 포함하는 새 <see cref="T:System.Numerics.Complex" /> 인스턴스를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="66bb5-657">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="66bb5-658">합니다 <xref:System.Numerics.Complex.Zero> 속성은 가장 자주 비교 하는 데는 <xref:System.Numerics.Complex> 값을 0입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-658">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="66bb5-659">다음 예제에서는 한 <xref:System.Numerics.Complex> 사용 하 여 값을 <xref:System.Numerics.Complex.Zero> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-659">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="66bb5-660">그런 다음이 값을 호출 하 여 인스턴스화된 다른 값을 비교 합니다 <xref:System.Numerics.Complex> 실수부 0, 0을 허수 부분을 사용 하 여 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-660">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="66bb5-661">예제의 출력에서 볼 수 있듯이 두 값이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="66bb5-661">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>