<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CommittableTransaction.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86cd3e8700bb48cfabbbc72eb2ea0616b8d41848bb1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3e8700bb48cfabbbc72eb2ea0616b8d41848bb1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Transactions.CommittableTransaction">
          <source>Describes a committable transaction.</source>
          <target state="translated">커밋할 수 있는 트랜잭션에 대해 설명합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>The <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> class provides an explicit way for applications to use a transaction, as opposed to using the <ph id="ph2">&lt;xref:System.Transactions.TransactionScope&gt;</ph> class implicitly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> 클래스를 암시적으로 사용하는 경우와 달리 <ph id="ph2">&lt;xref:System.Transactions.TransactionScope&gt;</ph> 클래스는 응용 프로그램이 트랜잭션을 사용할 수 있는 명시적 방법을 제공합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Transactions.TransactionScope&gt;</ph> class, the application writer needs to specifically call the <ph id="ph2">&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Transactions.Transaction.Rollback%2A&gt;</ph> methods in order to commit or abort the transaction.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Transactions.TransactionScope&gt;</ph> 클래스와 달리 응용 프로그램 작성기에서 특별히 <ph id="ph2">&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Transactions.Transaction.Rollback%2A&gt;</ph> 메서드를 호출하여 트랜잭션을 커밋하거나 중단해야 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>However, only the creator of a transaction can commit the transaction.</source>
          <target state="translated">그러나 작성자만 콘텐츠 팩 트랜잭션의 트랜잭션을 커밋할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>Therefore, copies of a committable transaction, obtained through the <ph id="ph1">&lt;xref:System.Transactions.Transaction.Clone%2A&gt;</ph> method are not committable.</source>
          <target state="translated">따라서, 커밋할 수 있는 트랜잭션에의 복사본을 얻은 <ph id="ph1">&lt;xref:System.Transactions.Transaction.Clone%2A&gt;</ph> 메서드는 커밋할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>We recommend that you create implicit transactions using the <ph id="ph1">&lt;xref:System.Transactions.TransactionScope&gt;</ph> class, so that the ambient transaction context is automatically managed for you.</source>
          <target state="translated">사용 하 여 암시적 트랜잭션을 만드는 것이 좋습니다는 <ph id="ph1">&lt;xref:System.Transactions.TransactionScope&gt;</ph> 클래스, 앰비언트 트랜잭션 컨텍스트에 자동으로 관리 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>You should also use the <ph id="ph1">&lt;xref:System.Transactions.TransactionScope&gt;</ph> and <ph id="ph2">&lt;xref:System.Transactions.DependentTransaction&gt;</ph> class for applications that require the use of the same transaction across multiple function calls or multiple thread calls.</source>
          <target state="translated">또한 사용 해야는 <ph id="ph1">&lt;xref:System.Transactions.TransactionScope&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Transactions.DependentTransaction&gt;</ph> 여러 함수 호출이 나 여러 스레드 호출에서 동일한 트랜잭션 사용 해야 하는 응용 프로그램에 대 한 클래스입니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>For more information on this model, see the <bpt id="p1">[</bpt>Implementing An Implicit Transaction Using Transaction Scope<ept id="p1">](~/docs/framework/data/transactions/implementing-an-implicit-transaction-using-transaction-scope.md)</ept> topic.</source>
          <target state="translated">이 모델에 대 한 자세한 내용은 참조는 <bpt id="p1">[</bpt>구현 하는 암시적 트랜잭션을 사용 하 여 트랜잭션 범위<ept id="p1">](~/docs/framework/data/transactions/implementing-an-implicit-transaction-using-transaction-scope.md)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>Creating a <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> does not automatically set the ambient transaction, which is the transaction your code executes in.</source>
          <target state="translated">만들기는 <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> 앰비언트 트랜잭션을 코드 실행에 트랜잭션을 자동으로 설정 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>You can get or set the ambient transaction by calling the static <ph id="ph1">&lt;xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType&gt;</ph> property of the global <ph id="ph2">&lt;xref:System.Transactions.Transaction&gt;</ph> object.</source>
          <target state="translated">가져오거나 정적을 호출 하 여 앰비언트 트랜잭션을 설정할 수 있습니다 <ph id="ph1">&lt;xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType&gt;</ph> 은 전역 <ph id="ph2">&lt;xref:System.Transactions.Transaction&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>For more information on ambient transactions, see the " Managing Transaction Flow using TransactionScopeOption" section of the <bpt id="p1">[</bpt>Implementing An Implicit Transaction Using Transaction Scope<ept id="p1">](~/docs/framework/data/transactions/implementing-an-implicit-transaction-using-transaction-scope.md)</ept> topic.</source>
          <target state="translated">앰비언트 트랜잭션에 대 한 자세한 내용은의 "Managing 트랜잭션 흐름 TransactionScopeOption를 사용 하 여" 섹션을 참조 하십시오.는 <bpt id="p1">[</bpt>구현 하는 암시적 트랜잭션을 사용 하 여 트랜잭션 범위<ept id="p1">](~/docs/framework/data/transactions/implementing-an-implicit-transaction-using-transaction-scope.md)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>If the ambient transaction is not set, any operation on a resource manager is not part of that transaction.</source>
          <target state="translated">앰비언트 트랜잭션이 설정 되지 않은 경우 리소스 관리자에 대 한 작업 해당 트랜잭션의 일부가 아닙니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>You need to explicitly set and reset the ambient transaction to ensure that resource managers operate under the right transaction context.</source>
          <target state="translated">명시적으로 설정 하 고 리소스 관리자 올바른 트랜잭션 컨텍스트 내에서 작동 하도록 앰비언트 트랜잭션이 다시 설정 해야 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>Until a <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> has been committed, all the resources involved with the transaction are still locked.</source>
          <target state="translated">될 때까지 한 <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> 가 커밋될 트랜잭션과 관련된 된 모든 리소스가 잠겨 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>A <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> object cannot be reused.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> 개체는 다시 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>Once it has been committed or rolled back, it cannot be used again in a transaction or set as the current ambient transaction context.</source>
          <target state="translated">커밋 또는 롤백 되었는지가, 되 면 트랜잭션에서 다시 사용 하거나 현재 앰비언트 트랜잭션 컨텍스트로 설정 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>The following sample creates two new instances of <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph>, commits and rolls back them respectively.</source>
          <target state="translated">다음 샘플의 두 개의 새 인스턴스를 만드는 <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph>을 커밋한 다음 롤백합니다 각각.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Transactions.CommittableTransaction">
          <source>This type is thread safe.</source>
          <target state="translated">이 형식은 스레드로부터 안전합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="T:System.Transactions.CommittableTransaction">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Transactions.CommittableTransaction" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Transactions.CommittableTransaction" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Transactions.CommittableTransaction" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Transactions.CommittableTransaction" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.#ctor">
          <source>The following sample creates a new instance of <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> and commits it.</source>
          <target state="translated">다음 샘플의 새 인스턴스를 만듭니다. <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> 커밋되면 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.#ctor">
          <source>An attempt to create a transaction under Windows 98, Windows 98 Second Edition or Windows Millennium Edition.</source>
          <target state="translated">Windows 98, Windows 98 Second Edition 또는 Windows Millennium Edition에서 트랜잭션을 만들려고 한 경우</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.#ctor(System.TimeSpan)">
          <source>The maximum amount of time the transaction can exist, before it is aborted.</source>
          <target state="translated">트랜잭션이 중단되기 전에 존재할 수 있는 최대 시간입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.#ctor(System.TimeSpan)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Transactions.CommittableTransaction" /&gt;</ph> class with the specified <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> value.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Transactions.CommittableTransaction" /&gt;</ph> 값을 사용하여 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.#ctor(System.TimeSpan)">
          <source>An attempt to create a transaction under Windows 98, Windows 98 Second Edition or Windows Millennium Edition.</source>
          <target state="translated">Windows 98, Windows 98 Second Edition 또는 Windows Millennium Edition에서 트랜잭션을 만들려고 한 경우</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.#ctor(System.Transactions.TransactionOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Transactions.TransactionOptions" /&gt;</ph> structure that describes the transaction options to use for the new transaction.</source>
          <target state="translated">새 트랜잭션에 사용할 트랜잭션 옵션을 설명하는 <ph id="ph1">&lt;see cref="T:System.Transactions.TransactionOptions" /&gt;</ph> 구조체입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.#ctor(System.Transactions.TransactionOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Transactions.CommittableTransaction" /&gt;</ph> class with the specified transaction options.</source>
          <target state="translated">지정된 트랜잭션 옵션을 사용하여 <ph id="ph1">&lt;see cref="T:System.Transactions.CommittableTransaction" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.#ctor(System.Transactions.TransactionOptions)">
          <source>The following sample creates a new instance of <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> with options, and aborts it.</source>
          <target state="translated">다음 샘플의 새 인스턴스를 만듭니다. <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction&gt;</ph> 옵션이 있는 것을 중단 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.#ctor(System.Transactions.TransactionOptions)">
          <source>An attempt to create a transaction under Windows 98, Windows 98 Second Edition or Windows Millennium Edition.</source>
          <target state="translated">Windows 98, Windows 98 Second Edition 또는 Windows Millennium Edition에서 트랜잭션을 만들려고 한 경우</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.#ctor(System.Transactions.TransactionOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph>이 잘못되었습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)">
          <source>Begins an attempt to commit the transaction asynchronously.</source>
          <target state="translated">비동기적으로 트랜잭션을 커밋하려는 시도를 시작합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> interface that can be used by the caller to check the status of the asynchronous operation, or to wait for the operation to complete.</source>
          <target state="translated">비동기 작업 상태를 확인하거나 작업이 완료될 때까지 대기하기 위해 호출자가 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)">
          <source>This method returns immediately, before the transaction has been completed.</source>
          <target state="translated">이 메서드는 트랜잭션이 완료 되기 전에 즉시 반환 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)">
          <source>The transaction then commits on a different thread, and the <ph id="ph1">`asyncCallback`</ph> delegate is invoked when it has completed.</source>
          <target state="translated">트랜잭션 후 다른 스레드에서 커밋 및 <ph id="ph1">`asyncCallback`</ph> 완료 되지 않았을 때 대리자가 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)">
          <source>After this method is called, you do not receive the outcome of the transaction until you call <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt;</ph>.</source>
          <target state="translated">이 메서드가 호출 된 후 나타나지 않으면 트랜잭션 결과 호출할 때까지 <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)">
          <source>The commit process may complete synchronously inside this method call.</source>
          <target state="translated">이 메서드 호출 내 커밋 프로세스 동기적으로 완료 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>Attempts to commit the transaction.</source>
          <target state="translated">트랜잭션을 커밋하려고 시도합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>When this method is called, all objects that have registered to participate in the transaction are polled and can independently indicate their vote to either commit or roll back the transaction.</source>
          <target state="translated">이 메서드는 트랜잭션에 참여 하도록 등록 된 모든 개체 폴링을 수행 하 고 독립적으로 커밋 또는 트랜잭션을 여부를 나타낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>If any participant votes to roll back the transaction, it is rolled back and this method throws a <ph id="ph1">&lt;xref:System.Transactions.TransactionException&gt;</ph> exception.</source>
          <target state="translated">트랜잭션을 선택한 참가 요소 롤백됩니다 않으며이 메서드는 <ph id="ph1">&lt;xref:System.Transactions.TransactionException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>This is a normal occurrence for a transaction and your code should catch and process such exceptions.</source>
          <target state="translated">이 트랜잭션에 대 한 일반적으로 발생 하 고 코드를 catch 하 고 이러한 예외를 처리 해야 합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source><ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt;</ph> block until the first phase of transaction processing is complete.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt;</ph> 트랜잭션 처리의 첫 번째 단계 완료 될 때까지 차단 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>The first phase ends after all resource managers and enlistments in the transaction have voted on the transaction outcome and the <ph id="ph1">&lt;xref:System.Transactions.TransactionManager&gt;</ph> has durably decided to commit or abort the transaction.</source>
          <target state="translated">첫 번째 단계는 모든 리소스 관리자 한 후 종료 하 고 트랜잭션에 인 리스트 먼 트 트랜잭션 결과에 투표 했 고 <ph id="ph1">&lt;xref:System.Transactions.TransactionManager&gt;</ph> 가 지 속력 있게 커밋하거나 트랜잭션을 중단 하 고 결정 합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>The second phase of processing is always asynchronous.</source>
          <target state="translated">처리의 두 번째 단계는 항상 비동기입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>Therefore, there is no guarantee that data just committed from within a given transaction will be immediately available afterwards when not using another transaction to view this data.</source>
          <target state="translated">따라서은 커밋된 데이터를 바로에서 지정된 된 트랜잭션 내에서 사용할 수 있다는 즉시 나중에이 데이터를 다른 트랜잭션이 사용 하지 않을 때 아닙니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>Because this method blocks until the first phase of transaction processing is complete, you should be extremely careful when using this method in a Windows Form (WinForm) application, or a deadlock can occur.</source>
          <target state="translated">이 메서드 차단 트랜잭션 처리의 첫 번째 단계 완료 될 때까지, 매우 주의 해야는 Windows Form (WinForm) 응용 프로그램 또는 교착 상태에서이 메서드를 사용 하는 경우 발생할 수 있습니다 때문에.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>If you call this method inside one WinForm Control event (for example, clicking a button), and use the synchronous <ph id="ph1">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> method to direct the control to perform some UI tasks (for example, changing colors) in the middle of processing the transaction, a deadlock will happen.</source>
          <target state="translated">(예: 단추 클릭), 하나의 WinForm 컨트롤 이벤트 내에서이 메서드를 호출 하 고 동기를 사용 하는 경우 <ph id="ph1">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> 컨트롤, 트랜잭션을 처리 중에 일부 UI 작업 (예를 들어 변경 색)을 수행 하는 메서드는 교착 상태가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>This is because the <ph id="ph1">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> method is synchronous and blocks the worker thread until the UI thread finishes its job.</source>
          <target state="translated">때문에 이것이 <ph id="ph1">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> 메서드는 동기적 이므로 UI 스레드 작업을 완료 될 때까지 작업자 스레드를 차단 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>However, in our scenario, the UI thread is also waiting for the worker thread to commit the transaction.</source>
          <target state="translated">시나리오에서 UI 스레드 또한 트랜잭션을 커밋하는 작업자 스레드 대기 됩니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>The result is that none is able to proceed and the scope waits indefinitely for the Commit to finish.</source>
          <target state="translated">결과를 계속할 수 없는 및 범위는 커밋이 완료에 대 한 무기한 대기입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source>You should use <ph id="ph1">&lt;xref:System.Windows.Forms.Control.BeginInvoke%2A&gt;</ph> rather than <ph id="ph2">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> wherever possible, because it is asynchronous and thus less prone to deadlock.</source>
          <target state="translated">사용 해야 <ph id="ph1">&lt;xref:System.Windows.Forms.Control.BeginInvoke%2A&gt;</ph> 대신 <ph id="ph2">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> 비동기적이 고 교착 상태가 발생할 가능성이 적으므로 이기 때문에 가능 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source><ph id="ph1">&lt;see cref="M:System.Transactions.CommittableTransaction.Commit" /&gt;</ph> is called on a transaction and the transaction becomes <ph id="ph2">&lt;see cref="F:System.Transactions.TransactionStatus.InDoubt" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Transactions.CommittableTransaction.Commit" /&gt;</ph>이 트랜잭션에서 호출되고 트랜잭션이 <ph id="ph2">&lt;see cref="F:System.Transactions.TransactionStatus.InDoubt" /&gt;</ph>가 되는 경우</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.Commit">
          <source><ph id="ph1">&lt;see cref="M:System.Transactions.CommittableTransaction.Commit" /&gt;</ph> is called and the transaction rolls back for the first time.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Transactions.CommittableTransaction.Commit" /&gt;</ph>이 호출되고 트랜잭션이 처음으로 롤백된 경우</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)">
          <source>Ends an attempt to commit the transaction asynchronously.</source>
          <target state="translated">트랜잭션을 비동기적으로 커밋하려는 시도를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)">
          <source>You should call this method in the callback delegate specified as a parameter to the <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction.BeginCommit%2A&gt;</ph> method, when you have finished any cleanup work associated with the asynchronous commitment.</source>
          <target state="translated">에 대 한 매개 변수로 지정 된 콜백 대리자에서이 메서드를 호출 해야는 <ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction.BeginCommit%2A&gt;</ph> 메서드를 비동기 커밋과 관련 된 정리 작업을 완료 합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)">
          <source>You can also call this method early without waiting for the delegate.</source>
          <target state="translated">또한이 메서드는 대리자를 기다리지 않고 초기 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)">
          <source>If, by the time you call this method, the transaction has not completed, this method waits for its completion.</source>
          <target state="translated">이 메서드를 호출 하는 시점에서는 트랜잭션이 완료 되지 않은 경우이 메서드는 완료 되기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property returned by <ph id="ph2">`asyncResult`</ph> is always <ph id="ph3">`false`</ph>, even if the operation completed synchronously.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> 속성에서 반환 되 <ph id="ph2">`asyncResult`</ph> 항상 <ph id="ph3">`false`</ph>작업이 동기적으로 완료 하는 경우에 합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt;</ph> block until the first phase of transaction processing is complete.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Transactions.CommittableTransaction.EndCommit%2A&gt;</ph> 트랜잭션 처리의 첫 번째 단계 완료 될 때까지 차단 합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)">
          <source>The first phase ends after all resource managers and enlistments in the transaction have voted on the transaction outcome and the <ph id="ph1">&lt;xref:System.Transactions.TransactionManager&gt;</ph> has durably decided to commit or abort the transaction.</source>
          <target state="translated">첫 번째 단계는 모든 리소스 관리자 한 후 종료 하 고 트랜잭션에 인 리스트 먼 트 트랜잭션 결과에 투표 했 고 <ph id="ph1">&lt;xref:System.Transactions.TransactionManager&gt;</ph> 가 지 속력 있게 커밋하거나 트랜잭션을 중단 하 고 결정 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)">
          <source>The second phase of processing is always asynchronous.</source>
          <target state="translated">처리의 두 번째 단계는 항상 비동기입니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)">
          <source>Therefore, there is no guarantee that data just committed from within a given transaction will be immediately available afterwards when not using another transaction to view this data.</source>
          <target state="translated">따라서은 커밋된 데이터를 바로에서 지정된 된 트랜잭션 내에서 사용할 수 있다는 즉시 나중에이 데이터를 다른 트랜잭션이 사용 하지 않을 때 아닙니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)" /&gt;</ph> is called and the transaction rolls back for the first time.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)" /&gt;</ph>이 호출되고 트랜잭션이 처음으로 롤백된 경우</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="P:System.Transactions.CommittableTransaction.System#IAsyncResult#AsyncState">
          <source>Gets the object provided as the last parameter of the <ph id="ph1">&lt;see cref="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)" /&gt;</ph> method call.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)" /&gt;</ph> 메서드 호출의 마지막 매개 변수로 제공된 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Transactions.CommittableTransaction.System#IAsyncResult#AsyncState">
          <source>The object provided as the last parameter of the <ph id="ph1">&lt;see cref="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)" /&gt;</ph> method call.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)" /&gt;</ph> 메서드 호출의 마지막 매개 변수로 제공된 개체입니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="P:System.Transactions.CommittableTransaction.System#IAsyncResult#AsyncWaitHandle">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> that is used to wait for an asynchronous operation to complete.</source>
          <target state="translated">비동기 작업이 완료될 때까지 기다리는 데 사용하는 <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph>을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Transactions.CommittableTransaction.System#IAsyncResult#AsyncWaitHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> that is used to wait for an asynchronous operation to complete.</source>
          <target state="translated">비동기 작업이 완료될 때까지 기다리는 데 사용하는 <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="P:System.Transactions.CommittableTransaction.System#IAsyncResult#CompletedSynchronously">
          <source>Gets an indication of whether the asynchronous commit operation completed synchronously.</source>
          <target state="translated">비동기 커밋 작업이 동기적으로 완료되었는지 여부를 나타내는 표시를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Transactions.CommittableTransaction.System#IAsyncResult#CompletedSynchronously">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the asynchronous commit operation completed synchronously; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">비동기 커밋 작업이 동기적으로 완료되면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Transactions.CommittableTransaction.System#IAsyncResult#CompletedSynchronously">
          <source>This property always returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> even if the operation completed synchronously.</source>
          <target state="translated">작업이 동기적으로 완료된 경우에도 이 속성은 항상 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="P:System.Transactions.CommittableTransaction.System#IAsyncResult#IsCompleted">
          <source>Gets an indication whether the asynchronous commit operation has completed.</source>
          <target state="translated">비동기 커밋 작업이 완료되었는지 여부를 나타내는 표시를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Transactions.CommittableTransaction.System#IAsyncResult#IsCompleted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is complete; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업이 끝나면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>