<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FormatterTypeStyle.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5e990cc2ba4f28358cd07886e0e7b7aa04f6a7d75.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e990cc2ba4f28358cd07886e0e7b7aa04f6a7d75</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.Serialization.Formatters.FormatterTypeStyle">
          <source>Indicates the format in which type descriptions are laid out in the serialized stream.</source>
          <target state="translated">형식 설명을 serialize된 스트림에 레이아웃하는 형식을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.TypesAlways">
          <source>Indicates that types can be given to all object members and <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> object members.</source>
          <target state="translated">형식이 모든 개체 멤버와 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> 개체 멤버에 지정될 수 있음을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.TypesWhenNeeded">
          <source>Indicates that types can be stated only for arrays of objects, object members of type <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, and <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> non-primitive value types.</source>
          <target state="translated">개체 배열, <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> 형식의 개체 멤버 및 기본 형식이 아닌 <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> 값 형식에 대해서만 형식을 지정할 수 있음을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>Indicates that strings can be given in the XSD format rather than SOAP.</source>
          <target state="translated">SOAP 형식이 아닌 XSD 형식으로 문자열을 지정할 수 있음을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>No string IDs are transmitted.</source>
          <target state="translated">문자열 ID는 전송되지 않습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>The <ph id="ph1">`XsdString`</ph> and <ph id="ph2">`TypesWhenNeeded`</ph> settings are meant for high performance serialization between services built on the same version of the <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">`XsdString`</ph> 및 <ph id="ph2">`TypesWhenNeeded`</ph> 동일한 버전의에서 작성 된 서비스 간의 고성능 serialization에 대 한 설정을 큐브일는 <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>These two values do not support VTS (Version Tolerant Serialization) because they intentionally omit type information that VTS uses to skip or add optional fields and properties.</source>
          <target state="translated">VTS 사용를 건너뛰거나 선택적 필드 및 속성을 추가 하는 형식 정보를 의도적으로 생략 하기 때문에이 두 값 VTS (버전 독립적 Serialization)를 지원 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>You should not use the <ph id="ph1">`XsdString`</ph> or <ph id="ph2">`TypesWhenNeeded`</ph> type formats when serializing and deserializing types on a computer running a different version of the <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> than the computer on which the type was serialized.</source>
          <target state="translated">사용 하지 않아야는 <ph id="ph1">`XsdString`</ph> 또는 <ph id="ph2">`TypesWhenNeeded`</ph> 직렬화 및 역직렬화의 다른 버전을 실행 하는 컴퓨터에 대 한 형식에 형식는 <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> 형식을 직렬화 된 컴퓨터.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>Serializing and deserializing on computers running different versions of the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> causes the formatter to skip serialization of type information, thus making it impossible for the deserializer to skip optional fields if they are not present in certain types that may exist in the other version of the <ph id="ph2">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</source>
          <target state="translated">직렬화 및 역직렬화의 서로 다른 버전을 실행 하는 컴퓨터에는 <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> 있기 때문에 특정 존재 하지 않는 경우 선택적 필드를 건너뛰려면 deserializer에 형식 정보를 직렬화 하지 않으려면 포맷터로 인해 다른 버전의에 있을 수 있는 형식은 <ph id="ph2">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>If you must use <ph id="ph1">`XsdString`</ph> or <ph id="ph2">`TypesWhenNeeded`</ph> in such a scenario, you must provide custom serialization for types that have changed from one version of the <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> to the other.</source>
          <target state="translated">사용 해야 할 경우 <ph id="ph1">`XsdString`</ph> 또는 <ph id="ph2">`TypesWhenNeeded`</ph> 이러한 시나리오의 한 버전에서 변경 된 형식에 대 한 사용자 지정 직렬화를 제공 해야 합니다는 <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> 다른 합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>