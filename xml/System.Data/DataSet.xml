<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5e84607c810b7307a449ac176f00e6a7a789c10a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36680148" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataSet = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>데이터의 인-메모리 캐시를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet>, 데이터 원본에서 검색 된 데이터의 메모리 내 캐시는 ADO.NET 아키텍처의 주요 구성 요소입니다. <xref:System.Data.DataSet> 의 컬렉션 <xref:System.Data.DataTable> 개체를 통해 서로 연결할 수 있습니다 <xref:System.Data.DataRelation> 개체입니다. 데이터 무결성을 적용할 수 있습니다는 <xref:System.Data.DataSet> 를 사용 하 여는 <xref:System.Data.UniqueConstraint> 및 <xref:System.Data.ForeignKeyConstraint> 개체입니다. 작업에 대 한 자세한 내용은 <xref:System.Data.DataSet> 개체 참조 [데이터 집합, Datatable 및 Dataview](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md)합니다.  
  
 반면 <xref:System.Data.DataTable> 개체 데이터가 <xref:System.Data.DataRelationCollection> 테이블 계층 구조를 탐색할 수 있습니다. 테이블에 포함 된 한 <xref:System.Data.DataTableCollection> 를 통해 액세스는 <xref:System.Data.DataSet.Tables%2A> 속성입니다. 에 액세스할 때 <xref:System.Data.DataTable> 개체, 조건에 따라 대/소문자 구분 되는지 확인 합니다. 예를 들어 하나의 <xref:System.Data.DataTable> "mydatatable" 라고 하 고 "Mydatatable" 라는 다른, 테이블 중 하나를 검색 하는 데 사용 하는 문자열 같이 대/소문자 구분 간주 됩니다. 그러나 "mydatatable" 있으며 "Mydatatable" 하지 않는 경우 검색 문자열 소문자 간주 됩니다. 작업에 대 한 자세한 내용은 <xref:System.Data.DataTable> 개체 참조 [DataTable 만들기](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)합니다.  
  
 A <xref:System.Data.DataSet> 읽고 XML 문서로 데이터와 스키마를 쓸 수 있습니다. 데이터 및 스키마 다음 전체 HTTP 전송 및 사용할 수는 XML을 사용 하도록 설정 하는 모든 플랫폼에서 모든 응용 프로그램에서 합니다. 스키마와 XML 스키마로 저장할 수 있습니다는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드, 및 스키마와 데이터 모두를 사용 하 여 저장할 수는 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 사용 하 여 스키마와 데이터 모두 포함 하는 XML 문서를 읽으려면는 <xref:System.Data.DataSet.ReadXml%2A> 메서드.  
  
 일반적인 다중 계층 구현을 만들고 새로 고침 단계에서 한 <xref:System.Data.DataSet>에 원래 데이터를 업데이트 하 고:  
  
1.  빌드 및 각 채우기 <xref:System.Data.DataTable> 에 <xref:System.Data.DataSet> 사용 하 여 데이터 소스의 데이터로 <xref:System.Data.Common.DataAdapter>합니다.  
  
2.  개인의 데이터 변경 <xref:System.Data.DataTable> 추가, 업데이트 또는 삭제 하 여 개체 <xref:System.Data.DataRow> 개체입니다.  
  
3.  호출 된 <xref:System.Data.DataSet.GetChanges%2A> 초를 만드는 메서드를 <xref:System.Data.DataSet> 만 데이터를 변경 하는 기능입니다.  
  
4.  호출의 <xref:System.Data.Common.DataAdapter.Update%2A> 의 메서드는 <xref:System.Data.Common.DataAdapter>, 두 번째 전달 <xref:System.Data.DataSet> 인수로 합니다.  
  
5.  호출는 <xref:System.Data.DataSet.Merge%2A> 메서드를 두 번째의 변경 내용을 병합 <xref:System.Data.DataSet> 첫 번째에 있습니다.  
  
6.  호출 된 <xref:System.Data.DataSet.AcceptChanges%2A> 에 <xref:System.Data.DataSet>합니다. 또는, 호출 <xref:System.Data.DataSet.RejectChanges%2A> 변경 내용을 취소 합니다.  
  
> [!NOTE]
>  <xref:System.Data.DataSet> 및 <xref:System.Data.DataTable> 개체에서 상속 <xref:System.ComponentModel.MarshalByValueComponent>, 및 지원에서 <xref:System.Runtime.Serialization.ISerializable> 원격 제어를 위한 인터페이스입니다. 이 두 개체는 원격으로 연결할 수 있는 유일한 ADO.NET 개체입니다.  
  
> [!NOTE]
>  클래스에서 상속 된 <xref:System.Data.DataSet> 종료자 억제 되었기 때문에 가비지 수집기에 의해 종료 되지 않습니다 <xref:System.Data.DataSet>합니다. 파생된 클래스를 호출할 수는 <xref:System.GC.ReRegisterForFinalize%2A> 해당 생성자를 클래스에는 가비지 수집기에 의해 종료 될 수 있도록 합니다.  
  
   
  
## Examples  
 다음 예제에서는 결합 된 여러 가지 방법으로 이루어져을 만들고 채우는 <xref:System.Data.DataSet> 에서 **Northwind** 데이터베이스입니다.  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 다중 스레드 읽기 작업에 안전 합니다. 쓰기 작업을 동기화 해야 합니다.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 구현에서 <xref:System.Data.DataSet> 생성자 매개 변수를 하 고 새 인스턴스에 대 한 기본 이름이 "NewDataSet"를 만듭니다.  
  
 에 대 한 이름을 <xref:System.Data.DataSet> 의 XML 표현이 있는지 확인 하는 데 필요한는 <xref:System.Data.DataSet> 항상 스키마 정의에 최상위 요소가 문서 요소에 대 한 이름을 가집니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataSet>, 두 개 추가 <xref:System.Data.DataTable> 개체를 합니다.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : string -&gt; System.Data.DataSet" Usage="new System.Data.DataSet dataSetName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">
          <see cref="T:System.Data.DataSet" />의 이름입니다.</param>
        <summary>지정된 이름을 사용하여 <see cref="T:System.Data.DataSet" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 이름을 <xref:System.Data.DataSet> 의 XML 표현이 있는지 확인 하는 데 필요한는 <xref:System.Data.DataSet> 항상 스키마 정의에서 가장 높은 수준의 요소가 있는 문서 요소에 대 한 이름을 가집니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataSet>, 두 개의를 <xref:System.Data.DataTable> 개체가 추가 됩니다.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">개체를 serialize 또는 deserialize하는 데 필요한 데이터입니다.</param>
        <param name="context">serialize된 특정 스트림의 소스와 대상입니다.</param>
        <summary>지정한 serialization 정보와 컨텍스트가 있는 <see cref="T:System.Data.DataSet" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext * bool -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context, ConstructSchema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> 개체</param>
        <param name="ConstructSchema">부울 값입니다.</param>
        <summary>
          <see cref="T:System.Data.DataSet" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataSet.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Data.DataSet" />이 로드된 이후 또는 <see cref="M:System.Data.DataSet.AcceptChanges" />가 마지막으로 호출된 이후에 변경된 DataSet의 모든 내용을 커밋합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 둘 다는 <xref:System.Data.DataRow> 및 <xref:System.Data.DataTable> 클래스에는 <xref:System.Data.DataSet.AcceptChanges%2A> 메서드. 호출 <xref:System.Data.DataTable.AcceptChanges%2A> 에 <xref:System.Data.DataTable> 원인을 수준는 <xref:System.Data.DataRow.AcceptChanges%2A> 메서드 각각에 대해 <xref:System.Data.DataRow> 를 호출할 수 있습니다. 마찬가지로, 호출 <xref:System.Data.DataSet.AcceptChanges%2A> 에 <xref:System.Data.DataSet> 하면 <xref:System.Data.DataTable.AcceptChanges%2A> 각 테이블에 대해 호출 되는 <xref:System.Data.DataSet>합니다. 이러한 방식으로 메서드를 호출할 수 있는 여러 수준을 사용할 수 있습니다. 호출 된 <xref:System.Data.DataSet.AcceptChanges%2A> 의 <xref:System.Data.DataSet> 호출 하 여 모든 하위 개체 (예: 테이블 및 행)에 대 한 메서드를 호출할 수 있습니다.  
  
 호출 하는 경우 `AcceptChanges` 에 `DataSet`있으면 모든 <xref:System.Data.DataRow> 아직 편집 모드에에서는 개체의 편집을 성공적으로 완료 합니다. <xref:System.Data.DataRow.RowState%2A> 각 속성 <xref:System.Data.DataRow> 설치 경로도 변경 됩니다. `Added` 및 `Modified` 될 행 `Unchanged`, 및 `Deleted` 행이 제거 됩니다.  
  
 경우는 `DataSet` 포함 <xref:System.Data.ForeignKeyConstraint> 개체를 호출 하는 `AcceptChanges` 메서드는 <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> 적용 됩니다.  
  
> [!NOTE]
>  `AcceptChanges` 및 `RejectChanges` 에 적용 `DataRow` 관련 변경 내용 (즉, 추가, 제거, 삭제 및 수정). 스키마 나 구조 변경 내용을 적용 되지 않습니다.  
>   
>  AcceptChanges를 호출 복제 되지 않습니다 이러한 변경 내용을 데이터 소스에 다시 DataAdapter를 사용 하 여 데이터 집합 채워진 경우. 이러한 상황에서는 호출 <xref:System.Data.Common.DataAdapter.Update%2A> 대신 합니다. 참조 [Dataadapter로 데이터 원본 업데이트](http://msdn.microsoft.com/library/33y2221y.aspx) 자세한 정보에 대 한 합니다.  
  
   
  
## Examples  
 다음 예제에서는 추가 <xref:System.Data.DataRow> 에 <xref:System.Data.DataTable> 에 <xref:System.Data.DataSet>합니다. <xref:System.Data.DataSet.AcceptChanges%2A> 에서 메서드가 호출 됩니다는 <xref:System.Data.DataSet>, 모두에 적용 <xref:System.Data.DataTable> 포함 된 개체입니다.  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataSet.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>폼에 사용되거나 다른 구성 요소에서 사용하는 <see cref="T:System.Data.DataSet" />의 초기화를 시작합니다. 초기화는 런타임에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 시작 합니다. <xref:System.Data.DataSet.EndInit%2A> 메서드 초기화를 끝냅니다. 사용 하는 <xref:System.Data.DataSet.BeginInit%2A> 및 <xref:System.Data.DataSet.EndInit%2A> 메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> 개체에서 문자열을 비교할 때 대/소문자를 구분하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>대/소문자를 구분하여 문자열을 비교하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.CaseSensitive%2A> 속성 정렬, 검색 및 필터링 작업도 각에서 수행 하는 방법에 영향을 줍니다. <xref:System.Data.DataTable> 에 포함 된 개체는 <xref:System.Data.DataSet> 사용 하는 경우는 <xref:System.Data.DataTable.Select%2A> 메서드.  
  
 기본적으로 설정는 <xref:System.Data.DataSet.CaseSensitive%2A> 속성에 대 한는 <xref:System.Data.DataSet> 설정는 <xref:System.Data.DataTable.CaseSensitive%2A> 의 연결 된 각 속성 <xref:System.Data.DataTable> 과 같은 값입니다.  
  
   
  
## Examples  
 다음 예제에서는 설정/해제는 <xref:System.Data.DataSet.CaseSensitive%2A> 속성입니다.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 테이블에서 행을 모두 제거하여 데이터의 <see cref="T:System.Data.DataSet" />을 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Data.DataSet> 에 바인딩된는 <xref:System.Xml.XmlDataDocument>호출, <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> 또는 <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> 발생는 <xref:System.NotSupportedException>합니다. 이러한 상황을 방지 하려면 한 번에 하나씩 행을 제거, 각 테이블을 이동 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지웁니다는 <xref:System.Data.DataSet> 모든 테이블의 모든 행입니다.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataSet&#xA;override this.Clone : unit -&gt; System.Data.DataSet" Usage="dataSet.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 <see cref="T:System.Data.DataSet" /> 스키마, 관계 및 제약 조건을 포함하여 <see cref="T:System.Data.DataTable" />의 구조를 복사합니다. 데이터는 복사하지 않습니다.</summary>
        <returns>현재 <see cref="T:System.Data.DataSet" />과 같은 스키마를 가지지만 데이터가 없는 새 <see cref="T:System.Data.DataSet" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이러한 클래스 서브클래싱된 복제본 서브 클래스 수도 있습니다.  
  
   
  
## Examples  
 다음 예제에서는의 복제본을 만듭니다는 <xref:System.Data.DataSet> 개체의 스키마입니다.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataSet" Usage="dataSet.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Data.DataSet" />의 구조와 데이터를 모두 복사합니다.</summary>
        <returns>이 <see cref="T:System.Data.DataSet" />과 같은 구조(테이블 스키마, 관계 및 제약 조건)와 데이터를 가진 새 <see cref="T:System.Data.DataSet" />을 반환합니다.  
  
 <block subset="none" type="note"><para> 이 클래스가 서브클래싱된 경우 서브클래스도 복사됩니다.  </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataSet.Copy%2A> 원본의 복사본을 만드는 메서드를 <xref:System.Data.DataSet>합니다.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>테이블이 <see cref="T:System.Data.DataTableReader" /> 컬렉션에 나타나는 순서대로 <see cref="T:System.Data.DataTable" />마다 결과 집합이 하나씩 있는 <see cref="P:System.Data.DataSet.Tables" />를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 결과 집합의 순서를 보장 하기 위해 <xref:System.Data.DataTableReader>경우는 <xref:System.Data.DataTable> 내는 <xref:System.Data.DataSet> 가 비어 있는 경우 것으로 표시 됩니다는 빈 결과 집합 반환 된 `DataTableReader`합니다.  
  
   
  
## Examples  
 이 예제에서는 콘솔 응용 프로그램을 세 개를 만들며 <xref:System.Data.DataTable> 인스턴스를 추가 하는 각각로 <xref:System.Data.DataSet>합니다. 예제에서는 호출은 <xref:System.Data.DataSet.CreateDataReader%2A> 메서드와 표시 합니다. 반환된 된 내용의 <xref:System.Data.DataTableReader>합니다. 집합 결과의 순서는 `DataTableReader` 의 순서 의해 제어 되는 `DataTable` 매개 변수로 전달 된 인스턴스.  
  
> [!NOTE]
>  오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 주는이 예제 `CreateDataReader`합니다. 사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 코드를 표시합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>테이블이 <see cref="T:System.Data.DataTableReader" /> 컬렉션에 나타나는 순서대로 <see cref="T:System.Data.DataTable" />마다 결과 집합이 하나씩 있는 <see cref="P:System.Data.DataSet.Tables" />를 반환합니다.</summary>
        <returns>결과 집합을 하나 이상 포함하는 <see cref="T:System.Data.DataTableReader" />이고, 소스 <see cref="T:System.Data.DataTable" />에 포함된 <see cref="T:System.Data.DataSet" /> 인스턴스에 해당합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 결과 집합의 순서를 보장 하기 위해 <xref:System.Data.DataTableReader>경우는 <xref:System.Data.DataTable> 내는 <xref:System.Data.DataSet> 는 빈 결과 반환 된 집합으로 표현 비어 됩니다 `DataTableReader`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 <xref:System.Data.DataTable> 인스턴스와 각각을 추가 하는 <xref:System.Data.DataSet>합니다. 이 예제에서는 다음 채워진 전달 `DataSet` 를 호출 하는 프로시저에는 <xref:System.Data.DataSet.CreateDataReader%2A> 메서드와 진행 내에 포함 된 모든 결과 집합을 반복 하는 <xref:System.Data.DataTableReader>합니다. 이 예제에서는 콘솔 창에 결과 표시합니다.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader dataTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">
          <see cref="T:System.Data.DataTableReader" />에 반환될 결과 집합의 순서를 제공하는 DataTables의 배열입니다.</param>
        <summary>
          <see cref="T:System.Data.DataTableReader" />마다 결과 집합이 하나씩 있는 <see cref="T:System.Data.DataTable" />를 반환합니다.</summary>
        <returns>결과 집합을 하나 이상 포함하는 <see cref="T:System.Data.DataTableReader" />이고, 소스 <see cref="T:System.Data.DataTable" />에 포함된 <see cref="T:System.Data.DataSet" /> 인스턴스에 해당합니다. 반환된 결과 집합은 <paramref name="dataTables" /> 매개 변수에 의해 지정된 순서를 따릅니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 결과의 순서를 설정 한다는 보장 하기 위해 <xref:System.Data.DataTableReader>경우는 <xref:System.Data.DataTable> 내는 <xref:System.Data.DataSet> 는 빈 결과 반환 된 집합으로 표현 비어 됩니다 `DataTableReader`합니다. 이 오버 로드 된 버전의 목록을 제공할 수 있으므로 `DataTable` 인스턴스 매개 변수로 반환 된 결과 집합을 나타나는 순서를 지정할 수 있습니다 `DataTableReader`합니다.  
  
   
  
## Examples  
 이 예제에서는 콘솔 응용 프로그램을 세 개를 만들며 <xref:System.Data.DataTable> 인스턴스를 추가 하는 각각로 <xref:System.Data.DataSet>합니다. 예제에서는 호출은 <xref:System.Data.DataSet.CreateDataReader%2A> 메서드와 표시 합니다. 반환된 된 내용의 <xref:System.Data.DataTableReader>합니다. 집합 결과의 순서는 `DataTableReader` 의 순서 의해 제어 되는 `DataTable` 매개 변수로 전달 된 인스턴스. 이 예제에서는 콘솔 창에 결과 표시합니다.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSetName : string with get, set" Usage="System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Data.DataSet" />의 이름을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Data.DataSet" />의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataSet> 와 주어진 <xref:System.Data.DataSet.DataSetName%2A>합니다.  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultViewManager : System.Data.DataViewManager" Usage="System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자 지정 <see cref="T:System.Data.DataSet" />를 사용하여 필터링, 검색 및 탐색 작업을 수행할 수 있도록 <see cref="T:System.Data.DataViewManager" />에 포함된 데이터의 사용자 지정 뷰를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Data.DataViewManager" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataViewManager> 에서 반환 되는 <xref:System.Data.DataSet.DefaultViewManager%2A> 속성 각각에 대 한 사용자 지정 설정을 만들 수 있습니다 <xref:System.Data.DataTable> 에 <xref:System.Data.DataSet>합니다.  
  
 가져올 때 한 <xref:System.Data.DataView> 에서 <xref:System.Data.DataTable>, 필터링, 정렬 순서 및 <xref:System.Data.DataViewRowState> 설정에 따라 구성 된는 <xref:System.Data.DataSet.DefaultViewManager%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 가져옵니다 <xref:System.Data.DataViewManager> 에 대 한는 <xref:System.Data.DataSet>, 추가 <xref:System.Data.DataTable> 에 <xref:System.Data.DataTableCollection>합니다.  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="P:System.Data.DataSet.SchemaSerializationMode" />의 <see cref="T:System.Data.DataSet" />를 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식화 된를 역직렬화 할 때이 메서드를 호출할 수 있습니다 <xref:System.Data.DataSet> 확인 하려면 해당 <xref:System.Data.DataSet.SchemaSerializationMode%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Xml.XmlReader -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" />을 deserialization을 수행하는 동안 전달되는 <see cref="T:System.Data.DataSet" /> 인스턴스입니다.</param>
        <summary>
          <see cref="P:System.Data.DataSet.SchemaSerializationMode" />의 <see cref="T:System.Data.DataSet" />를 확인합니다.</summary>
        <returns>스키마 정보가 페이로드에서 생략되었는지 여부를 나타내는 <see cref="T:System.Data.SchemaSerializationMode" /> 열거형입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식화 된를 역직렬화 할 때이 메서드를 호출할 수 있습니다 <xref:System.Data.DataSet> 확인 하려면 해당 <xref:System.Data.DataSet.SchemaSerializationMode%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">원격 시나리오에서 deserialization을 수행하는 동안 <see langword="DataSet" />의 protected 생성자 <see cref="T:System.Runtime.Serialization.SerializationInfo" />를 호출하는 데 사용되는 <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />입니다.</param>
        <param name="context">원격 시나리오에서 deserialization을 수행하는 동안 <see langword="DataSet" />의 protected 생성자 <see cref="T:System.Runtime.Serialization.StreamingContext" />를 호출하는 데 사용되는 <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />입니다.</param>
        <summary>
          <see cref="P:System.Data.DataSet.SchemaSerializationMode" />의 <see cref="T:System.Data.DataSet" />를 확인합니다.</summary>
        <returns>스키마 정보가 페이로드에서 생략되었는지 여부를 나타내는 <see cref="T:System.Data.SchemaSerializationMode" /> 열거형입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식화 된를 역직렬화 할 때이 메서드를 호출할 수 있습니다 <xref:System.Data.DataSet> 확인 하려면 해당 <xref:System.Data.DataSet.SchemaSerializationMode%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataSet.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>폼에 사용되거나 다른 구성 요소에서 사용하는 <see cref="T:System.Data.DataSet" />의 초기화를 끝냅니다. 초기화는 런타임에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 끝냅니다. <xref:System.Data.DataSet.BeginInit%2A> 메서드 초기화를 시작 합니다. 사용 하는 <xref:System.Data.DataSet.BeginInit%2A> 및 <xref:System.Data.DataSet.EndInit%2A> 메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnforceConstraints : bool with get, set" Usage="System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>업데이트 작업을 수행할 때 제약 조건 규칙을 따르는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>규칙이 적용되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제약 조건에 설정 되 고 <xref:System.Data.DataTable> 수준 (<xref:System.Data.DataTable.Constraints%2A> 속성). 제약 조건을 만드는 방법에 대 한 자세한 내용은 참조 [DataTable 제약 조건](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Data.DataSet> 한 테이블, 열, 생성자와 5 개의 행을 가진 <xref:System.Data.UniqueConstraint>합니다. <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false` 있고 각 행의 값이 동일한 값으로 설정 합니다. 경우는 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성으로 다시 설정 됩니다 `true`, <xref:System.Data.ConstraintException> 생성 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">제약 조건을 적용할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="DataSet" />에 연결된 사용자 지정 사용자 정보의 컬렉션을 가져옵니다.</summary>
        <value>모든 사용자 지정 사용자 정보가 있는 <see cref="T:System.Data.PropertyCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ExtendedProperties%2A> 속성을 사용 하 여 사용자 지정 정보를 저장할 수는 `DataSet`합니다. 예를 들어 데이터를 새로 고쳐야 할 시간을 저장할 수 있습니다.  
  
 확장된 속성 형식 이어야 합니다 <xref:System.String> 파일과 유지는 <xref:System.Data.DataSet> XML로 기록 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자 지정 속성을 추가 <xref:System.Data.PropertyCollection> 에서 반환 되는 <xref:System.Data.DataColumn.ExtendedProperties%2A> 속성입니다. 두 번째 예에서는 사용자 지정 속성을 검색합니다.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>마지막으로 로드되거나 <see cref="T:System.Data.DataSet" />가 호출된 후에 변경된 내용이 모두 들어 있는 <see cref="M:System.Data.DataSet.AcceptChanges" />의 복사본을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataSet" Usage="dataSet.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>로드되거나 <see cref="T:System.Data.DataSet" />가 마지막으로 호출된 후에 변경된 내용이 모두 들어 있는 <see cref="M:System.Data.DataSet.AcceptChanges" />의 복사본을 가져옵니다.</summary>
        <returns>작업을 수행한 다음 <see cref="T:System.Data.DataSet" />를 사용하여 다시 병합할 수 있는 경우 이 <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />의 변경 사항 복사본을 반환합니다. 변경된 행이 없으면 메서드는 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 <xref:System.Data.DataSet> 원래에 모든 행의 복사본이 포함 된 <xref:System.Data.DataSet> 보류 중인 변경 내용이 있는 합니다. 관계 제약 조건으로 인해 새에 추가할 추가 변경 되지 않은 행 <xref:System.Data.DataSet> 변경 되지 않은 행에는 변경 된 행에서 외래 키에 해당 하는 기본 키를 포함 하는 경우. 메서드가 반환 `null` 원래에서 행이 없는 경우 <xref:System.Data.DataSet> 보류 중인 변경 내용이입니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한 <xref:System.Data.DataSet> 된 한 테이블과 두 개의 열 10 개 행입니다. 두 값이 변경 되 고 하나의 행이 추가 됩니다. 변경된 된 데이터의 하위 집합을 사용 하 여 만들어집니다는 <xref:System.Data.DataSet.GetChanges%2A> 메서드. 오류를 조정한 다음 새 열은 스키마 변경 되는 하위 집합에 추가 됩니다. 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드는 `missingSchemaAction` 로 설정 `MissingSchemaAction.Add`, 새 열이 원본에 추가 <xref:System.Data.DataSet> 개체의 스키마입니다.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataSet" Usage="dataSet.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">
          <see cref="T:System.Data.DataRowState" /> 값 중 하나입니다.</param>
        <summary>마지막으로 로드되거나 <see cref="T:System.Data.DataSet" />가 호출된 후에 변경되어 <see cref="M:System.Data.DataSet.AcceptChanges" />를 기준으로 필터링된 내용이 모두 들어 있는 <see cref="T:System.Data.DataRowState" />의 복사본을 가져옵니다.</summary>
        <returns>작업을 수행한 다음 <see cref="T:System.Data.DataSet" />를 사용하여 다시 병합할 수 있는 경우 <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />의 필터링된 복사본을 반환합니다. 원하는 <see cref="T:System.Data.DataRowState" /> 행이 없으면 이 메서드는 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.GetChanges%2A> 초를 생성 하기 위해 메서드를 사용 하는 <xref:System.Data.DataSet> 원래에 도입 된 변경 내용만 포함 하는 개체입니다. 사용 하 여는 `rowStates` 인수를 새 개체에 포함 될 변경 유형을 지정 합니다.  
  
 이 복사본이 원래에 다시 병합 될 하도록 되어 반환 <xref:System.Data.DataSet>합니다. 관계 제약 조건으로 표시 된 부모 행 않을 `Unchanged` 포함 되도록 합니다. 원하는 행이 없으면 <xref:System.Data.DataRowState> 발견 되는 <xref:System.Data.DataSet.GetChanges%2A> 메서드 반환 `null`합니다.  
  
   
  
## Examples  
 사용 하 여 다음 예제는 <xref:System.Data.DataSet.GetChanges%2A> 메서드를 두 번째 <xref:System.Data.DataSet> 개체 다음에 사용 되는 데이터 소스를 업데이트 합니다.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataSetSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataSet.GetDataSetSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">지정된 스키마 집합입니다.</param>
        <summary>DataSet에 대한 <see cref="T:System.Xml.Schema.XmlSchemaSet" />의 복사본을 가져옵니다.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchemaSet" />의 복사본입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" />과 연결된 serialize된 개체가 들어 있는 <see cref="T:System.Data.DataSet" />입니다.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />과 연결된 serialize된 스트림의 소스와 대상이 들어 있는 <see cref="T:System.Data.DataSet" />입니다.</param>
        <summary>
          <see cref="T:System.Data.DataSet" />을 serialize하는 데 필요한 데이터로 serialization 정보 개체를 채웁니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberSignature Language="F#" Value="abstract member GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataSet.GetSchemaSerializable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>serializable <see cref="T:System.Xml.Schema.XmlSchema" /> 인스턴스를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchema" /> 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.GetSerializationData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetSerializationData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 인스턴스입니다.</param>
        <param name="context">스트리밍 컨텍스트입니다.</param>
        <summary>이진 또는 XML 스트림에서 테이블 데이터를 deserialize합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberSignature Language="F#" Value="member this.GetXml : unit -&gt; string" Usage="dataSet.GetXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" />에 저장된 데이터의 XML 표현을 반환합니다.</summary>
        <returns>
          <see cref="T:System.Data.DataSet" />에 저장된 데이터를 나타내는 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 것은 호출 동일 <xref:System.Data.DataSet.WriteXml%2A> 와 <xref:System.Data.XmlWriteMode> 로 설정 <xref:System.Data.XmlWriteMode.IgnoreSchema>합니다.  
  
 <xref:System.Data.DataSet.GetXml%2A> XML을 문자열로 반환 하 고 보다 많은 오버 헤드가 발생 하므로 <xref:System.Data.DataSet.WriteXml%2A> XML 파일에 쓸 수 있습니다.  
  
 작성 하는 경우는 <xref:System.Data.DataSet> 스키마 유추를 사용 하 고 serialize XML 또는 웹 서비스를 사용 하 고, 열 순서 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Data.DataSet> 및 <xref:System.Data.DataTable>예제 데이터를 추가 하 고 XML 형식으로 데이터를 표시 합니다.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 이 샘플에는 데이터 집합에서 XML 파일에 데이터를 작성 하 고 XML에서 데이터 집합에 데이터를 읽는 방법을 보여 줍니다. 이 샘플 하나의 데이터 집합에 두 개의 테이블이 포함 된, 두 가지 방법으로 데이터 집합 (WriteXml 및 GetXml) XML 파일로 내보내려면를 사용 하 여 만들고 사용 (ReadXml 및 InferXmlSchema)를 XML 파일에서 데이터 집합을 가져오는 두 가지 방법입니다.  
  
 컴파일 및 샘플을 실행 하기 전에 예제 디렉터리에 4 개의 XML 파일을 만들 필요 합니다. 먼저, ElementsWithAttributes.xml를 만듭니다.  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 다음으로 ElementsWithChildElementsxml.xml를 만듭니다.  
  
```  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 이제 ElementsWithOnlyAttributes.xml를 만듭니다.  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 마지막으로, RepeatingElements.xml를 만듭니다.  
  
```  
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 이제 컴파일 하 고 다음 소스 코드를 실행할 수 있습니다.  [저장소 데이터의 데이터 집합을 XML 파일로 방법](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) 이 샘플에 대 한 Visual Basic 및 C# 프로젝트에 있습니다.  
  
```  
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberSignature Language="F#" Value="member this.GetXmlSchema : unit -&gt; string" Usage="dataSet.GetXmlSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" />에 저장된 데이터의 XML 표현에 대한 XML 스키마를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Data.DataSet" />에 저장된 데이터의 XML 표현에 대한 XML 스키마 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 것은 호출 동일 <xref:System.Data.DataSet.WriteXmlSchema%2A>한다는 점을 제외 하는 기본 스키마만 기록 됩니다.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> XML을 문자열로 반환 하 고 보다 많은 오버 헤드가 발생 하므로 <xref:System.Data.DataSet.WriteXmlSchema%2A> XML 파일에 쓸 수 있습니다.  
  
 작성 하는 경우는 <xref:System.Data.DataSet> 스키마 유추를 사용 하 고 serialize XML 또는 웹 서비스를 사용 하 고, 열 순서 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Data.DataSet> 및 <xref:System.Data.DataTable>, 다음 XML 형식에는 스키마를 표시 합니다.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" />에 새 행, 삭제된 행 또는 수정된 행을 포함하여 변경 내용이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberSignature Language="F#" Value="member this.HasChanges : unit -&gt; bool" Usage="dataSet.HasChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" />에 새 행, 삭제된 행 또는 수정된 행을 포함하여 변경 내용이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns>
          <see cref="T:System.Data.DataSet" />에 변경 내용이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataSet.GetChanges%2A> 메서드를 두 번째 <xref:System.Data.DataSet> 데이터 원본을 업데이트 하려면 다음 사용 되는 개체입니다.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.HasChanges : System.Data.DataRowState -&gt; bool" Usage="dataSet.HasChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">
          <see cref="T:System.Data.DataRowState" /> 값 중 하나입니다.</param>
        <summary>
          <see cref="T:System.Data.DataSet" />에 새 행, 삭제된 행 또는 수정된 행을 포함하여 <see cref="T:System.Data.DataRowState" />를 기준으로 필터링된 변경 내용이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns>
          <see cref="T:System.Data.DataSet" />에 변경 내용이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검사는 <xref:System.Data.DataSet.HasChanges%2A> 의 속성은 `DataSet` 호출 하기 전에 <xref:System.Data.DataSet.GetChanges%2A> 메서드.  
  
   
  
## Examples  
 사용 하 여 다음 예제는 <xref:System.Data.DataSet.GetChanges%2A> 메서드를 두 번째 <xref:System.Data.DataSet> 개체 다음에 사용 되는 데이터 소스를 업데이트 합니다.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Data.DataTable" /> 내의 <see cref="T:System.Data.DataSet" /> 개체에 오류가 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>테이블에 오류가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 <xref:System.Data.DataTable> 에 <xref:System.Data.DataSet> 역시는 <xref:System.Data.DataTable.HasErrors%2A> 속성입니다. 사용 하 여는 `HasErrors` 속성은 `DataSet` 테이블 개별 검사 하기 전에 오류를에 있는지 확인 하려면 첫 번째 <xref:System.Data.DataTable> 개체입니다. 경우는 `DataTable` 에 오류가 <xref:System.Data.DataTable.GetErrors%2A> 메서드 배열을 반환 <xref:System.Data.DataRow> 오류를 포함 하는 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataSet.HasErrors%2A> 속성을 확인 여부는 <xref:System.Data.DataSet> 개체에 오류가 있는 합니다. 이 경우 각각에 대 한 오류 <xref:System.Data.DataRow> 각 <xref:System.Data.DataTable> 인쇄 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" />에 XML 스키마를 적용합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.Stream * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (stream, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">스키마를 읽어올 <see langword="Stream" />입니다.</param>
        <param name="nsArray">스키마 유추에서 제외할 네임스페이스 URI(Uniform Resource Identifier) 문자열로 이루어진 배열입니다.</param>
        <summary>지정된 <see cref="T:System.IO.Stream" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 적용합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.TextReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">스키마를 읽어올 <see langword="TextReader" />입니다.</param>
        <param name="nsArray">스키마 유추에서 제외할 네임스페이스 URI(Uniform Resource Identifier) 문자열로 이루어진 배열입니다.</param>
        <summary>지정된 <see cref="T:System.IO.TextReader" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 적용합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : string * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (fileName, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">스키마를 읽어올 파일의 경로를 포함한 이름입니다.</param>
        <param name="nsArray">스키마 유추에서 제외할 네임스페이스 URI(Uniform Resource Identifier) 문자열로 이루어진 배열입니다.</param>
        <summary>지정된 파일에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 적용합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연관된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.Xml.XmlReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">스키마를 읽어올 <see langword="XMLReader" />입니다.</param>
        <param name="nsArray">스키마 유추에서 제외할 네임스페이스 URI(Uniform Resource Identifier) 문자열로 이루어진 배열입니다.</param>
        <summary>지정된 <see cref="T:System.Xml.XmlReader" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 적용합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" />이 초기화된 후 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 <xref:System.Data.DataSet.IsInitialized%2A>을 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberSignature Language="F#" Value="abstract member InitializeDerivedDataSet : unit -&gt; unit&#xA;override this.InitializeDerivedDataSet : unit -&gt; unit" Usage="dataSet.InitializeDerivedDataSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이진 또는 XML 스트림에서 DataSet의 모든 테이블 데이터를 deserialize합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.IsBinarySerialized : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; bool" Usage="dataSet.IsBinarySerialized (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> 개체</param>
        <summary>
          <see langword="DataSet" />의 serialize된 표현에 대한 형식을 검사합니다.</summary>
        <returns>지정된 <see cref="T:System.Runtime.Serialization.SerializationInfo" />가 이진 형식으로 serialize된 <see langword="true" />을 나타내면 <see langword="DataSet" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 .NET Framework 인프라를 지원하며 사용자 코드에서 직접 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" />이 초기화되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>구성 요소의 초기화가 완료되었음을 나타내려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상태를 반환 하는 <xref:System.Data.DataSet> 것은 생성 되 고, 예를 들어 Visual Studio에서 동안 합니다. <xref:System.Data.DataSet.BeginInit%2A> 메서드를 설정 `false` 및 <xref:System.Data.DataSet.EndInit%2A> 메서드를 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>제공된 <see cref="T:System.Data.DataSet" />를 사용해서 <see cref="T:System.Data.IDataReader" />을 데이터 소스의 값으로 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> 메서드는 단일을 채우기 위한 수 있는 방법을 제공 <xref:System.Data.DataTable> 에서 검색 된 데이터와는 <xref:System.Data.IDataReader> 인스턴스. 여러 결과 집합을 로드할 수 있습니다, 동일한 기능을 제공 하는이 메서드는 `IDataReader` 내에서 여러 테이블에는 `DataSet`합니다.  
  
 `DataSet`에 이미 행이 포함되어 있으면 데이터 소스에서 들어오는 데이터가 기존 행과 병합됩니다.  
  
 `Load` 몇 가지 일반적인 시나리오는 지정 된 데이터 원본에서 데이터 가져오기 및 현재 데이터 컨테이너에 추가에서 메서드를 사용할 수 있습니다 (이 경우는 `DataSet`). 에 대 한 일반 사용법을 설명 하는 이러한 시나리오는 `DataSet`해당 업데이트를 설명 하는, 및 동작을 병합 합니다.  
  
 A `DataSet` 동기화 하거나 단일 기본 데이터 원본을 업데이트 합니다. `DataSet` 주 데이터 소스와 동기화 할 수 있도록 변경 내용을 추적 합니다. 또한 한 `DataSet` 하나 이상의 보조 데이터 원본의 증분 데이터를 수락할 수 있습니다. `DataSet` 보조 데이터 소스와 동기화 할 수 있도록 변경 내용을 추적 하지는 않습니다.  
  
 이러한 두 개의 가상의 데이터 소스를 매개 변수로 받아 사용자 해야 하는 다음 동작 중 하나:  
  
-   초기화 `DataSet` 주 데이터 원본에서 합니다. 이 시나리오에서 사용자는 빈 초기화 하려는 `DataSet` 주 데이터 원본의 값으로. 하나 이상의 DataTable의 내용은 수정 됩니다. 나중에 사용자를 기본 데이터 소스 변경 내용을 전파 하는 것입니다.  
  
-   변경 내용을 유지 하 고 기본 데이터 원본에서 다시 동기화 합니다. 이 시나리오에서는 사용자가 수행 하는 `DataSet` 이전 시나리오에서의 변경 내용을 유지 하는 기본 데이터 원본과 증분 동기화를 수행 채워지고는 `DataSet`합니다.  
  
-   증분 데이터를 보조 데이터 원본에서 제공 합니다. 이 시나리오에서는 사용자가 하나 이상의 보조 데이터 원본에서 변경 내용을 병합 하 여 다시 주 데이터 원본에 해당 변경 내용을 전파 합니다.  
  
 `Load` 메서드 이러한 모든 시나리오 가능 하 게 합니다. 이 메서드를 사용 하면 로드 옵션 매개 변수를 지정할 수 있습니다를 나타내는 방법을 있는 행 한 <xref:System.Data.DataTable> 로드 중인 행과 결합 합니다. 다음 표에에서 제공 하는 세 가지 부하 옵션은 <xref:System.Data.LoadOption> 열거형입니다. 각각의 경우 설명 들어오는 데이터에 있는 행의 기본 키에는 기존 행의 기본 키와 일치 하는 경우 동작을 나타냅니다.  
  
|로드 옵션|설명|  
|-----------------|-----------------|  
|`PreserveChanges`(기본값)|들어오는 행의 값을 가진 행의 원래 버전을 업데이트합니다.|  
|`OverwriteChanges`|들어오는 행의 값을 가진 행의 현재 버전과 원래 버전을 업데이트합니다.|  
|`Upsert`|들어오는 행의 값을 가진 행의 현재 버전을 업데이트합니다.|  
  
 일반적으로 `PreserveChanges` 및 `OverwriteChanges` 옵션은 사용자를 동기화 해야 하는 시나리오에 대 한 않습니다는 `DataSet` 및 기본 데이터 원본과 해당 변경 합니다. `Upsert` 옵션을 하나 이상의 보조 데이터 원본에서 집계 변경 내용을 용이 하 게 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">하나 이상의 결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</param>
        <param name="loadOption">
          <see cref="T:System.Data.LoadOption" /> 열거형의 값으로서, 이미 <see cref="T:System.Data.DataTable" />의 <see cref="T:System.Data.DataSet" /> 인스턴스에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</param>
        <param name="tables">
          <see cref="T:System.Data.DataTable" /> 메서드가 이름 및 네임스페이스 정보를 검색하는 <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> 인스턴스의 배열입니다. 이러한 테이블은 각각 이 <see cref="T:System.Data.DataTableCollection" />에 포함된 <see cref="T:System.Data.DataSet" />의 멤버여야 합니다.</param>
        <summary>
          <see cref="T:System.Data.DataSet" /> 인스턴스의 배열을 사용해 스키마 및 네임스페이스 정보를 제공하여, 제공된 <see cref="T:System.Data.IDataReader" />를 사용하는 데이터 소스의 값으로 <see cref="T:System.Data.DataTable" />을 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> 메서드는 단일을 채우기 위한 수 있는 방법을 제공 <xref:System.Data.DataTable> 에서 검색 된 데이터와는 <xref:System.Data.IDataReader> 인스턴스. 여러 결과 집합을 로드할 수 있습니다, 동일한 기능을 제공 하는이 메서드는 <xref:System.Data.IDataReader> 내에서 여러 테이블에는 <xref:System.Data.DataSet>합니다.  
  
> [!NOTE]
>  로드 작업이 실패 하며는 <xref:System.InvalidOperationException> 경우 들어오는 원본 데이터 열 `reader` 계산된 열이 있습니다.  
  
 `loadOption` 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 및의 값 중 하나일 수 있습니다 방법을 지정할 수 있습니다는 <xref:System.Data.LoadOption> 열거형입니다. 에 대 한 설명서를 참조 하십시오.는 <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> 이 매개 변수를 사용 하 여 대 한 자세한 내용은 메서드.  
  
 `tables` 매개 변수 배열을 지정할 수 있습니다 <xref:System.Data.DataTable> 해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 인스턴스. <xref:System.Data.DataSet.Load%2A> 메서드 채우기 각 제공 <xref:System.Data.DataTable> 단일 결과 집합에서 원본 데이터 판독기에서에서 데이터를 사용 하 여 인스턴스. 각 결과 집합 후의 <xref:System.Data.DataSet.Load%2A> 메서드 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내에서 집합으로 이동 합니다.  
  
 이 메서드에 대 한 이름 확인 스키마 뒤와 같은지는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 의 메서드는 <xref:System.Data.Common.DbDataAdapter> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataSet>, 두 개 추가 <xref:System.Data.DataTable> 인스턴스는 <xref:System.Data.DataSet>, 후 채우는 <xref:System.Data.DataSet> 를 사용 하는 <xref:System.Data.DataSet.Load%2A> 에서 데이터를 검색할 메서드는 <xref:System.Data.DataTableReader> 두 개의 결과 집합을 포함 하 합니다. 마지막으로,이 예제에서는 콘솔 창에는 테이블의 내용을 표시합니다.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * string[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">하나 이상의 결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</param>
        <param name="loadOption">
          <see cref="T:System.Data.LoadOption" /> 열거형의 값으로서, 이미 <see cref="T:System.Data.DataTable" />의 <see langword="DataSet" /> 인스턴스에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</param>
        <param name="tables">
          <see langword="Load" /> 메서드가 테이블 이름 정보를 검색하는 문자열의 배열입니다.</param>
        <summary>문자열의 배열을 사용해 <see langword="DataSet" /> 내의 테이블에 대한 이름을 제공하여, 제공된 <see cref="T:System.Data.DataSet" />를 사용하는 데이터 소스의 값으로 <see cref="T:System.Data.IDataReader" />를 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> 메서드는 단일을 채우기 위한 수 있는 방법을 제공 <xref:System.Data.DataTable> 에서 검색 된 데이터와는 <xref:System.Data.IDataReader> 인스턴스. 여러 결과 집합을 로드할 수 있습니다, 동일한 기능을 제공 하는이 메서드는 `IDataReader` 내에서 여러 테이블에는 `DataSet`합니다.  
  
> [!NOTE]
>  로드 작업이 실패 하며는 <xref:System.InvalidOperationException> 경우 들어오는 원본 데이터 열 `reader` 계산된 열이 있습니다.  
  
 `loadOption` 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 및의 값 중 하나일 수 있습니다 방법을 지정할 수 있습니다는 <xref:System.Data.LoadOption> 열거형입니다. 에 대 한 설명서를 참조 하십시오.는 <xref:System.Data.DataTable.Load%2A> 이 매개 변수를 사용 하 여 대 한 자세한 내용은 메서드.  
  
 `tables` 매개 변수를 사용 하면 해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 테이블 이름의 배열을 지정 지정할 수 있습니다. `Load` 메서드 내에서 테이블을 찾으려고는 `DataSet` 이름과 일치 하는 순서로 테이블 이름의 배열에서 찾을 수 있습니다. 일치 하는 테이블 발견 되 면 해당 테이블은 현재 결과 집합의 내용을 사용 하 여 로드 됩니다. 일치 하는 테이블이 있으면 테이블 이름의 배열에 제공 된 이름을 사용 하 여 테이블을 만들 하 고 새 테이블의 스키마는 결과 집합에서 유추 됩니다. 각 결과 집합 후의 `Load` 메서드 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내에서 집합으로 이동 합니다.  
  
 와 연결 된 기본 네임 스페이스 `DataSet`있는 경우 새로 만든 각와 연결 된 경우, `DataTable`합니다. 이 메서드에 대 한 이름 확인 스키마 뒤와 같은지는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 의 메서드는 <xref:System.Data.Common.DbDataAdapter> 클래스입니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램 예제에서는 먼저 테이블을 만들고에 판독기에서 데이터를 로드 한 <xref:System.Data.DataSet>를 사용 하 여는 `Load` 메서드. 이 예제에는 다음에 테이블을 추가 <xref:System.Data.DataSet> 하 고 테이블의 데이터로 채우는 하려고 한 <xref:System.Data.DataTableReader>합니다. 이 예제에 전달 된 매개 변수는 `Load` 메서드 존재 하지 않는 테이블 이름으로 나타낼는 `Load` 메서드 매개 변수로 전달 된 이름과 일치 하도록 새 테이블을 만듭니다. 데이터가 로드 되 면이 예제에서는 모든 테이블의 내용을 콘솔 창에 표시 합니다.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, errorHandler, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">하나 이상의 결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</param>
        <param name="loadOption">
          <see cref="T:System.Data.LoadOption" /> 열거형의 값으로서, 이미 <see cref="T:System.Data.DataTable" />의 <see cref="T:System.Data.DataSet" /> 인스턴스에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</param>
        <param name="errorHandler">데이터를 로드하는 동안 오류가 발생하면 호출할 <see cref="T:System.Data.FillErrorEventHandler" /> 대리자입니다.</param>
        <param name="tables">
          <see cref="T:System.Data.DataTable" /> 메서드가 이름 및 네임스페이스 정보를 검색하는 <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> 인스턴스의 배열입니다.</param>
        <summary>
          <see cref="T:System.Data.DataSet" /> 인스턴스의 배열을 사용해 스키마 및 네임스페이스 정보를 제공하여, 제공된 <see cref="T:System.Data.IDataReader" />를 사용하는 데이터 소스의 값으로 <see cref="T:System.Data.DataTable" />을 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> 메서드는 단일을 채우기 위한 수 있는 방법을 제공 <xref:System.Data.DataTable> 에서 검색 된 데이터와는 <xref:System.Data.IDataReader> 인스턴스. 여러 결과 집합을 로드할 수 있습니다, 동일한 기능을 제공 하는이 메서드는 <xref:System.Data.IDataReader> 내에서 여러 테이블에는 <xref:System.Data.DataSet>합니다.  
  
> [!NOTE]
>  로드 작업이 실패 하며는 <xref:System.InvalidOperationException> 경우 들어오는 원본 데이터 열 `reader` 계산된 열이 있습니다.  
  
 `loadOption` 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 및의 값 중 하나일 수 있습니다 방법을 지정할 수 있습니다는 <xref:System.Data.LoadOption> 열거형입니다. 에 대 한 설명서를 참조 하십시오.는 <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> 이 매개 변수를 사용 하 여 대 한 자세한 내용은 메서드.  
  
 `errorHandler` 매개 변수는 한 <xref:System.Data.FillErrorEventHandler> 데이터를 로드 하는 동안 오류가 발생할 때 호출 되는 프로시저를 참조 하는 대리자입니다. <xref:System.Data.FillErrorEventArgs> 발생 한 오류, 데이터의 현재 행에 대 한 정보를 검색할 수 있도록 하는 속성을 제공 하는 프로시저에 전달 된 매개 변수 및 <xref:System.Data.DataTable> 채워지고 합니다. 이 대리자 메커니즘을 사용 하 여, 대신 간단한 try/catch 블록을 오류를 확인할 수 있습니다 상황을 처리을 원하는 경우 처리를 계속 합니다. <xref:System.Data.FillErrorEventArgs> 매개 변수를 제공는 <xref:System.Data.FillErrorEventArgs.Continue%2A> 속성:이 속성을 설정 `true` 오류 및; 처리를 계속 하려는 처리 했음을 나타내기 위해 속성을 설정 `false` 처리를 중단 하려면 나타냅니다. 주의 해당 속성을 설정 `false` 하면 예외를 throw 하는 문제를 발생 시킨 코드가 있습니다.  
  
 `tables` 매개 변수 배열을 지정할 수 있습니다 <xref:System.Data.DataTable> 해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 인스턴스. <xref:System.Data.DataSet.Load%2A> 메서드 채우기 각 제공 <xref:System.Data.DataTable> 단일 결과 집합에서 원본 데이터 판독기에서에서 데이터를 사용 하 여 인스턴스. 각 결과 집합 후의 <xref:System.Data.DataSet.Load%2A> 메서드 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내에서 집합으로 이동 합니다.  
  
 이 메서드에 대 한 이름 확인 스키마 뒤와 같은지는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 의 메서드는 <xref:System.Data.Common.DbDataAdapter> 클래스입니다.  
  
   
  
## Examples  
 표를 추가 하는 다음 예제는 <xref:System.Data.DataSet>, 사용 하려고 하 고는 <xref:System.Data.DataSet.Load%2A> 에서 데이터를 로드 하는 메서드는 <xref:System.Data.DataTableReader> 호환 되지 않는 스키마를 포함 하 합니다. 이 예에서는 오류를 트래핑 하는 대신는 <xref:System.Data.FillErrorEventHandler> 조사 하 고 오류 처리는 대리자입니다. 출력은 콘솔 창에 표시 됩니다.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>테이블 내의 문자열을 비교하는 데 사용되는 로캘 정보를 가져오거나 설정합니다.</summary>
        <value>사용자의 컴퓨터 로캘에 대한 데이터가 들어 있는 <see cref="T:System.Globalization.CultureInfo" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Locale%2A> 속성 로캘을 지정 정렬을 적용할 합니다.  
  
 기본적으로 설정는 <xref:System.Data.DataSet.Locale%2A> 에 대 한는 <xref:System.Data.DataSet> 설정는 <xref:System.Data.DataSet.Locale%2A> 각각에 대해 <xref:System.Data.DataTable> 개체의 `DataSet` 과 같은 값입니다.  
  
> [!NOTE]
>  식이 포함 된 열에는 <xref:System.StringComparison.InvariantCulture> 사용 됩니다. <xref:System.StringComparison.CurrentCulture> 는 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 가져옵니다는 <xref:System.Globalization.CultureInfo> 에 대 한는 <xref:System.Data.DataSet> 하 고 출력은 <xref:System.Globalization.CultureInfo.DisplayName%2A> 및 <xref:System.Globalization.CultureInfo.EnglishName%2A> 속성입니다.  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 <see cref="T:System.Data.DataSet" />, <see cref="T:System.Data.DataTable" /> 또는 <see cref="T:System.Data.DataRow" /> 개체의 배열을 현재 <see langword="DataSet" /> 또는 <see langword="DataTable" />에 병합합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] -&gt; unit" Usage="dataSet.Merge rows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">
          <see langword="DataRow" />에 병합되는 <see langword="DataSet" /> 개체의 배열입니다.</param>
        <summary>
          <see cref="T:System.Data.DataRow" /> 개체의 배열을 현재 <see cref="T:System.Data.DataSet" />에 병합합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> 병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet> 비슷하긴 하지만 스키마가 포함 된 개체입니다. 기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 합니다.  
  
 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체에만 포함 되어는 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 더 작은 때문에 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`합니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마와 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 대상에 모든 소스 행 한 <xref:System.Data.DataRowState> 값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다. 소스 행 한 <xref:System.Data.DataRowState> 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException> 생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다. 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet -&gt; unit" Usage="dataSet.Merge dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">데이터와 스키마를 병합할 <see langword="DataSet" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 스키마를 현재 <see langword="DataSet" />에 병합합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> 병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet> 비슷하긴 하지만 스키마가 포함 된 개체입니다. 기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 합니다.  
  
 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체에만 포함 되어는 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`합니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마와 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 대상에 모든 소스 행 한 <xref:System.Data.DataRowState> 값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다. 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException> 생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다. 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataSet.GetChanges%2A>, 업데이트 및 <xref:System.Data.DataSet.Merge%2A> 에 대 한 메서드는 <xref:System.Data.DataSet>합니다.  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">제약 조건을 사용할 수 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" />이 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataSet.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">데이터와 스키마를 병합할 <see cref="T:System.Data.DataTable" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" /> 및 스키마를 현재 <see cref="T:System.Data.DataSet" />에 병합합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> 병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet> 비슷하긴 하지만 스키마가 포함 된 개체입니다. 기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 합니다.  
  
 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체에만 포함 되어는 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`합니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마와 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 대상에 모든 소스 행 한 <xref:System.Data.DataRowState> 값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다. 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException> 생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다. 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`합니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한 <xref:System.Data.DataSet> 된 한 테이블과 두 개의 열 10 개 행입니다. 두 번째 <xref:System.Data.DataTable> 즉 만들어질 첫 번째와 동일 합니다. 다음에 병합 되는 두 번째 테이블에 두 개의 행이 추가 <xref:System.Data.DataSet>합니다.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="table" />이 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">데이터와 스키마를 병합할 <see langword="DataSet" />입니다.</param>
        <param name="preserveChanges">현재 <see langword="true" />의 변경 내용을 유지하려면 <see langword="DataSet" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 스키마를 현재 <see langword="DataSet" />에 병합합니다. 이때 지정된 인수에 따라 이 <see langword="DataSet" />의 변경 내용을 유지하거나 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> 병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet> 비슷하긴 하지만 스키마가 포함 된 개체입니다. 기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 합니다.  
  
 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체에만 포함 되어는 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`합니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마와 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 대상에 모든 소스 행 한 <xref:System.Data.DataRowState> 값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다. 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException> 생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다. 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`합니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한 <xref:System.Data.DataSet> 된 한 테이블과 두 개의 열 10 개 행입니다. 10 개의 행을 추가한 후 두 개의 값이 변경 되 및 한 개의 행이 추가 됩니다. 변경된 된 데이터의 하위 집합을 사용 하 여 만들어집니다는 <xref:System.Data.DataSet.GetChanges%2A> 메서드. 오류를 조정한 다음 하위 집합 데이터를 병합할 원래 <xref:System.Data.DataSet>합니다.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (rows, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">
          <see cref="T:System.Data.DataRow" />에 병합되는 <see langword="DataSet" /> 개체의 배열입니다.</param>
        <param name="preserveChanges">
          <see langword="true" />의 변경 내용을 유지하려면 <see langword="DataSet" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="missingSchemaAction">
          <see cref="T:System.Data.MissingSchemaAction" /> 값 중 하나입니다.</param>
        <summary>
          <see cref="T:System.Data.DataRow" /> 개체의 배열을 현재 <see cref="T:System.Data.DataSet" />에 병합합니다. 이때 지정된 인수에 따라 <see langword="DataSet" />의 변경 내용을 유지하거나 삭제하고 호환되지 않는 스키마를 처리합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> 병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet> 비슷하긴 하지만 스키마가 포함 된 개체입니다. 기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 합니다.  
  
 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체에만 포함 되어는 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 설명은 용이 하 게 하려면는 <xref:System.Data.DataSet.Merge%2A> 메서드를 사용 하 여 "대상" 현재 나타낼 <xref:System.Data.DataSet>, 및 두 번째 (매개 변수) 이름을 지정 하는 "source" <xref:System.Data.DataSet>합니다. 대상 <xref:System.Data.DataSet> 가 의미 하는 동작 (병합) 발생 하는 개체입니다. 두 번째 <xref:System.Data.DataSet> 포함 된 정보를 변경 되지 않지만 대신 현재에 병합 되 때문에 "source" 라고 <xref:System.Data.DataSet>합니다.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`합니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마와 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 대상에 모든 소스 행 한 <xref:System.Data.DataRowState> 값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다. 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException> 생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다. 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">데이터와 스키마를 병합할 <see langword="DataSet" />입니다.</param>
        <param name="preserveChanges">현재 <see langword="true" />의 변경 내용을 유지하려면 <see langword="DataSet" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="missingSchemaAction">
          <see cref="T:System.Data.MissingSchemaAction" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 스키마를 현재 <see langword="DataSet" />에 병합합니다. 이때 지정된 인수에 따라 현재 <see langword="DataSet" />의 변경 내용을 유지하거나 삭제하고 호환되지 않는 스키마를 처리합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> 병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet> 비슷하긴 하지만 스키마가 포함 된 개체입니다. 기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 합니다.  
  
 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 클라이언트 응용 프로그램에서는 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 됩니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체에만 포함 되어는 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 설명은 용이 하 게 하려면는 <xref:System.Data.DataSet.Merge%2A> 메서드를 사용 하 여 "대상" 현재 나타낼 <xref:System.Data.DataSet>, 및 두 번째 (매개 변수) 이름을 지정 하는 "source" <xref:System.Data.DataSet>합니다. 대상 <xref:System.Data.DataSet> 가 의미 하는 동작 (병합) 발생 하는 개체입니다. 두 번째 <xref:System.Data.DataSet> 포함 된 정보를 변경 되지 않지만 대신 현재에 병합 되 때문에 "source" 라고 <xref:System.Data.DataSet>합니다.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`합니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마와 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 대상에 모든 소스 행 한 <xref:System.Data.DataRowState> 값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다. 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException> 생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다. 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`합니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한 <xref:System.Data.DataSet> 된 한 테이블과 두 개의 열 10 개 행입니다. 두 값이 변경 되 고 하나의 행이 추가 됩니다. 변경된 된 데이터의 하위 집합을 사용 하 여 만들어집니다는 <xref:System.Data.DataSet.GetChanges%2A> 메서드. 오류를 조정한 다음 새 열은 스키마 변경 되는 하위 집합에 추가 됩니다. 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드는 `missingSchemaAction` 로 설정 `MissingSchemaAction.Add`, 새 열이 원본에 추가 <xref:System.Data.DataSet> 개체의 스키마입니다.  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" />이 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">데이터와 스키마를 병합할 <see langword="DataTable" />입니다.</param>
        <param name="preserveChanges">
          <see cref="T:System.Data.MissingSchemaAction" /> 값 중 하나입니다.</param>
        <param name="missingSchemaAction">
          <see langword="true" />의 변경 내용을 유지하려면 <see langword="DataSet" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" /> 및 스키마를 현재 <see langword="DataSet" />과 병합합니다. 이때 지정된 인수에 따라 현재 <see langword="DataSet" />의 변경 내용을 유지하거나 삭제하고 호환되지 않는 스키마를 처리합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> 병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataSet> 비슷하긴 하지만 스키마가 포함 된 개체입니다. 기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 합니다.  
  
 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 일반적으로 한 번의 단추는 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 클라이언트 응용 프로그램 이온 되었기 합니다. 이 시나리오는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체에만 포함 되어는 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 더 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되 면 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`합니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마와 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 대상에 모든 소스 행 한 <xref:System.Data.DataRowState> 값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다. 소스 행 한 `DataRowState` 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건이 비활성화 됩니다. 병합의 끝에 모든 제약 조건을 사용할 수 없으면는 <xref:System.Data.ConstraintException> 생성 되 고 병합 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 오류에서 유효 하지 않은 모든 행을 표시 합니다. 다시 설정 하기 전에 오류를 해결 해야 합니다는 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`합니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한 <xref:System.Data.DataSet> 된 한 테이블과 두 개의 열 10 개 행입니다. 두 번째 <xref:System.Data.DataTable> 즉 만들어질 첫 번째 거의 동일한 점을 제외 하 고 새 `DataColumn` 테이블에 추가 합니다. 다음에 병합 되는 두 번째 테이블에 두 개의 행이 추가 <xref:System.Data.DataSet> 와 `preserveChanges` 인수로 설정 `false`, 및 `missingSchemaAction` 인수로 설정 `MissingSchemaAction.Add`합니다.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" />이 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberSignature Language="F#" Value="member this.MergeFailed : System.Data.MergeFailedEventHandler " Usage="member this.MergeFailed : System.Data.MergeFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>대상과 소스 <see cref="T:System.Data.DataRow" />의 기본 키 값이 같고 <see cref="P:System.Data.DataSet.EnforceConstraints" />를 true로 설정한 경우 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataSet.MergeFailed> 이벤트입니다.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" />의 네임스페이스를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Data.DataSet" />의 네임스페이스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Namespace%2A> 에 문서를 읽고 XML을 쓸 때 속성은 사용 된 <xref:System.Data.DataSet> 를 사용 하 여는 <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>, 또는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 문서의 네임 스페이스 XML 특성 및 요소를 읽을 때 범위를 지정 하는 데 사용 되는 <xref:System.Data.DataSet>합니다. 예를 들어 경우는 <xref:System.Data.DataSet> 스키마가 포함 된 네임 스페이스가 "myCompany" 문서에서 읽은 및만 다른 네임 스페이스를 사용 하 여 문서에서에서 데이터를 읽을 하려고 시도 하 고, 기존 스키마에 해당 하지 않는 모든 데이터는 무시 됩니다.  
  
   
  
## Examples  
 다음 예에서는 <xref:System.Data.DataSet.Prefix%2A> 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">네임스페이스에 데이터가 이미 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataSet.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">이벤트 데이터를 포함하는 <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />입니다.</param>
        <summary>
          <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스 <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveRelation : System.Data.DataRelation -&gt; unit&#xA;override this.OnRemoveRelation : System.Data.DataRelation -&gt; unit" Usage="dataSet.OnRemoveRelation relation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">제거 중인 <see cref="T:System.Data.DataRelation" />입니다.</param>
        <summary>
          <see cref="T:System.Data.DataRelation" />에서 <see cref="T:System.Data.DataTable" /> 개체를 제거할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 테이블을 제거 하 고 제한 하는 서브 클래스에서 재정의 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveTable : System.Data.DataTable -&gt; unit&#xA;override this.OnRemoveTable : System.Data.DataTable -&gt; unit" Usage="dataSet.OnRemoveTable table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">제거 중인 <see cref="T:System.Data.DataTable" />입니다.</param>
        <summary>
          <see cref="T:System.Data.DataTable" />에서 <see cref="T:System.Data.DataSet" />을 제거할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 제거 되지 않도록 테이블을 제한 하는 서브 클래스에서 재정의할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서 파생 된 클래스를 보여 줍니다.는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.OnRemoveTable%2A> 메서드를 재정의 합니다.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" /> 네임스페이스의 별칭인 XML 접두사를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Data.DataSet" /> 네임스페이스의 XML 접두사입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Prefix%2A> 속성은 사용 하는 XML 문서 전체에서 네임 스페이스에 속한 요소를 식별 하는 <xref:System.Data.DataSet> 개체 (의해 설정는 <xref:System.Data.DataSet.Namespace%2A> 속성).  
  
   
  
## Examples  
 다음 예에서는 <xref:System.Data.DataSet.Prefix%2A> 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RaisePropertyChanging : string -&gt; unit" Usage="dataSet.RaisePropertyChanging name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">변경될 속성의 이름입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 속성이 변경될 것이라는 알림을 보냅니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML 스키마와 데이터를 <see cref="T:System.Data.DataSet" />으로 읽어옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />에서 파생되는 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.IO.Stream" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet> XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마는 <xref:System.Data.DataSet> 포함 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML과 함께 합니다. 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 간단한을 먼저 만듭니다 <xref:System.Data.DataSet> 하나로 <xref:System.Data.DataTable>, 두 개의 열과 10 개 행입니다. <xref:System.Data.DataSet> 스키마와 데이터를 호출 하 여 디스크에 기록 된 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 두 번째 <xref:System.Data.DataSet> 만들어집니다 및 <xref:System.Data.DataSet.ReadXml%2A> 메서드 스키마와 데이터를 채우는 데 사용 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">스키마와 데이터를 읽어올 <see langword="TextReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.IO.TextReader" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet> XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마는 <xref:System.Data.DataSet> 포함 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML과 함께 합니다. 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 클래스에서 상속 되는 <xref:System.IO.TextReader> 클래스에 포함 된 <xref:System.IO.StreamReader> 및 <xref:System.IO.StringReader> 클래스입니다.  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 간단한을 먼저 만듭니다 <xref:System.Data.DataSet> 하나로 <xref:System.Data.DataTable>, 두 개의 열과 10 개 행입니다. <xref:System.Data.DataSet> 스키마와 데이터를 호출 하 여 디스크에 기록 된 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 두 번째 <xref:System.Data.DataSet> 만들어집니다 및 <xref:System.Data.DataSet.ReadXml%2A> 메서드 스키마와 데이터를 채우는 데 사용 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">읽어올 파일의 경로를 포함한 이름입니다.</param>
        <summary>지정된 파일을 사용하여 XML 스키마와 데이터를 <see cref="T:System.Data.DataSet" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet> XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마는 <xref:System.Data.DataSet> 포함는 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML과 함께 합니다. 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 간단한을 먼저 만듭니다 <xref:System.Data.DataSet> 하나로 <xref:System.Data.DataTable>, 두 개의 열과 10 개 행입니다. <xref:System.Data.DataSet> 스키마와 데이터를 호출 하 여 디스크에 기록 된 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 두 번째 <xref:System.Data.DataSet> 만들어집니다 및 <xref:System.Data.DataSet.ReadXml%2A> 메서드 스키마와 데이터를 채우는 데 사용 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연결 된 열거형의 경우: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">읽어올 <see cref="T:System.Xml.XmlReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Xml.XmlReader" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet> XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마는 <xref:System.Data.DataSet> 포함는 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML과 함께 합니다. 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType>는 <xref:System.Xml.XmlReader>에서 상속됩니다.  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 간단한을 먼저 만듭니다 <xref:System.Data.DataSet> 하나로 <xref:System.Data.DataTable>, 두 개의 열과 10 개 행입니다. <xref:System.Data.DataSet> 스키마와 데이터를 호출 하 여 디스크에 기록 된 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 두 번째 <xref:System.Data.DataSet> 만들어집니다 및 <xref:System.Data.DataSet.ReadXml%2A> 메서드 스키마와 데이터를 채우는 데 사용 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">읽어올 <see cref="T:System.IO.Stream" />입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlReadMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 <see cref="T:System.IO.Stream" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Data.XmlReadMode" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet> XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.  
  
 에 마찬가지입니다는 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  사용 하는 경우 <xref:System.Data.DataSet.ReadXml%2A> 설정한 <xref:System.Data.XmlReadMode> 를 `Diffgram`, 대상의 내용을 `DataSet` 과 원래 `DataSet` diffgram 생성 되 고 처리 되는 방식으로 인해 달라질 수 있습니다. Diffgram에 대 한 자세한 내용은 참조 하십시오. [Diffgram](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md)합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마는 <xref:System.Data.DataSet> 포함 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML과 함께 합니다. 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">읽어올 <see cref="T:System.IO.TextReader" />입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlReadMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 <see cref="T:System.IO.TextReader" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Data.XmlReadMode" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet> XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마는 <xref:System.Data.DataSet> 포함 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML과 함께 합니다. 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">읽어올 파일의 경로를 포함한 이름입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlReadMode" /> 값 중 하나입니다.</param>
        <summary>지정된 파일과 <see cref="T:System.Data.DataSet" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Data.XmlReadMode" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet> XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마는 <xref:System.Data.DataSet> 포함는 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML과 함께 합니다. 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연결 된 열거형의 경우: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">읽어올 <see cref="T:System.Xml.XmlReader" />입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlReadMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 <see cref="T:System.Xml.XmlReader" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Data.XmlReadMode" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataSet> XML 문서 로부터 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마는 <xref:System.Data.DataSet> 포함는 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML과 함께 합니다. 정규화 되지 않은 요소를 읽으려면 설정 `elementFormDefault` 같은를 "qualified" XML 스키마에서 다음 예제에서 보여 주듯이 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML 스키마를 <see cref="T:System.Data.DataSet" />으로 읽어옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">읽어올 <see cref="T:System.IO.Stream" />입니다.</param>
        <summary>지정된 <see cref="T:System.IO.Stream" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 에 대 한 스키마를 만들려면 다음 메서드는 <xref:System.Data.DataSet>합니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
> [!NOTE]
>  msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataSet>합니다.  
  
 파생 된 클래스는 <xref:System.IO.Stream> 클래스 포함 <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, 및 <xref:System.Net.Sockets.NetworkStream>합니다.  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 예외가 throw에 스키마를 읽을 때는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXmlSchema%2A>합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.FileStream> 개체, XML 스키마 읽기를 호출 하는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드 개체를 사용 합니다.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">읽어올 <see cref="T:System.IO.TextReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.IO.TextReader" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 에 대 한 스키마를 만들려면 다음 메서드는 <xref:System.Data.DataSet>합니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
> [!NOTE]
>  msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataSet>합니다.  
  
 클래스에서 상속 되는 <xref:System.IO.TextReader> 클래스에 포함 된 <xref:System.IO.StreamReader> 및 <xref:System.IO.StringReader> 클래스입니다.  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 예외가 throw에 스키마를 읽을 때는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXmlSchema%2A>합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.IO.StreamReader> , 스키마를 읽거나 개체를 호출 하는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 개체와 메서드.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataSet.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">읽을 파일 이름(경로 포함)입니다.</param>
        <summary>지정된 파일에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 에 대 한 스키마를 만들려면 다음 메서드는 <xref:System.Data.DataSet>합니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
> [!NOTE]
>  msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataSet>합니다.  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 스키마를 읽고 하려고 할 때 예외가 throw 됩니다는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXmlSchema%2A>합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연결 된 열거형의 경우: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">읽어올 <see cref="T:System.Xml.XmlReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.Xml.XmlReader" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 에 대 한 스키마를 만들려면 다음 메서드는 <xref:System.Data.DataSet>합니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
> [!NOTE]
>  msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataSet>합니다.  
  
 <xref:System.Xml.XmlReader?displayProperty=nameWithType> 클래스는 추상 클래스입니다. 상속 되는 클래스는 `XmlReader` 는 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> 클래스입니다.  
  
> [!NOTE]
>  경우에 대 한 스키마 프로그램 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스의 다른 종류의 예외가 throw에 스키마를 읽을 때는 <xref:System.Data.DataSet> 와 <xref:System.Data.DataSet.ReadXmlSchema%2A>합니다. .NET Framework 버전 1.0 사용 하는 경우이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataSet> 및 <xref:System.IO.FileStream?displayProperty=nameWithType> 개체입니다. <xref:System.IO.FileStream> 파일 경로 파일 이름을 사용 하 여 만든 개체를 만드는 데 사용 되는 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> 에 인수로 전달 되는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">지정된 XML 판독기입니다.</param>
        <summary>특성을 무시하고 빈 DataSet을 반환합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberSignature Language="F#" Value="abstract member RejectChanges : unit -&gt; unit&#xA;override this.RejectChanges : unit -&gt; unit" Usage="dataSet.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" />이 만들어진 이후 또는 <see cref="M:System.Data.DataSet.AcceptChanges" />가 마지막으로 호출된 이후에 해당 DataSet에서 변경된 내용을 모두 롤백합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType> 호출 하는 <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> 모든 메서드 <xref:System.Data.DataTable> 개체에 포함 된는 <xref:System.Data.DataSet>합니다.  
  
 <xref:System.Data.DataRow> 에 포함 된 개체는 <xref:System.Data.DataSet> 호출 하 여 편집 모드로 설정할 수 있습니다는 <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType> 메서드. 호출 후는 <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> 메서드를 호출 하 여 변경 내용이 거부 될 수 있습니다는 <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> 에 <xref:System.Data.DataTable> 입니다는 <xref:System.Data.DataRow> 개체 속합니다.  
  
 경우는 <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> 메서드가 호출 되 면 행이 편집 모드에 계속 편집이 취소 합니다. 새 행이 제거 됩니다. 원래 상태로 다시 수정 및 삭제 된 행을 반환 합니다. (`DataRowState.Unchanged`).  
  
 AcceptChanges 및 RejectChanges에만 적용 <xref:System.Data.DataRow> 관련 변경 내용 (즉, `Add`, `Remove`, `Delete`, 및 `Modify`). 스키마 나 구조 변경 내용을 적용 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서 파생 된 클래스는 <xref:System.Data.DataSet> 클래스입니다. <xref:System.Data.DataSet.RejectChanges%2A> 이벤트 함수 내에서 호출 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Relations : System.Data.DataRelationCollection" Usage="System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>테이블을 연결하고 부모 테이블에서 자식 테이블까지 탐색할 수 있는 관계 컬렉션을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Data.DataRelationCollection" /> 개체 컬렉션을 포함하는 <see cref="T:System.Data.DataRelation" />입니다. <see cref="T:System.Data.DataRelation" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 출력을 통해 모든 자식 테이블의 열 이름에서 <xref:System.Data.DataSet.Relations%2A> 속성입니다.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>원격 작업 동안 사용된 <see cref="T:System.Data.SerializationFormat" />의 <see cref="T:System.Data.DataSet" />을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Data.SerializationFormat" /> 개체입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataSet.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 테이블을 지우고 <see cref="T:System.Data.DataSet" />에서 모든 관계, 외래 제약 조건 및 테이블을 제거합니다. 서브클래스에서 <see cref="M:System.Data.DataSet.Reset" />을 재정의하여 <see cref="T:System.Data.DataSet" />을 원래 상태로 복원해야 합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSerializationMode : System.Data.SchemaSerializationMode with get, set" Usage="System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.SchemaSerializationMode" />에 대한 <see cref="T:System.Data.DataSet" />를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Data.SchemaSerializationMode" />에 대한 <see cref="T:System.Data.DataSet" />를 가져오거나 설정합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.DataSet> 웹 서비스 및 원격 시나리오에 기본적으로 해당 스키마 및 인스턴스 데이터를 serialize 합니다. 설정의 <xref:System.Data.DataSet.SchemaSerializationMode%2A> 의 형식화 된 속성 `DataSet` 를 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> serialization 페이로드에서 제외 되어야 하는 스키마 정보로 인해 합니다.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 지원 되는 형식화 된에 대해서만 `DataSet`합니다. 형식화 되지 않은 `DataSet` 이 속성 설정할 수 있습니다 <xref:System.Data.SchemaSerializationMode.IncludeSchema>합니다.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 기본 스키마 정보를 입력 한 경우에만 사용 해야 `DataTables`, `DataRelations` 및 `Constraints` 수정 되지 않았습니다. 전체, 오류가 발생 했습니다 스키마 정보를 serialize 해야 수정 작업이 필요한 경우 <xref:System.Data.SchemaSerializationMode.IncludeSchema>합니다.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 2.0 이상 버전의.NET Framework에서 지원 됩니다.  
  
 때 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 설정 되어만 최상위 수준 런타임 속성에는 <xref:System.Data.DataSet> serialize 됩니다. 또한 기본 값과에서 다를 경우에 serialize 됩니다. 중에서 `Tables`, `Relations` 또는 `Constraints` serialize 됩니다. Serialize 된 런타임 속성에 포함 <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>, <xref:System.Data.DataSet.Prefix%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>, 및 <xref:System.Data.DataSet.CaseSensitive%2A>합니다. 이러한 속성은 전체 런타임 데이터 무결성이 유지 되도록 serialize 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeRelations : unit -&gt; bool&#xA;override this.ShouldSerializeRelations : unit -&gt; bool" Usage="dataSet.ShouldSerializeRelations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Data.DataSet.Relations" /> 속성을 유지해야 하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns>속성 값이 기본값에서 변경되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 디자이너를 만들거나 하는 경우 일반적으로이 메서드를 사용는 <xref:System.Data.DataSet>를 포함 하는 사용자 고유의 컨트롤을 만드는 <xref:System.Data.DataSet>합니다.  
  
   
  
## Examples  
 다음 예제에서는 보여에서 파생 된 클래스는 <xref:System.Data.DataSet> 클래스입니다. <xref:System.Data.DataSet.Reset%2A> 및 <xref:System.Data.DataSet.ShouldSerializeRelations%2A> 메서드는 파생된 클래스에서 함수 내에서 호출 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTables : unit -&gt; bool&#xA;override this.ShouldSerializeTables : unit -&gt; bool" Usage="dataSet.ShouldSerializeTables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Data.DataSet.Tables" /> 속성을 유지해야 하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns>속성 값이 기본값에서 변경되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 디자이너를 만들거나 하는 경우에이 메서드를 일반적으로 사용 된 <xref:System.Data.DataSet>, 포함 하는 사용자 고유의 컨트롤을 만드는 <xref:System.Data.DataSet>합니다.  
  
   
  
## Examples  
 다음 예제에서 파생 된 클래스는 <xref:System.Data.DataSet> 클래스입니다. <xref:System.Data.DataSet.ShouldSerializeTables%2A> 파생된 클래스에서 함수 내에서 메서드가 호출 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.ComponentModel.ISite" />에 대한 <see cref="T:System.Data.DataSet" />를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" />에 대한 <see cref="T:System.Data.DataSet" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사이트 바인딩는 <xref:System.ComponentModel.Component> 에 <xref:System.ComponentModel.Container> 서로 통신할 수 있도록 할 뿐만 아니라 컨테이너에서 해당 구성 요소를 관리할 수 있는 방법을 제공 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Data.DataSet.System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.ComponentModel.IListSource> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.ComponentModel.IListSource.GetList" />를 참조하세요.</summary>
        <returns>이 멤버에 대한 설명은 <see cref="M:System.ComponentModel.IListSource.GetList" />를 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.ComponentModel.IListSource> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />를 참조하세요.</summary>
        <returns>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />를 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" />
        </param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />를 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" />
        </param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />를 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Tables : System.Data.DataTableCollection" Usage="System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" />에 포함된 테이블 컬렉션을 가져옵니다.</summary>
        <value>이 <see cref="T:System.Data.DataTableCollection" />에 포함된 <see cref="T:System.Data.DataSet" />입니다. <see cref="T:System.Data.DataTable" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션에 테이블을 추가 하려면 사용 <xref:System.Data.DataTableCollection.Add%2A> 의 메서드는 <xref:System.Data.DataTableCollection>합니다. 사용 하 여 테이블을 제거 하려면는 <xref:System.Data.DataTableCollection.Remove%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 반환 된 <xref:System.Data.DataSet> 개체의 <xref:System.Data.DataTableCollection>, 하 고 각 테이블에서 행 및 열을 출력 합니다.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" />에서 XML 데이터를 쓰고 선택적으로 스키마를 씁니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">파일에 쓸 때 사용되는 <see cref="T:System.IO.Stream" /> 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />을 사용하여 <see cref="T:System.IO.Stream" />의 현재 데이터를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.IO.FileStream?displayProperty=nameWithType> 개체입니다. 개체가 만들어진는 <xref:System.Data.DataSet.WriteXml%2A> 메서드는 XML 문서를 작성 합니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">쓰기에 사용할 <see cref="T:System.IO.TextWriter" /> 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />을 사용하여 <see cref="T:System.IO.TextWriter" />의 현재 데이터를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataSet.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">쓸 대상 파일 이름(경로 포함)입니다.</param>
        <summary>지정된 파일에 <see cref="T:System.Data.DataSet" />의 현재 데이터를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연결 된 열거형의 경우: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">쓰기에 사용할 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />에 <see cref="T:System.Xml.XmlWriter" />의 현재 데이터를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">파일에 쓸 때 사용되는 <see cref="T:System.IO.Stream" /> 개체입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />와 <see cref="T:System.IO.Stream" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 설정는 `mode` 매개 변수를 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">문서를 작성하는 데 사용되는 <see cref="T:System.IO.TextWriter" /> 개체입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />와 <see cref="T:System.IO.TextWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 설정는 `mode` 매개 변수를 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 예에서는 간단한을 먼저 만듭니다 <xref:System.Data.DataSet> 하나로 <xref:System.Data.DataTable>, 두 개의 열과 10 개 행입니다. <xref:System.Data.DataSet> 스키마와 데이터를 호출 하 여 디스크에 기록 된 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 두 번째 <xref:System.Data.DataSet> 만들어집니다 및 <xref:System.Data.DataSet.ReadXml%2A> 메서드 스키마와 데이터를 채우는 데 사용 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">쓸 대상 파일 이름(경로 포함)입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />를 사용하여 지정된 파일에 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 설정는 `mode` 매개 변수를 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataSet.WriteXml%2A> 메서드는 XML 문서를 작성 합니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연결 된 열거형의 경우: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">쓰기에 사용할 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />와 <see cref="T:System.Xml.XmlWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 설정는 `mode` 매개 변수를 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.IO.FileStream?displayProperty=nameWithType> 새로 만들려면 사용 되는 개체 <xref:System.Xml.XmlTextWriter>합니다. <xref:System.Xml.XmlTextWriter> 개체 함께 사용 되는 <xref:System.Data.DataSet.WriteXml%2A> 메서드는 XML 문서를 작성 합니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" /> 구조를 XML 스키마로 씁니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">파일에 쓸 때 사용되는 <see cref="T:System.IO.Stream" /> 개체입니다.</param>
        <summary>
          <see cref="T:System.Data.DataSet" /> 구조체를 지정된 <see cref="T:System.IO.Stream" /> 개체에 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataSet> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataSet.WriteXml%2A> 메서드.  
  
 파생 된 클래스는 <xref:System.IO.Stream> 클래스 포함 <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, 및 <xref:System.Net.Sockets.NetworkStream>합니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.IO.FileStream> 에 전달 되는 개체는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마를 디스크에 쓸 수 있습니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">쓰기에 사용할 <see cref="T:System.IO.TextWriter" /> 개체입니다.</param>
        <summary>
          <see cref="T:System.Data.DataSet" /> 구조체를 지정된 <see cref="T:System.IO.TextWriter" /> 개체에 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataSet> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataSet.WriteXml%2A> 메서드.  
  
 클래스에서 파생 되는는 <xref:System.IO.TextWriter?displayProperty=nameWithType> 클래스에 포함 된 <xref:System.Web.HttpWriter?displayProperty=nameWithType>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, <xref:System.IO.StreamWriter?displayProperty=nameWithType>, 및 <xref:System.IO.StringWriter?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.StringBuilder?displayProperty=nameWithType> 개체를 하는 데 새 <xref:System.IO.StringWriter?displayProperty=nameWithType>합니다. <xref:System.IO.StringWriter> 에 전달 되는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드와 결과 문자열이 콘솔 창에 출력 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataSet.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">쓸 대상 파일 이름(경로 포함)입니다.</param>
        <summary>
          <see cref="T:System.Data.DataSet" /> 구조를 파일에 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataSet> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataSet.WriteXml%2A> 메서드.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연결 된 열거형의 경우: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">쓸 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <summary>
          <see cref="T:System.Data.DataSet" /> 구조를 <see cref="T:System.Xml.XmlWriter" /> 개체에 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataSet> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다. 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataSet.WriteXml%2A> 메서드.  
  
 하나의 클래스에서 상속 되는 <xref:System.Xml.XmlWriter?displayProperty=nameWithType> 클래스는는 <xref:System.Xml.XmlTextWriter> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.IO.FileStream?displayProperty=nameWithType> 지정 된 경로 개체입니다. <xref:System.IO.FileStream> 개체를 만드는 데 사용 되는 <xref:System.Xml.XmlTextWriter> 개체입니다. <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 호출 합니다는 <xref:System.Xml.XmlTextWriter> 스키마 디스크에 쓸 개체입니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (stream, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">쓸 <see cref="T:System.IO.Stream" /> 개체입니다.</param>
        <param name="multipleTargetConverter">
          <see cref="T:System.Type" />을 문자열로 변환하는 데 사용되는 대리자입니다.</param>
        <summary>
          <see cref="T:System.Data.DataSet" /> 구조체를 지정된 <see cref="T:System.IO.Stream" /> 개체에 XML 스키마로 씁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">쓸 <see cref="T:System.IO.TextWriter" /> 개체입니다.</param>
        <param name="multipleTargetConverter">
          <see cref="T:System.Type" />을 문자열로 변환하는 데 사용되는 대리자입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />에 <see cref="T:System.IO.TextWriter" /> 구조를 XML 스키마로 씁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (fileName, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">쓸 파일의 이름입니다.</param>
        <param name="multipleTargetConverter">
          <see cref="T:System.Type" />을 문자열로 변환하는 데 사용되는 대리자입니다.</param>
        <summary>
          <see cref="T:System.Data.DataSet" /> 구조를 파일에 XML 스키마로 씁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">쓸 <see cref="T:System.Xml.XmlWriter" /> 개체입니다.</param>
        <param name="multipleTargetConverter">
          <see cref="T:System.Type" />을 문자열로 변환하는 데 사용되는 대리자입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />에 <see cref="T:System.Xml.XmlWriter" /> 구조를 XML 스키마로 씁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>