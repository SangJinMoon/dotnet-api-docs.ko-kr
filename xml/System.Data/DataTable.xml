<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ebfc2930ba77d02811472dac7449a79e1eea9c8a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36679907" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataTable = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents one table of in-memory data.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable> ADO.NET 라이브러리의 중앙 개체입니다. 사용 하는 다른 개체는 <xref:System.Data.DataTable> 포함는 <xref:System.Data.DataSet> 및 <xref:System.Data.DataView>합니다.  
  
 에 액세스할 때 <xref:System.Data.DataTable> 개체, 조건에 따라 대/소문자 구분 되는지 확인 합니다. 예를 들어 하나의 <xref:System.Data.DataTable> "mydatatable" 라고 하 고 "Mydatatable" 라는 다른, 테이블 중 하나를 검색 하는 데 사용 하는 문자열 같이 대/소문자 구분 간주 됩니다. 그러나 "mydatatable" 있으며 "Mydatatable" 하지 않는 경우 검색 문자열 소문자 간주 됩니다. A <xref:System.Data.DataSet> 두 개를 포함할 수 있습니다 <xref:System.Data.DataTable> 동일한 개체 <xref:System.Data.DataTable.TableName%2A> 속성 값은 다른 <xref:System.Data.DataTable.Namespace%2A> 속성 값입니다. 작업에 대 한 자세한 내용은 <xref:System.Data.DataTable> 개체 참조 [DataTable 만들기](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)합니다.  
  
 만들려는 경우 한 <xref:System.Data.DataTable> 프로그래밍 방식으로 정의 해야 해당 스키마를 추가 하 여 <xref:System.Data.DataColumn> 개체를 <xref:System.Data.DataColumnCollection> (통해 액세스는 <xref:System.Data.DataTable.Columns%2A> 속성). 추가 하는 방법에 대 한 자세한 내용은 <xref:System.Data.DataColumn> 개체 참조 [DataTable에 열 추가](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md)합니다.  
  
 행을 추가 하는 <xref:System.Data.DataTable>를 먼저 사용 해야 합니다는 <xref:System.Data.DataTable.NewRow%2A> 새 반환 하는 메서드 <xref:System.Data.DataRow> 개체입니다. <xref:System.Data.DataTable.NewRow%2A> 의 스키마가 있는 행을 반환 하는 메서드는 <xref:System.Data.DataTable>는 테이블에 의해 정의 된 대로, <xref:System.Data.DataColumnCollection>합니다. 행의 최대 개수는 <xref:System.Data.DataTable> 수 저장소는 16777216 합니다. 자세한 내용은 참조 [DataTable에 데이터 추가](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md)합니다.  
  
 <xref:System.Data.DataTable> 의 컬렉션도 포함 <xref:System.Data.Constraint> 데이터의 무결성을 보장 하는 데 사용할 수 있습니다. 자세한 내용은 참조 [DataTable 제약 조건](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)합니다.  
  
 여러 <xref:System.Data.DataTable> 테이블에 변경 내용이 시기를 결정 하는 데 사용할 수 있는 이벤트입니다. 이것에는 <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting> 및 <xref:System.Data.DataTable.RowDeleted>가 있습니다. 함께 사용할 수 있는 이벤트에 대 한 자세한 내용은 <xref:System.Data.DataTable>, 참조 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
 인스턴스가 <xref:System.Data.DataTable> 를 만드는 경우 일부 속성 읽기/쓰기의 초기 값으로 설정 됩니다. 이러한 값의 목록에 대 한 참조는 <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> 생성자 항목입니다.  
  
> [!NOTE]
>  <xref:System.Data.DataSet> 및 <xref:System.Data.DataTable> 개체에서 상속 <xref:System.ComponentModel.MarshalByValueComponent>, 및 지원에서 <xref:System.Runtime.Serialization.ISerializable> .NET Framework remoting에 대 한 인터페이스입니다. 이들은.NET Framework remoting에 사용할 수 있는 유일한 ADO.NET 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 <xref:System.Data.DataTable> 개체와 하나의 <xref:System.Data.DataRelation> 개체를 새 개체를 추가 하는 <xref:System.Data.DataSet>합니다. 테이블에 표시 되는 <xref:System.Windows.Forms.DataGridView> 제어 합니다.  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 이 샘플에는 특정 스키마 정의를 DataTable을 수동으로 만드는 방법을 보여 줍니다.  
  
-   여러 Datatable을 만들고 첫 열을 정의 합니다.  
  
-   테이블 제약 조건을 만듭니다.  
  
-   값을 삽입 하 고 테이블을 표시 합니다.  
  
-   식 열을 만들고 테이블을 표시 합니다.  
  
 이 코드 예제와 함께 C# 및 Visual Basic 프로젝트에서 확인할 수 있습니다 [개발자 코드 샘플](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914)합니다.  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 다중 스레드 읽기 작업에 안전 합니다. 쓰기 작업을 동기화 해야 합니다.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with no arguments.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 속성에 대 한 초기 값을 설정 하는 생성자는 <xref:System.Data.DataTable> 개체입니다. 다음 표에서 속성 및 기본값을 보여 줍니다. 인스턴스가 <xref:System.Data.DataTable> 만들어지면 다음 읽기/쓰기 속성은 초기 값으로 설정 됩니다.  
  
|속성|기본값|  
|--------------|-------------------|  
|**CaseSensitive**|부모와 동일한 <xref:System.Data.DataSet>하나에 속하게 하는 경우. 그렇지 않으면 `false`입니다.|  
|**DisplayExpression**|빈 문자열 ("")|  
|**로캘**|부모와 동일한 <xref:System.Data.DataSet> 개체의 <xref:System.Globalization.CultureInfo> (에서 반환 되는 <xref:System.Data.DataSet.Locale%2A> 속성) 부모가 없으면; 기본값은 현재 시스템 <xref:System.Globalization.CultureInfo>합니다.|  
|**MinimumCapacity**|50 행 수입니다.|  
  
 속성에 별도 호출을 통해 이러한 속성 중 하나에 대 한 값을 변경할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataTable> 와 <xref:System.Data.DataColumn> 및 <xref:System.Data.DataRow>에 표시 된 <xref:System.Windows.Forms.DataGridView> 제어 합니다.  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable tableName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">The name to give the table. If <c>tableName</c> is <see langword="null" /> or an empty string, a default name is given when added to the <see cref="T:System.Data.DataTableCollection" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with the specified table name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 한 <xref:System.Data.DataTable> 에 표시는 <xref:System.Windows.Forms.DataGridView> 제어 합니다.  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">The data needed to serialize or deserialize an object.</param>
        <param name="context">The source and destination of a given serialized stream.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and the <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 구현에서 <xref:System.Data.DataTable> 생성자가 필요 <xref:System.Runtime.Serialization.ISerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string * string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (tableName, tableNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">The name to give the table. If <c>tableName</c> is <see langword="null" /> or an empty string, a default name is given when added to the <see cref="T:System.Data.DataTableCollection" />.</param>
        <param name="tableNamespace">The namespace for the XML representation of the data stored in the <see langword="DataTable" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class using the specified table name and namespace.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataTable.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commits all the changes made to this table since the last time <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Data.DataTable.AcceptChanges%2A> 호출, <xref:System.Data.DataRow> 아직 편집 모드에에서는 개체의 편집을 성공적으로 종료 합니다. <xref:System.Data.DataRowState> 설치 경로도 변경: 모든 `Added` 및 `Modified` 될 행 `Unchanged`, 및 `Deleted` 행이 제거 됩니다.  
  
 <xref:System.Data.DataTable.AcceptChanges%2A> 일반적으로 메서드가 호출 되는 <xref:System.Data.DataTable> 후 업데이트 하 려 하면는 <xref:System.Data.DataSet> 를 사용 하 여는 <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 각 테이블의 오류를 테스트합니다. (에 전달 하 여 정의 되지 않은 함수), 테이블의 오류를 해결할 수 있는 경우 <xref:System.Data.DataTable.AcceptChanges%2A> 고, 그러지 않으면 호출 <xref:System.Data.DataTable.RejectChanges%2A> 호출 됩니다.  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataTable.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins the initialization of a <see cref="T:System.Data.DataTable" /> that is used on a form or used by another component. The initialization occurs at run time.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 시작 합니다. <xref:System.Data.DataTable.EndInit%2A> 메서드 초기화를 끝냅니다. 사용 하는 <xref:System.Data.DataTable.BeginInit%2A> 및 <xref:System.Data.DataTable.EndInit%2A> 메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberSignature Language="F#" Value="member this.BeginLoadData : unit -&gt; unit" Usage="dataTable.BeginLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Turns off notifications, index maintenance, and constraints while loading data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Data.DataTable.BeginLoadData%2A> 함께에서 <xref:System.Data.DataTable.LoadDataRow%2A> 및 <xref:System.Data.DataTable.EndLoadData%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether string comparisons within the table are case-sensitive.</summary>
        <value>
          <see langword="true" /> 비교는 대/소문자 구분; 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 parent로 설정 된 <see cref="T:System.Data.DataSet" /> 개체의 <see cref="P:System.Data.DataSet.CaseSensitive" /> 속성을 또는 <see langword="false" /> 경우는 <see cref="T:System.Data.DataTable" /> 와 독립적으로 만들어진는 <see cref="T:System.Data.DataSet" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.CaseSensitive%2A> 속성 정렬, 검색 및 필터링에 대 한 문자열 비교에 영향을 줍니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable.Select%2A> 메서드를 두 번는 <xref:System.Data.DataTable>합니다. 처음으로 <xref:System.Data.DataTable.CaseSensitive%2A> 속성이 `false`에 두 번째 `true`합니다.  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of child relations for this <see cref="T:System.Data.DataTable" />.</summary>
        <value>A <see cref="T:System.Data.DataRelationCollection" /> 테이블에 대 한 자식 관계를 포함 하 합니다. 없는 경우에 빈 컬렉션이 반환 됩니다 <see cref="T:System.Data.DataRelation" /> 개체가 존재 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.DataRelation> 두 테이블 간의 관계를 정의 합니다. 일반적으로 두 테이블은 동일한 데이터를 포함 하는 단일 필드를 통해 연결 됩니다. 예를 들어 주소 데이터를 포함 하는 테이블에는 국가/지역을 나타내는 코드를 포함 하는 단일 필드가 있을 수 있습니다. 국가/지역 데이터를 포함 하는 두 번째 테이블에서 국가/지역을 식별 하는 코드를 포함 하는 단일 필드 있으며이 코드가 첫 번째 테이블의 해당 필드에 삽입 됩니다. A <xref:System.Data.DataRelation>, 적어도 다음 4 가지 정보를 포함 합니다: (1) 첫 번째 테이블의 이름, 첫 번째 테이블의 열 이름 (2), (3) 두 번째 테이블의 이름 및 (4) 두 번째 테이블의 열 이름입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable.ChildRelations%2A> 각 자식 반환할 속성 <xref:System.Data.DataRelation> 에 <xref:System.Data.DataTable>합니다. 각 관계에 대 한 인수로 사용 됩니다는 <xref:System.Data.DataRow.GetChildRows%2A> 의 메서드는 <xref:System.Data.DataRow> 행의 배열을 반환 하도록 합니다. 행에 있는 각 열의 값이 출력 합니다.  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the <see cref="T:System.Data.DataTable" /> of all data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 테이블의 모든 행이 제거 됩니다. 테이블에 자식 관계가 적용된 해야 하는 자식 행이 분리 될 경우 예외가 생성 됩니다.  
  
 경우는 <xref:System.Data.DataSet> 에 바인딩된는 <xref:System.Xml.XmlDataDocument>호출, <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> 또는 <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> 발생는 <xref:System.NotSupportedException>합니다. 이러한 상황을 방지 하려면 한 번에 하나씩 행을 제거, 각 테이블을 이동 합니다. 사용 하는 경우 <xref:System.Data.DataTable.NewRow%2A> 새 행을 만들려면는 행을 처리 해야를 호출 하기 전에 <xref:System.Data.DataTable.Clear%2A>합니다.  
  
   
  
## Examples  
 다음 예에서는 테이블의 모든 데이터를 지웁니다.  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataTable&#xA;override this.Clone : unit -&gt; System.Data.DataTable" Usage="dataTable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clones the structure of the <see cref="T:System.Data.DataTable" />, including all <see cref="T:System.Data.DataTable" /> schemas and constraints.</summary>
        <returns>A new <see cref="T:System.Data.DataTable" /> with the same schema as the current <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이러한 클래스를 파생 된 경우 동일한 파생된 클래스가 복제가 됩니다.  
  
 복제 대상을 새 <xref:System.Data.DataTable> 원본과 같은 구조와 <xref:System.Data.DataTable>, 하지만 모든 데이터를 복사 하지 않습니다 (새 <xref:System.Data.DataTable> 포함 되지 것입니다 `DataRows`). 새 구조와 데이터를 복사 하려면 <xref:System.Data.DataTable>를 사용 하 여 <xref:System.Data.DataTable.Copy%2A>합니다.  
  
   
  
## Examples  
 다음 샘플에는 구조와 대상 테이블의 제약 조건을 DataTable.Clone를 실행 한 후 업데이트 하는 방법을 보여 줍니다. 대상 테이블 반환 하 고 모든 업데이트 이벤트를 포함 하는 ClonedDataTable 클래스. 복제 후 원본 테이블의 구조 변경 내용은 대상 테이블에 반영 되지 않습니다. 특히,이 샘플 수행합니다.  
  
-   원본 테이블의 열의 변경 내용을 업데이트 합니다.  
  
-   원본 테이블의 UniqueConstraint의 변경 내용을 업데이트 합니다.  
  
-   원본 테이블의 외래 키의 변경 내용을 업데이트 합니다.  
  
 이 코드 예제와 함께 C# 및 Visual Basic 프로젝트에서 확인할 수 있습니다 [개발자 코드 샘플](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable)합니다.  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 이 샘플에서는 DataTable에서 데이터를 수정 하 고 데이터 소스를 업데이트 하는 방법을 보여 줍니다.  
  
 먼저 데이터베이스를 만듭니다.  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 이제 컴파일 및 샘플을 실행할 수 있습니다. [DataTable 및 데이터 원본에 대 한 업데이트에 대 한 데이터를 수정 하는 방법](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) 이 샘플의 Visual Basic 및 C# 프로젝트에 있습니다.  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a value has been changed for the specified <see cref="T:System.Data.DataColumn" /> in a <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 참조 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a value is being changed for the specified <see cref="T:System.Data.DataColumn" /> in a <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 참조 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Columns : System.Data.DataColumnCollection" Usage="System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of columns that belong to this table.</summary>
        <value>A <see cref="T:System.Data.DataColumnCollection" /> 의 컬렉션을 포함 하는 <see cref="T:System.Data.DataColumn" /> 테이블에 대 한 개체입니다. 없는 경우에 빈 컬렉션이 반환 됩니다 <see cref="T:System.Data.DataColumn" /> 개체가 존재 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataColumnCollection> 각 열의 데이터 형식을 정의 하 여 테이블의 스키마를 결정 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하 여 테이블의 각 행의 값을 출력에서 <xref:System.Data.DataTable.Columns%2A> 속성입니다.  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Compute : string * string -&gt; obj" Usage="dataTable.Compute (expression, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">The expression to compute.</param>
        <param name="filter">The filter to limit the rows that evaluate in the expression.</param>
        <summary>Computes the given expression on the current rows that pass the filter criteria.</summary>
        <returns>An <see cref="T:System.Object" />, set to the result of the computation. If the expression evaluates to null, the return value will be <see cref="F:System.DBNull.Value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `expression` 매개 변수는 집계 함수가 필요 합니다. 예를 들어 다음은 올바른 식입니다.  
  
 `Count(Quantity)`  
  
 하지만이 식은 하지 않습니다.  
  
 `Sum (Quantity * UnitPrice)`  
  
 두 개 이상의 열에 대 한 작업을 수행 해야 하는 경우 만든는 <xref:System.Data.DataColumn>설정, 해당 <xref:System.Data.DataColumn.Expression%2A> 속성을 적절 한 식이 다음 결과 열에 집계 식 사용 합니다. 지정 된 경우에 <xref:System.Data.DataColumn> 이름이 "total"와 및 <xref:System.Data.DataColumn.Expression%2A> 속성이이로 설정 합니다.  
  
 `"Quantity * UnitPrice"`  
  
 에 대 한 식 인수는 <xref:System.Data.DataTable.Compute%2A> 메서드 된 것이:  
  
 `Sum(total)`  
  
 두 번째 매개 변수 `filter`, 식에 사용 될 행을 결정 합니다. 예를 들어 테이블에 있는 경우 "colDate" 라는 날짜 열을 다음 식으로 행을 제한할 수 있습니다.  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 매개 변수가 모두에 대 한 식을 만드는 방법에 대 한 규칙을 참조 하십시오.는 <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 해당 id 번호는 5는 판매 직원에 대 한 "Total" 이라는 열의 값을 찾습니다.  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraints : System.Data.ConstraintCollection" Usage="System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of constraints maintained by this table.</summary>
        <value>A <see cref="T:System.Data.ConstraintCollection" /> 의 컬렉션을 포함 하는 <see cref="T:System.Data.Constraint" /> 테이블에 대 한 개체입니다. 없는 경우에 빈 컬렉션이 반환 됩니다 <see cref="T:System.Data.Constraint" /> 개체가 존재 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.ForeignKeyConstraint> 열 또는 열에 값이 삭제 되거나 업데이트할 때 수행 하는 작업을 제한 합니다. 이러한 제약 조건은 기본 키 열과 함께 사용 하는 데 사용 됩니다. 두 테이블 간에 부모/자식 관계에서 부모 테이블에서 값을 삭제할 영향을 줄 수 자식 행에서 다음 방법 중 하나입니다.  
  
-   자식 행 수도 있습니다 (연계 동작)를 삭제 합니다.  
  
-   자식 열 (또는 열)의 값은 null 값으로 설정할 수 있습니다.  
  
-   자식 열 (또는 열)의 값을 기본값으로 설정할 수 있습니다.  
  
-   예외를 생성할 수 있습니다.  
  
 A <xref:System.Data.UniqueConstraint> 값이 고유 기본 키의 값을 설정 하려고 할 때 활성화 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 추가 <xref:System.Data.ForeignKeyConstraint> 제약 조건 컬렉션에 있습니다.  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataTable" Usage="dataTable.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copies both the structure and data for this <see cref="T:System.Data.DataTable" />.</summary>
        <returns>A new <see cref="T:System.Data.DataTable" /> with the same structure (table schemas and constraints) and data as this <see cref="T:System.Data.DataTable" />.  If these classes have been derived, the copy will also be of the same derived classes.  
  
 <see cref="M:System.Data.DataTable.Copy" /> creates a new <see cref="T:System.Data.DataTable" /> with the same structure and data as the original <see cref="T:System.Data.DataTable" />. To copy the structure to a new <see cref="T:System.Data.DataTable" />, but not the data, use <see cref="M:System.Data.DataTable.Clone" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable.Copy%2A> 원본의 복사본을 만드는 메서드를 <xref:System.Data.DataTable>합니다. 부모 로부터 상속 되는 경우에 네임 스페이스 이름을 유지 되지 않습니다 <xref:System.Data.DataTable> 또는 <xref:System.Data.DataSet>합니다.  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataTable.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <see cref="T:System.Data.DataTableReader" /> corresponding to the data within this <see cref="T:System.Data.DataTable" />.</summary>
        <returns>A <see cref="T:System.Data.DataTableReader" /> containing one result set, corresponding to the source <see cref="T:System.Data.DataTable" /> instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 콘솔 응용 프로그램에서는 <xref:System.Data.DataTable> 인스턴스를 만듭니다. 이 예제에서는 다음 채워진 전달 <xref:System.Data.DataTable> 를 호출 하는 프로시저는 <xref:System.Data.DataTable.CreateDataReader%2A> 메서드 내에 포함 된 결과를 반복 하는 <xref:System.Data.DataTableReader>합니다.  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 출력을 표시합니다.  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : unit -&gt; System.Data.DataTable&#xA;override this.CreateInstance : unit -&gt; System.Data.DataTable" Usage="dataTable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new instance of <see cref="T:System.Data.DataTable" />.</summary>
        <returns>The new expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Data.DataSet" /> to which this table belongs.</summary>
        <value>
          <see cref="T:System.Data.DataSet" /> 이 테이블이 속해 있는 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤 데이터에 바인딩된는 <xref:System.Data.DataTable>, 테이블에 속해는 <xref:System.Data.DataSet>에 가져올 수 있습니다는 <xref:System.Data.DataSet> 이 속성을 통해.  
  
   
  
## Examples  
 다음 예제에서는 부모 반환 <xref:System.Data.DataSet> 통해 지정된 된 테이블의는 <xref:System.Data.DataTable.DataSet%2A> 속성입니다.  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultView : System.Data.DataView" Usage="System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a customized view of the table that may include a filtered view, or a cursor position.</summary>
        <value>
          <see cref="T:System.Data.DataView" />와 연결된 <see cref="T:System.Data.DataTable" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.DefaultView%2A> 속성에서 반환 된 <xref:System.Data.DataView> 정렬, 필터 및 검색 하는 데 사용할 수는 <xref:System.Data.DataTable>합니다.  
  
   
  
## Examples  
 속성을 설정 하는 다음 예제는 <xref:System.Data.DataTable> 개체의 <xref:System.Data.DataView> 통해는 <xref:System.Data.DataTable.DefaultView%2A> 속성입니다. 또한이 예제에서는의 바인딩을 <xref:System.Windows.Forms.DataGridView> 컨트롤을 한 <xref:System.Data.DataTable> "CompanyName" 라는 열이 포함 된 "공급자" 라는  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayExpression : string with get, set" Usage="System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the expression that returns a value used to represent this table in the user interface. The <see langword="DisplayExpression" /> property lets you display the name of this table in a user interface.</summary>
        <value>표시 문자열입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataTable.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends the initialization of a <see cref="T:System.Data.DataTable" /> that is used on a form or used by another component. The initialization occurs at run time.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 끝냅니다. <xref:System.Data.DataTable.BeginInit%2A> 메서드 초기화를 시작 합니다. 사용 하는 <xref:System.Data.DataTable.BeginInit%2A> 및 <xref:System.Data.DataTable.EndInit%2A> 메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberSignature Language="F#" Value="member this.EndLoadData : unit -&gt; unit" Usage="dataTable.EndLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Turns on notifications, index maintenance, and constraints after loading data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Data.DataTable.EndLoadData%2A> 함께에서 <xref:System.Data.DataTable.LoadDataRow%2A> 및 <xref:System.Data.DataTable.BeginLoadData%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of customized user information.</summary>
        <value>A <see cref="T:System.Data.PropertyCollection" /> 하는 사용자 지정 사용자 정보를 포함 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.ExtendedProperties%2A> 사용자 지정 정보를 추가 하는 <xref:System.Data.DataTable>합니다. 추가 정보는 `Add` 메서드. 정보를 검색할는 `Item` 메서드.  
  
 확장된 속성 형식 이어야 합니다 <xref:System.String>합니다. 문자열 형식이 아닌 속성 유지 되지 않습니다 때는 <xref:System.Data.DataTable> XML로 기록 됩니다.  
  
   
  
## Examples  
 타임 스탬프 값을 추가 하는 다음 예제는 <xref:System.Data.DataTable> 통해는 <xref:System.Data.DataTable.ExtendedProperties%2A> 속성입니다.  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberSignature Language="F#" Value="val mutable fInitInProgress : bool" Usage="System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Checks whether initialization is in progress. The initialization occurs at run time.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a copy of the <see cref="T:System.Data.DataTable" /> containing all changes made to it since it was last loaded, or since <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataTable" Usage="dataTable.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a copy of the <see cref="T:System.Data.DataTable" /> that contains all changes made to it since it was loaded or <see cref="M:System.Data.DataTable.AcceptChanges" /> was last called.</summary>
        <returns>A copy of the changes from this <see cref="T:System.Data.DataTable" />, or <see langword="null" /> if no changes are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 <xref:System.Data.DataSet> 원래에 모든 행의 복사본이 포함 된 <xref:System.Data.DataSet> 보류 중인 변경 내용이 있는 합니다. 관계 제약 조건으로 인해 새에 추가할 추가 변경 되지 않은 행 <xref:System.Data.DataSet> 변경 되지 않은 행에는 변경 된 행에서 외래 키에 해당 하는 기본 키를 포함 하는 경우. 메서드가 반환 `null` (`Nothing` Visual basic에서)는 원본에서 행이 없는 경우 <xref:System.Data.DataSet> 와 보류 중인 변경 내용.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataTable" Usage="dataTable.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">One of the <see cref="T:System.Data.DataRowState" /> values.</param>
        <summary>Gets a copy of the <see cref="T:System.Data.DataTable" /> containing all changes made to it since it was last loaded, or since <see cref="M:System.Data.DataTable.AcceptChanges" /> was called, filtered by <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>A filtered copy of the <see cref="T:System.Data.DataTable" /> that can have actions performed on it, and later be merged back in the <see cref="T:System.Data.DataTable" /> using <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. If no rows of the desired <see cref="T:System.Data.DataRowState" /> are found, the method returns <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.GetChanges%2A> 초를 생성 하기 위해 메서드를 사용 하는 <xref:System.Data.DataTable> 원래에 도입 된 변경 내용만 포함 하는 개체입니다. 사용 하 여는 `rowStates` 인수를 새 개체에 포함 될 변경 유형을 지정 합니다.  
  
 관계 제약 조건 하면 변경 되지 않은 부모 행이 포함 될 수 있습니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataTableSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataTable.GetDataTableSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">An <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance.</param>
        <summary>This method returns an <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance containing the Web Services Description Language (WSDL) that describes the <see cref="T:System.Data.DataTable" /> for Web Services.</summary>
        <returns>The <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberSignature Language="F#" Value="member this.GetErrors : unit -&gt; System.Data.DataRow[]" Usage="dataTable.GetErrors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an array of <see cref="T:System.Data.DataRow" /> objects that contain errors.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects that have errors.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 목록을 반환 <xref:System.Data.DataRow> 개체 <xref:System.Data.DataRow.RowError%2A> 설정 합니다. 호출할 때 오류가 발생할 수 있습니다는 예를 들어 <xref:System.Data.Common.DataAdapter.Update%2A> 와 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 로 설정 **true**합니다. 호출 하지 말고 <xref:System.Data.DataTable.AcceptChanges%2A> 에 <xref:System.Data.DataTable> 모든 오류를 해결 하 고 다시 전송 될 때까지 <xref:System.Data.DataSet> 업데이트에 대 한 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable.GetErrors%2A> 의 배열을 반환 하는 메서드 <xref:System.Data.DataRow> 오류가 있는 개체입니다.  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataTable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that holds the serialized data associated with the <see cref="T:System.Data.DataTable" />.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains the source and destination of the serialized stream associated with the <see cref="T:System.Data.DataTable" />.</param>
        <summary>Populates a serialization information object with the data needed to serialize the <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberSignature Language="F#" Value="abstract member GetRowType : unit -&gt; Type&#xA;override this.GetRowType : unit -&gt; Type" Usage="dataTable.GetRowType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the row type.</summary>
        <returns>Returns the type of the <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberSignature Language="F#" Value="abstract member GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataTable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> method.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether there are errors in any of the rows in any of the tables of the <see cref="T:System.Data.DataSet" /> to which the table belongs.</summary>
        <value>
          <see langword="true" /> 오류가 없으면; 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 작업에 포함 된 데이터 집합에는 <xref:System.Data.DataTable>, 변경으로 인해 일부 유효성 검사 실패 하는 경우 오류가 발생 하 여 각 변경을 표시할 수 있습니다. 전체를 표시할 수 있습니다 <xref:System.Data.DataRow> 사용 하 여 오류 메시지는 <xref:System.Data.DataRow.RowError%2A> 속성입니다. 오류가 있는 행의 각 열에 설정할 수도 있습니다는 <xref:System.Data.DataRow.SetColumnError%2A> 메서드.  
  
 데이터 원본을 업데이트 하기 전에 <xref:System.Data.DataSet>를 먼저 호출 하는 것이 좋습니다.는 <xref:System.Data.DataSet.GetChanges%2A> 대상 메서드 <xref:System.Data.DataSet>합니다. 이렇게 한 <xref:System.Data.DataSet> 원본에 대 한 변경 내용만 포함 하 합니다. 보내기 전에 <xref:System.Data.DataSet> 확인 업데이트에 대 한 데이터 원본에는 <xref:System.Data.DataTable.HasErrors%2A> 각 테이블을 행 이나 행의 열에 오류가 있는지 연결 되는 경우의 속성입니다.  
  
 각 오류를 해결 한 후 사용 하 여 오류를 지울는 <xref:System.Data.DataRow.ClearErrors%2A> 의 메서드는 `DataRow`합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable.HasErrors%2A> 속성을 테이블에 오류가 포함 되어 있는지 확인 합니다.  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberSignature Language="F#" Value="member this.ImportRow : System.Data.DataRow -&gt; unit" Usage="dataTable.ImportRow row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">The <see cref="T:System.Data.DataRow" /> to be imported.</param>
        <summary>Copies a <see cref="T:System.Data.DataRow" /> into a <see cref="T:System.Data.DataTable" />, preserving any property settings, as well as original and current values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.Data.DataTable.NewRow%2A> 행에 대 한 기본값을 사용 하면서 기존 테이블 스키마를 사용 하 여 테이블 행을 추가 하 고 설정 된 <xref:System.Data.DataRowState> 를 `Detached`합니다. 호출 <xref:System.Data.DataTable.ImportRow%2A> 기존 유지 <xref:System.Data.DataRowState> 행에 다른 값과 함께 합니다. 경우는 `DataRow` 분리 된 상태에는 매개 변수는, 무시 되 고 예외가 throw 되지 않습니다 변수로 전달 된입니다.  
  
 새 행의 데이터 테이블 끝에 추가 됩니다.  
  
 새 행에는 제약 조건을 위반 하는 경우에 데이터 테이블에 추가 되지 않습니다.  
  
 DataTable.Rows.Find 및 DataTable.Rows.IndexOf로 새 행의 인덱스를 가져올 수 있습니다. 자세한 내용은 <xref:System.Data.DataRowCollection> 및 <xref:System.Data.DataTable.Rows%2A>를 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after the <see cref="T:System.Data.DataTable" /> is initialized.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 <xref:System.Data.DataTable.IsInitialized%2A>을 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Data.DataTable" /> is initialized.</summary>
        <value>
          <see langword="true" /> 초기화가 완료를 나타내는 구성 요소 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상태를 반환 하는 <xref:System.Data.DataTable> 것은 생성 되 고, 예를 들어 Visual Studio에서 동안 합니다. <xref:System.Data.DataTable.BeginInit%2A> 메서드를 설정 `false` 및 <xref:System.Data.DataTable.EndInit%2A> 메서드를 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />. If the <see langword="DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` 몇 가지 일반적인 시나리오는 지정 된 데이터 원본에서 데이터 가져오기 및 현재 데이터 컨테이너에 추가에서 메서드를 사용할 수 있습니다 (이 경우는 `DataTable`). 에 대 한 일반 사용법을 설명 하는 이러한 시나리오는 `DataTable`해당 업데이트를 설명 하는, 및 동작을 병합 합니다.  
  
 A `DataTable` 동기화 하거나 단일 기본 데이터 원본을 업데이트 합니다. `DataTable` 주 데이터 소스와 동기화 할 수 있도록 변경 내용을 추적 합니다. 또한 한 `DataTable` 하나 이상의 보조 데이터 원본의 증분 데이터를 수락할 수 있습니다. `DataTable` 보조 데이터 소스와 동기화 할 수 있도록 변경 내용을 추적 하지는 않습니다.  
  
 이러한 두 개의 가상의 데이터 소스를 매개 변수로 받아 사용자 해야 하는 다음 동작 중 하나:  
  
-   초기화 `DataTable` 주 데이터 원본에서 합니다. 이 시나리오에서 사용자는 빈 초기화 하려는 `DataTable` 주 데이터 원본의 값으로. 나중에 사용자를 기본 데이터 소스 변경 내용을 전파 하는 것입니다.  
  
-   변경 내용을 유지 하 고 기본 데이터 원본에서 다시 동기화 합니다. 이 시나리오에서는 사용자가 수행 하는 `DataTable` 이전 시나리오에서의 변경 내용을 유지 하는 기본 데이터 원본과 증분 동기화를 수행 채워지고는 `DataTable`합니다.  
  
-   증분 데이터를 보조 데이터 원본에서 제공 합니다. 이 시나리오에서는 사용자가 하나 이상의 보조 데이터 원본에서 변경 내용을 병합 하 여 다시 주 데이터 원본에 해당 변경 내용을 전파 합니다.  
  
 `Load` 메서드 이러한 모든 시나리오 가능 하 게 합니다. 하나를 제외한 모든 오버 로드 중에이 메서드를 사용 하면 부하 옵션 매개 변수를 지정할 수 있습니다를 나타내는 방법을 있는 행 한 <xref:System.Data.DataTable> 로드 중인 행과 결합 합니다. (기본 로드 옵션의 동작을 지정할 수를 허용 하지 않는 오버 로드에 사용 합니다.) 다음 표에에서 제공 하는 세 가지 부하 옵션은 <xref:System.Data.LoadOption> 열거형입니다. 각각의 경우 설명 들어오는 데이터에 있는 행의 기본 키에는 기존 행의 기본 키와 일치 하는 경우 동작을 나타냅니다.  
  
|로드 옵션|설명|  
|-----------------|-----------------|  
|`PreserveChanges`(기본값)|들어오는 행의 값을 가진 행의 원래 버전을 업데이트합니다.|  
|`OverwriteChanges`|들어오는 행의 값을 가진 행의 현재 버전과 원래 버전을 업데이트합니다.|  
|`Upsert`|들어오는 행의 값을 가진 행의 현재 버전을 업데이트합니다.|  
  
 일반적으로 `PreserveChanges` 및 `OverwriteChanges` 옵션은 사용자를 동기화 해야 하는 시나리오에 대 한 않습니다는 `DataSet` 및 기본 데이터 원본과 해당 변경 합니다. `Upsert` 옵션을 하나 이상의 보조 데이터 원본에서 집계 변경 내용을 용이 하 게 합니다.  
  
   
  
## Examples  
 다음 예제에서는 일부의 호출과 관련된 된 문제는 <xref:System.Data.DataTable.Load%2A> 메서드. 이 예제에서 로드 된 스키마를 유추 등의 스키마 문제 중점적으로 먼저 <xref:System.Data.IDataReader>, 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다. 다음 예에서는 데이터 문제를 처리 다양 한 로드 옵션을 포함 하 여 집중 합니다.  
  
> [!NOTE]
>  오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 주는이 예제 `Load`합니다. 사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader -&gt; unit" Usage="dataTable.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">An <see cref="T:System.Data.IDataReader" /> that provides a result set.</param>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />. If the <see cref="T:System.Data.DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> 첫 번째 결과 집합에서 로드를 사용 하는 메서드 <xref:System.Data.IDataReader>, 성공적으로 완료 한 후 설정 판독기의 위치는 다음 결과 집합에 있는 경우. 데이터를 변환할 때의 `Load` 으로 같은 변환 규칙을 사용 하는 메서드는 <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Data.DataTable.Load%2A> 메서드 고려해 야 문제에서 데이터를 로드할 때는 <xref:System.Data.IDataReader> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다. 스키마와 함께 작업 하는 경우는 <xref:System.Data.DataTable.Load%2A> 메서드는 다음 표에 설명 된 대로 같은 조건이 발생할 수 있습니다. 데이터가 포함 된 것까지 모든 가져온된 결과 집합에 대 한 스키마 작업 수행.  
  
|조건|동작|  
|---------------|--------------|  
|<xref:System.Data.DataTable> 에 스키마가 없습니다.|<xref:System.Data.DataTable.Load%2A> 메서드는 가져온에서 결과 집합에 따라 스키마를 유추한 <xref:System.Data.IDataReader>합니다.|  
|<xref:System.Data.DataTable> 는 스키마, 하지만 로드 된 스키마와 호환 되지 않습니다.|<xref:System.Data.DataTable.Load%2A> 메서드 호환 되지 않는 스키마에 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.|  
|스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 되어는 <xref:System.Data.DataTable>합니다.|<xref:System.Data.DataTable.Load%2A> 메서드 추가 열을 추가 하는 `DataTable`의 스키마입니다. 에 해당 하는 경우 예외를 throw의 열은 <xref:System.Data.DataTable> 로드 된 결과 집합 값이 서로 호환 되지 않으며 합니다. 메서드는 또한 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다. Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보를 경우에 사용 현재 <xref:System.Data.DataTable> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.|  
|스키마가 호환 되지만 열 수보다 적은 포함 하는 로드 된 결과 집합 스키마는 `DataTable`합니다.|누락 된 열에 기본값이 정의 된 또는 열의 데이터 형식이 null을 허용 하는 경우는 <xref:System.Data.DataTable.Load%2A> 메서드를 사용 하면 행을 추가할 수 대신 기본값이 또는 `null` 누락 된 열에 대 한 값입니다. 기본값이 사용 되지 않는 경우 또는 `null` 사용할 수 면 `Load` 메서드에서 예외를 throw 합니다. 특정 기본 값을 제공 하는 경우는 `Load` 메서드는 `null` 암시 된 기본값으로 값입니다.|  
  
 동작을 고려 하기 전에 `Load` 메서드 데이터 작업을 고려 하는 각 행 내에서 한 <xref:System.Data.DataTable> 현재 값과 각 열에 대 한 원래 값이 모두 유지 관리 합니다. 이러한 값 같을 수도 있지만, 또는 데이터 행에 채워진 후 변경 된 경우에 다를 수 있습니다는 `DataTable`합니다.  자세한 내용은 참조 [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)합니다.  
  
 이 버전의는 `Load` 메서드는 원래 값을 그대로 두고 각 행의 현재 값을 유지 하려고 합니다. (들어오는 데이터의 동작을 보다 자세히 제어 하려면 참조 <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) 기존 행과 들어오는 행에 해당 기본 키 값이 있으면의 현재 행 상태 값을 사용 하는 행을 처리 하는, 그렇지 않으면 새 행으로 처리 합니다.  
  
 이벤트 작업의 경우는 <xref:System.Data.DataTable.RowChanging> 각 행이 변경 되기 전에 이벤트 발생 및 <xref:System.Data.DataTable.RowChanged> 이벤트는 각 행이 변경 된 후 발생 합니다. 각각의 경우에는 <xref:System.Data.DataRowChangeEventArgs.Action%2A> 속성은 <xref:System.Data.DataRowChangeEventArgs> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 관련 된 특정 작업에 대 한 정보를 포함 합니다. 이 작업 값 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다. 각각의 경우에서 두 이벤트가 발생 하 고 각각에 대해 동일한 동작입니다. 작업은 각 행의 현재 또는 원래의 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.  
  
 다음 표에서 동작을 보여 줍니다는 `Load` 메서드. ("(없음)" 라는) 마지막 행 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작에 설명 합니다. 와 함께 행의 필드에 대 한 현재 및 원래 값을 설명 하는이 테이블의 각 셀의 <xref:System.Data.DataRowState> 후의 값에 대 한는 `Load` 메서드가 완료 합니다. 이 경우 메서드가 로드 옵션을 지정할 수 하 고 기본적으로 사용 `PreserveChanges`합니다.  
  
|기존 DataRowState|완료 후의 값 `Load` 메서드와 이벤트 동작|  
|---------------------------|--------------------------------------------------|  
|추가됨|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = ChangeOriginal|  
|수정한 날짜|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = ChangeOriginal|  
|삭제됨|현재 = \<사용할 수 없음 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<삭제 ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
|(없음)|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 값에 <xref:System.Data.DataColumn> 와 같은 속성을 사용 하 여 제한 될 수 <xref:System.Data.DataColumn.ReadOnly%2A> 및 <xref:System.Data.DataColumn.AutoIncrement%2A>합니다. `Load` 메서드 열의 속성에 의해 정의 된 동작에 일치 하는 방식으로 해당 열을 처리 합니다. 에 읽기 전용 제약은 <xref:System.Data.DataColumn> 메모리에 발생 하는 변경에만 적용 됩니다. `Load` 메서드는 필요에 따라 읽기 전용 열 값을 덮어씁니다.  
  
 현재 행과 들어오는 행을 비교 하는 데 사용할 기본 키 필드의 버전을 확인 하 고 `Load` 있는 경우 메서드는 행의 기본 키 값의 원래 버전을 사용 합니다. 그렇지 않은 경우는 `Load` 메서드는 기본 키 필드의 현재 버전을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 일부의 호출과 관련된 된 문제는 <xref:System.Data.DataTable.Load%2A> 메서드. 이 예제에서 로드 된 스키마를 유추 등의 스키마 문제 중점적으로 먼저 <xref:System.Data.IDataReader>, 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다. 이 예에서는 다음 호출에서 `Load` 메서드를 이전과 이후에 로드 작업의 데이터를 표시 합니다.  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption -&gt; unit" Usage="dataTable.Load (reader, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">An <see cref="T:System.Data.IDataReader" /> that provides one or more result sets.</param>
        <param name="loadOption">A value from the <see cref="T:System.Data.LoadOption" /> enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" /> are combined with incoming rows that share the same primary key.</param>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />. If the <see langword="DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows according to the value of the <paramref name="loadOption" /> parameter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` 첫 번째 결과 집합에서 로드를 사용 하는 메서드 <xref:System.Data.IDataReader>, 성공적으로 완료 한 후 설정 판독기의 위치는 다음 결과 집합에 있는 경우. 데이터를 변환할 때의 `Load` 으로 같은 변환 규칙을 사용 하는 메서드는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드.  
  
 `Load` 메서드 고려해 야 문제에서 데이터를 로드할 때는 <xref:System.Data.IDataReader> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다. 스키마와 함께 작업 하는 경우는 `Load` 메서드는 다음 표에 설명 된 대로 같은 조건이 발생할 수 있습니다. 데이터가 포함 된 것까지 모든 가져온된 결과 집합에 대 한 스키마 작업 수행.  
  
|조건|동작|  
|---------------|--------------|  
|<xref:System.Data.DataTable> 에 스키마가 없습니다.|`Load` 메서드는 가져온에서 결과 집합에 따라 스키마를 유추한 <xref:System.Data.IDataReader>합니다.|  
|<xref:System.Data.DataTable> 는 스키마, 하지만 로드 된 스키마와 호환 되지 않습니다.|`Load` 메서드 호환 되지 않는 스키마에 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.|  
|스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 되어는 `DataTable`합니다.|`Load` 메서드 추가 열을 추가 하는 `DataTable`의 스키마입니다. 에 해당 하는 경우 예외를 throw의 열은 <xref:System.Data.DataTable> 로드 된 결과 집합 값이 서로 호환 되지 않으며 합니다. 메서드는 또한 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다. Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보를 경우에 사용 현재 <xref:System.Data.DataTable> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.|  
|스키마가 호환 되지만 열 수보다 적은 포함 하는 로드 된 결과 집합 스키마는 `DataTable`합니다.|누락 된 열에 기본값이 정의 된 또는 열의 데이터 형식이 null을 허용 하는 경우는 `Load` 메서드를 사용 하면 행을 추가할 수는 누락 된 열에 대 한 default 또는 null 값을 대체 합니다. 기본값이 없거나 null를 사용할 수 경우 하면 `Load` 메서드에서 예외를 throw 합니다. 특정 기본 값을 제공 하는 경우는 `Load` 메서드는 암시적된 기본 값으로 null 값을 사용 합니다.|  
  
 동작을 고려 하기 전에 `Load` 메서드 데이터 작업을 고려 하는 각 행 내에서 한 <xref:System.Data.DataTable> 현재 값과 각 열에 대 한 원래 값이 모두 유지 관리 합니다. 이러한 값 같을 수도 있지만, 또는 데이터 행에 채워진 후 변경 된 경우에 다를 수 있습니다는 `DataTable`합니다. 참조 [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) 자세한 정보에 대 한 합니다.  
  
 지정된 된이 메서드 호출에서 <xref:System.Data.LoadOption> 매개 변수는 들어오는 데이터의 처리에 영향을 줍니다. Load 메서드 로드가 있는 행을 기존 행과 동일한 기본 키를 어떻게 처리 해야 합니까? 현재 값, 원래 값 또는 둘 다 수정 해야? 이러한 문제 등으로 제어 되는 `loadOption` 매개 변수입니다.  
  
 기존 행과 들어오는 행에 해당 기본 키 값이 있으면의 현재 행 상태 값을 사용 하는 행을 처리 하는, 그렇지 않으면 새 행으로 처리 합니다.  
  
 이벤트 작업의 경우는 <xref:System.Data.DataTable.RowChanging> 각 행이 변경 되기 전에 이벤트 발생 및 <xref:System.Data.DataTable.RowChanged> 이벤트는 각 행이 변경 된 후 발생 합니다. 각각의 경우에는 <xref:System.Data.DataRowChangeEventArgs.Action%2A> 속성은 <xref:System.Data.DataRowChangeEventArgs> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 관련 된 특정 작업에 대 한 정보를 포함 합니다. 이 작업 값 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다. 각각의 경우에서 두 이벤트가 발생 하 고 각각에 대해 동일한 동작입니다. 작업은 각 행의 현재 또는 원래의 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.  
  
 다음 표에 각각의 경우에 Load 메서드에서 대 한 동작은 `LoadOption` 값, 및 값 로드 중인 행에 대 한 행 상태와 상호 작용 하는 방법을 보여 줍니다. ("(없음)" 라는) 마지막 행 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작에 설명 합니다. 와 함께 행의 필드에 대 한 현재 및 원래 값을 설명 하는이 테이블의 각 셀의 <xref:System.Data.DataRowState> 후의 값에 대 한는 `Load` 메서드가 완료 합니다.  
  
|기존 DataRowState|Upsert|OverwriteChanges|PreserveChanges (기본 동작)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|추가됨|현재 = \<들어오는 ><br /><br /> 원래 =-\<사용할 수 없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = ChangeOriginal|  
|수정한 날짜|현재 = \<들어오는 ><br /><br /> 원래 = \<기존 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction =ChangeOriginal|  
파일과|(부하는 행을 삭제 하는 영향을 하지 않는)<br /><br /> 현재 =--<br /><br /> 원래 = \<기존 ><br /><br /> 상태 = \<삭제 ><br /><br /> (다음 특징을 가진 새 행이 추가 됨)<br /><br /> 현재 = \<들어오는 ><br /><br /> 원래 = \<사용할 수 없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 추가|삭제를 취소 하 고<br /><br /> 현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<사용할 수 없음 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<삭제 ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|현재 = \<들어오는 ><br /><br /> 원래 = \<기존 ><br /><br /> 새 값 동일한 경우 기존 값과 다음<br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> 상태 = \<수정 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
없음)|현재 = \<들어오는 ><br /><br /> 원래 = \<사용할 수 없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 추가|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 값에 <xref:System.Data.DataColumn> 와 같은 속성을 사용 하 여 제한 될 수 <xref:System.Data.DataColumn.ReadOnly%2A> 및 <xref:System.Data.DataColumn.AutoIncrement%2A>합니다. `Load` 메서드 열의 속성에 의해 정의 된 동작에 일치 하는 방식으로 해당 열을 처리 합니다. 에 읽기 전용 제약은 <xref:System.Data.DataColumn> 메모리에 발생 하는 변경에만 적용 됩니다. `Load` 메서드는 필요에 따라 읽기 전용 열 값을 덮어씁니다.  
  
 호출할 때 OverwriteChanges 또는 PreserveChanges 옵션을 지정 하는 경우는 `Load` 메서드, 다음 가정을 들어오는 데이터에서 제공 되 수행 되는 `DataTable`의 주 데이터 원본 및 데이터 테이블의 변경 내용을 추적 하 고 전파할 수 데이터 소스에 다시 변경 합니다. Upsert 옵션을 선택 하면 데이터는 사용자에 의해 변경 된 중간 계층 구성 요소에서 제공 하는 데이터와 같은 보조 데이터 원본 중 하나에서 제공 됩니다 간주 됩니다. 이 경우 가정은 하나 이상의 데이터 원본에서 데이터를 집계 의도는 `DataTable`, 다음 데이터는 주 데이터 원본에 다시 전파 하 고 있습니다. <xref:System.Data.LoadOption> 기본 키 비교에 사용 되는 행의 특정 버전을 확인 하기 위한 매개 변수를 사용 합니다. 다음 표에서 세부 정보를 제공 합니다.  
  
|로드 옵션|기본 키 비교에 사용 되는 DataRow 버전|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|있는 경우의 원래 버전, 그렇지 않으면 현재 버전|  
|`PreserveChanges`|있는 경우의 원래 버전, 그렇지 않으면 현재 버전|  
|`Upsert`|현재 버전에 있는 경우, 그렇지 않으면 원본 버전|  
  
   
  
## Examples  
 다음 예제에서는 일부의 호출과 관련된 된 문제는 <xref:System.Data.DataTable.Load%2A> 메서드. 이 예제에서 로드 된 스키마를 유추 등의 스키마 문제 중점적으로 먼저 <xref:System.Data.IDataReader>, 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다. 다음 예에서는 데이터 문제를 처리 다양 한 로드 옵션을 포함 하 여 집중 합니다.  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit" Usage="dataTable.Load (reader, loadOption, errorHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Data.IDataReader" /> that provides a result set.</param>
        <param name="loadOption">A value from the <see cref="T:System.Data.LoadOption" /> enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" /> are combined with incoming rows that share the same primary key.</param>
        <param name="errorHandler">A <see cref="T:System.Data.FillErrorEventHandler" /> delegate to call when an error occurs while loading data.</param>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" /> using an error-handling delegate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` 첫 번째 결과 집합에서 로드를 사용 하는 메서드 <xref:System.Data.IDataReader>, 성공적으로 완료 한 후 설정 판독기의 위치는 다음 결과 집합에 있는 경우. 데이터를 변환할 때의 `Load` 으로 같은 변환 규칙을 사용 하는 메서드는 <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> 메서드.  
  
 `Load` 메서드 고려해 야 문제에서 데이터를 로드할 때는 <xref:System.Data.IDataReader> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다. 스키마와 함께 작업 하는 경우는 `Load` 메서드는 다음 표에 설명 된 대로 같은 조건이 발생할 수 있습니다. 데이터가 포함 된 것까지 모든 가져온된 결과 집합에 대 한 스키마 작업 수행.  
  
|조건|동작|  
|---------------|--------------|  
|<xref:System.Data.DataTable> 에 스키마가 없습니다.|`Load` 메서드는 가져온에서 결과 집합에 따라 스키마를 유추한 <xref:System.Data.IDataReader>합니다.|  
|<xref:System.Data.DataTable> 는 스키마, 하지만 로드 된 스키마와 호환 되지 않습니다.|`Load` 메서드 호환 되지 않는 스키마에 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.|  
|스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 되어는 `DataTable`합니다.|`Load` 여분의 열을 추가 하는 메서드 `DataTable`의 스키마입니다. 에 해당 하는 경우 예외를 throw의 열은 <xref:System.Data.DataTable> 로드 된 결과 집합 값이 서로 호환 되지 않으며 합니다. 메서드는 또한 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다. Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보를 경우에 사용 현재 <xref:System.Data.DataTable> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.|  
|스키마가 호환 되지만 열 수보다 적은 포함 하는 로드 된 결과 집합 스키마는 `DataTable`합니다.|누락 된 열에 기본값이 정의 된 또는 열의 데이터 형식이 null을 허용 하는 경우는 `Load` 메서드를 사용 하면 행을 추가할 수는 누락 된 열에 대 한 default 또는 null 값을 대체 합니다. 기본값이 없거나 null를 사용할 수 경우 하면 `Load` 메서드에서 예외를 throw 합니다. 특정 기본 값을 제공 하는 경우는 `Load` 메서드는 암시적된 기본 값으로 null 값을 사용 합니다.|  
  
 동작을 고려 하기 전에 `Load` 메서드 데이터 작업을 고려 하는 각 행 내에서 한 <xref:System.Data.DataTable> 현재 값과 각 열에 대 한 원래 값이 모두 유지 관리 합니다. 이러한 값 같을 수도 있지만, 또는 데이터 행에 채워진 후 변경 된 경우에 다를 수 있습니다는 `DataTable`합니다. 참조 [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) 자세한 정보에 대 한 합니다.  
  
 지정된 된이 메서드 호출에서 <xref:System.Data.LoadOption> 매개 변수는 들어오는 데이터의 처리에 영향을 줍니다. Load 메서드 로드가 있는 행을 기존 행과 동일한 기본 키를 어떻게 처리 해야 합니까? 현재 값, 원래 값 또는 둘 다 수정 해야? 이러한 문제 등으로 제어 되는 `loadOption` 매개 변수입니다.  
  
 기존 행과 들어오는 행에 해당 기본 키 값이 있으면의 현재 행 상태 값을 사용 하는 행을 처리 하는, 그렇지 않으면 새 행으로 처리 합니다.  
  
 이벤트 작업의 경우는 <xref:System.Data.DataTable.RowChanging> 각 행이 변경 되기 전에 이벤트 발생 및 <xref:System.Data.DataTable.RowChanged> 이벤트는 각 행이 변경 된 후 발생 합니다. 각각의 경우에는 <xref:System.Data.DataRowChangeEventArgs.Action%2A> 속성은 <xref:System.Data.DataRowChangeEventArgs> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 관련 된 특정 작업에 대 한 정보를 포함 합니다. 이 작업 값 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다. 각각의 경우에서 두 이벤트가 발생 하 고 각각에 대해 동일한 동작입니다. 작업은 각 행의 현재 또는 원래의 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.  
  
 다음 표에 각각의 경우에 Load 메서드에서 대 한 동작은 `LoadOption` 값, 및 값 로드 중인 행에 대 한 행 상태와 상호 작용 하는 방법을 보여 줍니다. ("(없음)" 라는) 마지막 행 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작에 설명 합니다. 와 함께 행의 필드에 대 한 현재 및 원래 값을 설명 하는이 테이블의 각 셀의 <xref:System.Data.DataRowState> 후의 값에 대 한는 `Load` 메서드가 완료 합니다.  
  
|기존 DataRowState|Upsert|OverwriteChanges|PreserveChanges (기본 동작)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|추가됨|현재 = \<들어오는 ><br /><br /> 원래 =-\<사용할 수 없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = ChangeOriginal|  
|수정한 날짜|현재 = \<들어오는 ><br /><br /> 원래 = \<기존 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction =ChangeOriginal|  
파일과|(부하는 행을 삭제 하는 영향을 하지 않는)<br /><br /> 현재 =--<br /><br /> 원래 = \<기존 ><br /><br /> 상태 = \<삭제 ><br /><br /> (다음 특징을 가진 새 행이 추가 됨)<br /><br /> 현재 = \<들어오는 ><br /><br /> 원래 = \<사용할 수 없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 추가|삭제를 취소 하 고<br /><br /> 현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<사용할 수 없음 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<삭제 ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|현재 = \<들어오는 ><br /><br /> 원래 = \<기존 ><br /><br /> 새 값 동일한 경우 기존 값과 다음<br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> 상태 = \<수정 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
없음)|현재 = \<들어오는 ><br /><br /> 원래 = \<사용할 수 없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 추가|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 값에 <xref:System.Data.DataColumn> 와 같은 속성을 사용 하 여 제한 될 수 <xref:System.Data.DataColumn.ReadOnly%2A> 및 <xref:System.Data.DataColumn.AutoIncrement%2A>합니다. `Load` 메서드 열의 속성에 의해 정의 된 동작에 일치 하는 방식으로 해당 열을 처리 합니다. 에 읽기 전용 제약은 <xref:System.Data.DataColumn> 메모리에 발생 하는 변경에만 적용 됩니다. `Load` 메서드는 필요에 따라 읽기 전용 열 값을 덮어씁니다.  
  
 호출할 때 OverwriteChanges 또는 PreserveChanges 옵션을 지정 하는 경우는 `Load` 메서드, 다음 가정을 들어오는 데이터에서 제공 되 수행 되는 `DataTable`의 주 데이터 원본 및 데이터 테이블의 변경 내용을 추적 하 고 전파할 수 데이터 소스에 다시 변경 합니다. Upsert 옵션을 선택 하면 데이터는 사용자에 의해 변경 된 중간 계층 구성 요소에서 제공 하는 데이터와 같은 보조 데이터 원본 중 하나에서 제공 됩니다 간주 됩니다. 이 경우 가정은 하나 이상의 데이터 원본에서 데이터를 집계 의도는 `DataTable`, 다음 데이터는 주 데이터 원본에 다시 전파 하 고 있습니다. <xref:System.Data.LoadOption> 기본 키 비교에 사용 되는 행의 특정 버전을 확인 하기 위한 매개 변수를 사용 합니다. 다음 표에서 세부 정보를 제공 합니다.  
  
|로드 옵션|기본 키 비교에 사용 되는 DataRow 버전|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|있는 경우의 원래 버전, 그렇지 않으면 현재 버전|  
|`PreserveChanges`|있는 경우의 원래 버전, 그렇지 않으면 현재 버전|  
|`Upsert`|현재 버전에 있는 경우, 그렇지 않으면 원본 버전|  
  
 `errorHandler` 매개 변수는 한 <xref:System.Data.FillErrorEventHandler> 데이터를 로드 하는 동안 오류가 발생할 때 호출 되는 프로시저를 참조 하는 대리자입니다. <xref:System.Data.FillErrorEventArgs> 발생 한 오류, 데이터의 현재 행에 대 한 정보를 검색할 수 있도록 하는 속성을 제공 하는 프로시저에 전달 된 매개 변수 및 <xref:System.Data.DataTable> 채워지고 합니다. 이 대리자 메커니즘을 사용 하 여, 대신 간단한 try/catch 블록을 오류를 확인할 수 있습니다 상황을 처리을 원하는 경우 처리를 계속 합니다. <xref:System.Data.FillErrorEventArgs> 매개 변수를 제공는 <xref:System.Data.FillErrorEventArgs.Continue%2A> 속성:이 속성을 설정 `true` 를 나타내는 오류를 처리 하 고 처리를 계속 합니다. 속성을 설정 `false` 처리를 중단 하려면 나타냅니다. 주의 해당 속성을 설정 `false` 하면 예외를 throw 하는 문제를 발생 시킨 코드가 있습니다.  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Finds and updates a specific row. If no matching row is found, a new row is created using the given values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * bool -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, fAcceptChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">An array of values used to create the new row.</param>
        <param name="fAcceptChanges">
          <see langword="true" /> to accept changes; otherwise <see langword="false" />.</param>
        <summary>Finds and updates a specific row. If no matching row is found, a new row is created using the given values.</summary>
        <returns>The new <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A> 메서드 값의 배열을 사용 하 고 기본 키 열에 일치 하는 값을 찾습니다.  
  
 열에 기본 값, 해당 열에 대 한 기본값을 설정 하는 배열에 null 값을 전달 합니다. 마찬가지로, 열에 있으면 해당 <xref:System.Data.DataColumn.AutoIncrement%2A> 속성이 행에 대해 자동으로 생성 된 값을 설정 하는 배열에 null 값을 전달 합니다. true로 설정 합니다.  
  
 경우는 `fAcceptChanges` 매개 변수는 `true` 하거나 지정 하지 않으면 새 데이터가 추가 되 차례로 <xref:System.Data.DataTable.AcceptChanges%2A> 에서 모든 변경 내용을 적용 하기 위해 호출 됩니다는 <xref:System.Data.DataTable>인수가; `false`, 새로 추가 된 삽입, 코드 변경 내용으로 표시 된 행 기존 행 수정으로 표시 됩니다.  
  
 예외도 수행 하는 동안 발생할 수 있습니다는 <xref:System.Data.DataTable.ColumnChanging> 또는 <xref:System.Data.DataTable.RowChanging> 이벤트입니다. 예외가 발생 하는 경우 테이블에 행 추가 되지 않습니다.  
  
 사용 하 여 <xref:System.Data.DataTable.LoadDataRow%2A> 함께에서 <xref:System.Data.DataTable.BeginLoadData%2A> 및 <xref:System.Data.DataTable.EndLoadData%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable.LoadDataRow%2A> 메서드를 행을 찾습니다. 이러한 행이 없으면 새 행을 만들고 값이 사용 됩니다.  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The array is larger than the number of columns in the table.</exception>
        <exception cref="T:System.InvalidCastException">A value doesn't match its respective column type.</exception>
        <exception cref="T:System.Data.ConstraintException">Adding the row invalidates a constraint.</exception>
        <exception cref="T:System.Data.NoNullAllowedException">Attempting to put a null in a column where <see cref="P:System.Data.DataColumn.AllowDBNull" /> is false.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * System.Data.LoadOption -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">An array of values used to create the new row.</param>
        <param name="loadOption">Used to determine how the array values are applied to the corresponding values in an existing row.</param>
        <summary>Finds and updates a specific row. If no matching row is found, a new row is created using the given values.</summary>
        <returns>The new <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A> 메서드 값의 배열을 사용 하 고 기본 키 열에 일치 하는 값을 찾습니다.  
  
 열에 기본 값, 해당 열에 대 한 기본값을 설정 하는 배열에 null 값을 전달 합니다. 마찬가지로, 열에 있으면 해당 <xref:System.Data.DataColumn.AutoIncrement%2A> 속성이 행에 대해 자동으로 생성 된 값을 설정 하는 배열에 null 값을 전달 합니다. true로 설정 합니다.  
  
 값은 `loadOption` 매개 변수를 사용 하는 배열의 값이 기존 행에 적용 되는 방식을 결정 합니다. 예를 들어 경우 `loadOption` 로 설정 된 `OverwriteChanges`, `Original` 및 `Current` 각 열의 값이 들어오는 행의 값으로 바뀌는 및 `RowState` 속성이로 설정 된 `Unchanged`합니다.  
  
 예외도 수행 하는 동안 발생할 수 있습니다는 <xref:System.Data.DataTable.ColumnChanging> 또는 <xref:System.Data.DataTable.RowChanging> 이벤트입니다. 예외가 발생 하는 경우 테이블에 행 추가 되지 않습니다.  
  
 사용 하 여 <xref:System.Data.DataTable.LoadDataRow%2A> 함께에서 <xref:System.Data.DataTable.BeginLoadData%2A> 및 <xref:System.Data.DataTable.EndLoadData%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the locale information used to compare strings within the table.</summary>
        <value>A <see cref="T:System.Globalization.CultureInfo" /> 사용자의 컴퓨터 로캘에 대 한 데이터가 들어 있는입니다. 기본값은는 <see cref="T:System.Data.DataSet" /> 개체의 <see cref="T:System.Globalization.CultureInfo" /> (에서 반환 되는 <see cref="P:System.Data.DataSet.Locale" /> 속성)을는 <see cref="T:System.Data.DataTable" /> 속한; 테이블에 속하지는 <see cref="T:System.Data.DataSet" />, 기본값은 현재 시스템 <see cref="T:System.Globalization.CultureInfo" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Globalization.CultureInfo> 특정 문화권 또는 커뮤니티의 소프트웨어 기본 설정을 나타냅니다.  
  
 문자열 비교에 사용 되는 경우는 <xref:System.Globalization.CultureInfo> 비교, 정렬 및 필터링에 영향을 줍니다.  
  
> [!NOTE]
>  식이 포함 된 열에는 <xref:System.StringComparison.InvariantCulture> 사용 됩니다. <xref:System.StringComparison.CurrentCulture> 는 무시 됩니다.  
  
   
  
## Examples  
 다음 예에서는 <xref:System.Globalization.CultureInfo> 통해는 <xref:System.Data.DataTable.Locale%2A> ISO 언어 이름을 출력 합니다.  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge` 병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataTable> 비슷하긴 하지만 스키마가 포함 된 개체입니다. 기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <xref:System.Data.DataTable>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 합니다.  
  
 병합 작업은 원래 테이블만 병합 될 테이블을 고려 합니다. 자식 테이블은 영향을 하지 않거나 포함 하십시오. 테이블 관계의 일부분으로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블은 개별적으로 병합 해야 합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램의 동작을 보여 줍니다.는 `missingSchemaAction` 의 매개 변수는 <xref:System.Data.DataTable.Merge%2A> 메서드. 이 예에서는 두 가지 버전의 두 번째 버전에 대 한 스키마를 수정 하는 동일한 테이블을 만듭니다. 코드는 다음 두 번째 테이블에 첫 번째 병합 하려고 합니다.  
  
> [!NOTE]
>  이 예에서는 병합의 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다. 사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataTable.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">The <see cref="T:System.Data.DataTable" /> to be merged with the current <see cref="T:System.Data.DataTable" />.</param>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge 메서드 두 개를 병합 하는 데는 <xref:System.Data.DataTable> 비슷하긴 하지만 스키마가 포함 된 개체입니다. 기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <xref:System.Data.DataTable>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 합니다.  
  
 병합 작업은 원래 테이블만 병합 될 테이블을 고려 합니다. 자식 테이블은 영향을 하지 않거나 포함 하십시오. 테이블 관계의 일부분으로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블은 개별적으로 병합 해야 합니다.  
  
 `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <xref:System.Data.DataTable>합니다.  
  
 병합을 수행할 때 기존 데이터를 병합 하기 전에 변경 내용이 병합 작업 동안 기본적으로 유지 됩니다. 개발자는이 메서드에 대 한 호출 하는 다른 두 오버 로드 중 하나에 대 한 값이 false를 지정 하 여이 동작을 수정할 수는 `preserveChanges` 매개 변수입니다.  
  
 클라이언트 응용 프로그램에는 단일 단추가 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 별로있지 않습니다. 이 시나리오는 <xref:System.Data.DataTable.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataTable> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataTable> 개체에만 포함 되어는 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataTable>합니다. 이 하위 집합은 일반적으로 더 작은 때문에 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataTable> 와 <xref:System.Data.DataTable.Merge%2A> 메서드.  
  
 새 소스를 병합할 때 <xref:System.Data.DataTable> 대상에 모든 소스 행 한 <xref:System.Data.DataRowState> 값 `Unchanged`, `Modified`, 또는 `Deleted`, 동일한 기본 키 값을 가진 대상 행에 일치 합니다. 소스 행 한 <xref:System.Data.DataRowState> 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램을 만듭니다는 간단한 <xref:System.Data.DataTable> 데이터 테이블에 추가 합니다. 다음 예에서는 행 복사본에 추가 테이블의 복사본을 만듭니다. 마지막으로,이 예에서는 호출에서 <xref:System.Data.DataTable.Merge%2A> 메서드를 첫 번째 테이블의 데이터를 사용 하 여 두 번째 테이블의 데이터를 병합 합니다.  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool -&gt; unit" Usage="dataTable.Merge (table, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">The <see langword="DataTable" /> to be merged with the current <see langword="DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, to preserve changes in the current <see langword="DataTable" />; otherwise <see langword="false" />.<see langword="" /></param>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see langword="DataTable" />, indicating whether to preserve changes in the current <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge 메서드 두 개를 병합 하는 데는 <xref:System.Data.DataTable> 비슷하긴 하지만 스키마가 포함 된 개체입니다. 기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <xref:System.Data.DataTable>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 합니다.  
  
 병합 작업은 원래 테이블만 병합 될 테이블을 고려 합니다. 자식 테이블은 영향을 하지 않거나 포함 하십시오. 테이블 관계의 일부분으로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블은 개별적으로 병합 해야 합니다.  
  
 `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <xref:System.Data.DataTable>합니다.  
  
 개발자에 대해서는 false를 지정 하지 않은 경우 기존 데이터를 병합 하기 전에 변경 내용이 병합 작업 동안 유지 됩니다 병합을 수행할 때의 `preserveChanges` 매개 변수입니다. 경우는 `preserveChanges` 로 설정 된 `true`, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어쓰지 않습니다. 경우는 `preserveChanges` 로 설정 된 `false`, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어씁니다. 행 버전에 대 한 자세한 내용은 참조 [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)합니다.  
  
 클라이언트 응용 프로그램에는 단일 단추가 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 별로있지 않습니다. 이 시나리오는 <xref:System.Data.DataTable.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataTable> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataTable> 개체에만 포함 되어는 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataTable>합니다. 이 하위 집합 일반적으로 더 작은 이며 따라서이 하위 집합은 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataTable> 와 <xref:System.Data.DataTable.Merge%2A> 메서드.  
  
 새 소스를 병합할 때 <xref:System.Data.DataTable> 대상에 모든 소스 행 한 <xref:System.Data.DataRowState> 값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다. 소스 행 한 <xref:System.Data.DataRowState> 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램을 만듭니다는 <xref:System.Data.DataTable> 해당 행의 데이터 중 일부를 수정 하 고 다른 데이터를 병합 하려고 행을 포함 하 <xref:System.Data.DataTable>합니다. 예제에 대 한 다양 한 동작에는 `preserveChanges` 매개 변수입니다.  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataTable.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">The <see cref="T:System.Data.DataTable" /> to be merged with the current <see cref="T:System.Data.DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, to preserve changes in the current <see cref="T:System.Data.DataTable" />; otherwise <see langword="false" />.</param>
        <param name="missingSchemaAction">One of the <see cref="T:System.Data.MissingSchemaAction" /> values.</param>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see langword="DataTable" />, indicating whether to preserve changes and how to handle missing schema in the current <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge` 병합할 두 개의 메서드를 사용 하는 <xref:System.Data.DataTable> 비슷하긴 하지만 스키마가 포함 된 개체입니다. 기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <xref:System.Data.DataTable>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 합니다.  
  
 병합 작업은 원래 테이블만 병합 될 테이블을 고려 합니다. 자식 테이블은 영향을 하지 않거나 포함 하십시오. 테이블 관계의 일부분으로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블은 개별적으로 병합 해야 합니다.  
  
 `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <xref:System.Data.DataTable>합니다.  
  
 개발자에 대해서는 false를 지정 하지 않은 경우 기존 데이터를 병합 하기 전에 변경 내용이 병합 작업 동안 유지 됩니다 병합을 수행할 때의 `preserveChanges` 매개 변수입니다. 경우는 `preserveChanges` 로 설정 된 `true`, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어쓰지 않습니다. 경우는 `preserveChanges` 로 설정 된 `false`, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어씁니다. 행 버전에 대 한 자세한 내용은 참조 [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)합니다.  
  
 클라이언트 응용 프로그램에는 단일 단추가 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 별로있지 않습니다. 이 시나리오는 <xref:System.Data.DataTable.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataTable> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataTable> 개체에만 포함 되어는 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataTable>합니다. 이 하위 집합 일반적으로 더 작은 이며 따라서이 하위 집합은 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다. 중간 계층은 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <xref:System.Data.DataTable> 와 <xref:System.Data.DataTable.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataTable.Merge%2A> 메서드가 호출 되 면 두 스키마 <xref:System.Data.DataTable> 개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다. 경우 소스 <xref:System.Data.DataTable> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 `missingSchemaAction` 인수 `MissingSchemaAction.Add`합니다. 병합 된 경우에서 <xref:System.Data.DataTable> 추가 된 스키마와 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataTable> 대상에 모든 소스 행 한 <xref:System.Data.DataRowState> 값 `Unchanged`, `Modified`, 또는 `Deleted` 동일한 기본 키 값을 가진 대상 행에 대응 됩니다. 소스 행 한 <xref:System.Data.DataRowState> 값 `Added` 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램의 동작을 보여 줍니다.는 `missingSchemaAction` 의 매개 변수는 <xref:System.Data.DataTable.Merge%2A> 메서드. 이 예에서는 두 가지 버전의 두 번째 버전에 대 한 스키마를 수정 하는 동일한 테이블을 만듭니다. 코드는 다음 두 번째 테이블에 첫 번째 병합 하려고 합니다.  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumCapacity : int with get, set" Usage="System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the initial starting size for this table.</summary>
        <value>이 테이블의 행에 대 한 초기 시작 크기입니다. 기본값은 50입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.MinimumCapacity%2A> 시스템이 데이터를 인출 하기 전에 리소스의 적절 한 세트를 만들 수 있습니다. 상황에서이 속성을 설정할 경우 성능 상태가 심각 하면 성능을 최적화할 수 있습니다.  
  
   
  
## Examples  
 다음 예에서는 <xref:System.Data.DataTable.MinimumCapacity%2A> 의 <xref:System.Data.DataTable>합니다.  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the namespace for the XML representation of the data stored in the <see cref="T:System.Data.DataTable" />.</summary>
        <value>
          <see cref="T:System.Data.DataTable" />의 네임스페이스입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberSignature Language="F#" Value="member this.NewRow : unit -&gt; System.Data.DataRow" Usage="dataTable.NewRow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Data.DataRow" /> with the same schema as the table.</summary>
        <returns>A <see cref="T:System.Data.DataRow" /> with the same schema as the <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 해야 합니다는 <xref:System.Data.DataTable.NewRow%2A> 메서드 새로 만드는 <xref:System.Data.DataRow> 동일한 스키마를 사용 하 여 개체는 <xref:System.Data.DataTable>합니다. 만든 후는 <xref:System.Data.DataRow>를에 추가할 수 있습니다는 <xref:System.Data.DataRowCollection>통해는 <xref:System.Data.DataTable> 개체의 <xref:System.Data.DataTable.Rows%2A> 속성입니다. 사용 하는 경우 <xref:System.Data.DataTable.NewRow%2A> 에 새 행을 만드는 행에 추가 하거나 삭제 해야 데이터 테이블에서 호출 하기 전에 <xref:System.Data.DataTable.Clear%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Data.DataTable>, 두 개 추가 <xref:System.Data.DataColumn> 에서는 몇 가지 새 및 테이블의 스키마를 지정 하는 개체 <xref:System.Data.DataRow> 를 사용 하 여 개체는 <xref:System.Data.DataTable.NewRow%2A> 메서드. 이러한 <xref:System.Data.DataRow> 개체에 추가 됩니다는 <xref:System.Data.DataRowCollection> 를 사용 하 여는 <xref:System.Data.DataRowCollection.Add%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberSignature Language="F#" Value="member this.NewRowArray : int -&gt; System.Data.DataRow[]" Usage="dataTable.NewRowArray size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">A <see cref="T:System.Int32" /> value that describes the size of the array.</param>
        <summary>Returns an array of <see cref="T:System.Data.DataRow" />.</summary>
        <returns>The new array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow&#xA;override this.NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow" Usage="dataTable.NewRowFromBuilder builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">A <see cref="T:System.Data.DataRowBuilder" /> object.</param>
        <summary>Creates a new row from an existing row.</summary>
        <returns>A <see cref="T:System.Data.DataRow" /> derived class.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataColumnChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.ColumnChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataColumnChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.ColumnChanging" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataTable.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">A <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveColumn : System.Data.DataColumn -&gt; unit&#xA;override this.OnRemoveColumn : System.Data.DataColumn -&gt; unit" Usage="dataTable.OnRemoveColumn column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">The <see cref="T:System.Data.DataColumn" /> being removed.</param>
        <summary>Notifies the <see cref="T:System.Data.DataTable" /> that a <see cref="T:System.Data.DataColumn" /> is being removed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowChanging" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowDeleted" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowDeleting" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableCleared e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableClearEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.TableCleared" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 발생는 <xref:System.Data.DataTable.TableCleared> 모든 행이 성공적으로 지워진 하기 전에 직후 발생 하는 이벤트는 <xref:System.Data.DataTable.Clear%2A> 메서드 호출자에 게 제어를 반환 합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableClearing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableClearEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.TableClearing" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 발생 된 <xref:System.Data.DataTable.TableClearing> 처리 되기 전에 발생 하는 이벤트는 <xref:System.Data.DataTable.Clear%2A> 작업이 시작 합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit&#xA;override this.OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit" Usage="dataTable.OnTableNewRow e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableNewRowEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.TableNewRow" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 발생는 <xref:System.Data.DataTable.TableNewRow> 새 후 발생 하는 이벤트 <xref:System.Data.DataRow> 사용 하 여 만든 <xref:System.Data.DataTable.NewRow%2A>합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of parent relations for this <see cref="T:System.Data.DataTable" />.</summary>
        <value>A <see cref="T:System.Data.DataRelationCollection" /> 테이블에 대 한 부모 관계를 포함 하 합니다. 없는 경우에 빈 컬렉션이 반환 됩니다 <see cref="T:System.Data.DataRelation" /> 개체가 존재 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable.ParentRelations%2A> 각 부모를 반환 하는 속성 <xref:System.Data.DataRelation> 에 <xref:System.Data.DataTable>합니다. 각 관계에 대 한 인수로 사용 됩니다는 <xref:System.Data.DataRow.GetParentRows%2A> 의 메서드는 <xref:System.Data.DataRow> 행의 배열을 반환 하도록 합니다. 행에 있는 각 열의 값이 출력 합니다.  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the namespace for the XML representation of the data stored in the <see cref="T:System.Data.DataTable" />.</summary>
        <value>접두사는 <see cref="T:System.Data.DataTable" />합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : System.Data.DataColumn[] with get, set" Usage="System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an array of columns that function as primary keys for the data table.</summary>
        <value>
          <see cref="T:System.Data.DataColumn" /> 개체의 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 테이블의 기본 키 테이블의 레코드를 식별 하 고유 해야 합니다. 두 개 이상의 열으로 구성 하는 기본 키가 있는 테이블을 가질 수 이기도 합니다. 단일 열 충분 한 고유 값을 포함할 수 없는 경우 발생 합니다. 예를 들어 두 개의 열 기본 키 "FirstName" 및 "LastName" 열의 구성 될 수 있습니다. 기본 키 하나 이상의 열은 구성할 수 있으므로 <xref:System.Data.DataTable.PrimaryKey%2A> 속성의 배열로 구성 됩니다 <xref:System.Data.DataColumn> 개체입니다.  
  
   
  
## Examples  
 첫 번째 예에 대 한 기본 키 열을 반환 하는 방법을 보여 줍니다는 <xref:System.Data.DataTable> 에 표시 되는 `DataGrid`합니다. 두 번째 예제에 대 한 기본 키 열을 설정 하는 방법을 보여 줍니다는 <xref:System.Data.DataTable>합니다.  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">The key is a foreign key.</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataTable> XML 문서 로부터 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 데이터 및 스미카를 읽으려면 중 하나를 사용는 `ReadXML` 포함 하는 오버 로드는 `XmlReadMode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">An object that derives from <see cref="T:System.IO.Stream" /></param>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.Stream" />.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Data.DataTable> 및 제공 된 데이터와 함께 로드 되는 해당 하위 항목이 <xref:System.IO.Stream>합니다. 이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> 메서드와 비슷하지만 경우에 데이터는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.  
  
 <xref:System.Data.DataTable.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataTable> XML 문서 로부터 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Data.DataTable> 두 개의 열과 열 개의 행을 포함 합니다. 이 예제에서는 기록는 <xref:System.Data.DataTable> 스키마와 데이터를 호출 하 여 메모리 스트림에 <xref:System.Data.DataTable.WriteXml%2A> 메서드. 이 예에서는 두 번째 만듭니다 <xref:System.Data.DataTable> 호출는 <xref:System.Data.DataTable.ReadXml%2A> 메서드를 스키마와 데이터를 채우는 것입니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.IO.TextReader" /> that will be used to read the data.</param>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextReader" />.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Data.DataTable> 및 제공 된 데이터와 함께 로드 되는 해당 하위 항목이 <xref:System.IO.TextReader>합니다. 이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> 메서드와 비슷하지만 경우에 데이터는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.  
  
 <xref:System.Data.DataTable.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataTable> XML 문서 로부터 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Data.DataTable> 두 개의 열과 열 개의 행을 포함 합니다. 이 예제에서는 기록는 <xref:System.Data.DataTable> 스키마와 데이터를 호출 하 여 메모리 스트림에 <xref:System.Data.DataTable.WriteXml%2A> 메서드. 이 예에서는 두 번째 만듭니다 <xref:System.Data.DataTable> 호출는 <xref:System.Data.DataTable.ReadXml%2A> 메서드를 스키마와 데이터를 채우는 것입니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file from which to read the data.</param>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> from the specified file.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Data.DataTable> 및 그 하위 항목에 제공 된 명명 된 파일에서 데이터와 함께 로드 되 <xref:System.String>합니다. 이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> 메서드와 비슷하지만 경우에 데이터는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.  
  
 <xref:System.Data.DataTable.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataTable> XML 문서 로부터 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Data.DataTable> 두 개의 열과 열 개의 행을 포함 합니다. 이 예제에서는 기록는 <xref:System.Data.DataTable> 스키마와 데이터 디스크를 합니다. 이 예에서는 두 번째 만듭니다 <xref:System.Data.DataTable> 호출는 <xref:System.Data.DataTable.ReadXml%2A> 메서드를 스키마와 데이터를 채우는 것입니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.Xml.XmlReader" /> that will be used to read the data.</param>
        <summary>Reads XML Schema and Data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Data.DataTable> 및 그 하위 항목에 제공 된 명명 된 파일에서 데이터와 함께 로드 되 <xref:System.Xml.XmlReader>합니다. 이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataTable.ReadXml%2A> 메서드와 비슷하지만 경우에 데이터는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.  
  
 <xref:System.Data.DataTable.ReadXml%2A> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <xref:System.Data.DataTable> XML 문서 로부터 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여는 `WriteXml` 메서드. 스키마만을 작성 하기 위해 사용 하 여는 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.  
  
 인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다. 유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.  
  
> [!NOTE]
>  `DataSet` 해당 XML 요소를 연결 하지는 않습니다 `DataColumn` 또는 `DataTable` 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우. `DataSet` XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다. XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Data.DataTable> 두 개의 열과 열 개의 행을 포함 합니다. 이 예제에서는 기록는 <xref:System.Data.DataTable> 스키마와 데이터를 한 <xref:System.Xml.XmlReader>합니다. 이 예에서는 두 번째 만듭니다 <xref:System.Data.DataTable> 호출는 <xref:System.Data.DataTable.ReadXml%2A> 스키마와 데이터를 채울 메서드는 <xref:System.Xml.XmlReader> 인스턴스.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 `ReadXmlSchema` 에 대 한 스키마를 만들려면 다음 메서드는 <xref:System.Data.DataTable>합니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준에 따라 해석 됩니다.  
  
 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The stream used to read the schema.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만들려면 다음 메서드는 <xref:System.Data.DataTable>합니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준에 따라 해석 됩니다.  
  
 msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.  
  
 XML 스키마를 사용 하 여 중첩된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다. 명시적 열 이름을 사용 하도록 중첩된 관계를 구성할 수 있습니다. 요소 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 순서 대로 암시적으로 중첩 되어야 합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램에서는 새 <xref:System.Data.DataTable>, 해당 테이블에 대 한 스키마를 작성 하 고는 <xref:System.IO.MemoryStream>합니다. 그런 다음 예제에서는 새 <xref:System.Data.DataTable> 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.IO.TextReader" /> used to read the schema information.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만들려면 다음 메서드는 <xref:System.Data.DataTable>합니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준에 따라 해석 됩니다.  
  
 msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.  
  
 XML 스키마를 사용 하 여 중첩된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다. 명시적 열 이름을 사용 하도록 중첩된 관계를 재구성할 수 있습니다. 요소 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 순서 대로 암시적으로 중첩 되어야 합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램에서는 새 <xref:System.Data.DataTable>, 해당 테이블에 대 한 스키마를 작성 하 고는 <xref:System.IO.MemoryStream>합니다. 그런 다음 예제에서는 새 <xref:System.Data.DataTable> 및 사용 하 여 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.는 <xref:System.IO.StreamReader> (에서 상속 되 <xref:System.IO.TextReader>)를 원본으로 합니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataTable.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file from which to read the schema information.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> from the specified file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만들려면 다음 메서드는 <xref:System.Data.DataTable>합니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준에 따라 해석 됩니다.  
  
 msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 `DataTable`합니다.  
  
 XML 스키마를 사용 하 여 중첩된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다. 명시적 열 이름을 사용 하도록 중첩된 관계를 재구성할 수 있습니다. 요소 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 순서 대로 암시적으로 중첩 되어야 합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램에서는 새 <xref:System.Data.DataTable>, 해당 테이블에 대 한 스키마 파일을 씁니다. 그런 다음 예제에서는 새 <xref:System.Data.DataTable> 및 파일을 사용 하 여 원본으로 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.Xml.XmlReader" /> used to read the schema information.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만들려면 다음 메서드는 <xref:System.Data.DataTable>합니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 스키마는 XML 문서를 작성 하려면 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준에 따라 해석 됩니다.  
  
 msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.  
  
> [!NOTE]
>  XML 스키마를 사용 하 여 중첩된 관계를 만들 수 있는 방법은 암시적 중첩 된 요소를 것입니다. 또한 중첩된 관계 명시적 열 이름을 사용 하도록 다시 연결할 수 있습니다. 암시적으로 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 중첩 된 요소에 대 한 필수입니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램에서는 새 <xref:System.Data.DataTable>, 해당 테이블에 대 한 스키마를 작성 하 고는 <xref:System.IO.MemoryStream>합니다. 그런 다음 예제에서는 새 <xref:System.Data.DataTable> 및 사용 하 여 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.는 <xref:System.Xml.XmlTextReader> (에서 상속 되 <xref:System.Xml.XmlReader>)를 원본으로 합니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Xml.XmlReader" /> object.</param>
        <summary>Reads from an XML stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberSignature Language="F#" Value="member this.RejectChanges : unit -&gt; unit" Usage="dataTable.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rolls back all changes that have been made to the table since it was loaded, or the last time <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Data.DataTable.RejectChanges%2A> 호출, <xref:System.Data.DataRow> 아직 편집 모드에에서 있는 개체의 편집이 취소 합니다. 새 행이 제거 됩니다. 행의 <xref:System.Data.DataRowState> 로 설정 `Modified` 또는 `Deleted` 를 원래 상태로 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 몇 가지 변경 내용에는 <xref:System.Data.DataTable>를 호출 하 여 변경 내용을 거부는 <xref:System.Data.DataTable.RejectChanges%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the serialization format.</summary>
        <value>A <see cref="T:System.Data.SerializationFormat" /> 중 하나를 지정 하는 열거형 <see langword="Binary" /> 또는 <see langword="Xml" /> 직렬화 합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataTable.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the <see cref="T:System.Data.DataTable" /> to its original state. Reset removes all data, indexes, relations, and columns of the table. If a DataSet includes a DataTable, the table will still be part of the DataSet after the table is reset.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberSignature Language="F#" Value="member this.RowChanged : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanged : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a <see cref="T:System.Data.DataRow" /> has been changed successfully.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 참조 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberSignature Language="F#" Value="member this.RowChanging : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanging : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a <see cref="T:System.Data.DataRow" /> is changing.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 참조 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberSignature Language="F#" Value="member this.RowDeleted : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleted : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a row in the table has been deleted.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 참조 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberSignature Language="F#" Value="member this.RowDeleting : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleting : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs before a row in the table is about to be deleted.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 참조 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Rows : System.Data.DataRowCollection" Usage="System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of rows that belong to this table.</summary>
        <value>A <see cref="T:System.Data.DataRowCollection" /> 포함 된 <see cref="T:System.Data.DataRow" /> 개체이 고, 그렇지 않은 경우에 null 값이 없는 경우 <see cref="T:System.Data.DataRow" /> 개체가 존재 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새로 만들려면 <xref:System.Data.DataRow>를 사용 해야 합니다는 <xref:System.Data.DataTable.NewRow%2A> 메서드는 새 개체를 반환 합니다. 이러한 개체에 대해 정의 된 스키마에 따라 자동으로 구성 되는 <xref:System.Data.DataTable> 의 컬렉션을 통해 <xref:System.Data.DataColumn> 개체입니다. 새 행을 만드는 행의 각 열에 대 한 값을 설정 후, 행을 추가 하는 <xref:System.Data.DataRowCollection> 를 사용 하는 `Add` 메서드.  
  
 각 <xref:System.Data.DataRow> 컬렉션에는 테이블에 데이터의 행을 나타냅니다. 행의 열 값에는 변경 내용을 커밋하지를 호출 해야는 <xref:System.Data.DataTable.AcceptChanges%2A> 메서드.  
  
   
  
## Examples  
 다음은 반환 하 고 행을 설정 하는 두 가지 예입니다. 사용 하 여 첫 번째 예제는 <xref:System.Data.DataTable.Rows%2A> 속성 하 고 모든 행에 대 한 각 열의 값을 출력 합니다. 사용 하 여 두 번째 예제는 <xref:System.Data.DataTable> 개체의 <xref:System.Data.DataTable.NewRow%2A> 만드는 새 메서드를 <xref:System.Data.DataRow> 개체의 스키마와는 <xref:System.Data.DataTable>합니다. 행 값을 설정한 후에 행이 추가 <xref:System.Data.DataRowCollection> 통해는 `Add` 메서드.  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets an array of <see cref="T:System.Data.DataRow" /> objects.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; System.Data.DataRow[]" Usage="dataTable.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 된 정렬 조건을 적절 한 정렬 순서를 보장 하려면 <xref:System.Data.DataTable.Select%2A> 또는 <xref:System.Data.DataTable.Select%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열을 반환 <xref:System.Data.DataRow> 통해 개체는 <xref:System.Data.DataTable.Select%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberSignature Language="F#" Value="member this.Select : string -&gt; System.Data.DataRow[]" Usage="dataTable.Select filterExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter criteria.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 만들려는 `filterExpression` 인수를에 적용 되는 동일한 규칙을 사용 하 여는 <xref:System.Data.DataColumn> 클래스의 <xref:System.Data.DataColumn.Expression%2A> 필터를 만들기 위한 속성 값입니다.  
  
 지정 된 정렬 조건을 적절 한 정렬 순서를 보장 하려면 <xref:System.Data.DataTable.Select%2A> 또는 <xref:System.Data.DataTable.Select%2A>합니다.  
  
 필터에 열에 null 값이 포함 된 결과에 포함 되지 않습니다.  
  
   
  
## Examples  
 다음 예제는 필터 식을 사용 하 여의 배열을 반환할 <xref:System.Data.DataRow> 개체입니다.  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">A string specifying the column and sort direction.</param>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter criteria, in the specified sort order.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects matching the filter expression.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 양식에 `filterExpression` 인수를 동일한 규칙을 만들기 위한 사용는 <xref:System.Data.DataColumn> 클래스의 <xref:System.Data.DataColumn.Expression%2A> 속성 값입니다. `Sort` 인수 클래스의를 만들기 위한 동일한 규칙에도 사용 <xref:System.Data.DataColumn.Expression%2A> 문자열입니다.  
  
 필터에 열에 null 값이 포함 된 결과에 포함 되지 않습니다.  
  
   
  
## Examples  
 다음 예제는 필터 식을 사용 하 여의 배열을 반환할 <xref:System.Data.DataRow> 개체입니다.  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string * System.Data.DataViewRowState -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort, recordStates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">A string specifying the column and sort direction.</param>
        <param name="recordStates">One of the <see cref="T:System.Data.DataViewRowState" /> values.</param>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter in the order of the sort that match the specified state.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 양식에 `filterExpression` 인수를 동일한 규칙을 만들기 위한 사용는 <xref:System.Data.DataColumn> 클래스의 <xref:System.Data.DataColumn.Expression%2A> 속성 값입니다. `Sort` 인수 클래스의를 만들기 위한 동일한 규칙에도 사용 <xref:System.Data.DataColumn.Expression%2A> 문자열입니다.  
  
 필터에 열에 null 값이 포함 된 결과에 포함 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 필터 식과 레코드 상태를 사용 하 여 배열을 반환할 <xref:System.Data.DataRow> 개체입니다.  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an <see cref="T:System.ComponentModel.ISite" /> for the <see cref="T:System.Data.DataTable" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" />에 대한 <see cref="T:System.Data.DataTable" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사이트 바인딩는 <xref:System.ComponentModel.Component> 에 <xref:System.ComponentModel.Container> 서로 통신할 수 있도록 할 뿐만 아니라 컨테이너에서 해당 구성 요소를 관리할 수 있는 방법을 제공 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Data.DataTable.System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>
          <see langword="true" /> 컬렉션의 컬렉션의 경우 <see cref="T:System.Collections.IList" /> 개체이 고, 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataTable> 인스턴스가 <xref:System.ComponentModel.IListSource> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>For a description of this member, see <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>An <see cref="T:System.Collections.IList" /> that can be bound to a data source from the object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataTable> 인스턴스가 <xref:System.ComponentModel.IListSource> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">An XmlReader.</param>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">An XmlWriter.</param>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberSignature Language="F#" Value="member this.TableCleared : System.Data.DataTableClearEventHandler " Usage="member this.TableCleared : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a <see cref="T:System.Data.DataTable" /> is cleared.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableCleared> 이벤트가 모든 행이 성공적으로 지워진 하기 전에 직후는 <xref:System.Data.DataTable.Clear%2A> 메서드 호출자에 게 제어를 반환 합니다. <xref:System.Data.DataTable.TableCleared> 지우기 작업 중 모든 예외가 있는 경우에 이벤트가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberSignature Language="F#" Value="member this.TableClearing : System.Data.DataTableClearEventHandler " Usage="member this.TableClearing : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a <see cref="T:System.Data.DataTable" /> is cleared.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableClearing> 이벤트가 처리 되기 전에 <xref:System.Data.DataTable.Clear%2A> 작업이 시작 됩니다. 이 이벤트는 시기는 <xref:System.Data.DataTable.Clear%2A> 테이블 0 개의 행을 포함 하는 경우에 메서드를 호출 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the <see cref="T:System.Data.DataTable" />.</summary>
        <value>
          <see cref="T:System.Data.DataTable" />의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableName%2A> 부모 개체에서이 테이블을 반환 하는 데 사용 <xref:System.Data.DataSet> 개체의 <xref:System.Data.DataTableCollection> (에서 반환 되는 <xref:System.Data.DataSet.Tables%2A> 속성).  
  
   
  
## Examples  
 다음 예제에서는 인쇄는 <xref:System.Data.DataTable.TableName%2A> 컬렉션의 각 테이블에 대해 <xref:System.Data.DataTable> 개체입니다.  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="null" /> or empty string ("") is passed in and this table belongs to a collection.</exception>
        <exception cref="T:System.Data.DuplicateNameException">The table belongs to a collection that already has a table with the same name. (Comparison is case-sensitive).</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberSignature Language="F#" Value="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " Usage="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a new <see cref="T:System.Data.DataRow" /> is inserted.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 발생 한 이후에 새 시작 <xref:System.Data.DataRow> 사용 하 여 만든 <xref:System.Data.DataTable.NewRow%2A>합니다. 이 이벤트가 발생 하기 전에 호출 된 `NewRow` 메서드 반환 합니다. 새 <xref:System.Data.DataRow> 컬렉션에 추가 되지 않으면 인스턴스는 분리 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="dataTable.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the <see cref="P:System.Data.DataTable.TableName" /> and <see cref="P:System.Data.DataTable.DisplayExpression" />, if there is one as a concatenated string.</summary>
        <returns>A string consisting of the <see cref="P:System.Data.DataTable.TableName" /> and the <see cref="P:System.Data.DataTable.DisplayExpression" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가져옵니다는 <xref:System.Data.DataTable.TableName%2A> 및 <xref:System.Data.DataTable.DisplayExpression%2A> 에 대 한는 <xref:System.Data.DataTable>합니다.  
  
   
  
## Examples  
 다음 예제에서는 반환 된 <xref:System.Data.DataTable.TableName%2A> 및 <xref:System.Data.DataTable.DisplayExpression%2A> 를 사용 하 여는 <xref:System.Data.DataTable.ToString%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램에서는 두 개의 <xref:System.Data.DataTable> 인스턴스, 각각을 추가 하는 <xref:System.Data.DataSet>, 만듭니다는 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드는 하는부모테이블내에포함된데이터를쓸<xref:System.IO.TextWriter>. 이 예제에서는 설정할 때 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.  
  
> [!NOTE]
>  이 예제에는 WriteXml의 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다. 사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 출력을 표시합니다.  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write the content.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataTable.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The file to which to write the XML data.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> with which to write the contents.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXml (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.Stream" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> to the specified file using the specified <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write the content.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.TextWriter" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목, 관련 테이블에 대 한 데이터를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램에서는 두 개의 <xref:System.Data.DataTable> 인스턴스, 각각을 추가 하는 <xref:System.Data.DataSet>, 만듭니다는 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드는 하는부모테이블내에포함된데이터를쓸<xref:System.IO.TextWriter>. 이 예제에서는 설정할 때 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 `true`합니다.  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">The file to which to write the XML data.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified file. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified file and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> with which to write the contents.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 데이터를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (stream, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> to the specified file using the specified <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 `DataTable` XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `XmlWriteMode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 저장 합니다. `WriteXml` 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 `DataTable` XML 문서로 반면는 `WriteXmlSchema` 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 `XmlWriteMode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 저장 합니다. <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램에서는 두 개의 <xref:System.Data.DataTable> 인스턴스, 각각을 추가 하는 <xref:System.Data.DataSet>, 만듭니다는 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드는 하는부모테이블내에포함된데이터를쓸<xref:System.IO.TextWriter>. 이 예제에서는 설정할 때 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 출력을 표시합니다.  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified file and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 저장 합니다. 현재 테이블 및 모든 스키마에 대 한 데이터를 저장 하려는 경우는 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 모든 하위 항목, 관련 테이블에 대 한 데이터를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`합니다.  
  
 동일한은 대 한 적용 된 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여는 `ReadXml` 메서드. 사용 하 여 스키마만 읽을 수는 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 데이터를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 유형이 throw 됩니다는 `DataRow` 에서 읽거나 구현에 기록 되 고 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않으므로 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램에서는 두 개의 <xref:System.Data.DataTable> 인스턴스, 각각을 추가 하는 <xref:System.Data.DataSet>, 만듭니다는 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 하는부모테이블내에포함된데이터를쓸<xref:System.IO.TextWriter>. 이 예제에서는 설정할 때 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.  
  
> [!NOTE]
>  오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 주는이 예제 `WriteXmlSchema` 다른 예제를 사용할 수 있는 오버 로드 개별 항목을 참조 합니다.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 출력을 표시합니다.  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the XML schema will be written.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataTable.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to use.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> to use.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the XML schema will be written.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified stream. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 일반적으로 `WriteXmlSchema` 메서드는 현재 테이블에 대 한 스키마를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.IO.TextWriter" />. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 일반적으로 `WriteXmlSchema` 메서드는 현재 테이블에 대 한 스키마를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램에서는 두 개의 <xref:System.Data.DataTable> 인스턴스, 각각을 추가 하는 <xref:System.Data.DataSet>, 만듭니다는 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 하는부모테이블내에포함된데이터를쓸<xref:System.IO.TextWriter>. 이 예제에서는 설정할 때 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 출력을 표시합니다.  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to use.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified file. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 일반적으로 `WriteXmlSchema` 메서드는 현재 테이블에 대 한 스키마를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.Xml.XmlWriter" />. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드는 <xref:System.Data.DataTable> XML 문서에 있습니다. 스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 일반적으로 `WriteXmlSchema` 메서드는 현재 테이블에 대 한 스키마를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>