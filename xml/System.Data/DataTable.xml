<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DataTable.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac51ca059a55e7219b43068a0a701adfb187f239dc3.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1ca059a55e7219b43068a0a701adfb187f239dc3</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>Represents one table of in-memory data.</source>
          <target state="translated">메모리 내 데이터의 한 테이블을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> is a central object in the ADO.NET library.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> ADO.NET 라이브러리의 중앙 개체입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Other objects that use the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> include the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> and the <ph id="ph3">&lt;xref:System.Data.DataView&gt;</ph>.</source>
          <target state="translated">사용 하는 다른 개체는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 포함는 <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataView&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>When accessing <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects, note that they are conditionally case sensitive.</source>
          <target state="translated">에 액세스할 때 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 개체, 조건에 따라 대/소문자 구분 되는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>For example, if one <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> is named "mydatatable" and another is named "Mydatatable", a string used to search for one of the tables is regarded as case sensitive.</source>
          <target state="translated">예를 들어 하나의 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> "mydatatable" 라고 하 고 "Mydatatable" 라는 다른, 테이블 중 하나를 검색 하는 데 사용 하는 문자열 같이 대/소문자 구분 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>However, if "mydatatable" exists and "Mydatatable" does not, the search string is regarded as case insensitive.</source>
          <target state="translated">그러나 "mydatatable" 있으며 "Mydatatable" 하지 않는 경우 검색 문자열 소문자 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>A <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can contain two <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects that have the same <ph id="ph3">&lt;xref:System.Data.DataTable.TableName%2A&gt;</ph> property value but different <ph id="ph4">&lt;xref:System.Data.DataTable.Namespace%2A&gt;</ph> property values.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 두 개를 포함할 수 있습니다 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 동일한 개체 <ph id="ph3">&lt;xref:System.Data.DataTable.TableName%2A&gt;</ph> 속성 값은 다른 <ph id="ph4">&lt;xref:System.Data.DataTable.Namespace%2A&gt;</ph> 속성 값입니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>For more information about working with <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects, see <bpt id="p1">[</bpt>Creating a DataTable<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)</ept>.</source>
          <target state="translated">작업에 대 한 자세한 내용은 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 개체 참조 <bpt id="p1">[</bpt>DataTable 만들기<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>If you are creating a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> programmatically, you must first define its schema by adding <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects to the <ph id="ph3">&lt;xref:System.Data.DataColumnCollection&gt;</ph> (accessed through the <ph id="ph4">&lt;xref:System.Data.DataTable.Columns%2A&gt;</ph> property).</source>
          <target state="translated">만들려는 경우 한 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 프로그래밍 방식으로 정의 해야 해당 스키마를 추가 하 여 <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> 개체를 <ph id="ph3">&lt;xref:System.Data.DataColumnCollection&gt;</ph> (통해 액세스는 <ph id="ph4">&lt;xref:System.Data.DataTable.Columns%2A&gt;</ph> 속성).</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>For more information about adding <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> objects, see <bpt id="p1">[</bpt>Adding Columns to a DataTable<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md)</ept>.</source>
          <target state="translated">추가 하는 방법에 대 한 자세한 내용은 <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> 개체 참조 <bpt id="p1">[</bpt>DataTable에 열 추가<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>To add rows to a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, you must first use the <ph id="ph2">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> method to return a new <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> object.</source>
          <target state="translated">행을 추가 하는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>를 먼저 사용 해야 합니다는 <ph id="ph2">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> 새 반환 하는 메서드 <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> method returns a row with the schema of the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, as it is defined by the table's <ph id="ph3">&lt;xref:System.Data.DataColumnCollection&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> 의 스키마가 있는 행을 반환 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>는 테이블에 의해 정의 된 대로, <ph id="ph3">&lt;xref:System.Data.DataColumnCollection&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The maximum number of rows that a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> can store is 16,777,216.</source>
          <target state="translated">행의 최대 개수는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 수 저장소는 16777216 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>For more information, see <bpt id="p1">[</bpt>Adding Data to a DataTable<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>DataTable에 데이터 추가<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> also contains a collection of <ph id="ph2">&lt;xref:System.Data.Constraint&gt;</ph> objects that can be used to ensure the integrity of the data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 의 컬렉션도 포함 <ph id="ph2">&lt;xref:System.Data.Constraint&gt;</ph> 데이터의 무결성을 보장 하는 데 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>For more information, see <bpt id="p1">[</bpt>DataTable Constraints<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>DataTable 제약 조건<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>There are many <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> events that can be used to determine when changes are made to a table.</source>
          <target state="translated">여러 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 테이블에 변경 내용이 시기를 결정 하는 데 사용할 수 있는 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>These include <ph id="ph1">&lt;xref:System.Data.DataTable.RowChanged&gt;</ph>, <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph>, <ph id="ph3">&lt;xref:System.Data.DataTable.RowDeleting&gt;</ph>, and <ph id="ph4">&lt;xref:System.Data.DataTable.RowDeleted&gt;</ph>.</source>
          <target state="translated">이것에는 <ph id="ph1">&lt;xref:System.Data.DataTable.RowChanged&gt;</ph>, <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph>, <ph id="ph3">&lt;xref:System.Data.DataTable.RowDeleting&gt;</ph> 및 <ph id="ph4">&lt;xref:System.Data.DataTable.RowDeleted&gt;</ph>가 있습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>For more information about the events that can be used with a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, see <bpt id="p1">[</bpt>Handling DataTable Events<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>.</source>
          <target state="translated">함께 사용할 수 있는 이벤트에 대 한 자세한 내용은 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, 참조 <bpt id="p1">[</bpt>DataTable 이벤트 처리<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>When an instance of <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> is created, some of the read/write properties are set to initial values.</source>
          <target state="translated">인스턴스가 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 를 만드는 경우 일부 속성 읽기/쓰기의 초기 값으로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>For a list of these values, see the <ph id="ph1">&lt;xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType&gt;</ph> constructor topic.</source>
          <target state="translated">이러한 값의 목록에 대 한 참조는 <ph id="ph1">&lt;xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType&gt;</ph> 생성자 항목입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects inherit from <ph id="ph3">&lt;xref:System.ComponentModel.MarshalByValueComponent&gt;</ph>, and support the <ph id="ph4">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface for .NET Framework remoting.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 개체에서 상속 <ph id="ph3">&lt;xref:System.ComponentModel.MarshalByValueComponent&gt;</ph>, 및 지원에서 <ph id="ph4">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> .NET Framework remoting에 대 한 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>These are the only ADO.NET objects that you can use for .NET Framework remoting.</source>
          <target state="translated">이들은.NET Framework remoting에 사용할 수 있는 유일한 ADO.NET 개체입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The following example creates two <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects and one <ph id="ph2">&lt;xref:System.Data.DataRelation&gt;</ph> object, and adds the new objects to a <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 두 개의 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 개체와 하나의 <ph id="ph2">&lt;xref:System.Data.DataRelation&gt;</ph> 개체를 새 개체를 추가 하는 <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The tables are then displayed in a <ph id="ph1">&lt;xref:System.Windows.Forms.DataGridView&gt;</ph> control.</source>
          <target state="translated">테이블에 표시 되는 <ph id="ph1">&lt;xref:System.Windows.Forms.DataGridView&gt;</ph> 제어 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>This sample demonstrates how to create a DataTable manually with specific schema definitions:</source>
          <target state="translated">이 샘플에는 특정 스키마 정의를 DataTable을 수동으로 만드는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Create multiple DataTables and define the initial columns.</source>
          <target state="translated">여러 Datatable을 만들고 첫 열을 정의 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Create the table constraints.</source>
          <target state="translated">테이블 제약 조건을 만듭니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Insert the values and display the tables.</source>
          <target state="translated">값을 삽입 하 고 테이블을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Create the expression columns and display the tables.</source>
          <target state="translated">식 열을 만들고 테이블을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>C# and Visual Basic projects with this code sample can be found on <bpt id="p1">[</bpt>Developer Code Samples<ept id="p1">](http://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914)</ept>.</source>
          <target state="translated">이 코드 예제와 함께 C# 및 Visual Basic 프로젝트에서 확인할 수 있습니다 <bpt id="p1">[</bpt>개발자 코드 샘플<ept id="p1">](http://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>This type is safe for multithreaded read operations.</source>
          <target state="translated">이 형식은 다중 스레드 읽기 작업에 안전 합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>You must synchronize any write operations.</source>
          <target state="translated">쓰기 작업을 동기화 해야 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> class with no arguments.</source>
          <target state="translated">인수를 사용하지 않고 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>The constructor sets initial values for all properties of the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> object.</source>
          <target state="translated">모든 속성에 대 한 초기 값을 설정 하는 생성자는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>The following table shows the properties and their default values.</source>
          <target state="translated">다음 표에서 속성 및 기본값을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>When an instance of <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> is created, the following read/write properties are set to initial values.</source>
          <target state="translated">인스턴스가 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 만들어지면 다음 읽기/쓰기 속성은 초기 값으로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>Property</source>
          <target state="translated">속성</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>Default value</source>
          <target state="translated">기본값</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source><bpt id="p1">**</bpt>CaseSensitive<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>CaseSensitive<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>Same as the parent <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, if it belongs to one.</source>
          <target state="translated">부모와 동일한 <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>하나에 속하게 하는 경우.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>Otherwise, <ph id="ph1">`false`</ph>.</source>
          <target state="translated">그렇지 않으면 <ph id="ph1">`false`</ph>입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source><bpt id="p1">**</bpt>DisplayExpression<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>DisplayExpression<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>Empty string ("")</source>
          <target state="translated">빈 문자열 ("")</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source><bpt id="p1">**</bpt>Locale<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>로캘<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>Same as the parent <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object's <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (returned by the <ph id="ph3">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> property); if no parent exists, the default is the current system <ph id="ph4">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">부모와 동일한 <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (에서 반환 되는 <ph id="ph3">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> 속성) 부모가 없으면; 기본값은 현재 시스템 <ph id="ph4">&lt;xref:System.Globalization.CultureInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source><bpt id="p1">**</bpt>MinimumCapacity<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>MinimumCapacity<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>50 rows.</source>
          <target state="translated">50 행 수입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>You can change the value for any of these properties through a separate call to the property.</source>
          <target state="translated">속성에 별도 호출을 통해 이러한 속성 중 하나에 대 한 값을 변경할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> with <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph>, and displays it in a <ph id="ph4">&lt;xref:System.Windows.Forms.DataGridView&gt;</ph> control.</source>
          <target state="translated">다음 예제에서는 새 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph>에 표시 된 <ph id="ph4">&lt;xref:System.Windows.Forms.DataGridView&gt;</ph> 제어 합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.#ctor(System.String)">
          <source>The name to give the table.</source>
          <target state="translated">테이블에 지정할 이름입니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.#ctor(System.String)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>tableName<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an empty string, a default name is given when added to the <ph id="ph2">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>tableName<ept id="p1">&lt;/c&gt;</ept>이 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 또는 빈 문자열이면 <ph id="ph2">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph>에 테이블이 추가될 때 기본 이름이 지정됩니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> class with the specified table name.</source>
          <target state="translated">지정된 테이블 이름을 사용하여 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor(System.String)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and displays it in a <ph id="ph2">&lt;xref:System.Windows.Forms.DataGridView&gt;</ph> control.</source>
          <target state="translated">다음 예제에서는 한 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 에 표시는 <ph id="ph2">&lt;xref:System.Windows.Forms.DataGridView&gt;</ph> 제어 합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The data needed to serialize or deserialize an object.</source>
          <target state="translated">개체를 serialize 또는 deserialize하는 데 필요한 데이터입니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The source and destination of a given serialized stream.</source>
          <target state="translated">serialize된 특정 스트림의 소스와 대상입니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> class with the <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> and the <ph id="ph3">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>와 <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>를 사용하여 <ph id="ph3">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This implementation of the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> constructor is required for <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph>.</source>
          <target state="translated">이 구현에서 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 생성자가 필요 <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.#ctor(System.String,System.String)">
          <source>The name to give the table.</source>
          <target state="translated">테이블에 지정할 이름입니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.#ctor(System.String,System.String)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>tableName<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an empty string, a default name is given when added to the <ph id="ph2">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>tableName<ept id="p1">&lt;/c&gt;</ept>이 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 또는 빈 문자열이면 <ph id="ph2">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph>에 테이블이 추가될 때 기본 이름이 지정됩니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.#ctor(System.String,System.String)">
          <source>The namespace for the XML representation of the data stored in the <ph id="ph1">&lt;see langword="DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DataTable" /&gt;</ph>에 저장된 데이터의 XML 표현에 대한 네임스페이스입니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.#ctor(System.String,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> class using the specified table name and namespace.</source>
          <target state="translated">지정된 테이블 이름과 네임스페이스를 사용하여 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.AcceptChanges">
          <source>Commits all the changes made to this table since the last time <ph id="ph1">&lt;see cref="M:System.Data.DataTable.AcceptChanges" /&gt;</ph> was called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Data.DataTable.AcceptChanges" /&gt;</ph>가 마지막으로 호출된 이후 이 테이블에서 변경된 내용을 모두 커밋합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.AcceptChanges">
          <source>When <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> is called, any <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> object still in edit mode successfully ends its edits.</source>
          <target state="translated">때 <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> 호출, <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> 아직 편집 모드에에서는 개체의 편집을 성공적으로 종료 합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.AcceptChanges">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> also changes: all <ph id="ph2">`Added`</ph> and <ph id="ph3">`Modified`</ph> rows become <ph id="ph4">`Unchanged`</ph>, and <ph id="ph5">`Deleted`</ph> rows are removed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> 설치 경로도 변경: 모든 <ph id="ph2">`Added`</ph> 및 <ph id="ph3">`Modified`</ph> 될 행 <ph id="ph4">`Unchanged`</ph>, 및 <ph id="ph5">`Deleted`</ph> 행이 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.AcceptChanges">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> method is generally called on a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> after you attempt to update the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> using the <ph id="ph4">&lt;xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> 일반적으로 메서드가 호출 되는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 후 업데이트 하 려 하면는 <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> 를 사용 하 여는 <ph id="ph4">&lt;xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.AcceptChanges">
          <source>The following example tests each table for errors.</source>
          <target state="translated">다음 예제에서는 각 테이블의 오류를 테스트합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.AcceptChanges">
          <source>If the table's errors can be reconciled (by passing it to an undefined function), <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> is called; otherwise, <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A&gt;</ph> is called.</source>
          <target state="translated">(에 전달 하 여 정의 되지 않은 함수), 테이블의 오류를 해결할 수 있는 경우 <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> 고, 그러지 않으면 호출 <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A&gt;</ph> 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.BeginInit">
          <source>Begins the initialization of a <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> that is used on a form or used by another component.</source>
          <target state="translated">폼에 사용되거나 다른 구성 요소에서 사용하는 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 초기화를 시작합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.BeginInit">
          <source>The initialization occurs at run time.</source>
          <target state="translated">초기화는 런타임에 발생합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.BeginInit">
          <source>The Visual Studio .NET design environment uses this method to start the initialization of a component that is used on a form or used by another component.</source>
          <target state="translated">Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 시작 합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.BeginInit">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.EndInit%2A&gt;</ph> method ends the initialization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.EndInit%2A&gt;</ph> 메서드 초기화를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.BeginInit">
          <source>Using the <ph id="ph1">&lt;xref:System.Data.DataTable.BeginInit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.EndInit%2A&gt;</ph> methods prevents the control from being used before it is fully initialized.</source>
          <target state="translated">사용 하는 <ph id="ph1">&lt;xref:System.Data.DataTable.BeginInit%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.EndInit%2A&gt;</ph> 메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.BeginLoadData">
          <source>Turns off notifications, index maintenance, and constraints while loading data.</source>
          <target state="translated">데이터를 로드하는 동안 알림, 인덱스 유지 관리 및 제약 조건 기능을 해제합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.BeginLoadData">
          <source>Use <ph id="ph1">&lt;xref:System.Data.DataTable.BeginLoadData%2A&gt;</ph> in conjunction with <ph id="ph2">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataTable.EndLoadData%2A&gt;</ph>.</source>
          <target state="translated">사용 하 여 <ph id="ph1">&lt;xref:System.Data.DataTable.BeginLoadData%2A&gt;</ph> 함께에서 <ph id="ph2">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataTable.EndLoadData%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.CaseSensitive">
          <source>Indicates whether string comparisons within the table are case-sensitive.</source>
          <target state="translated">테이블 내의 문자열을 비교할 때 대/소문자를 구분할지 여부를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.CaseSensitive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the comparison is case-sensitive; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">비교할 때 대/소문자를 구분하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.CaseSensitive">
          <source>The default is set to the parent <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> object's <ph id="ph2">&lt;see cref="P:System.Data.DataSet.CaseSensitive" /&gt;</ph> property, or <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the <ph id="ph4">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> was created independently of a <ph id="ph5">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">기본값은 부모 <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> 개체의 <ph id="ph2">&lt;see cref="P:System.Data.DataSet.CaseSensitive" /&gt;</ph> 속성으로 설정되거나, <ph id="ph4">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>과 별도로 만들어진 <ph id="ph5">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>의 경우 <ph id="ph3">&lt;see langword="false" /&gt;</ph>로 설정됩니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.CaseSensitive">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.CaseSensitive%2A&gt;</ph> property affects string comparisons in sorting, searching, and filtering.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.CaseSensitive%2A&gt;</ph> 속성 정렬, 검색 및 필터링에 대 한 문자열 비교에 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.CaseSensitive">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> method twice on a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> 메서드를 두 번는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.CaseSensitive">
          <source>The first time, the <ph id="ph1">&lt;xref:System.Data.DataTable.CaseSensitive%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, the second, to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">처음으로 <ph id="ph1">&lt;xref:System.Data.DataTable.CaseSensitive%2A&gt;</ph> 속성이 <ph id="ph2">`false`</ph>에 두 번째 <ph id="ph3">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.ChildRelations">
          <source>Gets the collection of child relations for this <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>에 대한 자식 관계 컬렉션을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ChildRelations">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRelationCollection" /&gt;</ph> that contains the child relations for the table.</source>
          <target state="translated">테이블의 자식 관계가 포함된 <ph id="ph1">&lt;see cref="T:System.Data.DataRelationCollection" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ChildRelations">
          <source>An empty collection is returned if no <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> objects exist.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> 개체가 없으면 빈 컬렉션이 반환됩니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ChildRelations">
          <source>A <ph id="ph1">&lt;xref:System.Data.DataRelation&gt;</ph> defines the relationship between two tables.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Data.DataRelation&gt;</ph> 두 테이블 간의 관계를 정의 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ChildRelations">
          <source>Typically, two tables are linked through a single field that contains the same data.</source>
          <target state="translated">일반적으로 두 테이블은 동일한 데이터를 포함 하는 단일 필드를 통해 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ChildRelations">
          <source>For example, a table which contains address data may have a single field containing codes that represent countries/regions.</source>
          <target state="translated">예를 들어 주소 데이터를 포함 하는 테이블에는 국가/지역을 나타내는 코드를 포함 하는 단일 필드가 있을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ChildRelations">
          <source>A second table that contains country/region data will have a single field that contains the code that identifies the country/region, and it is this code which is inserted into the corresponding field in the first table.</source>
          <target state="translated">국가/지역 데이터를 포함 하는 두 번째 테이블에서 국가/지역을 식별 하는 코드를 포함 하는 단일 필드 있으며이 코드가 첫 번째 테이블의 해당 필드에 삽입 됩니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ChildRelations">
          <source>A <ph id="ph1">&lt;xref:System.Data.DataRelation&gt;</ph>, then, contains at least four pieces of information: (1) the name of the first table, (2) the column name in the first table, (3) the name of the second table, and (4) the column name in the second table.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Data.DataRelation&gt;</ph>, 적어도 다음 4 가지 정보를 포함 합니다: (1) 첫 번째 테이블의 이름, 첫 번째 테이블의 열 이름 (2), (3) 두 번째 테이블의 이름 및 (4) 두 번째 테이블의 열 이름입니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ChildRelations">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataTable.ChildRelations%2A&gt;</ph> property to return each child <ph id="ph2">&lt;xref:System.Data.DataRelation&gt;</ph> in a <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Data.DataTable.ChildRelations%2A&gt;</ph> 각 자식 반환할 속성 <ph id="ph2">&lt;xref:System.Data.DataRelation&gt;</ph> 에 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ChildRelations">
          <source>Each relation is then used as an argument in the <ph id="ph1">&lt;xref:System.Data.DataRow.GetChildRows%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> to return an array of rows.</source>
          <target state="translated">각 관계에 대 한 인수로 사용 됩니다는 <ph id="ph1">&lt;xref:System.Data.DataRow.GetChildRows%2A&gt;</ph> 의 메서드는 <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> 행의 배열을 반환 하도록 합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ChildRelations">
          <source>The value of each column in the row is then printed.</source>
          <target state="translated">행에 있는 각 열의 값이 출력 합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Clear">
          <source>Clears the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> of all data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 모든 데이터를 지웁니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clear">
          <source>All rows in all tables are removed.</source>
          <target state="translated">모든 테이블의 모든 행이 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clear">
          <source>An exception is generated if the table has any enforced child relations that would cause child rows to be orphaned.</source>
          <target state="translated">테이블에 자식 관계가 적용된 해야 하는 자식 행이 분리 될 경우 예외가 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clear">
          <source>If the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is bound to an <ph id="ph2">&lt;xref:System.Xml.XmlDataDocument&gt;</ph>, calling <ph id="ph3">&lt;xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph4">&lt;xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType&gt;</ph> raises the <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 에 바인딩된는 <ph id="ph2">&lt;xref:System.Xml.XmlDataDocument&gt;</ph>호출, <ph id="ph3">&lt;xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType&gt;</ph> 또는 <ph id="ph4">&lt;xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType&gt;</ph> 발생는 <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clear">
          <source>To avoid this situation, traverse each table, removing each row one at a time.</source>
          <target state="translated">이러한 상황을 방지 하려면 한 번에 하나씩 행을 제거, 각 테이블을 이동 합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clear">
          <source>When you use <ph id="ph1">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> to create new rows, the rows must be processed before you call <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph>.</source>
          <target state="translated">사용 하는 경우 <ph id="ph1">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> 새 행을 만들려면는 행을 처리 해야를 호출 하기 전에 <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clear">
          <source>The following example clears the table of all data.</source>
          <target state="translated">다음 예에서는 테이블의 모든 데이터를 지웁니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Clone">
          <source>Clones the structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, including all <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> schemas and constraints.</source>
          <target state="translated">모든 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> 스키마, 관계 및 제약 조건을 포함하여 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 구조를 복제합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Clone">
          <source>A new <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> with the same schema as the current <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>과 동일한 스키마를 갖는 새 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>If these classes have been derived, the clone will also be of the same derived classes.</source>
          <target state="translated">이러한 클래스를 파생 된 경우 동일한 파생된 클래스가 복제가 됩니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>Clone creates a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> with the same structure as the original <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, but does not copy any data (the new <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> will not contain any <ph id="ph4">`DataRows`</ph>).</source>
          <target state="translated">복제 대상을 새 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 원본과 같은 구조와 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, 하지만 모든 데이터를 복사 하지 않습니다 (새 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> 포함 되지 것입니다 <ph id="ph4">`DataRows`</ph>).</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>To copy both the structure and data into a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, use <ph id="ph2">&lt;xref:System.Data.DataTable.Copy%2A&gt;</ph>.</source>
          <target state="translated">새 구조와 데이터를 복사 하려면 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>를 사용 하 여 <ph id="ph2">&lt;xref:System.Data.DataTable.Copy%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>The following sample demonstrates how to update the structure and constraints of the destination table after you execute DataTable.Clone.</source>
          <target state="translated">다음 샘플에는 구조와 대상 테이블의 제약 조건을 DataTable.Clone를 실행 한 후 업데이트 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>The ClonedDataTable class will return a destination table and includes all the updating events.</source>
          <target state="translated">대상 테이블 반환 하 고 모든 업데이트 이벤트를 포함 하는 ClonedDataTable 클래스.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>After the clone, structure changes in the source table won’t be reflected in the destination table.</source>
          <target state="translated">복제 후 원본 테이블의 구조 변경 내용은 대상 테이블에 반영 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>Specifically, this sample will:</source>
          <target state="translated">특히,이 샘플 수행합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>Update the changes of the columns in source table.</source>
          <target state="translated">원본 테이블의 열의 변경 내용을 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>Update the changes of the UniqueConstraint in source table.</source>
          <target state="translated">원본 테이블의 UniqueConstraint의 변경 내용을 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>Update the changes of the ForeignKeyConstraint in source table.</source>
          <target state="translated">원본 테이블의 외래 키의 변경 내용을 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>C# and Visual Basic projects with this code sample can be found on <bpt id="p1">[</bpt>Developer Code Samples<ept id="p1">](http://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&amp;f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable)</ept>.</source>
          <target state="translated">이 코드 예제와 함께 C# 및 Visual Basic 프로젝트에서 확인할 수 있습니다 <bpt id="p1">[</bpt>개발자 코드 샘플<ept id="p1">](http://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&amp;f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>This sample shows how to modify data in a DataTable and update the data source.</source>
          <target state="translated">이 샘플에서는 DataTable에서 데이터를 수정 하 고 데이터 소스를 업데이트 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>First, create a database:</source>
          <target state="translated">먼저 데이터베이스를 만듭니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source>You can now compile and run the sample.</source>
          <target state="translated">이제 컴파일 및 샘플을 실행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Clone">
          <source><bpt id="p1">[</bpt>How to modify data in DataTable and update to the data source<ept id="p1">](http://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4)</ept> has Visual Basic and C# projects of this sample.</source>
          <target state="translated"><bpt id="p1">[</bpt>DataTable 및 데이터 원본에 대 한 업데이트에 대 한 데이터를 수정 하는 방법<ept id="p1">](http://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4)</ept> 이 샘플의 Visual Basic 및 C# 프로젝트에 있습니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="E:System.Data.DataTable.ColumnChanged">
          <source>Occurs after a value has been changed for the specified <ph id="ph1">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph> in a <ph id="ph2">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph>에 있는 지정된 <ph id="ph2">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>의 값이 변경된 후 발생합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.ColumnChanged">
          <source>For more information, see <bpt id="p1">[</bpt>Handling DataTable Events<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>DataTable 이벤트 처리<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="E:System.Data.DataTable.ColumnChanging">
          <source>Occurs when a value is being changed for the specified <ph id="ph1">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph> in a <ph id="ph2">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph>에 있는 지정된 <ph id="ph2">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>의 값이 변경될 때 발생합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.ColumnChanging">
          <source>For more information, see <bpt id="p1">[</bpt>Handling DataTable Events<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>DataTable 이벤트 처리<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.Columns">
          <source>Gets the collection of columns that belong to this table.</source>
          <target state="translated">이 테이블에 속한 열의 컬렉션을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Columns">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataColumnCollection" /&gt;</ph> that contains the collection of <ph id="ph2">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph> objects for the table.</source>
          <target state="translated">테이블의 <ph id="ph1">&lt;see cref="T:System.Data.DataColumnCollection" /&gt;</ph> 개체 컬렉션이 포함된 <ph id="ph2">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Columns">
          <source>An empty collection is returned if no <ph id="ph1">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph> objects exist.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph> 개체가 없으면 빈 컬렉션이 반환됩니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Columns">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataColumnCollection&gt;</ph> determines the schema of a table by defining the data type of each column.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataColumnCollection&gt;</ph> 각 열의 데이터 형식을 정의 하 여 테이블의 스키마를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Columns">
          <source>The following example prints each value of each row in a table using the <ph id="ph1">&lt;xref:System.Data.DataTable.Columns%2A&gt;</ph> property.</source>
          <target state="translated">다음 예제에서는 사용 하 여 테이블의 각 행의 값을 출력에서 <ph id="ph1">&lt;xref:System.Data.DataTable.Columns%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>The expression to compute.</source>
          <target state="translated">계산할 식입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>The filter to limit the rows that evaluate in the expression.</source>
          <target state="translated">식에서 계산하는 행을 제한할 필터입니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>Computes the given expression on the current rows that pass the filter criteria.</source>
          <target state="translated">필터 조건을 전달하는 현재 행에서 지정된 식을 계산합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, set to the result of the computation.</source>
          <target state="translated">계산 결과로 설정된 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>If the expression evaluates to null, the return value will be <ph id="ph1">&lt;see cref="F:System.DBNull.Value" /&gt;</ph>.</source>
          <target state="translated">식이 null로 평가되는 경우 반환 값은 <ph id="ph1">&lt;see cref="F:System.DBNull.Value" /&gt;</ph>가 됩니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>The <ph id="ph1">`expression`</ph> parameter requires an aggregate function.</source>
          <target state="translated"><ph id="ph1">`expression`</ph> 매개 변수는 집계 함수가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>For example, the following is a legal expression:</source>
          <target state="translated">예를 들어 다음은 올바른 식입니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>But this expression is not:</source>
          <target state="translated">하지만이 식은 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>If you must perform an operation on two or more columns, you should create a <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph>, set its <ph id="ph2">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> property to an appropriate expression, and use an aggregate expression on the resulting column.</source>
          <target state="translated">두 개 이상의 열에 대 한 작업을 수행 해야 하는 경우 만든는 <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph>설정, 해당 <ph id="ph2">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> 속성을 적절 한 식이 다음 결과 열에 집계 식 사용 합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>In that case, given a <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> with the name "total", and the <ph id="ph2">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> property set to this:</source>
          <target state="translated">지정 된 경우에 <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> 이름이 "total"와 및 <ph id="ph2">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> 속성이이로 설정 합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>The expression argument for the <ph id="ph1">&lt;xref:System.Data.DataTable.Compute%2A&gt;</ph> method would then be this:</source>
          <target state="translated">에 대 한 식 인수는 <ph id="ph1">&lt;xref:System.Data.DataTable.Compute%2A&gt;</ph> 메서드 된 것이:</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>The second parameter, <ph id="ph1">`filter`</ph>, determines which rows are used in the expression.</source>
          <target state="translated">두 번째 매개 변수 <ph id="ph1">`filter`</ph>, 식에 사용 될 행을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>For example, if the table contains a date column named "colDate", you could limit the rows with the following expression:</source>
          <target state="translated">예를 들어 테이블에 있는 경우 "colDate" 라는 날짜 열을 다음 식으로 행을 제한할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>For rules on creating expressions for both parameters, see the <ph id="ph1">&lt;xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">매개 변수가 모두에 대 한 식을 만드는 방법에 대 한 규칙을 참조 하십시오.는 <ph id="ph1">&lt;xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Compute(System.String,System.String)">
          <source>The following example sums the values of a column named "Total", for the salesperson whose identification number is five.</source>
          <target state="translated">다음 예제에서는 해당 id 번호는 5는 판매 직원에 대 한 "Total" 이라는 열의 값을 찾습니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.Constraints">
          <source>Gets the collection of constraints maintained by this table.</source>
          <target state="translated">이 테이블이 유지하는 제약 조건의 컬렉션을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Constraints">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.ConstraintCollection" /&gt;</ph> that contains the collection of <ph id="ph2">&lt;see cref="T:System.Data.Constraint" /&gt;</ph> objects for the table.</source>
          <target state="translated">테이블의 <ph id="ph1">&lt;see cref="T:System.Data.ConstraintCollection" /&gt;</ph> 개체 컬렉션이 포함된 <ph id="ph2">&lt;see cref="T:System.Data.Constraint" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Constraints">
          <source>An empty collection is returned if no <ph id="ph1">&lt;see cref="T:System.Data.Constraint" /&gt;</ph> objects exist.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.Constraint" /&gt;</ph> 개체가 없으면 빈 컬렉션이 반환됩니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Constraints">
          <source>A <ph id="ph1">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> restricts the action performed when a value in a column (or columns) is either deleted or updated.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> 열 또는 열에 값이 삭제 되거나 업데이트할 때 수행 하는 작업을 제한 합니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Constraints">
          <source>Such a constraint is intended to be used with primary key columns.</source>
          <target state="translated">이러한 제약 조건은 기본 키 열과 함께 사용 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Constraints">
          <source>In a parent/child relationship between two tables, deleting a value from the parent table can affect the child rows in one of the following ways.</source>
          <target state="translated">두 테이블 간에 부모/자식 관계에서 부모 테이블에서 값을 삭제할 영향을 줄 수 자식 행에서 다음 방법 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Constraints">
          <source>The child rows can also be deleted (a cascading action).</source>
          <target state="translated">자식 행 수도 있습니다 (연계 동작)를 삭제 합니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Constraints">
          <source>The values in the child column (or columns) can be set to null values.</source>
          <target state="translated">자식 열 (또는 열)의 값은 null 값으로 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Constraints">
          <source>The values in the child column (or columns) can be set to default values.</source>
          <target state="translated">자식 열 (또는 열)의 값을 기본값으로 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Constraints">
          <source>An exception can be generated.</source>
          <target state="translated">예외를 생성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Constraints">
          <source>A <ph id="ph1">&lt;xref:System.Data.UniqueConstraint&gt;</ph> becomes active when attempting to set a value in a primary key to a non-unique value.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Data.UniqueConstraint&gt;</ph> 값이 고유 기본 키의 값을 설정 하려고 할 때 활성화 됩니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Constraints">
          <source>The following example adds a <ph id="ph1">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> to the collection of constraints.</source>
          <target state="translated">다음 예제에서는 추가 <ph id="ph1">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> 제약 조건 컬렉션에 있습니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Copy">
          <source>Copies both the structure and data for this <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 구조와 데이터를 모두 복사합니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Copy">
          <source>A new <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> with the same structure (table schemas and constraints) and data as this <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>과 같은 구조(테이블 스키마, 관계, 제약 조건)와 데이터를 가진 새 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Copy">
          <source>If these classes have been derived, the copy will also be of the same derived classes.</source>
          <target state="translated">이 클래스가 파생된 경우 동일한 파생 클래스가 복사됩니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Copy">
          <source><ph id="ph1">&lt;see cref="M:System.Data.DataTable.Copy" /&gt;</ph> creates a new <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> with the same structure and data as the original <ph id="ph3">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Data.DataTable.Copy" /&gt;</ph>는 원래 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>과 동일한 구조 및 데이터로 새 <ph id="ph3">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Copy">
          <source>To copy the structure to a new <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, but not the data, use <ph id="ph2">&lt;see cref="M:System.Data.DataTable.Clone" /&gt;</ph>.</source>
          <target state="translated">구조체를 새 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>로 복사하고 데이터는 복사하지 않으려면 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.Clone" /&gt;</ph>을 사용하십시오.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Copy">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataTable.Copy%2A&gt;</ph> method to create a copy of the original <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Data.DataTable.Copy%2A&gt;</ph> 원본의 복사본을 만드는 메서드를 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Copy">
          <source>The namespace name is not retained if it is inherited from a parent <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> or <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">부모 로부터 상속 되는 경우에 네임 스페이스 이름을 유지 되지 않습니다 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.CreateDataReader">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> corresponding to the data within this <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph>의 데이터에 해당하는 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.CreateDataReader">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> containing one result set, corresponding to the source <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instance.</source>
          <target state="translated">결과 집합 하나를 포함하고 소스 <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> 인스턴스에 해당하는 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.CreateDataReader">
          <source>The following console application creates a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instance.</source>
          <target state="translated">다음 콘솔 응용 프로그램에서는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 인스턴스를 만듭니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.CreateDataReader">
          <source>The example then passes the filled <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> to a procedure that calls the <ph id="ph2">&lt;xref:System.Data.DataTable.CreateDataReader%2A&gt;</ph> method, which iterates through the results contained within the <ph id="ph3">&lt;xref:System.Data.DataTableReader&gt;</ph>.</source>
          <target state="translated">이 예제에서는 다음 채워진 전달 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 를 호출 하는 프로시저는 <ph id="ph2">&lt;xref:System.Data.DataTable.CreateDataReader%2A&gt;</ph> 메서드 내에 포함 된 결과를 반복 하는 <ph id="ph3">&lt;xref:System.Data.DataTableReader&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.CreateDataReader">
          <source>The example displays the following output in the console window:</source>
          <target state="translated">이 예제에서는 콘솔 창에 다음 출력을 표시합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.CreateInstance">
          <source>Creates a new instance of <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 새 인스턴스를 만듭니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.CreateInstance">
          <source>The new expression.</source>
          <target state="translated">새 식입니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.DataSet">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to which this table belongs.</source>
          <target state="translated">이 테이블이 속한 <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.DataSet">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to which this table belongs.</source>
          <target state="translated">이 테이블이 속한 <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.DataSet">
          <source>If a control is data bound to a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, and the table belongs to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, you can get to the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> through this property.</source>
          <target state="translated">컨트롤 데이터에 바인딩된는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, 테이블에 속해는 <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>에 가져올 수 있습니다는 <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> 이 속성을 통해.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.DataSet">
          <source>The following example returns the parent <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> of a given table through the <ph id="ph2">&lt;xref:System.Data.DataTable.DataSet%2A&gt;</ph> property.</source>
          <target state="translated">다음 예제에서는 부모 반환 <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 통해 지정된 된 테이블의는 <ph id="ph2">&lt;xref:System.Data.DataTable.DataSet%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.DefaultView">
          <source>Gets a customized view of the table that may include a filtered view, or a cursor position.</source>
          <target state="translated">필터링된 뷰를 포함할 수 있는 테이블의 사용자 지정 뷰 또는 커서 위치를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.DefaultView">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataView" /&gt;</ph> associated with the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataView" /&gt;</ph>와 연결된 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.DefaultView">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.DefaultView%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Data.DataView&gt;</ph> you can use to sort, filter, and search a <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.DefaultView%2A&gt;</ph> 속성에서 반환 된 <ph id="ph2">&lt;xref:System.Data.DataView&gt;</ph> 정렬, 필터 및 검색 하는 데 사용할 수는 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.DefaultView">
          <source>The following example sets a property of the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> object's <ph id="ph2">&lt;xref:System.Data.DataView&gt;</ph> through the <ph id="ph3">&lt;xref:System.Data.DataTable.DefaultView%2A&gt;</ph> property.</source>
          <target state="translated">속성을 설정 하는 다음 예제는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Data.DataView&gt;</ph> 통해는 <ph id="ph3">&lt;xref:System.Data.DataTable.DefaultView%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.DefaultView">
          <source>The example also shows the binding of a <ph id="ph1">&lt;xref:System.Windows.Forms.DataGridView&gt;</ph> control to a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> named "Suppliers" that includes a column named "CompanyName."</source>
          <target state="translated">또한이 예제에서는의 바인딩을 <ph id="ph1">&lt;xref:System.Windows.Forms.DataGridView&gt;</ph> 컨트롤을 한 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> "CompanyName" 라는 열이 포함 된 "공급자" 라는</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.DisplayExpression">
          <source>Gets or sets the expression that returns a value used to represent this table in the user interface.</source>
          <target state="translated">이 테이블을 사용자 인터페이스에 나타내는 데 사용되는 값을 반환하는 식을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.DisplayExpression">
          <source>The <ph id="ph1">&lt;see langword="DisplayExpression" /&gt;</ph> property lets you display the name of this table in a user interface.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DisplayExpression" /&gt;</ph> 속성을 사용하여 이 테이블의 이름을 사용자 인터페이스에 표시할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.DisplayExpression">
          <source>A display string.</source>
          <target state="translated">표시 문자열입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.EndInit">
          <source>Ends the initialization of a <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> that is used on a form or used by another component.</source>
          <target state="translated">폼에 사용되거나 다른 구성 요소에서 사용하는 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 초기화를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.EndInit">
          <source>The initialization occurs at run time.</source>
          <target state="translated">초기화는 런타임에 발생합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.EndInit">
          <source>The Visual Studio .NET design environment uses this method to end the initialization of a component that is used on a form or used by another component.</source>
          <target state="translated">Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소 초기화를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.EndInit">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.BeginInit%2A&gt;</ph> method starts the initialization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.BeginInit%2A&gt;</ph> 메서드 초기화를 시작 합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.EndInit">
          <source>Using the <ph id="ph1">&lt;xref:System.Data.DataTable.BeginInit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.EndInit%2A&gt;</ph> methods prevents the control from being used before it is fully initialized.</source>
          <target state="translated">사용 하는 <ph id="ph1">&lt;xref:System.Data.DataTable.BeginInit%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.EndInit%2A&gt;</ph> 메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.EndLoadData">
          <source>Turns on notifications, index maintenance, and constraints after loading data.</source>
          <target state="translated">데이터를 로드한 후 알림, 인덱스 유지 관리 및 제약 조건 기능을 설정합니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.EndLoadData">
          <source>Use <ph id="ph1">&lt;xref:System.Data.DataTable.EndLoadData%2A&gt;</ph> in conjunction with <ph id="ph2">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataTable.BeginLoadData%2A&gt;</ph>.</source>
          <target state="translated">사용 하 여 <ph id="ph1">&lt;xref:System.Data.DataTable.EndLoadData%2A&gt;</ph> 함께에서 <ph id="ph2">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataTable.BeginLoadData%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.ExtendedProperties">
          <source>Gets the collection of customized user information.</source>
          <target state="translated">사용자 지정 사용자 정보 컬렉션을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ExtendedProperties">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.PropertyCollection" /&gt;</ph> that contains custom user information.</source>
          <target state="translated">사용자 지정 사용자 정보가 들어 있는 <ph id="ph1">&lt;see cref="T:System.Data.PropertyCollection" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ExtendedProperties">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.ExtendedProperties%2A&gt;</ph> to add custom information to a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.ExtendedProperties%2A&gt;</ph> 사용자 지정 정보를 추가 하는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ExtendedProperties">
          <source>Add information with the <ph id="ph1">`Add`</ph> method.</source>
          <target state="translated">추가 정보는 <ph id="ph1">`Add`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ExtendedProperties">
          <source>Retrieve information with the <ph id="ph1">`Item`</ph> method.</source>
          <target state="translated">정보를 검색할는 <ph id="ph1">`Item`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ExtendedProperties">
          <source>Extended properties must be of type <ph id="ph1">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">확장된 속성 형식 이어야 합니다 <ph id="ph1">&lt;xref:System.String&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ExtendedProperties">
          <source>Properties that are not of type String are not persisted when the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> is written as XML.</source>
          <target state="translated">문자열 형식이 아닌 속성 유지 되지 않습니다 때는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> XML로 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ExtendedProperties">
          <source>The following example adds a timestamp value to the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> through the <ph id="ph2">&lt;xref:System.Data.DataTable.ExtendedProperties%2A&gt;</ph> property.</source>
          <target state="translated">타임 스탬프 값을 추가 하는 다음 예제는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 통해는 <ph id="ph2">&lt;xref:System.Data.DataTable.ExtendedProperties%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="F:System.Data.DataTable.fInitInProgress">
          <source>Checks whether initialization is in progress.</source>
          <target state="translated">초기화가 진행 중인지 여부를 확인합니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="F:System.Data.DataTable.fInitInProgress">
          <source>The initialization occurs at run time.</source>
          <target state="translated">초기화는 런타임에 발생합니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>Gets a copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> containing all changes made to it since it was last loaded, or since <ph id="ph2">&lt;see cref="M:System.Data.DataTable.AcceptChanges" /&gt;</ph> was called.</source>
          <target state="translated">마지막으로 로드되거나 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>가 호출된 후에 변경된 내용이 모두 들어 있는 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.AcceptChanges" /&gt;</ph>의 복사본을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetChanges">
          <source>Gets a copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> that contains all changes made to it since it was loaded or <ph id="ph2">&lt;see cref="M:System.Data.DataTable.AcceptChanges" /&gt;</ph> was last called.</source>
          <target state="translated">로드되거나 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>가 마지막으로 호출된 후에 변경된 내용이 모두 들어 있는 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.AcceptChanges" /&gt;</ph>의 복사본을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetChanges">
          <source>A copy of the changes from this <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no changes are found.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 변경 내용의 복사본을 반환하거나, 변경 내용이 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.GetChanges">
          <source>Creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> containing a copy of all rows in the original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> that have pending changes.</source>
          <target state="translated">새 <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 원래에 모든 행의 복사본이 포함 된 <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> 보류 중인 변경 내용이 있는 합니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.GetChanges">
          <source>Relationship constraints can cause additional unchanged rows to be added to the new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> if the unchanged rows contain primary keys corresponding to foreign keys in the changed rows.</source>
          <target state="translated">관계 제약 조건으로 인해 새에 추가할 추가 변경 되지 않은 행 <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 변경 되지 않은 행에는 변경 된 행에서 외래 키에 해당 하는 기본 키를 포함 하는 경우.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.GetChanges">
          <source>The method returns <ph id="ph1">`null`</ph> (<ph id="ph2">`Nothing`</ph> in Visual Basic) if there are no rows in the original <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> with pending changes.</source>
          <target state="translated">메서드가 반환 <ph id="ph1">`null`</ph> (<ph id="ph2">`Nothing`</ph> Visual basic에서)는 원본에서 행이 없는 경우 <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> 와 보류 중인 변경 내용.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)">
          <source>Gets a copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> containing all changes made to it since it was last loaded, or since <ph id="ph2">&lt;see cref="M:System.Data.DataTable.AcceptChanges" /&gt;</ph> was called, filtered by <ph id="ph3">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</source>
          <target state="translated">마지막으로 로드되거나 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>가 호출된 후에 변경되어 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.AcceptChanges" /&gt;</ph>를 기준으로 필터링된 내용이 모두 들어 있는 <ph id="ph3">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>의 복사본을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)">
          <source>A filtered copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> that can have actions performed on it, and later be merged back in the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using <ph id="ph3">&lt;see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /&gt;</ph>.</source>
          <target state="translated">작업을 수행한 다음 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 다시 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>에 병합할 수 있는 경우 <ph id="ph3">&lt;see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /&gt;</ph>의 필터링된 복사본을 반환합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)">
          <source>If no rows of the desired <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> are found, the method returns <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">원하는 <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> 행이 없으면 이 메서드는 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.GetChanges%2A&gt;</ph> method is used to produce a second <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> object that contains only the changes introduced into the original.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.GetChanges%2A&gt;</ph> 초를 생성 하기 위해 메서드를 사용 하는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 원래에 도입 된 변경 내용만 포함 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)">
          <source>Use the <ph id="ph1">`rowStates`</ph> argument to specify the type of changes the new object should include.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">`rowStates`</ph> 인수를 새 개체에 포함 될 변경 유형을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)">
          <source>Relationship constraints may cause unchanged parent rows to be included.</source>
          <target state="translated">관계 제약 조건 하면 변경 되지 않은 부모 행이 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph> 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)">
          <source>This method returns an <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph> instance containing the Web Services Description Language (WSDL) that describes the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> for Web Services.</source>
          <target state="translated">이 메서드는 웹 서비스의 <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph>을 설명하는 WSDL(Web Services Description Language)이 포함된 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph> 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetErrors">
          <source>Gets an array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects that contain errors.</source>
          <target state="translated">오류가 있는 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체로 이루어진 배열을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetErrors">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects that have errors.</source>
          <target state="translated">오류가 있는 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체로 이루어진 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.GetErrors">
          <source>Returns the list of <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> objects that have <ph id="ph2">&lt;xref:System.Data.DataRow.RowError%2A&gt;</ph> set.</source>
          <target state="translated">목록을 반환 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> 개체 <ph id="ph2">&lt;xref:System.Data.DataRow.RowError%2A&gt;</ph> 설정 합니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.GetErrors">
          <source>For example, errors can occur when calling <ph id="ph1">&lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;</ph> with <ph id="ph2">&lt;xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A&gt;</ph> set to <bpt id="p1">**</bpt>true<ept id="p1">**</ept>.</source>
          <target state="translated">호출할 때 오류가 발생할 수 있습니다는 예를 들어 <ph id="ph1">&lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A&gt;</ph> 로 설정 <bpt id="p1">**</bpt>true<ept id="p1">**</ept>합니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.GetErrors">
          <source>Do not invoke <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> on the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> until you resolve all errors and resubmit the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> for updating.</source>
          <target state="translated">호출 하지 말고 <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> 에 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 모든 오류를 해결 하 고 다시 전송 될 때까지 <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> 업데이트에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.GetErrors">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataTable.GetErrors%2A&gt;</ph> method to return an array of <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> objects that have errors.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Data.DataTable.GetErrors%2A&gt;</ph> 의 배열을 반환 하는 메서드 <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> 오류가 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object that holds the serialized data associated with the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>과 관련된 serialize된 개체가 들어 있는 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> object that contains the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>과 관련된 serialize된 스트림의 소스와 대상이 들어 있는 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a serialization information object with the data needed to serialize the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>을 serialize하는 데 필요한 데이터로 serialization 정보 개체를 채웁니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;paramref name="info" /&gt;</ph> parameter is a null reference (<ph id="ph2">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph>매개 변수가 null 참조(Visual Basic에서는 <ph id="ph2">&lt;see langword="Nothing" /&gt;</ph>)인 경우</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetRowType">
          <source>Gets the row type.</source>
          <target state="translated">행 형식을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetRowType">
          <source>Returns the type of the <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>의 형식을 반환합니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetSchema">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>.</source>
          <target state="translated">이 멤버에 대한 설명은 <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.GetSchema">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchema" /&gt;</ph> that describes the XML representation of the object that is produced by the <ph id="ph2">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph> method and consumed by the <ph id="ph3">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchema" /&gt;</ph> 메서드에 의해 생성되고 <ph id="ph2">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph> 메서드가 사용하는 개체의 XML 표현을 설명하는 <ph id="ph3">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.HasErrors">
          <source>Gets a value indicating whether there are errors in any of the rows in any of the tables of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to which the table belongs.</source>
          <target state="translated">해당 테이블이 속하는 <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>의 테이블에 있는 행에 오류가 있는지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.HasErrors">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if errors exist; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">오류가 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.HasErrors">
          <source>As users work on a set of data contained in a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, you can mark each change with an error if the change causes some validation failure.</source>
          <target state="translated">사용자가 작업에 포함 된 데이터 집합에는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, 변경으로 인해 일부 유효성 검사 실패 하는 경우 오류가 발생 하 여 각 변경을 표시할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.HasErrors">
          <source>You can mark an entire <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> with an error message using the <ph id="ph2">&lt;xref:System.Data.DataRow.RowError%2A&gt;</ph> property.</source>
          <target state="translated">전체를 표시할 수 있습니다 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> 사용 하 여 오류 메시지는 <ph id="ph2">&lt;xref:System.Data.DataRow.RowError%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.HasErrors">
          <source>You can also set errors on each column of the row with the <ph id="ph1">&lt;xref:System.Data.DataRow.SetColumnError%2A&gt;</ph> method.</source>
          <target state="translated">오류가 있는 행의 각 열에 설정할 수도 있습니다는 <ph id="ph1">&lt;xref:System.Data.DataRow.SetColumnError%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.HasErrors">
          <source>Before updating a data source with a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, it's recommended that you first invoke the <ph id="ph2">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method on the target <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">데이터 원본을 업데이트 하기 전에 <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>를 먼저 호출 하는 것이 좋습니다.는 <ph id="ph2">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> 대상 메서드 <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.HasErrors">
          <source>The method results in a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that contains only the changes made to the original.</source>
          <target state="translated">이렇게 한 <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 원본에 대 한 변경 내용만 포함 하 합니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.HasErrors">
          <source>Before sending the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> to the data source for updating, check the <ph id="ph2">&lt;xref:System.Data.DataTable.HasErrors%2A&gt;</ph> property of each table to see if any errors have been attached to the rows or columns in the rows.</source>
          <target state="translated">보내기 전에 <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 확인 업데이트에 대 한 데이터 원본에는 <ph id="ph2">&lt;xref:System.Data.DataTable.HasErrors%2A&gt;</ph> 각 테이블을 행 이나 행의 열에 오류가 있는지 연결 되는 경우의 속성입니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.HasErrors">
          <source>After reconciling each error, clear the errors with the <ph id="ph1">&lt;xref:System.Data.DataRow.ClearErrors%2A&gt;</ph> method of the <ph id="ph2">`DataRow`</ph>.</source>
          <target state="translated">각 오류를 해결 한 후 사용 하 여 오류를 지울는 <ph id="ph1">&lt;xref:System.Data.DataRow.ClearErrors%2A&gt;</ph> 의 메서드는 <ph id="ph2">`DataRow`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.HasErrors">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataTable.HasErrors%2A&gt;</ph> property to check if a table contains errors.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Data.DataTable.HasErrors%2A&gt;</ph> 속성을 테이블에 오류가 포함 되어 있는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ImportRow(System.Data.DataRow)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> to be imported.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ImportRow(System.Data.DataRow)">
          <source>Copies a <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> into a <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, preserving any property settings, as well as original and current values.</source>
          <target state="translated">원래 값 및 현재 값과 모든 속성 설정을 그대로 유지한 상태로 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>를 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>에 복사합니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ImportRow(System.Data.DataRow)">
          <source>Calling <ph id="ph1">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> adds a row to the table using the existing table schema, but with default values for the row, and sets the <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> to <ph id="ph3">`Detached`</ph>.</source>
          <target state="translated">호출 <ph id="ph1">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> 행에 대 한 기본값을 사용 하면서 기존 테이블 스키마를 사용 하 여 테이블 행을 추가 하 고 설정 된 <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> 를 <ph id="ph3">`Detached`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ImportRow(System.Data.DataRow)">
          <source>Calling <ph id="ph1">&lt;xref:System.Data.DataTable.ImportRow%2A&gt;</ph> preserves the existing <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> along with other values in the row.</source>
          <target state="translated">호출 <ph id="ph1">&lt;xref:System.Data.DataTable.ImportRow%2A&gt;</ph> 기존 유지 <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> 행에 다른 값과 함께 합니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ImportRow(System.Data.DataRow)">
          <source>If the <ph id="ph1">`DataRow`</ph> that is passed as a parameter is in a detached state, it is ignored, and no exception is thrown.</source>
          <target state="translated">경우는 <ph id="ph1">`DataRow`</ph> 분리 된 상태에는 매개 변수는, 무시 되 고 예외가 throw 되지 않습니다 변수로 전달 된입니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ImportRow(System.Data.DataRow)">
          <source>The new row will be added to the end of the data table.</source>
          <target state="translated">새 행의 데이터 테이블 끝에 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ImportRow(System.Data.DataRow)">
          <source>If the new row violates a Constraint it won’t be added to the data table.</source>
          <target state="translated">새 행에는 제약 조건을 위반 하는 경우에 데이터 테이블에 추가 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ImportRow(System.Data.DataRow)">
          <source>You can get the index of the new row with as DataTable.Rows.Find and DataTable.Rows.IndexOf.</source>
          <target state="translated">DataTable.Rows.Find 및 DataTable.Rows.IndexOf로 새 행의 인덱스를 가져올 수 있습니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ImportRow(System.Data.DataRow)">
          <source>See <ph id="ph1">&lt;xref:System.Data.DataRowCollection&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.Rows%2A&gt;</ph> for more information.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Data.DataRowCollection&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.Rows%2A&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="E:System.Data.DataTable.Initialized">
          <source>Occurs after the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> is initialized.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>이 초기화된 후 발생합니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.Initialized">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Data.DataTable.IsInitialized%2A&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Data.DataTable.IsInitialized%2A&gt;</ph>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.IsInitialized">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> is initialized.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>이 초기화되어 있는지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.IsInitialized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to indicate the component has completed initialization; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">구성 요소의 초기화가 완료되었음을 나타내려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.IsInitialized">
          <source>Returns the status of the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> while it’s being constructed, for instance by Visual Studio.</source>
          <target state="translated">상태를 반환 하는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 것은 생성 되 고, 예를 들어 Visual Studio에서 동안 합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.IsInitialized">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.BeginInit%2A&gt;</ph> method sets it to <ph id="ph2">`false`</ph> and <ph id="ph3">&lt;xref:System.Data.DataTable.EndInit%2A&gt;</ph> method sets it to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.BeginInit%2A&gt;</ph> 메서드를 설정 <ph id="ph2">`false`</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataTable.EndInit%2A&gt;</ph> 메서드를 설정 <ph id="ph4">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용해서 <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>을 데이터 소스의 값으로 채웁니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>If the <ph id="ph1">&lt;see langword="DataTable" /&gt;</ph> already contains rows, the incoming data from the data source is merged with the existing rows.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DataTable" /&gt;</ph>에 이미 행이 포함되어 있으면 데이터 소스에서 들어오는 데이터가 기존 행과 병합됩니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">`Load`</ph> method can be used in several common scenarios, all centered around getting data from a specified data source and adding it to the current data container (in this case, a <ph id="ph2">`DataTable`</ph>).</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 몇 가지 일반적인 시나리오는 지정 된 데이터 원본에서 데이터 가져오기 및 현재 데이터 컨테이너에 추가에서 메서드를 사용할 수 있습니다 (이 경우는 <ph id="ph2">`DataTable`</ph>).</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>These scenarios describe standard usage for a <ph id="ph1">`DataTable`</ph>, describing its update and merge behavior.</source>
          <target state="translated">에 대 한 일반 사용법을 설명 하는 이러한 시나리오는 <ph id="ph1">`DataTable`</ph>해당 업데이트를 설명 하는, 및 동작을 병합 합니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>A <ph id="ph1">`DataTable`</ph> synchronizes or updates with a single primary data source.</source>
          <target state="translated">A <ph id="ph1">`DataTable`</ph> 동기화 하거나 단일 기본 데이터 원본을 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">`DataTable`</ph> tracks changes, allowing synchronization with the primary data source.</source>
          <target state="translated"><ph id="ph1">`DataTable`</ph> 주 데이터 소스와 동기화 할 수 있도록 변경 내용을 추적 합니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>In addition, a <ph id="ph1">`DataTable`</ph> can accept incremental data from one or more secondary data sources.</source>
          <target state="translated">또한 한 <ph id="ph1">`DataTable`</ph> 하나 이상의 보조 데이터 원본의 증분 데이터를 수락할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">`DataTable`</ph> isn't responsible for tracking changes in order to allow synchronization with the secondary data source.</source>
          <target state="translated"><ph id="ph1">`DataTable`</ph> 보조 데이터 소스와 동기화 할 수 있도록 변경 내용을 추적 하지는 않습니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Given these two hypothetical data sources, a user is likely to require one of the following behaviors:</source>
          <target state="translated">이러한 두 개의 가상의 데이터 소스를 매개 변수로 받아 사용자 해야 하는 다음 동작 중 하나:</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Initialize <ph id="ph1">`DataTable`</ph> from a primary data source.</source>
          <target state="translated">초기화 <ph id="ph1">`DataTable`</ph> 주 데이터 원본에서 합니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>In this scenario, the user wants to initialize an empty <ph id="ph1">`DataTable`</ph> with values from the primary data source.</source>
          <target state="translated">이 시나리오에서 사용자는 빈 초기화 하려는 <ph id="ph1">`DataTable`</ph> 주 데이터 원본의 값으로.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Later the user intends to propagate changes back to the primary data source.</source>
          <target state="translated">나중에 사용자를 기본 데이터 소스 변경 내용을 전파 하는 것입니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Preserve changes and re-synchronize from the primary data source.</source>
          <target state="translated">변경 내용을 유지 하 고 기본 데이터 원본에서 다시 동기화 합니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>In this scenario, the user wants to take the <ph id="ph1">`DataTable`</ph> filled in the previous scenario and perform an incremental synchronization with the primary data source, preserving modifications made in the <ph id="ph2">`DataTable`</ph>.</source>
          <target state="translated">이 시나리오에서는 사용자가 수행 하는 <ph id="ph1">`DataTable`</ph> 이전 시나리오에서의 변경 내용을 유지 하는 기본 데이터 원본과 증분 동기화를 수행 채워지고는 <ph id="ph2">`DataTable`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Incremental data feed from secondary data sources.</source>
          <target state="translated">증분 데이터를 보조 데이터 원본에서 제공 합니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>In this scenario, the user wants to merge changes from one or more secondary data sources, and propagate those changes back to the primary data source.</source>
          <target state="translated">이 시나리오에서는 사용자가 하나 이상의 보조 데이터 원본에서 변경 내용을 병합 하 여 다시 주 데이터 원본에 해당 변경 내용을 전파 합니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">`Load`</ph> method makes all these scenarios possible.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드 이러한 모든 시나리오 가능 하 게 합니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>All but one of the overloads for this method allows you to specify a load option parameter, indicating how rows already in a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> combine with rows being loaded.</source>
          <target state="translated">하나를 제외한 모든 오버 로드 중에이 메서드를 사용 하면 부하 옵션 매개 변수를 지정할 수 있습니다를 나타내는 방법을 있는 행 한 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 로드 중인 행과 결합 합니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>(The overload that doesn't allow you to specify the behavior uses the default load option.) The following table describes the three load options provided by the <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> enumeration.</source>
          <target state="translated">(기본 로드 옵션의 동작을 지정할 수를 허용 하지 않는 오버 로드에 사용 합니다.) 다음 표에에서 제공 하는 세 가지 부하 옵션은 <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> 열거형입니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>In each case, the description indicates the behavior when the primary key of a row in the incoming data matches the primary key of an existing row.</source>
          <target state="translated">각각의 경우 설명 들어오는 데이터에 있는 행의 기본 키에는 기존 행의 기본 키와 일치 하는 경우 동작을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Load Option</source>
          <target state="translated">로드 옵션</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source><ph id="ph1">`PreserveChanges`</ph> (default)</source>
          <target state="translated"><ph id="ph1">`PreserveChanges`</ph>(기본값)</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Updates the original version of the row with the value of the incoming row.</source>
          <target state="translated">들어오는 행의 값을 가진 행의 원래 버전을 업데이트합니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Updates the current and original versions of the row with the value of the incoming row.</source>
          <target state="translated">들어오는 행의 값을 가진 행의 현재 버전과 원래 버전을 업데이트합니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Updates the current version of the row with the value of the incoming row.</source>
          <target state="translated">들어오는 행의 값을 가진 행의 현재 버전을 업데이트합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>In general, the <ph id="ph1">`PreserveChanges`</ph> and <ph id="ph2">`OverwriteChanges`</ph> options are intended for scenarios in which the user needs to synchronize the <ph id="ph3">`DataSet`</ph> and its changes with the primary data source.</source>
          <target state="translated">일반적으로 <ph id="ph1">`PreserveChanges`</ph> 및 <ph id="ph2">`OverwriteChanges`</ph> 옵션은 사용자를 동기화 해야 하는 시나리오에 대 한 않습니다는 <ph id="ph3">`DataSet`</ph> 및 기본 데이터 원본과 해당 변경 합니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">`Upsert`</ph> option facilitates aggregating changes from one or more secondary data sources.</source>
          <target state="translated"><ph id="ph1">`Upsert`</ph> 옵션을 하나 이상의 보조 데이터 원본에서 집계 변경 내용을 용이 하 게 합니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The following example demonstrates several of the issues involved with calling the <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 일부의 호출과 관련된 된 문제는 <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>First, the example focuses on schema issues, including inferring a schema from the loaded <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph>, and then handling incompatible schemas, and schemas with missing or additional columns.</source>
          <target state="translated">이 예제에서 로드 된 스키마를 유추 등의 스키마 문제 중점적으로 먼저 <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph>, 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The example then focuses on data issues, including handling the various loading options.</source>
          <target state="translated">다음 예에서는 데이터 문제를 처리 다양 한 로드 옵션을 포함 하 여 집중 합니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>This example shows how to use one of the overloaded versions of <ph id="ph1">`Load`</ph>.</source>
          <target state="translated">오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 주는이 예제 <ph id="ph1">`Load`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>For other examples that might be available, see the individual overload topics.</source>
          <target state="translated">사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> that provides a result set.</source>
          <target state="translated">결과 집합을 제공하는 <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용해서 <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>을 데이터 소스의 값으로 채웁니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> already contains rows, the incoming data from the data source is merged with the existing rows.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>에 이미 행이 포함되어 있으면 데이터 소스에서 들어오는 데이터가 기존 행과 병합됩니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method consumes the first result set from the loaded <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>, and after successful completion, sets the reader's position to the next result set, if any.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> 첫 번째 결과 집합에서 로드를 사용 하는 메서드 <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>, 성공적으로 완료 한 후 설정 판독기의 위치는 다음 결과 집합에 있는 경우.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>When converting data, the <ph id="ph1">`Load`</ph> method uses the same conversion rules as the <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">데이터를 변환할 때의 <ph id="ph1">`Load`</ph> 으로 같은 변환 규칙을 사용 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method must take into account three specific issues when loading the data from an <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph> instance: schema, data, and event operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> 메서드 고려해 야 문제에서 데이터를 로드할 때는 <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>When working with the schema, the <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method may encounter conditions as described in the following table.</source>
          <target state="translated">스키마와 함께 작업 하는 경우는 <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> 메서드는 다음 표에 설명 된 대로 같은 조건이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The schema operations take place for all imported result sets, even those containing no data.</source>
          <target state="translated">데이터가 포함 된 것까지 모든 가져온된 결과 집합에 대 한 스키마 작업 수행.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Condition</source>
          <target state="translated">조건</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Behavior</source>
          <target state="translated">동작</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> has no schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 에 스키마가 없습니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method infers the schema based on the result set from the imported <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> 메서드는 가져온에서 결과 집합에 따라 스키마를 유추한 <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> has a schema, but it is incompatible with the loaded schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 는 스키마, 하지만 로드 된 스키마와 호환 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> 메서드 호환 되지 않는 스키마에 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The schemas are compatible, but the loaded result set schema contains columns that do not exist in the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 되어는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method adds the extra columns to <ph id="ph2">`DataTable`</ph>'s schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> 메서드 추가 열을 추가 하는 <ph id="ph2">`DataTable`</ph>의 스키마입니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The method throws an exception if corresponding columns in the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and the loaded result set are not value compatible.</source>
          <target state="translated">에 해당 하는 경우 예외를 throw의 열은 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 로드 된 결과 집합 값이 서로 호환 되지 않으며 합니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The method also retrieves constraint information from the result set for all added columns.</source>
          <target state="translated">메서드는 또한 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Except for the case of Primary Key constraint, this constraint information is used only if the current <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> does not contain any columns at the start of the load operation.</source>
          <target state="translated">Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보를 경우에 사용 현재 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The schemas are compatible, but the loaded result set schema contains fewer columns than does the <ph id="ph1">`DataTable`</ph>.</source>
          <target state="translated">스키마가 호환 되지만 열 수보다 적은 포함 하는 로드 된 결과 집합 스키마는 <ph id="ph1">`DataTable`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>If a missing column has a default value defined or the column's data type is nullable, the <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method allows the rows to be added, substituting the default or <ph id="ph2">`null`</ph> value for the missing column.</source>
          <target state="translated">누락 된 열에 기본값이 정의 된 또는 열의 데이터 형식이 null을 허용 하는 경우는 <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> 메서드를 사용 하면 행을 추가할 수 대신 기본값이 또는 <ph id="ph2">`null`</ph> 누락 된 열에 대 한 값입니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>If no default value or <ph id="ph1">`null`</ph> can be used, then the <ph id="ph2">`Load`</ph> method throws an exception.</source>
          <target state="translated">기본값이 사용 되지 않는 경우 또는 <ph id="ph1">`null`</ph> 사용할 수 면 <ph id="ph2">`Load`</ph> 메서드에서 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>If no specific default value has been supplied, the <ph id="ph1">`Load`</ph> method uses the <ph id="ph2">`null`</ph> value as the implied default value.</source>
          <target state="translated">특정 기본 값을 제공 하는 경우는 <ph id="ph1">`Load`</ph> 메서드는 <ph id="ph2">`null`</ph> 암시 된 기본값으로 값입니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Before considering the behavior of the <ph id="ph1">`Load`</ph> method in terms of data operations, consider that each row within a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> maintains both the current value and the original value for each column.</source>
          <target state="translated">동작을 고려 하기 전에 <ph id="ph1">`Load`</ph> 메서드 데이터 작업을 고려 하는 각 행 내에서 한 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 현재 값과 각 열에 대 한 원래 값이 모두 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>These values may be equivalent, or may be different if the data in the row has been changed since filling the <ph id="ph1">`DataTable`</ph>.</source>
          <target state="translated">이러한 값 같을 수도 있지만, 또는 데이터 행에 채워진 후 변경 된 경우에 다를 수 있습니다는 <ph id="ph1">`DataTable`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>For more information, see <bpt id="p1">[</bpt>Row States and Row Versions<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>행 상태 및 행 버전<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>This version of the <ph id="ph1">`Load`</ph> method attempts to preserve the current values in each row, leaving the original value intact.</source>
          <target state="translated">이 버전의는 <ph id="ph1">`Load`</ph> 메서드는 원래 값을 그대로 두고 각 행의 현재 값을 유지 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>(If you want finer control over the behavior of incoming data, see <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType&gt;</ph>.) If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.</source>
          <target state="translated">(들어오는 데이터의 동작을 보다 자세히 제어 하려면 참조 <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType&gt;</ph>.) 기존 행과 들어오는 행에 해당 기본 키 값이 있으면의 현재 행 상태 값을 사용 하는 행을 처리 하는, 그렇지 않으면 새 행으로 처리 합니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>In terms of event operations, the <ph id="ph1">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph> event occurs before each row is changed, and the <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanged&gt;</ph> event occurs after each row has been changed.</source>
          <target state="translated">이벤트 작업의 경우는 <ph id="ph1">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph> 각 행이 변경 되기 전에 이벤트 발생 및 <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanged&gt;</ph> 이벤트는 각 행이 변경 된 후 발생 합니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>In each case, the <ph id="ph1">&lt;xref:System.Data.DataRowChangeEventArgs.Action%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Data.DataRowChangeEventArgs&gt;</ph> instance passed to the event handler contains information about the particular action associated with the event.</source>
          <target state="translated">각각의 경우에는 <ph id="ph1">&lt;xref:System.Data.DataRowChangeEventArgs.Action%2A&gt;</ph> 속성은 <ph id="ph2">&lt;xref:System.Data.DataRowChangeEventArgs&gt;</ph> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 관련 된 특정 작업에 대 한 정보를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>This action value depends on the state of the row before the load operation.</source>
          <target state="translated">이 작업 값 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>In each case, both events occur, and the action is the same for each.</source>
          <target state="translated">각각의 경우에서 두 이벤트가 발생 하 고 각각에 대해 동일한 동작입니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The action may be applied to either the current or original version of each row, or both, depending on the current row state.</source>
          <target state="translated">작업은 각 행의 현재 또는 원래의 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The following table displays behavior for the <ph id="ph1">`Load`</ph> method.</source>
          <target state="translated">다음 표에서 동작을 보여 줍니다는 <ph id="ph1">`Load`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The final row (labeled "(Not present)") describes the behavior for incoming rows that don't match any existing row.</source>
          <target state="translated">("(없음)" 라는) 마지막 행 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작에 설명 합니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Each cell in this table describes the current and original value for a field within a row, along with the <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> for the value after the <ph id="ph2">`Load`</ph> method has completed.</source>
          <target state="translated">와 함께 행의 필드에 대 한 현재 및 원래 값을 설명 하는이 테이블의 각 셀의 <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> 후의 값에 대 한는 <ph id="ph2">`Load`</ph> 메서드가 완료 합니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>In this case, the method doesn't allow you to indicate the load option, and uses the default, <ph id="ph1">`PreserveChanges`</ph>.</source>
          <target state="translated">이 경우 메서드가 로드 옵션을 지정할 수 하 고 기본적으로 사용 <ph id="ph1">`PreserveChanges`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Existing DataRowState</source>
          <target state="translated">기존 DataRowState</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Values after <ph id="ph1">`Load`</ph> method, and event action</source>
          <target state="translated">완료 후의 값 <ph id="ph1">`Load`</ph> 메서드와 이벤트 동작</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Added</source>
          <target state="translated">추가됨</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Current = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>State = <ph id="ph1">\&lt;</ph>Modified&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>수정 &gt;</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>RowAction = ChangeOriginal</source>
          <target state="translated">RowAction = ChangeOriginal</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Modified</source>
          <target state="translated">수정한 날짜</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Current = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>State = <ph id="ph1">\&lt;</ph>Modified&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>수정 &gt;</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>RowAction = ChangeOriginal</source>
          <target state="translated">RowAction = ChangeOriginal</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Deleted</source>
          <target state="translated">삭제됨</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Current = <ph id="ph1">\&lt;</ph>Not available&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>사용할 수 없음 &gt;</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>State = <ph id="ph1">\&lt;</ph>Deleted&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>삭제 &gt;</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>RowAction = ChangeOriginal</source>
          <target state="translated">RowAction = ChangeOriginal</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Unchanged</source>
          <target state="translated">Unchanged</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>(Not present)</source>
          <target state="translated">(없음)</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Values in a <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> can be constrained through use of properties such as <ph id="ph2">&lt;xref:System.Data.DataColumn.ReadOnly%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataColumn.AutoIncrement%2A&gt;</ph>.</source>
          <target state="translated">값에 <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> 와 같은 속성을 사용 하 여 제한 될 수 <ph id="ph2">&lt;xref:System.Data.DataColumn.ReadOnly%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataColumn.AutoIncrement%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The <ph id="ph1">`Load`</ph> method handles such columns in a manner that is consistent with the behavior defined by the column's properties.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드 열의 속성에 의해 정의 된 동작에 일치 하는 방식으로 해당 열을 처리 합니다.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The read only constraint on a <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> is applicable only for changes that occur in memory.</source>
          <target state="translated">에 읽기 전용 제약은 <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> 메모리에 발생 하는 변경에만 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The <ph id="ph1">`Load`</ph> method's overwrites the read-only column values, if needed.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드는 필요에 따라 읽기 전용 열 값을 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>To determine which version of the primary key field to use for comparing the current row with an incoming row, the <ph id="ph1">`Load`</ph> method uses the original version of the primary key value within a row, if it exists.</source>
          <target state="translated">현재 행과 들어오는 행을 비교 하는 데 사용할 기본 키 필드의 버전을 확인 하 고 <ph id="ph1">`Load`</ph> 있는 경우 메서드는 행의 기본 키 값의 원래 버전을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>Otherwise, the <ph id="ph1">`Load`</ph> method uses the current version of the primary key field.</source>
          <target state="translated">그렇지 않은 경우는 <ph id="ph1">`Load`</ph> 메서드는 기본 키 필드의 현재 버전을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The following example demonstrates several of the issues involved with calling the <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 일부의 호출과 관련된 된 문제는 <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>First, the example focuses on schema issues, including inferring a schema from the loaded <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph>, and then handling incompatible schemas, and schemas with missing or additional columns.</source>
          <target state="translated">이 예제에서 로드 된 스키마를 유추 등의 스키마 문제 중점적으로 먼저 <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph>, 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader)">
          <source>The example then calls the <ph id="ph1">`Load`</ph> method, displaying the data both before and after the load operation.</source>
          <target state="translated">이 예에서는 다음 호출에서 <ph id="ph1">`Load`</ph> 메서드를 이전과 이후에 로드 작업의 데이터를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> that provides one or more result sets.</source>
          <target state="translated">하나 이상의 결과 집합을 제공하는 <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>A value from the <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> enumeration that indicates how rows already in the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> are combined with incoming rows that share the same primary key.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> 열거형의 값으로서, 이미 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용해서 <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>을 데이터 소스의 값으로 채웁니다.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>If the <ph id="ph1">&lt;see langword="DataTable" /&gt;</ph> already contains rows, the incoming data from the data source is merged with the existing rows according to the value of the <ph id="ph2">&lt;paramref name="loadOption" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DataTable" /&gt;</ph>에 이미 행이 포함되어 있으면 데이터 소스에서 들어오는 데이터는 <ph id="ph2">&lt;paramref name="loadOption" /&gt;</ph> 매개 변수의 값에 따라 기존 행과 병합됩니다.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The <ph id="ph1">`Load`</ph> method consumes the first result set from the loaded <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>, and after successful completion, sets the reader's position to the next result set, if any.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 첫 번째 결과 집합에서 로드를 사용 하는 메서드 <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>, 성공적으로 완료 한 후 설정 판독기의 위치는 다음 결과 집합에 있는 경우.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>When converting data, the <ph id="ph1">`Load`</ph> method uses the same conversion rules as the <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> method.</source>
          <target state="translated">데이터를 변환할 때의 <ph id="ph1">`Load`</ph> 으로 같은 변환 규칙을 사용 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The <ph id="ph1">`Load`</ph> method must take into account three specific issues when loading the data from an <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph> instance: schema, data, and event operations.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드 고려해 야 문제에서 데이터를 로드할 때는 <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>When working with the schema, the <ph id="ph1">`Load`</ph> method may encounter conditions as described in the following table.</source>
          <target state="translated">스키마와 함께 작업 하는 경우는 <ph id="ph1">`Load`</ph> 메서드는 다음 표에 설명 된 대로 같은 조건이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The schema operations take place for all imported result sets, even those containing no data.</source>
          <target state="translated">데이터가 포함 된 것까지 모든 가져온된 결과 집합에 대 한 스키마 작업 수행.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Condition</source>
          <target state="translated">조건</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Behavior</source>
          <target state="translated">동작</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> has no schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 에 스키마가 없습니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The <ph id="ph1">`Load`</ph> method infers the schema based on the result set from the imported <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드는 가져온에서 결과 집합에 따라 스키마를 유추한 <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> has a schema, but it is incompatible with the loaded schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 는 스키마, 하지만 로드 된 스키마와 호환 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The <ph id="ph1">`Load`</ph> method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드 호환 되지 않는 스키마에 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The schemas are compatible, but the loaded result set schema contains columns that don't exist in the <ph id="ph1">`DataTable`</ph>.</source>
          <target state="translated">스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 되어는 <ph id="ph1">`DataTable`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The <ph id="ph1">`Load`</ph> method adds the extra columns to <ph id="ph2">`DataTable`</ph>’s schema.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드 추가 열을 추가 하는 <ph id="ph2">`DataTable`</ph>의 스키마입니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The method throws an exception if corresponding columns in the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and the loaded result set are not value compatible.</source>
          <target state="translated">에 해당 하는 경우 예외를 throw의 열은 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 로드 된 결과 집합 값이 서로 호환 되지 않으며 합니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The method also retrieves constraint information from the result set for all added columns.</source>
          <target state="translated">메서드는 또한 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Except for the case of Primary Key constraint, this constraint information is used only if the current <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> does not contain any columns at the start of the load operation.</source>
          <target state="translated">Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보를 경우에 사용 현재 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The schemas are compatible, but the loaded result set schema contains fewer columns than does the <ph id="ph1">`DataTable`</ph>.</source>
          <target state="translated">스키마가 호환 되지만 열 수보다 적은 포함 하는 로드 된 결과 집합 스키마는 <ph id="ph1">`DataTable`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>If a missing column has a default value defined or the column's data type is nullable, the <ph id="ph1">`Load`</ph> method allows the rows to be added, substituting the default or null value for the missing column.</source>
          <target state="translated">누락 된 열에 기본값이 정의 된 또는 열의 데이터 형식이 null을 허용 하는 경우는 <ph id="ph1">`Load`</ph> 메서드를 사용 하면 행을 추가할 수는 누락 된 열에 대 한 default 또는 null 값을 대체 합니다.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>If no default value or null can be used, then the <ph id="ph1">`Load`</ph> method throws an exception.</source>
          <target state="translated">기본값이 없거나 null를 사용할 수 경우 하면 <ph id="ph1">`Load`</ph> 메서드에서 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>If no specific default value has been supplied, the <ph id="ph1">`Load`</ph> method uses the null value as the implied default value.</source>
          <target state="translated">특정 기본 값을 제공 하는 경우는 <ph id="ph1">`Load`</ph> 메서드는 암시적된 기본 값으로 null 값을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Before considering the behavior of the <ph id="ph1">`Load`</ph> method in terms of data operations, consider that each row within a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> maintains both the current value and the original value for each column.</source>
          <target state="translated">동작을 고려 하기 전에 <ph id="ph1">`Load`</ph> 메서드 데이터 작업을 고려 하는 각 행 내에서 한 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 현재 값과 각 열에 대 한 원래 값이 모두 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>These values may be equivalent, or may be different if the data in the row has been changed since filling the <ph id="ph1">`DataTable`</ph>.</source>
          <target state="translated">이러한 값 같을 수도 있지만, 또는 데이터 행에 채워진 후 변경 된 경우에 다를 수 있습니다는 <ph id="ph1">`DataTable`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>See <bpt id="p1">[</bpt>Row States and Row Versions<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)</ept> for more information.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>행 상태 및 행 버전<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)</ept> 자세한 정보에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>In this method call, the specified <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> parameter influences the processing of the incoming data.</source>
          <target state="translated">지정된 된이 메서드 호출에서 <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> 매개 변수는 들어오는 데이터의 처리에 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>How should the Load method handle loading rows that have the same primary key as existing rows?</source>
          <target state="translated">Load 메서드 로드가 있는 행을 기존 행과 동일한 기본 키를 어떻게 처리 해야 합니까?</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Should it modify current values, original values, or both?</source>
          <target state="translated">현재 값, 원래 값 또는 둘 다 수정 해야?</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>These issues, and more, are controlled by the <ph id="ph1">`loadOption`</ph> parameter.</source>
          <target state="translated">이러한 문제 등으로 제어 되는 <ph id="ph1">`loadOption`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.</source>
          <target state="translated">기존 행과 들어오는 행에 해당 기본 키 값이 있으면의 현재 행 상태 값을 사용 하는 행을 처리 하는, 그렇지 않으면 새 행으로 처리 합니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>In terms of event operations, the <ph id="ph1">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph> event occurs before each row is changed, and the <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanged&gt;</ph> event occurs after each row has been changed.</source>
          <target state="translated">이벤트 작업의 경우는 <ph id="ph1">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph> 각 행이 변경 되기 전에 이벤트 발생 및 <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanged&gt;</ph> 이벤트는 각 행이 변경 된 후 발생 합니다.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>In each case, the <ph id="ph1">&lt;xref:System.Data.DataRowChangeEventArgs.Action%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Data.DataRowChangeEventArgs&gt;</ph> instance passed to the event handler contains information about the particular action associated with the event.</source>
          <target state="translated">각각의 경우에는 <ph id="ph1">&lt;xref:System.Data.DataRowChangeEventArgs.Action%2A&gt;</ph> 속성은 <ph id="ph2">&lt;xref:System.Data.DataRowChangeEventArgs&gt;</ph> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 관련 된 특정 작업에 대 한 정보를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>This action value varies, depending on the state of the row before the load operation.</source>
          <target state="translated">이 작업 값 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>In each case, both events occur, and the action is the same for each.</source>
          <target state="translated">각각의 경우에서 두 이벤트가 발생 하 고 각각에 대해 동일한 동작입니다.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The action may be applied to either the current or original version of each row, or both, depending on the current row state.</source>
          <target state="translated">작업은 각 행의 현재 또는 원래의 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The following table displays behavior for the Load method when called with each of the <ph id="ph1">`LoadOption`</ph> values, and also shows how the values interact with the row state for the row being loaded.</source>
          <target state="translated">다음 표에 각각의 경우에 Load 메서드에서 대 한 동작은 <ph id="ph1">`LoadOption`</ph> 값, 및 값 로드 중인 행에 대 한 행 상태와 상호 작용 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The final row (labeled "(Not present)") describes the behavior for incoming rows that don't match any existing row.</source>
          <target state="translated">("(없음)" 라는) 마지막 행 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작에 설명 합니다.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Each cell in this table describes the current and original value for a field within a row, along with the <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> for the value after the <ph id="ph2">`Load`</ph> method has completed.</source>
          <target state="translated">와 함께 행의 필드에 대 한 현재 및 원래 값을 설명 하는이 테이블의 각 셀의 <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> 후의 값에 대 한는 <ph id="ph2">`Load`</ph> 메서드가 완료 합니다.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Existing DataRowState</source>
          <target state="translated">기존 DataRowState</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Upsert</source>
          <target state="translated">Upsert</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>OverwriteChanges</source>
          <target state="translated">OverwriteChanges</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>PreserveChanges (Default behavior)</source>
          <target state="translated">PreserveChanges (기본 동작)</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Added</source>
          <target state="translated">추가됨</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = -<ph id="ph1">\&lt;</ph>Not available&gt;</source>
          <target state="translated">원래 =-<ph id="ph1">\&lt;</ph>사용할 수 없음 &gt;</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Added&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>추가 &gt;</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = Change</source>
          <target state="translated">RowAction = 변경</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Modified&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>수정 &gt;</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = ChangeOriginal</source>
          <target state="translated">RowAction = ChangeOriginal</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Modified</source>
          <target state="translated">수정한 날짜</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Modified&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>수정 &gt;</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = Change</source>
          <target state="translated">RowAction = 변경</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Modified&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>수정 &gt;</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction =ChangeOriginal</source>
          <target state="translated">RowAction =ChangeOriginal</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>eleted</source>
          <target state="translated">파일과</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>(Load does not affect deleted rows)</source>
          <target state="translated">(부하는 행을 삭제 하는 영향을 하지 않는)</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = ---</source>
          <target state="translated">현재 =--</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Deleted&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>삭제 &gt;</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>(New row is added with the following characteristics)</source>
          <target state="translated">(다음 특징을 가진 새 행이 추가 됨)</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Not available&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>사용할 수 없음 &gt;</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Added&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>추가 &gt;</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = Add</source>
          <target state="translated">RowAction = Add</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Undo delete and</source>
          <target state="translated">삭제를 취소 하 고</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Not available&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>사용할 수 없음 &gt;</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Deleted&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>삭제 &gt;</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = ChangeOriginal</source>
          <target state="translated">RowAction = ChangeOriginal</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Unchanged</source>
          <target state="translated">Unchanged</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>If new value is the same as the existing value then</source>
          <target state="translated">새 값 동일한 경우 기존 값과 다음</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = Nothing</source>
          <target state="translated">RowAction = Nothing</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Else</source>
          <target state="translated">Else</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Modified&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>수정 &gt;</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = Change</source>
          <target state="translated">RowAction = 변경</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Not present)</source>
          <target state="translated">없음)</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Not available&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>사용할 수 없음 &gt;</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Added&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>추가 &gt;</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = Add</source>
          <target state="translated">RowAction = Add</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Values in a <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> can be constrained through use of properties such as <ph id="ph2">&lt;xref:System.Data.DataColumn.ReadOnly%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataColumn.AutoIncrement%2A&gt;</ph>.</source>
          <target state="translated">값에 <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> 와 같은 속성을 사용 하 여 제한 될 수 <ph id="ph2">&lt;xref:System.Data.DataColumn.ReadOnly%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataColumn.AutoIncrement%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The <ph id="ph1">`Load`</ph> method handles such columns in a manner that is consistent with the behavior defined by the column's properties.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드 열의 속성에 의해 정의 된 동작에 일치 하는 방식으로 해당 열을 처리 합니다.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The read only constraint on a <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> is applicable only for changes that occur in memory.</source>
          <target state="translated">에 읽기 전용 제약은 <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> 메모리에 발생 하는 변경에만 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The <ph id="ph1">`Load`</ph> method's overwrites the read-only column values, if needed.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드는 필요에 따라 읽기 전용 열 값을 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>If you specify the OverwriteChanges or PreserveChanges options when calling the <ph id="ph1">`Load`</ph> method, then the assumption is made that the incoming data is coming from the <ph id="ph2">`DataTable`</ph>'s primary data source, and the DataTable tracks changes and can propagate the changes back to the data source.</source>
          <target state="translated">호출할 때 OverwriteChanges 또는 PreserveChanges 옵션을 지정 하는 경우는 <ph id="ph1">`Load`</ph> 메서드, 다음 가정을 들어오는 데이터에서 제공 되 수행 되는 <ph id="ph2">`DataTable`</ph>의 주 데이터 원본 및 데이터 테이블의 변경 내용을 추적 하 고 전파할 수 데이터 소스에 다시 변경 합니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>If you select the Upsert option, it is assumed that the data is coming from one of a secondary data source, such as data provided by a middle-tier component, perhaps altered by a user.</source>
          <target state="translated">Upsert 옵션을 선택 하면 데이터는 사용자에 의해 변경 된 중간 계층 구성 요소에서 제공 하는 데이터와 같은 보조 데이터 원본 중 하나에서 제공 됩니다 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>In this case, the assumption is that the intent is to aggregate data from one or more data sources in the <ph id="ph1">`DataTable`</ph>, and then perhaps propagate the data back to the primary data source.</source>
          <target state="translated">이 경우 가정은 하나 이상의 데이터 원본에서 데이터를 집계 의도는 <ph id="ph1">`DataTable`</ph>, 다음 데이터는 주 데이터 원본에 다시 전파 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> parameter is used for determining the specific version of the row that is to be used for primary key comparison.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> 기본 키 비교에 사용 되는 행의 특정 버전을 확인 하기 위한 매개 변수를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The table below provides the details.</source>
          <target state="translated">다음 표에서 세부 정보를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Load option</source>
          <target state="translated">로드 옵션</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>DataRow version used for primary key comparison</source>
          <target state="translated">기본 키 비교에 사용 되는 DataRow 버전</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original version, if it exists, otherwise Current version</source>
          <target state="translated">있는 경우의 원래 버전, 그렇지 않으면 현재 버전</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Original version, if it exists, otherwise Current version</source>
          <target state="translated">있는 경우의 원래 버전, 그렇지 않으면 현재 버전</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>Current version, if it exists, otherwise Original version</source>
          <target state="translated">현재 버전에 있는 경우, 그렇지 않으면 원본 버전</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The following example demonstrates several of the issues involved with calling the <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 일부의 호출과 관련된 된 문제는 <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>First, the example focuses on schema issues, including inferring a schema from the loaded <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph>, and then handling incompatible schemas, and schemas with missing or additional columns.</source>
          <target state="translated">이 예제에서 로드 된 스키마를 유추 등의 스키마 문제 중점적으로 먼저 <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph>, 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)">
          <source>The example then focuses on data issues, including handling the various loading options.</source>
          <target state="translated">다음 예에서는 데이터 문제를 처리 다양 한 로드 옵션을 포함 하 여 집중 합니다.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> that provides a result set.</source>
          <target state="translated">결과 집합을 제공하는 <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>A value from the <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> enumeration that indicates how rows already in the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> are combined with incoming rows that share the same primary key.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> 열거형의 값으로서, 이미 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.FillErrorEventHandler" /&gt;</ph> delegate to call when an error occurs while loading data.</source>
          <target state="translated">데이터를 로드하는 동안 오류가 발생하면 호출할 <ph id="ph1">&lt;see cref="T:System.Data.FillErrorEventHandler" /&gt;</ph> 대리자입니다.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> using an error-handling delegate.</source>
          <target state="translated">오류 처리 대리자를 사용하는 제공된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용해서 <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>을 데이터 소스의 값으로 채웁니다.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">`Load`</ph> method consumes the first result set from the loaded <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>, and after successful completion, sets the reader's position to the next result set, if any.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 첫 번째 결과 집합에서 로드를 사용 하는 메서드 <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>, 성공적으로 완료 한 후 설정 판독기의 위치는 다음 결과 집합에 있는 경우.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>When converting data, the <ph id="ph1">`Load`</ph> method uses the same conversion rules as the <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">데이터를 변환할 때의 <ph id="ph1">`Load`</ph> 으로 같은 변환 규칙을 사용 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">`Load`</ph> method must take into account three specific issues when loading the data from an <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph> instance: schema, data, and event operations.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드 고려해 야 문제에서 데이터를 로드할 때는 <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>When working with the schema, the <ph id="ph1">`Load`</ph> method may encounter conditions as described in the following table.</source>
          <target state="translated">스키마와 함께 작업 하는 경우는 <ph id="ph1">`Load`</ph> 메서드는 다음 표에 설명 된 대로 같은 조건이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The schema operations take place for all imported result sets, even those containing no data.</source>
          <target state="translated">데이터가 포함 된 것까지 모든 가져온된 결과 집합에 대 한 스키마 작업 수행.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Condition</source>
          <target state="translated">조건</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Behavior</source>
          <target state="translated">동작</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> has no schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 에 스키마가 없습니다.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">`Load`</ph> method infers the schema based on the result set from the imported <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드는 가져온에서 결과 집합에 따라 스키마를 유추한 <ph id="ph2">&lt;xref:System.Data.IDataReader&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> has a schema, but it is incompatible with the loaded schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 는 스키마, 하지만 로드 된 스키마와 호환 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">`Load`</ph> method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드 호환 되지 않는 스키마에 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The schemas are compatible, but the loaded result set schema contains columns that don't exist in the <ph id="ph1">`DataTable`</ph>.</source>
          <target state="translated">스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 되어는 <ph id="ph1">`DataTable`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">`Load`</ph> method adds the extra column(s) to <ph id="ph2">`DataTable`</ph>’s schema.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 여분의 열을 추가 하는 메서드 <ph id="ph2">`DataTable`</ph>의 스키마입니다.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The method throws an exception if corresponding columns in the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and the loaded result set are not value compatible.</source>
          <target state="translated">에 해당 하는 경우 예외를 throw의 열은 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 로드 된 결과 집합 값이 서로 호환 되지 않으며 합니다.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The method also retrieves constraint information from the result set for all added columns.</source>
          <target state="translated">메서드는 또한 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Except for the case of Primary Key constraint, this constraint information is used only if the current <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> does not contain any columns at the start of the load operation.</source>
          <target state="translated">Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보를 경우에 사용 현재 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The schemas are compatible, but the loaded result set schema contains fewer columns than does the <ph id="ph1">`DataTable`</ph>.</source>
          <target state="translated">스키마가 호환 되지만 열 수보다 적은 포함 하는 로드 된 결과 집합 스키마는 <ph id="ph1">`DataTable`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>If a missing column has a default value defined or the column's data type is nullable, the <ph id="ph1">`Load`</ph> method allows the rows to be added, substituting the default or null value for the missing column.</source>
          <target state="translated">누락 된 열에 기본값이 정의 된 또는 열의 데이터 형식이 null을 허용 하는 경우는 <ph id="ph1">`Load`</ph> 메서드를 사용 하면 행을 추가할 수는 누락 된 열에 대 한 default 또는 null 값을 대체 합니다.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>If no default value or null can be used, then the <ph id="ph1">`Load`</ph> method throws an exception.</source>
          <target state="translated">기본값이 없거나 null를 사용할 수 경우 하면 <ph id="ph1">`Load`</ph> 메서드에서 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>If no specific default value has been supplied, the <ph id="ph1">`Load`</ph> method uses the null value as the implied default value.</source>
          <target state="translated">특정 기본 값을 제공 하는 경우는 <ph id="ph1">`Load`</ph> 메서드는 암시적된 기본 값으로 null 값을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Before considering the behavior of the <ph id="ph1">`Load`</ph> method in terms of data operations, consider that each row within a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> maintains both the current value and the original value for each column.</source>
          <target state="translated">동작을 고려 하기 전에 <ph id="ph1">`Load`</ph> 메서드 데이터 작업을 고려 하는 각 행 내에서 한 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 현재 값과 각 열에 대 한 원래 값이 모두 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>These values may be equivalent, or may be different if the data in the row has been changed since filling the <ph id="ph1">`DataTable`</ph>.</source>
          <target state="translated">이러한 값 같을 수도 있지만, 또는 데이터 행에 채워진 후 변경 된 경우에 다를 수 있습니다는 <ph id="ph1">`DataTable`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>See <bpt id="p1">[</bpt>Row States and Row Versions<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)</ept> for more information.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>행 상태 및 행 버전<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)</ept> 자세한 정보에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>In this method call, the specified <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> parameter influences the processing of the incoming data.</source>
          <target state="translated">지정된 된이 메서드 호출에서 <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> 매개 변수는 들어오는 데이터의 처리에 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>How should the Load method handle loading rows that have the same primary key as existing rows?</source>
          <target state="translated">Load 메서드 로드가 있는 행을 기존 행과 동일한 기본 키를 어떻게 처리 해야 합니까?</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Should it modify current values, original values, or both?</source>
          <target state="translated">현재 값, 원래 값 또는 둘 다 수정 해야?</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>These issues, and more, are controlled by the <ph id="ph1">`loadOption`</ph> parameter.</source>
          <target state="translated">이러한 문제 등으로 제어 되는 <ph id="ph1">`loadOption`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.</source>
          <target state="translated">기존 행과 들어오는 행에 해당 기본 키 값이 있으면의 현재 행 상태 값을 사용 하는 행을 처리 하는, 그렇지 않으면 새 행으로 처리 합니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>In terms of event operations, the <ph id="ph1">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph> event occurs before each row is changed, and the <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanged&gt;</ph> event occurs after each row has been changed.</source>
          <target state="translated">이벤트 작업의 경우는 <ph id="ph1">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph> 각 행이 변경 되기 전에 이벤트 발생 및 <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanged&gt;</ph> 이벤트는 각 행이 변경 된 후 발생 합니다.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>In each case, the <ph id="ph1">&lt;xref:System.Data.DataRowChangeEventArgs.Action%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Data.DataRowChangeEventArgs&gt;</ph> instance passed to the event handler contains information about the particular action associated with the event.</source>
          <target state="translated">각각의 경우에는 <ph id="ph1">&lt;xref:System.Data.DataRowChangeEventArgs.Action%2A&gt;</ph> 속성은 <ph id="ph2">&lt;xref:System.Data.DataRowChangeEventArgs&gt;</ph> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 관련 된 특정 작업에 대 한 정보를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>This action value varies, depending on the state of the row before the load operation.</source>
          <target state="translated">이 작업 값 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>In each case, both events occur, and the action is the same for each.</source>
          <target state="translated">각각의 경우에서 두 이벤트가 발생 하 고 각각에 대해 동일한 동작입니다.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The action may be applied to either the current or original version of each row, or both, depending on the current row state.</source>
          <target state="translated">작업은 각 행의 현재 또는 원래의 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The following table displays behavior for the Load method when called with each of the <ph id="ph1">`LoadOption`</ph> values, and also shows how the values interact with the row state for the row being loaded.</source>
          <target state="translated">다음 표에 각각의 경우에 Load 메서드에서 대 한 동작은 <ph id="ph1">`LoadOption`</ph> 값, 및 값 로드 중인 행에 대 한 행 상태와 상호 작용 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The final row (labeled "(Not present)") describes the behavior for incoming rows that don't match any existing row.</source>
          <target state="translated">("(없음)" 라는) 마지막 행 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작에 설명 합니다.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Each cell in this table describes the current and original value for a field within a row, along with the <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> for the value after the <ph id="ph2">`Load`</ph> method has completed.</source>
          <target state="translated">와 함께 행의 필드에 대 한 현재 및 원래 값을 설명 하는이 테이블의 각 셀의 <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> 후의 값에 대 한는 <ph id="ph2">`Load`</ph> 메서드가 완료 합니다.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Existing DataRowState</source>
          <target state="translated">기존 DataRowState</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Upsert</source>
          <target state="translated">Upsert</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>OverwriteChanges</source>
          <target state="translated">OverwriteChanges</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>PreserveChanges (Default behavior)</source>
          <target state="translated">PreserveChanges (기본 동작)</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Added</source>
          <target state="translated">추가됨</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = -<ph id="ph1">\&lt;</ph>Not available&gt;</source>
          <target state="translated">원래 =-<ph id="ph1">\&lt;</ph>사용할 수 없음 &gt;</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Added&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>추가 &gt;</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = Change</source>
          <target state="translated">RowAction = 변경</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Modified&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>수정 &gt;</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = ChangeOriginal</source>
          <target state="translated">RowAction = ChangeOriginal</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Modified</source>
          <target state="translated">수정한 날짜</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Modified&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>수정 &gt;</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = Change</source>
          <target state="translated">RowAction = 변경</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Modified&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>수정 &gt;</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction =ChangeOriginal</source>
          <target state="translated">RowAction =ChangeOriginal</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>eleted</source>
          <target state="translated">파일과</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>(Load does not affect deleted rows)</source>
          <target state="translated">(부하는 행을 삭제 하는 영향을 하지 않는)</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = ---</source>
          <target state="translated">현재 =--</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Deleted&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>삭제 &gt;</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>(New row is added with the following characteristics)</source>
          <target state="translated">(다음 특징을 가진 새 행이 추가 됨)</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Not available&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>사용할 수 없음 &gt;</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Added&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>추가 &gt;</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = Add</source>
          <target state="translated">RowAction = Add</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Undo delete and</source>
          <target state="translated">삭제를 취소 하 고</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Not available&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>사용할 수 없음 &gt;</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Deleted&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>삭제 &gt;</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = ChangeOriginal</source>
          <target state="translated">RowAction = ChangeOriginal</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Unchanged</source>
          <target state="translated">Unchanged</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Existing&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>기존 &gt;</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>If new value is the same as the existing value then</source>
          <target state="translated">새 값 동일한 경우 기존 값과 다음</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = Nothing</source>
          <target state="translated">RowAction = Nothing</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Else</source>
          <target state="translated">Else</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Modified&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>수정 &gt;</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = Change</source>
          <target state="translated">RowAction = 변경</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Not present)</source>
          <target state="translated">없음)</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Not available&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>사용할 수 없음 &gt;</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Added&gt;</source>
          <target state="translated">상태 = <ph id="ph1">\&lt;</ph>추가 &gt;</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = Add</source>
          <target state="translated">RowAction = Add</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">현재 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original = <ph id="ph1">\&lt;</ph>Incoming&gt;</source>
          <target state="translated">원래 = <ph id="ph1">\&lt;</ph>들어오는 &gt;</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</source>
          <target state="translated">State = <ph id="ph1">\&lt;</ph>Unchanged&gt;</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>RowAction = ChangeCurrentAndOriginal</source>
          <target state="translated">RowAction = ChangeCurrentAndOriginal</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Values in a <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> can be constrained through use of properties such as <ph id="ph2">&lt;xref:System.Data.DataColumn.ReadOnly%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataColumn.AutoIncrement%2A&gt;</ph>.</source>
          <target state="translated">값에 <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> 와 같은 속성을 사용 하 여 제한 될 수 <ph id="ph2">&lt;xref:System.Data.DataColumn.ReadOnly%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataColumn.AutoIncrement%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">`Load`</ph> method handles such columns in a manner that is consistent with the behavior defined by the column's properties.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드 열의 속성에 의해 정의 된 동작에 일치 하는 방식으로 해당 열을 처리 합니다.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The read only constraint on a <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> is applicable only for changes that occur in memory.</source>
          <target state="translated">에 읽기 전용 제약은 <ph id="ph1">&lt;xref:System.Data.DataColumn&gt;</ph> 메모리에 발생 하는 변경에만 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">`Load`</ph> method's overwrites the read-only column values, if needed.</source>
          <target state="translated"><ph id="ph1">`Load`</ph> 메서드는 필요에 따라 읽기 전용 열 값을 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>If you specify the OverwriteChanges or PreserveChanges options when calling the <ph id="ph1">`Load`</ph> method, then the assumption is made that the incoming data is coming from the <ph id="ph2">`DataTable`</ph>'s primary data source, and the DataTable tracks changes and can propagate the changes back to the data source.</source>
          <target state="translated">호출할 때 OverwriteChanges 또는 PreserveChanges 옵션을 지정 하는 경우는 <ph id="ph1">`Load`</ph> 메서드, 다음 가정을 들어오는 데이터에서 제공 되 수행 되는 <ph id="ph2">`DataTable`</ph>의 주 데이터 원본 및 데이터 테이블의 변경 내용을 추적 하 고 전파할 수 데이터 소스에 다시 변경 합니다.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>If you select the Upsert option, it is assumed that the data is coming from one of a secondary data source, such as data provided by a middle-tier component, perhaps altered by a user.</source>
          <target state="translated">Upsert 옵션을 선택 하면 데이터는 사용자에 의해 변경 된 중간 계층 구성 요소에서 제공 하는 데이터와 같은 보조 데이터 원본 중 하나에서 제공 됩니다 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>In this case, the assumption is that the intent is to aggregate data from one or more data sources in the <ph id="ph1">`DataTable`</ph>, and then perhaps propagate the data back to the primary data source.</source>
          <target state="translated">이 경우 가정은 하나 이상의 데이터 원본에서 데이터를 집계 의도는 <ph id="ph1">`DataTable`</ph>, 다음 데이터는 주 데이터 원본에 다시 전파 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> parameter is used for determining the specific version of the row that is to be used for primary key comparison.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> 기본 키 비교에 사용 되는 행의 특정 버전을 확인 하기 위한 매개 변수를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The table below provides the details.</source>
          <target state="translated">다음 표에서 세부 정보를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Load option</source>
          <target state="translated">로드 옵션</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>DataRow version used for primary key comparison</source>
          <target state="translated">기본 키 비교에 사용 되는 DataRow 버전</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original version, if it exists, otherwise Current version</source>
          <target state="translated">있는 경우의 원래 버전, 그렇지 않으면 현재 버전</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Original version, if it exists, otherwise Current version</source>
          <target state="translated">있는 경우의 원래 버전, 그렇지 않으면 현재 버전</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Current version, if it exists, otherwise Original version</source>
          <target state="translated">현재 버전에 있는 경우, 그렇지 않으면 원본 버전</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">`errorHandler`</ph> parameter is a <ph id="ph2">&lt;xref:System.Data.FillErrorEventHandler&gt;</ph> delegate that refers to a procedure that is called when an error occurs while loading data.</source>
          <target state="translated"><ph id="ph1">`errorHandler`</ph> 매개 변수는 한 <ph id="ph2">&lt;xref:System.Data.FillErrorEventHandler&gt;</ph> 데이터를 로드 하는 동안 오류가 발생할 때 호출 되는 프로시저를 참조 하는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> parameter passed to the procedure provides properties that allow you to retrieve information about the error that occurred, the current row of data, and the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> being filled.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> 발생 한 오류, 데이터의 현재 행에 대 한 정보를 검색할 수 있도록 하는 속성을 제공 하는 프로시저에 전달 된 매개 변수 및 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 채워지고 합니다.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Using this delegate mechanism, rather than a simpler try/catch block, allows you to determine the error, handle the situation, and continue processing if you like.</source>
          <target state="translated">이 대리자 메커니즘을 사용 하 여, 대신 간단한 try/catch 블록을 오류를 확인할 수 있습니다 상황을 처리을 원하는 경우 처리를 계속 합니다.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>The <ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> parameter supplies a <ph id="ph2">&lt;xref:System.Data.FillErrorEventArgs.Continue%2A&gt;</ph> property: set this property to <ph id="ph3">`true`</ph> to indicate that you have handled the error and wish to continue processing.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> 매개 변수를 제공는 <ph id="ph2">&lt;xref:System.Data.FillErrorEventArgs.Continue%2A&gt;</ph> 속성:이 속성을 설정 <ph id="ph3">`true`</ph> 를 나타내는 오류를 처리 하 고 처리를 계속 합니다.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Set the property to <ph id="ph1">`false`</ph> to indicate that you wish to halt processing.</source>
          <target state="translated">속성을 설정 <ph id="ph1">`false`</ph> 처리를 중단 하려면 나타냅니다.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)">
          <source>Be aware that setting the property to <ph id="ph1">`false`</ph> causes the code that triggered the problem to throw an exception.</source>
          <target state="translated">주의 해당 속성을 설정 <ph id="ph1">`false`</ph> 하면 예외를 throw 하는 문제를 발생 시킨 코드가 있습니다.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>Finds and updates a specific row.</source>
          <target state="translated">특정 행을 찾아 업데이트합니다.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>If no matching row is found, a new row is created using the given values.</source>
          <target state="translated">일치하는 행을 찾지 못하면 지정된 값을 사용하여 새 행을 만듭니다.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>An array of values used to create the new row.</source>
          <target state="translated">새 행을 만드는 데 사용되는 값 배열입니다.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to accept changes; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">변경 사항을 적용하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>Finds and updates a specific row.</source>
          <target state="translated">특정 행을 찾아 업데이트합니다.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>If no matching row is found, a new row is created using the given values.</source>
          <target state="translated">일치하는 행을 찾지 못하면 지정된 값을 사용하여 새 행을 만듭니다.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> method takes an array of values and finds the matching value(s) in the primary key column(s).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> 메서드 값의 배열을 사용 하 고 기본 키 열에 일치 하는 값을 찾습니다.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>If a column has a default value, pass a null value in the array to set the default value for that column.</source>
          <target state="translated">열에 기본 값, 해당 열에 대 한 기본값을 설정 하는 배열에 null 값을 전달 합니다.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>Similarly, if a column has its <ph id="ph1">&lt;xref:System.Data.DataColumn.AutoIncrement%2A&gt;</ph> property set to true, pass a null value in the array to set the automatically generated value for the row.</source>
          <target state="translated">마찬가지로, 열에 있으면 해당 <ph id="ph1">&lt;xref:System.Data.DataColumn.AutoIncrement%2A&gt;</ph> 속성이 행에 대해 자동으로 생성 된 값을 설정 하는 배열에 null 값을 전달 합니다. true로 설정 합니다.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>If the <ph id="ph1">`fAcceptChanges`</ph> parameter is <ph id="ph2">`true`</ph> or not specified, the new data is added and then <ph id="ph3">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> is called to accept all changes in the <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph>; if the argument is <ph id="ph5">`false`</ph>, newly added rows are marked as insertions, and changes to existing rows are marked as modifications.</source>
          <target state="translated">경우는 <ph id="ph1">`fAcceptChanges`</ph> 매개 변수는 <ph id="ph2">`true`</ph> 하거나 지정 하지 않으면 새 데이터가 추가 되 차례로 <ph id="ph3">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> 에서 모든 변경 내용을 적용 하기 위해 호출 됩니다는 <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph>인수가; <ph id="ph5">`false`</ph>, 새로 추가 된 삽입, 코드 변경 내용으로 표시 된 행 기존 행 수정으로 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>Exceptions can also occur during either a <ph id="ph1">&lt;xref:System.Data.DataTable.ColumnChanging&gt;</ph> or <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph> event.</source>
          <target state="translated">예외도 수행 하는 동안 발생할 수 있습니다는 <ph id="ph1">&lt;xref:System.Data.DataTable.ColumnChanging&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>If an exception occurs, the row is not added to the table.</source>
          <target state="translated">예외가 발생 하는 경우 테이블에 행 추가 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>Use <ph id="ph1">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> in conjunction with <ph id="ph2">&lt;xref:System.Data.DataTable.BeginLoadData%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataTable.EndLoadData%2A&gt;</ph>.</source>
          <target state="translated">사용 하 여 <ph id="ph1">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> 함께에서 <ph id="ph2">&lt;xref:System.Data.DataTable.BeginLoadData%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataTable.EndLoadData%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> method to attempt to find a row.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> 메서드를 행을 찾습니다.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>If no such row is found, the values are used to create a new row.</source>
          <target state="translated">이러한 행이 없으면 새 행을 만들고 값이 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>The array is larger than the number of columns in the table.</source>
          <target state="translated">배열이 테이블의 열 수보다 큰 경우</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>A value doesn't match its respective column type.</source>
          <target state="translated">값이 해당 열 형식과 일치하지 않는 경우</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>Adding the row invalidates a constraint.</source>
          <target state="translated">행을 추가하여 제약 조건을 무효화한 경우</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)">
          <source>Attempting to put a null in a column where <ph id="ph1">&lt;see cref="P:System.Data.DataColumn.AllowDBNull" /&gt;</ph> is false.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Data.DataColumn.AllowDBNull" /&gt;</ph>이 false인 열에 null을 설정하려는 경우</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>An array of values used to create the new row.</source>
          <target state="translated">새 행을 만드는 데 사용되는 값 배열입니다.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>Used to determine how the array values are applied to the corresponding values in an existing row.</source>
          <target state="translated">배열 값이 기존 행의 해당 값에 적용되는 방식을 결정하는 데 사용됩니다.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>Finds and updates a specific row.</source>
          <target state="translated">특정 행을 찾아 업데이트합니다.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>If no matching row is found, a new row is created using the given values.</source>
          <target state="translated">일치하는 행을 찾지 못하면 지정된 값을 사용하여 새 행을 만듭니다.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> method takes an array of values and finds the matching value(s) in the primary key column(s).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> 메서드 값의 배열을 사용 하 고 기본 키 열에 일치 하는 값을 찾습니다.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>If a column has a default value, pass a null value in the array to set the default value for that column.</source>
          <target state="translated">열에 기본 값, 해당 열에 대 한 기본값을 설정 하는 배열에 null 값을 전달 합니다.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>Similarly, if a column has its <ph id="ph1">&lt;xref:System.Data.DataColumn.AutoIncrement%2A&gt;</ph> property set to true, pass a null value in the array to set the automatically generated value for the row.</source>
          <target state="translated">마찬가지로, 열에 있으면 해당 <ph id="ph1">&lt;xref:System.Data.DataColumn.AutoIncrement%2A&gt;</ph> 속성이 행에 대해 자동으로 생성 된 값을 설정 하는 배열에 null 값을 전달 합니다. true로 설정 합니다.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>The value of the <ph id="ph1">`loadOption`</ph> parameter is used to determine how the values in the array are applied to an existing row.</source>
          <target state="translated">값은 <ph id="ph1">`loadOption`</ph> 매개 변수를 사용 하는 배열의 값이 기존 행에 적용 되는 방식을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>For example, if <ph id="ph1">`loadOption`</ph> is set to <ph id="ph2">`OverwriteChanges`</ph>, the <ph id="ph3">`Original`</ph> and <ph id="ph4">`Current`</ph> values of each column are replaced with the values in the incoming row and the <ph id="ph5">`RowState`</ph> property is set to <ph id="ph6">`Unchanged`</ph>.</source>
          <target state="translated">예를 들어 경우 <ph id="ph1">`loadOption`</ph> 로 설정 된 <ph id="ph2">`OverwriteChanges`</ph>, <ph id="ph3">`Original`</ph> 및 <ph id="ph4">`Current`</ph> 각 열의 값이 들어오는 행의 값으로 바뀌는 및 <ph id="ph5">`RowState`</ph> 속성이로 설정 된 <ph id="ph6">`Unchanged`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>Exceptions can also occur during either a <ph id="ph1">&lt;xref:System.Data.DataTable.ColumnChanging&gt;</ph> or <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph> event.</source>
          <target state="translated">예외도 수행 하는 동안 발생할 수 있습니다는 <ph id="ph1">&lt;xref:System.Data.DataTable.ColumnChanging&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Data.DataTable.RowChanging&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>If an exception occurs, the row is not added to the table.</source>
          <target state="translated">예외가 발생 하는 경우 테이블에 행 추가 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)">
          <source>Use <ph id="ph1">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> in conjunction with <ph id="ph2">&lt;xref:System.Data.DataTable.BeginLoadData%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataTable.EndLoadData%2A&gt;</ph>.</source>
          <target state="translated">사용 하 여 <ph id="ph1">&lt;xref:System.Data.DataTable.LoadDataRow%2A&gt;</ph> 함께에서 <ph id="ph2">&lt;xref:System.Data.DataTable.BeginLoadData%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataTable.EndLoadData%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.Locale">
          <source>Gets or sets the locale information used to compare strings within the table.</source>
          <target state="translated">테이블 내의 문자열을 비교하는 데 사용되는 로캘 정보를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Locale">
          <source>A <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> that contains data about the user's machine locale.</source>
          <target state="translated">사용자의 컴퓨터 로캘에 대한 데이터가 들어 있는 <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Locale">
          <source>The default is the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> object's <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> (returned by the <ph id="ph3">&lt;see cref="P:System.Data.DataSet.Locale" /&gt;</ph> property) to which the <ph id="ph4">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> belongs; if the table doesn't belong to a <ph id="ph5">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, the default is the current system <ph id="ph6">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</source>
          <target state="translated">기본값은 <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>이 속해 있으며 <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> 속성에 의해 반환되는 <ph id="ph3">&lt;see cref="P:System.Data.DataSet.Locale" /&gt;</ph> 개체의 <ph id="ph4">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>이거나, 테이블이 <ph id="ph5">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>에 속하지 않은 경우 현재 시스템의 <ph id="ph6">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Locale">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> represents the software preferences of a particular culture or community.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> 특정 문화권 또는 커뮤니티의 소프트웨어 기본 설정을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Locale">
          <source>When used for string comparisons, the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> affects sorting, comparisons, and filtering.</source>
          <target state="translated">문자열 비교에 사용 되는 경우는 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> 비교, 정렬 및 필터링에 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Locale">
          <source>In columns that contain expressions, the <ph id="ph1">&lt;xref:System.StringComparison.InvariantCulture&gt;</ph> is used.</source>
          <target state="translated">식이 포함 된 열에는 <ph id="ph1">&lt;xref:System.StringComparison.InvariantCulture&gt;</ph> 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Locale">
          <source>The <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture&gt;</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture&gt;</ph> 는 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Locale">
          <source>The following example sets the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> through the <ph id="ph2">&lt;xref:System.Data.DataTable.Locale%2A&gt;</ph> and prints the ISO language name.</source>
          <target state="translated">다음 예에서는 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> 통해는 <ph id="ph2">&lt;xref:System.Data.DataTable.Locale%2A&gt;</ph> ISO 언어 이름을 출력 합니다.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>Merge the specified <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> with the current <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>을 현재 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>과 병합합니다.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">`Merge`</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated"><ph id="ph1">`Merge`</ph> 병합할 두 개의 메서드를 사용 하는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 비슷하긴 하지만 스키마가 포함 된 개체입니다.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 데이터 원본의 최신 데이터를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The merge operation takes into account only the original table, and the table to be merged.</source>
          <target state="translated">병합 작업은 원래 테이블만 병합 될 테이블을 고려 합니다.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Child tables are not affected or included.</source>
          <target state="translated">자식 테이블은 영향을 하지 않거나 포함 하십시오.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>If a table has one or more child tables, defined as part of a relationship, each child table must be merged individually.</source>
          <target state="translated">테이블 관계의 일부분으로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블은 개별적으로 병합 해야 합니다.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The following console application demonstrates the behavior of the <ph id="ph1">`missingSchemaAction`</ph> parameter of the <ph id="ph2">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> method.</source>
          <target state="translated">다음 콘솔 응용 프로그램의 동작을 보여 줍니다.는 <ph id="ph1">`missingSchemaAction`</ph> 의 매개 변수는 <ph id="ph2">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>This example creates two versions of the same table, modifying the schema for the second version.</source>
          <target state="translated">이 예에서는 두 가지 버전의 두 번째 버전에 대 한 스키마를 수정 하는 동일한 테이블을 만듭니다.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The code then attempts to merge the second table into the first.</source>
          <target state="translated">코드는 다음 두 번째 테이블에 첫 번째 병합 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>This example shows how to use one of the overloaded versions of Merge.</source>
          <target state="translated">이 예에서는 병합의 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>For other examples that might be available, see the individual overload topics.</source>
          <target state="translated">사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> to be merged with the current <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>과 병합할 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>Merge the specified <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> with the current <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>을 현재 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>과 병합합니다.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>The Merge method is used to merge two <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">Merge 메서드 두 개를 병합 하는 데는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 비슷하긴 하지만 스키마가 포함 된 개체입니다.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 데이터 원본의 최신 데이터를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>The merge operation takes into account only the original table, and the table to be merged.</source>
          <target state="translated">병합 작업은 원래 테이블만 병합 될 테이블을 고려 합니다.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>Child tables are not affected or included.</source>
          <target state="translated">자식 테이블은 영향을 하지 않거나 포함 하십시오.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>If a table has one or more child tables, defined as part of a relationship, each child table must be merged individually.</source>
          <target state="translated">테이블 관계의 일부분으로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블은 개별적으로 병합 해야 합니다.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>The <ph id="ph1">`Merge`</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Merge`</ph> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>When performing a merge, changes made to the existing data before the merge are preserved by default during the merge operation.</source>
          <target state="translated">병합을 수행할 때 기존 데이터를 병합 하기 전에 변경 내용이 병합 작업 동안 기본적으로 유지 됩니다.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>Developers can modify this behavior by calling one of the other two overloads for this method, and specifying a false value for the <ph id="ph1">`preserveChanges`</ph> parameter.</source>
          <target state="translated">개발자는이 메서드에 대 한 호출 하는 다른 두 오버 로드 중 하나에 대 한 값이 false를 지정 하 여이 동작을 수정할 수는 <ph id="ph1">`preserveChanges`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>In a client application, it is usual to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle tier component.</source>
          <target state="translated">클라이언트 응용 프로그램에는 단일 단추가 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 별로있지 않습니다.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataTable.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">이 시나리오는 <ph id="ph1">&lt;xref:System.Data.DataTable.GetChanges%2A&gt;</ph> 메서드가 먼저 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">이 메서드는 두 번째 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 유효성 검사 및 병합에 대해 최적화 합니다.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">이 두 번째 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 개체에만 포함 되어는 <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> 원래의 하위 집합에 변경 된 개체 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>This subset is generally smaller and thus more efficiently passed back to a middle tier component.</source>
          <target state="translated">이 하위 집합은 일반적으로 더 작은 때문에 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>The middle tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">중간 계층은 새 다시 보낼 수 있습니다 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph>, is matched to target rows with the same primary key values.</source>
          <target state="translated">새 소스를 병합할 때 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 대상에 모든 소스 행 한 <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> 값 <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, 또는 <ph id="ph5">`Deleted`</ph>, 동일한 기본 키 값을 가진 대상 행에 일치 합니다.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>Source rows with a <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">소스 행 한 <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> 값 <ph id="ph2">`Added`</ph> 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>The following console application creates a simple <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and adds data to the table.</source>
          <target state="translated">다음 콘솔 응용 프로그램을 만듭니다는 간단한 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 데이터 테이블에 추가 합니다.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>The example then creates a copy of the table, adding rows to the copy.</source>
          <target state="translated">다음 예에서는 행 복사본에 추가 테이블의 복사본을 만듭니다.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable)">
          <source>Finally, the example calls the <ph id="ph1">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> method to merge the data in the second table with the data in the first table.</source>
          <target state="translated">마지막으로,이 예에서는 호출에서 <ph id="ph1">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> 메서드를 첫 번째 테이블의 데이터를 사용 하 여 두 번째 테이블의 데이터를 병합 합니다.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="DataTable" /&gt;</ph> to be merged with the current <ph id="ph2">&lt;see langword="DataTable" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see langword="DataTable" /&gt;</ph>과 병합할 <ph id="ph2">&lt;see langword="DataTable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph>, to preserve changes in the current <ph id="ph2">&lt;see langword="DataTable" /&gt;</ph>; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.<ph id="ph4">&lt;see langword="" /&gt;</ph></source>
          <target state="translated">현재 <ph id="ph1">&lt;see langword="true" /&gt;</ph>의 변경 내용을 유지하려면 <ph id="ph2">&lt;see langword="DataTable" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.<ph id="ph4">&lt;see langword="" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>Merge the specified <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> with the current <ph id="ph2">&lt;see langword="DataTable" /&gt;</ph>, indicating whether to preserve changes in the current <ph id="ph3">&lt;see langword="DataTable" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>을 현재 <ph id="ph2">&lt;see langword="DataTable" /&gt;</ph>과 병합하여 현재 <ph id="ph3">&lt;see langword="DataTable" /&gt;</ph>에서 변경 내용을 유지할지 여부를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>The Merge method is used to merge two <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">Merge 메서드 두 개를 병합 하는 데는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 비슷하긴 하지만 스키마가 포함 된 개체입니다.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 데이터 원본의 최신 데이터를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>The merge operation takes into account only the original table, and the table to be merged.</source>
          <target state="translated">병합 작업은 원래 테이블만 병합 될 테이블을 고려 합니다.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>Child tables are not affected or included.</source>
          <target state="translated">자식 테이블은 영향을 하지 않거나 포함 하십시오.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>If a table has one or more child tables, defined as part of a relationship, each child table must be merged individually.</source>
          <target state="translated">테이블 관계의 일부분으로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블은 개별적으로 병합 해야 합니다.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>The <ph id="ph1">`Merge`</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Merge`</ph> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>When performing a merge, changes made to the existing data before the merge are preserved during the merge operation unless the developer specifies false for the <ph id="ph1">`preserveChanges`</ph> parameter.</source>
          <target state="translated">개발자에 대해서는 false를 지정 하지 않은 경우 기존 데이터를 병합 하기 전에 변경 내용이 병합 작업 동안 유지 됩니다 병합을 수행할 때의 <ph id="ph1">`preserveChanges`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>If the <ph id="ph1">`preserveChanges`</ph> parameter is set to <ph id="ph2">`true`</ph>, incoming values do not overwrite existing values in the Current row version of the existing row.</source>
          <target state="translated">경우는 <ph id="ph1">`preserveChanges`</ph> 로 설정 된 <ph id="ph2">`true`</ph>, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어쓰지 않습니다.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>If the <ph id="ph1">`preserveChanges`</ph> parameter is set to <ph id="ph2">`false`</ph>, incoming values do overwrite the existing values in the Current row version of the existing row.</source>
          <target state="translated">경우는 <ph id="ph1">`preserveChanges`</ph> 로 설정 된 <ph id="ph2">`false`</ph>, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>For more information about row versions, see <bpt id="p1">[</bpt>Row States and Row Versions<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)</ept>.</source>
          <target state="translated">행 버전에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>행 상태 및 행 버전<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>In a client application, it is usual to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle tier component.</source>
          <target state="translated">클라이언트 응용 프로그램에는 단일 단추가 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 별로있지 않습니다.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataTable.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">이 시나리오는 <ph id="ph1">&lt;xref:System.Data.DataTable.GetChanges%2A&gt;</ph> 메서드가 먼저 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">이 메서드는 두 번째 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 유효성 검사 및 병합에 대해 최적화 합니다.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">이 두 번째 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 개체에만 포함 되어는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> 원래의 하위 집합에 변경 된 개체 <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>This subset is generally smaller, and thus this subset is more efficiently passed back to a middle tier component.</source>
          <target state="translated">이 하위 집합 일반적으로 더 작은 이며 따라서이 하위 집합은 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>The middle tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">중간 계층은 새 다시 보낼 수 있습니다 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">새 소스를 병합할 때 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 대상에 모든 소스 행 한 <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> 값 <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, 또는 <ph id="ph5">`Deleted`</ph> 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>Source rows with a <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">소스 행 한 <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> 값 <ph id="ph2">`Added`</ph> 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>The following console application creates a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> containing rows, modifies some of the data in those rows, and attempts to merge data from a different <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">다음 콘솔 응용 프로그램을 만듭니다는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 해당 행의 데이터 중 일부를 수정 하 고 다른 데이터를 병합 하려고 행을 포함 하 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)">
          <source>The example demonstrates the different behaviors for the <ph id="ph1">`preserveChanges`</ph> parameter.</source>
          <target state="translated">예제에 대 한 다양 한 동작에는 <ph id="ph1">`preserveChanges`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> to be merged with the current <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>과 병합할 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph>, to preserve changes in the current <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see langword="true" /&gt;</ph>의 변경 내용을 유지하려면 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Merge the specified <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> with the current <ph id="ph2">&lt;see langword="DataTable" /&gt;</ph>, indicating whether to preserve changes and how to handle missing schema in the current <ph id="ph3">&lt;see langword="DataTable" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>을 현재 <ph id="ph2">&lt;see langword="DataTable" /&gt;</ph>과 병합하여, 변경 내용을 유지할지 여부와 현재 <ph id="ph3">&lt;see langword="DataTable" /&gt;</ph>의 누락된 스키마 처리 방식을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">`Merge`</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated"><ph id="ph1">`Merge`</ph> 병합할 두 개의 메서드를 사용 하는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 비슷하긴 하지만 스키마가 포함 된 개체입니다.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">기존 데이터 원본에서 최신 변경 내용을 통합 하는 클라이언트 응용 프로그램에는 병합은 일반적으로 사용 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 데이터 원본의 최신 데이터를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The merge operation takes into account only the original table, and the table to be merged.</source>
          <target state="translated">병합 작업은 원래 테이블만 병합 될 테이블을 고려 합니다.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Child tables are not affected or included.</source>
          <target state="translated">자식 테이블은 영향을 하지 않거나 포함 하십시오.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If a table has one or more child tables, defined as part of a relationship, each child table must be merged individually.</source>
          <target state="translated">테이블 관계의 일부분으로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블은 개별적으로 병합 해야 합니다.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">`Merge`</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Merge`</ph> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정으로 변경 되는 데이터 소스 업데이트 및 기존 새로 고침 관련 된 절차의 끝에 호출 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When performing a merge, changes made to the existing data before the merge are preserved during the merge operation unless the developer specifies false for the <ph id="ph1">`preserveChanges`</ph> parameter.</source>
          <target state="translated">개발자에 대해서는 false를 지정 하지 않은 경우 기존 데이터를 병합 하기 전에 변경 내용이 병합 작업 동안 유지 됩니다 병합을 수행할 때의 <ph id="ph1">`preserveChanges`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If the <ph id="ph1">`preserveChanges`</ph> parameter is set to <ph id="ph2">`true`</ph>, incoming values do not overwrite existing values in the Current row version of the existing row.</source>
          <target state="translated">경우는 <ph id="ph1">`preserveChanges`</ph> 로 설정 된 <ph id="ph2">`true`</ph>, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어쓰지 않습니다.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If the <ph id="ph1">`preserveChanges`</ph> parameter is set to <ph id="ph2">`false`</ph>, incoming values do overwrite the existing values in the Current row version of the existing row.</source>
          <target state="translated">경우는 <ph id="ph1">`preserveChanges`</ph> 로 설정 된 <ph id="ph2">`false`</ph>, 들어오는 값은 기존 행의 현재 행 버전의 기존 값을 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>For more information about row versions, see <bpt id="p1">[</bpt>Row States and Row Versions<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)</ept>.</source>
          <target state="translated">행 버전에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>행 상태 및 행 버전<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In a client application, it is usual to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle tier component.</source>
          <target state="translated">클라이언트 응용 프로그램에는 단일 단추가 사용자가 클릭할 수 있는 변경 된 데이터를 수집 하 고 중간 계층 구성 요소에 다시 보내기 전에 유효성 검사를 수행 하는 별로있지 않습니다.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataTable.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">이 시나리오는 <ph id="ph1">&lt;xref:System.Data.DataTable.GetChanges%2A&gt;</ph> 메서드가 먼저 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">이 메서드는 두 번째 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 유효성 검사 및 병합에 대해 최적화 합니다.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">이 두 번째 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 개체에만 포함 되어는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> 원래의 하위 집합에 변경 된 개체 <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This subset is generally smaller, and thus this subset is more efficiently passed back to a middle tier component.</source>
          <target state="translated">이 하위 집합 일반적으로 더 작은 이며 따라서이 하위 집합은 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용으로 원래 데이터 소스를 업데이트 합니다.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">중간 계층은 새 다시 보낼 수 있습니다 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> (다시 실행 하 여 원래 쿼리), 원래 데이터와 데이터 원본에서 최신 데이터를 포함 하는 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(예를 들어 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값 수에 다시 전파할 수 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 클라이언트 응용 프로그램의 원래로 다시 병합 되어야 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects are compared, because it is possible that the schemas may have been changed.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> 메서드가 호출 되 면 두 스키마 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 개체는 스키마 변경 되었을 수 있기 때문에 비교 됩니다.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">예를 들어, 기업 간 시나리오에서 새 열 수 있습니다에 추가한 XML 스키마는 자동화 된 프로세스에 의해 합니다.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">경우 소스 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 스키마 요소를 포함 (추가 <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> 개체) 대상에 누락 된, 스키마 요소를 설정 하 여 대상에 추가할 수는 <ph id="ph3">`missingSchemaAction`</ph> 인수 <ph id="ph4">`MissingSchemaAction.Add`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> contains the added schema and data.</source>
          <target state="translated">병합 된 경우에서 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 추가 된 스키마와 데이터를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">스키마를 병합 한 후 데이터를 병합 합니다.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">새 소스를 병합할 때 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 대상에 모든 소스 행 한 <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> 값 <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, 또는 <ph id="ph5">`Deleted`</ph> 동일한 기본 키 값을 가진 대상 행에 대응 됩니다.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Source rows with a <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">소스 행 한 <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> 값 <ph id="ph2">`Added`</ph> 새 원본 행과 동일한 기본 키 값을 가진 새 대상 행에 대응 됩니다.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The following console application demonstrates the behavior of the <ph id="ph1">`missingSchemaAction`</ph> parameter of the <ph id="ph2">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> method.</source>
          <target state="translated">다음 콘솔 응용 프로그램의 동작을 보여 줍니다.는 <ph id="ph1">`missingSchemaAction`</ph> 의 매개 변수는 <ph id="ph2">&lt;xref:System.Data.DataTable.Merge%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This example creates two versions of the same table, modifying the schema for the second version.</source>
          <target state="translated">이 예에서는 두 가지 버전의 두 번째 버전에 대 한 스키마를 수정 하는 동일한 테이블을 만듭니다.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The code then attempts to merge the second table into the first.</source>
          <target state="translated">코드는 다음 두 번째 테이블에 첫 번째 병합 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.MinimumCapacity">
          <source>Gets or sets the initial starting size for this table.</source>
          <target state="translated">이 테이블에 대한 초기 시작 크기를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.MinimumCapacity">
          <source>The initial starting size in rows of this table.</source>
          <target state="translated">이 테이블에 있는 행의 초기 시작 크기입니다.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.MinimumCapacity">
          <source>The default is 50.</source>
          <target state="translated">기본값은 50입니다.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.MinimumCapacity">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.MinimumCapacity%2A&gt;</ph> allows the system to create an appropriate set of resources before fetching data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.MinimumCapacity%2A&gt;</ph> 시스템이 데이터를 인출 하기 전에 리소스의 적절 한 세트를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.MinimumCapacity">
          <source>In a situation when performance is critical, setting this property can optimize performance.</source>
          <target state="translated">상황에서이 속성을 설정할 경우 성능 상태가 심각 하면 성능을 최적화할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.MinimumCapacity">
          <source>The following example sets the <ph id="ph1">&lt;xref:System.Data.DataTable.MinimumCapacity%2A&gt;</ph> of a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">다음 예에서는 <ph id="ph1">&lt;xref:System.Data.DataTable.MinimumCapacity%2A&gt;</ph> 의 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.Namespace">
          <source>Gets or sets the namespace for the XML representation of the data stored in the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>에 저장된 데이터의 XML 표현에 대한 네임스페이스를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Namespace">
          <source>The namespace of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 네임스페이스입니다.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.NewRow">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> with the same schema as the table.</source>
          <target state="translated">테이블과 동일한 스키마를 갖는 새 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.NewRow">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> with the same schema as the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>과 동일한 스키마를 갖는 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.NewRow">
          <source>You must use the <ph id="ph1">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> method to create new <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> objects with the same schema as the <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">사용 해야 합니다는 <ph id="ph1">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> 메서드 새로 만드는 <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> 동일한 스키마를 사용 하 여 개체는 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.NewRow">
          <source>After creating a <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph>, you can add it to the <ph id="ph2">&lt;xref:System.Data.DataRowCollection&gt;</ph>, through the <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> object's <ph id="ph4">&lt;xref:System.Data.DataTable.Rows%2A&gt;</ph> property.</source>
          <target state="translated">만든 후는 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph>를에 추가할 수 있습니다는 <ph id="ph2">&lt;xref:System.Data.DataRowCollection&gt;</ph>통해는 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> 개체의 <ph id="ph4">&lt;xref:System.Data.DataTable.Rows%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.NewRow">
          <source>When you use <ph id="ph1">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> to create new rows, the rows must be added to or deleted from the data table before you call <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph>.</source>
          <target state="translated">사용 하는 경우 <ph id="ph1">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> 에 새 행을 만드는 행에 추가 하거나 삭제 해야 데이터 테이블에서 호출 하기 전에 <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.NewRow">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, adds two <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects that determine the table's schema, and creates several new <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects using the <ph id="ph4">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 한 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, 두 개 추가 <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> 에서는 몇 가지 새 및 테이블의 스키마를 지정 하는 개체 <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> 를 사용 하 여 개체는 <ph id="ph4">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.NewRow">
          <source>Those <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> objects are then added to the <ph id="ph2">&lt;xref:System.Data.DataRowCollection&gt;</ph> using the <ph id="ph3">&lt;xref:System.Data.DataRowCollection.Add%2A&gt;</ph> method.</source>
          <target state="translated">이러한 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> 개체에 추가 됩니다는 <ph id="ph2">&lt;xref:System.Data.DataRowCollection&gt;</ph> 를 사용 하 여는 <ph id="ph3">&lt;xref:System.Data.DataRowCollection.Add%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.NewRowArray(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value that describes the size of the array.</source>
          <target state="translated">배열의 크기를 설명하는 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 값입니다.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.NewRowArray(System.Int32)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>의 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.NewRowArray(System.Int32)">
          <source>The new array.</source>
          <target state="translated">새 배열입니다.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRowBuilder" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRowBuilder" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)">
          <source>Creates a new row from an existing row.</source>
          <target state="translated">기존 행에서 새 행을 만듭니다.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> derived class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 파생 클래스입니다.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataColumnChangeEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">이벤트 데이터를 포함하는 <ph id="ph1">&lt;see cref="T:System.Data.DataColumnChangeEventArgs" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Data.DataTable.ColumnChanged" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Data.DataTable.ColumnChanged" /&gt;</ph> 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">에 대 한 개요 <bpt id="p1">[</bpt>이벤트 처리 및 발생<ept id="p1">](~/docs/standard/events/index.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /&gt;</ph> in a derived class, be sure to call the base class's <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">재정의 하는 경우 <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /&gt;</ph> 파생된 클래스에서 호출 해야 기본 클래스의 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataColumnChangeEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">이벤트 데이터를 포함하는 <ph id="ph1">&lt;see cref="T:System.Data.DataColumnChangeEventArgs" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Data.DataTable.ColumnChanging" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Data.DataTable.ColumnChanging" /&gt;</ph> 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">에 대 한 개요 <bpt id="p1">[</bpt>이벤트 처리 및 발생<ept id="p1">](~/docs/standard/events/index.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /&gt;</ph> in a derived class, be sure to call the base class's <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">재정의 하는 경우 <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /&gt;</ph> 파생된 클래스에서 호출 해야 기본 클래스의 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.ComponentModel.PropertyChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">이벤트 데이터를 포함하는 <ph id="ph1">&lt;see cref="T:System.ComponentModel.PropertyChangedEventArgs" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /&gt;</ph> 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">에 대 한 개요 <bpt id="p1">[</bpt>이벤트 처리 및 발생<ept id="p1">](~/docs/standard/events/index.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> in a derived class, be sure to call the base class's <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">재정의 하는 경우 <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> 파생된 클래스에서 호출 해야 기본 클래스의 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph> being removed.</source>
          <target state="translated">제거 중인 <ph id="ph1">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)">
          <source>Notifies the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> that a <ph id="ph2">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph> is being removed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>이 제거 중임을 <ph id="ph2">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph>에 알립니다.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)">
          <source>For more information, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>이벤트 처리 및 발생<ept id="p1">](~/docs/standard/events/index.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /&gt;</ph> in a derived class, be sure to call the base class's <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /&gt;</ph> method.</source>
          <target state="translated">재정의 하는 경우 <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /&gt;</ph> 파생된 클래스에서 호출 해야 기본 클래스의 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRowChangeEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">이벤트 데이터를 포함하는 <ph id="ph1">&lt;see cref="T:System.Data.DataRowChangeEventArgs" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Data.DataTable.RowChanged" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Data.DataTable.RowChanged" /&gt;</ph> 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">에 대 한 개요 <bpt id="p1">[</bpt>이벤트 처리 및 발생<ept id="p1">](~/docs/standard/events/index.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /&gt;</ph> in a derived class, be sure to call the base class's <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">재정의 하는 경우 <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /&gt;</ph> 파생된 클래스에서 호출 해야 기본 클래스의 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRowChangeEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">이벤트 데이터를 포함하는 <ph id="ph1">&lt;see cref="T:System.Data.DataRowChangeEventArgs" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Data.DataTable.RowChanging" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Data.DataTable.RowChanging" /&gt;</ph> 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">에 대 한 개요 <bpt id="p1">[</bpt>이벤트 처리 및 발생<ept id="p1">](~/docs/standard/events/index.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /&gt;</ph> in a derived class, be sure to call the base class's <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">재정의 하는 경우 <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /&gt;</ph> 파생된 클래스에서 호출 해야 기본 클래스의 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRowChangeEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">이벤트 데이터를 포함하는 <ph id="ph1">&lt;see cref="T:System.Data.DataRowChangeEventArgs" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Data.DataTable.RowDeleted" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Data.DataTable.RowDeleted" /&gt;</ph> 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">에 대 한 개요 <bpt id="p1">[</bpt>이벤트 처리 및 발생<ept id="p1">](~/docs/standard/events/index.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /&gt;</ph> in a derived class, be sure to call the base class's <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">재정의 하는 경우 <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /&gt;</ph> 파생된 클래스에서 호출 해야 기본 클래스의 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRowChangeEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">이벤트 데이터를 포함하는 <ph id="ph1">&lt;see cref="T:System.Data.DataRowChangeEventArgs" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Data.DataTable.RowDeleting" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Data.DataTable.RowDeleting" /&gt;</ph> 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">에 대 한 개요 <bpt id="p1">[</bpt>이벤트 처리 및 발생<ept id="p1">](~/docs/standard/events/index.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /&gt;</ph> in a derived class, be sure to call the base class's <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">재정의 하는 경우 <ph id="ph1">&lt;see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /&gt;</ph> 파생된 클래스에서 호출 해야 기본 클래스의 <ph id="ph2">&lt;see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataTableClearEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">이벤트 데이터를 포함하는 <ph id="ph1">&lt;see cref="T:System.Data.DataTableClearEventArgs" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Data.DataTable.TableCleared" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Data.DataTable.TableCleared" /&gt;</ph> 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)">
          <source>Raises the <ph id="ph1">&lt;xref:System.Data.DataTable.TableCleared&gt;</ph> event, which is fired immediately after all rows have been successfully cleared but before the <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph> method returns control back to the caller.</source>
          <target state="translated">발생는 <ph id="ph1">&lt;xref:System.Data.DataTable.TableCleared&gt;</ph> 모든 행이 성공적으로 지워진 하기 전에 직후 발생 하는 이벤트는 <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph> 메서드 호출자에 게 제어를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">에 대 한 개요 <bpt id="p1">[</bpt>이벤트 처리 및 발생<ept id="p1">](~/docs/standard/events/index.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataTableClearEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">이벤트 데이터를 포함하는 <ph id="ph1">&lt;see cref="T:System.Data.DataTableClearEventArgs" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Data.DataTable.TableClearing" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Data.DataTable.TableClearing" /&gt;</ph> 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)">
          <source>Raises the <ph id="ph1">&lt;xref:System.Data.DataTable.TableClearing&gt;</ph> event, which is fired before processing of the <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph> operation begins.</source>
          <target state="translated">발생 된 <ph id="ph1">&lt;xref:System.Data.DataTable.TableClearing&gt;</ph> 처리 되기 전에 발생 하는 이벤트는 <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph> 작업이 시작 합니다.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">에 대 한 개요 <bpt id="p1">[</bpt>이벤트 처리 및 발생<ept id="p1">](~/docs/standard/events/index.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataTableNewRowEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">이벤트 데이터를 포함하는 <ph id="ph1">&lt;see cref="T:System.Data.DataTableNewRowEventArgs" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Data.DataTable.TableNewRow" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Data.DataTable.TableNewRow" /&gt;</ph> 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)">
          <source>Raises the <ph id="ph1">&lt;xref:System.Data.DataTable.TableNewRow&gt;</ph> event, which fires after a new <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> has been created using <ph id="ph3">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph>.</source>
          <target state="translated">발생는 <ph id="ph1">&lt;xref:System.Data.DataTable.TableNewRow&gt;</ph> 새 후 발생 하는 이벤트 <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> 사용 하 여 만든 <ph id="ph3">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">에 대 한 개요 <bpt id="p1">[</bpt>이벤트 처리 및 발생<ept id="p1">](~/docs/standard/events/index.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.ParentRelations">
          <source>Gets the collection of parent relations for this <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>에 대한 부모 관계 컬렉션을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ParentRelations">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRelationCollection" /&gt;</ph> that contains the parent relations for the table.</source>
          <target state="translated">테이블의 부모 관계가 포함된 <ph id="ph1">&lt;see cref="T:System.Data.DataRelationCollection" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ParentRelations">
          <source>An empty collection is returned if no <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> objects exist.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> 개체가 없으면 빈 컬렉션이 반환됩니다.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ParentRelations">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataTable.ParentRelations%2A&gt;</ph> property to return each parent <ph id="ph2">&lt;xref:System.Data.DataRelation&gt;</ph> in a <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Data.DataTable.ParentRelations%2A&gt;</ph> 각 부모를 반환 하는 속성 <ph id="ph2">&lt;xref:System.Data.DataRelation&gt;</ph> 에 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ParentRelations">
          <source>Each relation is then used as an argument in the <ph id="ph1">&lt;xref:System.Data.DataRow.GetParentRows%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> to return an array of rows.</source>
          <target state="translated">각 관계에 대 한 인수로 사용 됩니다는 <ph id="ph1">&lt;xref:System.Data.DataRow.GetParentRows%2A&gt;</ph> 의 메서드는 <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> 행의 배열을 반환 하도록 합니다.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.ParentRelations">
          <source>The value of each column in the row is then printed.</source>
          <target state="translated">행에 있는 각 열의 값이 출력 합니다.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.Prefix">
          <source>Gets or sets the namespace for the XML representation of the data stored in the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>에 저장된 데이터의 XML 표현에 대한 네임스페이스를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Prefix">
          <source>The prefix of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 접두사입니다.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.PrimaryKey">
          <source>Gets or sets an array of columns that function as primary keys for the data table.</source>
          <target state="translated">데이터 테이블에 대한 기본 키로 사용되는 열의 배열을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.PrimaryKey">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataColumn" /&gt;</ph> 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.PrimaryKey">
          <source>The primary key of a table must be unique to identify the record in the table.</source>
          <target state="translated">테이블의 기본 키 테이블의 레코드를 식별 하 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.PrimaryKey">
          <source>It's also possible to have a table with a primary key made up of two or more columns.</source>
          <target state="translated">두 개 이상의 열으로 구성 하는 기본 키가 있는 테이블을 가질 수 이기도 합니다.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.PrimaryKey">
          <source>This occurs when a single column can't contain enough unique values.</source>
          <target state="translated">단일 열 충분 한 고유 값을 포함할 수 없는 경우 발생 합니다.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.PrimaryKey">
          <source>For example, a two column primary key might consist of a "FirstName" and "LastName" column.</source>
          <target state="translated">예를 들어 두 개의 열 기본 키 "FirstName" 및 "LastName" 열의 구성 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.PrimaryKey">
          <source>Because primary keys can be made up of more than one column, the <ph id="ph1">&lt;xref:System.Data.DataTable.PrimaryKey%2A&gt;</ph> property consists of an array of <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects.</source>
          <target state="translated">기본 키 하나 이상의 열은 구성할 수 있으므로 <ph id="ph1">&lt;xref:System.Data.DataTable.PrimaryKey%2A&gt;</ph> 속성의 배열로 구성 됩니다 <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.PrimaryKey">
          <source>The first example shows how to return the primary key columns for a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> displayed in a <ph id="ph2">`DataGrid`</ph>.</source>
          <target state="translated">첫 번째 예에 대 한 기본 키 열을 반환 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 에 표시 되는 <ph id="ph2">`DataGrid`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.PrimaryKey">
          <source>The second example demonstrates how to set the primary key columns for a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">두 번째 예제에 대 한 기본 키 열을 설정 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.PrimaryKey">
          <source>The key is a foreign key.</source>
          <target state="translated">해당 키가 외래 키인 경우</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">XML 스키마와 데이터를 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>으로 읽어옵니다.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서 로부터 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드는 스키마만 읽습니다.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that include the <ph id="ph2">`XmlReadMode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">데이터 및 스미카를 읽으려면 중 하나를 사용는 <ph id="ph1">`ReadXML`</ph> 포함 하는 오버 로드는 <ph id="ph2">`XmlReadMode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph3">`ReadSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>An object that derives from <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>에서 파생되는 개체입니다.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 XML 스키마와 데이터를 <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>으로 읽어옵니다.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated">데이터를 읽는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>The current <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and its descendents are loaded with the data from the supplied <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 및 제공 된 데이터와 함께 로드 되는 해당 하위 항목이 <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>The behavior of this method is identical to that of the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType&gt;</ph> method, except that in this case, data is loaded only for the current table and its descendants.</source>
          <target state="translated">이 메서드의 동작은 동일 합니다는 <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType&gt;</ph> 메서드와 비슷하지만 경우에 데이터는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서 로부터 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드는 스키마만 읽습니다.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph2">`DataColumn`</ph> 또는 <ph id="ph3">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> containing two columns and ten rows.</source>
          <target state="translated">다음 예제에서는 한 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 두 개의 열과 열 개의 행을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>The example writes the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> schema and data to a memory stream, by invoking the <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">이 예제에서는 기록는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 스키마와 데이터를 호출 하 여 메모리 스트림에 <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.Stream)">
          <source>The example creates a second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and calls the <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method to fill it with schema and data.</source>
          <target state="translated">이 예에서는 두 번째 만듭니다 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 호출는 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 메서드를 스키마와 데이터를 채우는 것입니다.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> that will be used to read the data.</source>
          <target state="translated">데이터를 읽는 데 사용할 <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 XML 스키마와 데이터를 <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>으로 읽어옵니다.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated">데이터를 읽는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>The current <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and its descendents are loaded with the data from the supplied <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 및 제공 된 데이터와 함께 로드 되는 해당 하위 항목이 <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>The behavior of this method is identical to that of the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType&gt;</ph> method, except that in this case, data is loaded only for the current table and its descendants.</source>
          <target state="translated">이 메서드의 동작은 동일 합니다는 <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType&gt;</ph> 메서드와 비슷하지만 경우에 데이터는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서 로부터 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드는 스키마만 읽습니다.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph2">`DataColumn`</ph> 또는 <ph id="ph3">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> containing two columns and ten rows.</source>
          <target state="translated">다음 예제에서는 한 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 두 개의 열과 열 개의 행을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>The example writes the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> schema and data to a memory stream, by invoking the <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">이 예제에서는 기록는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 스키마와 데이터를 호출 하 여 메모리 스트림에 <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.IO.TextReader)">
          <source>The example creates a second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and calls the <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method to fill it with schema and data.</source>
          <target state="translated">이 예에서는 두 번째 만듭니다 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 호출는 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 메서드를 스키마와 데이터를 채우는 것입니다.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>The name of the file from which to read the data.</source>
          <target state="translated">데이터를 읽을 파일의 이름입니다.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> from the specified file.</source>
          <target state="translated">지정된 파일로부터 XML 스키마와 데이터를 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>로 읽어옵니다.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated">데이터를 읽는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>The current <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and its descendents are loaded with the data from the file named in the supplied <ph id="ph2">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 및 그 하위 항목에 제공 된 명명 된 파일에서 데이터와 함께 로드 되 <ph id="ph2">&lt;xref:System.String&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>The behavior of this method is identical to that of the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType&gt;</ph> method, except that in this case, data is loaded only for the current table and its descendants.</source>
          <target state="translated">이 메서드의 동작은 동일 합니다는 <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType&gt;</ph> 메서드와 비슷하지만 경우에 데이터는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서 로부터 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드는 스키마만 읽습니다.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph2">`DataColumn`</ph> 또는 <ph id="ph3">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> containing two columns and ten rows.</source>
          <target state="translated">다음 예제에서는 한 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 두 개의 열과 열 개의 행을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>The example writes the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> schema and data to disk.</source>
          <target state="translated">이 예제에서는 기록는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 스키마와 데이터 디스크를 합니다.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.String)">
          <source>The example creates a second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and calls the <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method to fill it with schema and data.</source>
          <target state="translated">이 예에서는 두 번째 만듭니다 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 호출는 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 메서드를 스키마와 데이터를 채우는 것입니다.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that will be used to read the data.</source>
          <target state="translated">데이터를 읽는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>Reads XML Schema and Data into the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 XML 스키마와 데이터를 <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>로 읽어옵니다.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated">데이터를 읽는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>The current <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and its descendents are loaded with the data from the file named in the supplied <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 및 그 하위 항목에 제공 된 명명 된 파일에서 데이터와 함께 로드 되 <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>The behavior of this method is identical to that of the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method, except that in this case, data is loaded only for the current table and its descendants.</source>
          <target state="translated">이 메서드의 동작은 동일 합니다는 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 메서드와 비슷하지만 경우에 데이터는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 메서드 데이터와 스키마를를 모두만 데이터를 읽을 수 있습니다는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서 로부터 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드는 스키마만 읽습니다.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 작성 하는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`WriteXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">스키마만을 작성 하기 위해 사용 하 여는 <ph id="ph1">`WriteXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">충돌이 있는지 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">인라인 스키마를 지정 하는 경우 XML 문서의 구조에 따라 동일한 관계형 구조를 필요에 따라 유추를 통해 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">유추를 통해 모든 데이터를 노출 하기 위해 스키마를 확장할 수 없습니다, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> 해당 XML 요소를 연결 하지는 않습니다 <ph id="ph2">`DataColumn`</ph> 또는 <ph id="ph3">`DataTable`</ph> 는 serialize 된 xml ("_")와 같은 문자가 올바른 XML 문자는 이스케이프 하는 경우.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated"><ph id="ph1">`DataSet`</ph> XML 요소 이름에 잘못 된 XML 문자가 이스케이프 자신과 따라서만 사용할 수는 동일 합니다.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">XML 요소 이름에 사용할 수 있는 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> containing two columns and ten rows.</source>
          <target state="translated">다음 예제에서는 한 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 두 개의 열과 열 개의 행을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>The example writes the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> schema and data to an <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">이 예제에서는 기록는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 스키마와 데이터를 한 <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)">
          <source>The example creates a second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and calls the <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method to fill it with schema and data from the <ph id="ph3">&lt;xref:System.Xml.XmlReader&gt;</ph> instance.</source>
          <target state="translated">이 예에서는 두 번째 만듭니다 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 호출는 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 스키마와 데이터를 채울 메서드는 <ph id="ph3">&lt;xref:System.Xml.XmlReader&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>Reads an XML schema into the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">XML 스키마를 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>으로 읽어옵니다.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Use the <ph id="ph1">`ReadXmlSchema`</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">`ReadXmlSchema`</ph> 에 대 한 스키마를 만들려면 다음 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The XML schema is interpreted according to the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준에 따라 해석 됩니다.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">`ReadXmlSchema`</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`ReadXmlSchema`</ph> 일반적으로 메서드를 호출 하기 전에 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 채우는 데 사용 되는 메서드는 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>The stream used to read the schema.</source>
          <target state="translated">스키마를 읽는 데 사용되는 스트림입니다.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>Reads an XML schema into the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified stream.</source>
          <target state="translated">지정된 스트림을 사용하여 XML 스키마를 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>로 읽어옵니다.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 에 대 한 스키마를 만들려면 다음 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>The XML schema is interpreted according to the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준에 따라 해석 됩니다.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>No exception will be thrown.</source>
          <target state="translated">예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>The <ph id="ph1">`ReadXmlSchema`</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`ReadXmlSchema`</ph> 일반적으로 메서드를 호출 하기 전에 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 채우는 데 사용 되는 메서드는 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>To create a nested relation using XML schema, use implicit nested elements.</source>
          <target state="translated">XML 스키마를 사용 하 여 중첩된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>You can also configure the nested relation to use explicit column names.</source>
          <target state="translated">명시적 열 이름을 사용 하도록 중첩된 관계를 구성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>Elements must be implicitly nested in order for the corresponding DataTables to participate in a nested relation.</source>
          <target state="translated">요소 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 순서 대로 암시적으로 중첩 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>The following console application creates a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, and writes the schema for that table to a <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph>.</source>
          <target state="translated">다음 콘솔 응용 프로그램에서는 새 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, 해당 테이블에 대 한 스키마를 작성 하 고는 <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)">
          <source>Then, the example creates a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and reads its schema from the saved XML schema.</source>
          <target state="translated">그런 다음 예제에서는 새 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> used to read the schema information.</source>
          <target state="translated">스키마 정보를 읽는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>Reads an XML schema into the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 XML 스키마를 <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>로 읽어옵니다.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 에 대 한 스키마를 만들려면 다음 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>The XML schema is interpreted according to the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준에 따라 해석 됩니다.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>No exception will be thrown.</source>
          <target state="translated">예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>The <ph id="ph1">`ReadXmlSchema`</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`ReadXmlSchema`</ph> 일반적으로 메서드를 호출 하기 전에 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 채우는 데 사용 되는 메서드는 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>To create a nested relation using XML schema, use implicit nested elements.</source>
          <target state="translated">XML 스키마를 사용 하 여 중첩된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>You can also reconfigure the nested relation to use explicit column names.</source>
          <target state="translated">명시적 열 이름을 사용 하도록 중첩된 관계를 재구성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>Elements must be implicitly nested in order for the corresponding DataTables to participate in a nested relation.</source>
          <target state="translated">요소 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 순서 대로 암시적으로 중첩 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>The following console application creates a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, and writes the schema for that table to a <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph>.</source>
          <target state="translated">다음 콘솔 응용 프로그램에서는 새 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, 해당 테이블에 대 한 스키마를 작성 하 고는 <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)">
          <source>Then, the example creates a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and reads its schema from the saved XML schema, using a <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> (which inherits from <ph id="ph3">&lt;xref:System.IO.TextReader&gt;</ph>) as its source.</source>
          <target state="translated">그런 다음 예제에서는 새 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 및 사용 하 여 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.는 <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> (에서 상속 되 <ph id="ph3">&lt;xref:System.IO.TextReader&gt;</ph>)를 원본으로 합니다.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>The name of the file from which to read the schema information.</source>
          <target state="translated">스키마 정보를 읽을 파일의 이름입니다.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>Reads an XML schema into the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> from the specified file.</source>
          <target state="translated">지정된 파일로부터 XML 스키마를 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>로 읽어옵니다.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 에 대 한 스키마를 만들려면 다음 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>The XML schema is interpreted according to the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준에 따라 해석 됩니다.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>No exception will be thrown.</source>
          <target state="translated">예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>The <ph id="ph1">`ReadXmlSchema`</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">`DataTable`</ph>.</source>
          <target state="translated"><ph id="ph1">`ReadXmlSchema`</ph> 일반적으로 메서드를 호출 하기 전에 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 채우는 데 사용 되는 메서드는 <ph id="ph3">`DataTable`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>To create a nested relation using XML schema, use implicit nested elements.</source>
          <target state="translated">XML 스키마를 사용 하 여 중첩된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>You can also reconfigure the nested relation to use explicit column names.</source>
          <target state="translated">명시적 열 이름을 사용 하도록 중첩된 관계를 재구성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>Elements must be implicitly nested in order for the corresponding DataTables to participate in a nested relation.</source>
          <target state="translated">요소 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 순서 대로 암시적으로 중첩 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>The following console application creates a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, and writes the schema for that table to a file.</source>
          <target state="translated">다음 콘솔 응용 프로그램에서는 새 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, 해당 테이블에 대 한 스키마 파일을 씁니다.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.String)">
          <source>Then, the example creates a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and reads its schema from the saved XML schema, using the file as its source.</source>
          <target state="translated">그런 다음 예제에서는 새 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 및 파일을 사용 하 여 원본으로 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> used to read the schema information.</source>
          <target state="translated">스키마 정보를 읽는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>Reads an XML schema into the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 XML 스키마를 <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>로 읽어옵니다.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 에 대 한 스키마를 만들려면 다음 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">스키마는 XML 문서를 작성 하려면 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The XML schema is interpreted according to the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준에 따라 해석 됩니다.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">msdata:DataType 및 xs:type 형식 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>No exception will be thrown.</source>
          <target state="translated">예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The <ph id="ph1">`ReadXmlSchema`</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`ReadXmlSchema`</ph> 일반적으로 메서드를 호출 하기 전에 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 채우는 데 사용 되는 메서드는 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The way to create a nested relation using XML schema is to have implicit nested elements.</source>
          <target state="translated">XML 스키마를 사용 하 여 중첩된 관계를 만들 수 있는 방법은 암시적 중첩 된 요소를 것입니다.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>Additionally, the nested relation could be re-wired, to use explicit column names.</source>
          <target state="translated">또한 중첩된 관계 명시적 열 이름을 사용 하도록 다시 연결할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>It is mandatory for elements to be implicitly nested for the corresponding DataTables to participate in a nested relation.</source>
          <target state="translated">암시적으로 중첩된 관계에 참여 하도록 해당 Datatable에 대 한 중첩 된 요소에 대 한 필수입니다.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The following console application creates a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, and writes the schema for that table to a <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph>.</source>
          <target state="translated">다음 콘솔 응용 프로그램에서는 새 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, 해당 테이블에 대 한 스키마를 작성 하 고는 <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)">
          <source>Then, the example creates a new <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> and reads its schema from the saved XML schema, using a <ph id="ph2">&lt;xref:System.Xml.XmlTextReader&gt;</ph> (which inherits from <ph id="ph3">&lt;xref:System.Xml.XmlReader&gt;</ph>) as its source.</source>
          <target state="translated">그런 다음 예제에서는 새 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 및 사용 하 여 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.는 <ph id="ph2">&lt;xref:System.Xml.XmlTextReader&gt;</ph> (에서 상속 되 <ph id="ph3">&lt;xref:System.Xml.XmlReader&gt;</ph>)를 원본으로 합니다.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)">
          <source>Reads from an XML stream.</source>
          <target state="translated">XML 스트림에서 읽습니다.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.RejectChanges">
          <source>Rolls back all changes that have been made to the table since it was loaded, or the last time <ph id="ph1">&lt;see cref="M:System.Data.DataTable.AcceptChanges" /&gt;</ph> was called.</source>
          <target state="translated">테이블이 로드된 이후 또는 <ph id="ph1">&lt;see cref="M:System.Data.DataTable.AcceptChanges" /&gt;</ph>가 마지막으로 호출된 이후에 변경된 내용을 모두 롤백합니다.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.RejectChanges">
          <source>When <ph id="ph1">&lt;xref:System.Data.DataTable.RejectChanges%2A&gt;</ph> is called, any <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> objects that are still in edit-mode cancel their edits.</source>
          <target state="translated">때 <ph id="ph1">&lt;xref:System.Data.DataTable.RejectChanges%2A&gt;</ph> 호출, <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> 아직 편집 모드에에서 있는 개체의 편집이 취소 합니다.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.RejectChanges">
          <source>New rows are removed.</source>
          <target state="translated">새 행이 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.RejectChanges">
          <source>Rows with the <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> set to <ph id="ph2">`Modified`</ph> or <ph id="ph3">`Deleted`</ph> return back to their original state.</source>
          <target state="translated">행의 <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> 로 설정 <ph id="ph2">`Modified`</ph> 또는 <ph id="ph3">`Deleted`</ph> 를 원래 상태로 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.RejectChanges">
          <source>The following example makes several changes to a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>, but rejects the changes by invoking the <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 몇 가지 변경 내용에는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph>를 호출 하 여 변경 내용을 거부는 <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.RemotingFormat">
          <source>Gets or sets the serialization format.</source>
          <target state="translated">serialization 형식을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.RemotingFormat">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.SerializationFormat" /&gt;</ph> enumeration specifying either <ph id="ph2">&lt;see langword="Binary" /&gt;</ph> or <ph id="ph3">&lt;see langword="Xml" /&gt;</ph> serialization.</source>
          <target state="translated"><ph id="ph2">&lt;see langword="Binary" /&gt;</ph> 또는 <ph id="ph3">&lt;see langword="Xml" /&gt;</ph> serialization을 지정하는 <ph id="ph1">&lt;see cref="T:System.Data.SerializationFormat" /&gt;</ph> 열거형입니다.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Reset">
          <source>Resets the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> to its original state.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>을 원래 상태로 다시 설정합니다.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Reset">
          <source>Reset removes all data, indexes, relations, and columns of the table.</source>
          <target state="translated">다시 설정은 테이블의 모든 데이터, 인덱스, 관계 및 열을 제거합니다.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Reset">
          <source>If a DataSet includes a DataTable, the table will still be part of the DataSet after the table is reset.</source>
          <target state="translated">DataSet에 DataTable이 포함된 경우 테이블을 다시 설정한 후 테이블은 DataSet의 일부가 됩니다.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="E:System.Data.DataTable.RowChanged">
          <source>Occurs after a <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> has been changed successfully.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>가 변경된 후에 발생합니다.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.RowChanged">
          <source>For more information, see <bpt id="p1">[</bpt>Handling DataTable Events<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>DataTable 이벤트 처리<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="E:System.Data.DataTable.RowChanging">
          <source>Occurs when a <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> is changing.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>가 변경될 때 발생합니다.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.RowChanging">
          <source>For more information, see <bpt id="p1">[</bpt>Handling DataTable Events<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>DataTable 이벤트 처리<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="E:System.Data.DataTable.RowDeleted">
          <source>Occurs after a row in the table has been deleted.</source>
          <target state="translated">테이블의 행이 삭제된 후 발생합니다.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.RowDeleted">
          <source>For more information, see <bpt id="p1">[</bpt>Handling DataTable Events<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>DataTable 이벤트 처리<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="E:System.Data.DataTable.RowDeleting">
          <source>Occurs before a row in the table is about to be deleted.</source>
          <target state="translated">테이블의 행이 삭제되기 직전에 발생합니다.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.RowDeleting">
          <source>For more information, see <bpt id="p1">[</bpt>Handling DataTable Events<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>DataTable 이벤트 처리<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.Rows">
          <source>Gets the collection of rows that belong to this table.</source>
          <target state="translated">이 테이블에 속한 행의 컬렉션을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Rows">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRowCollection" /&gt;</ph> that contains <ph id="ph2">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects; otherwise a null value if no <ph id="ph3">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects exist.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRowCollection" /&gt;</ph> 개체가 포함된 <ph id="ph2">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>이거나, <ph id="ph3">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체가 없으면 null 값입니다.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Rows">
          <source>To create a new <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph>, you must use the <ph id="ph2">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> method to return a new object.</source>
          <target state="translated">새로 만들려면 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph>를 사용 해야 합니다는 <ph id="ph2">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> 메서드는 새 개체를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Rows">
          <source>Such an object is automatically configured according to the schema defined for the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> through its collection of <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects.</source>
          <target state="translated">이러한 개체에 대해 정의 된 스키마에 따라 자동으로 구성 되는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 의 컬렉션을 통해 <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Rows">
          <source>After creating a new row and setting the values for each column in the row, add the row to the <ph id="ph1">&lt;xref:System.Data.DataRowCollection&gt;</ph> using the <ph id="ph2">`Add`</ph> method.</source>
          <target state="translated">새 행을 만드는 행의 각 열에 대 한 값을 설정 후, 행을 추가 하는 <ph id="ph1">&lt;xref:System.Data.DataRowCollection&gt;</ph> 를 사용 하는 <ph id="ph2">`Add`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Rows">
          <source>Each <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> in the collection represents a row of data in the table.</source>
          <target state="translated">각 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> 컬렉션에는 테이블에 데이터의 행을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Rows">
          <source>To commit a change to the value of a column in the row, you must invoke the <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> method.</source>
          <target state="translated">행의 열 값에는 변경 내용을 커밋하지를 호출 해야는 <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Rows">
          <source>The following shows two examples of returning and setting rows.</source>
          <target state="translated">다음은 반환 하 고 행을 설정 하는 두 가지 예입니다.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Rows">
          <source>The first example uses the <ph id="ph1">&lt;xref:System.Data.DataTable.Rows%2A&gt;</ph> property and prints the value of each column for every row.</source>
          <target state="translated">사용 하 여 첫 번째 예제는 <ph id="ph1">&lt;xref:System.Data.DataTable.Rows%2A&gt;</ph> 속성 하 고 모든 행에 대 한 각 열의 값을 출력 합니다.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Rows">
          <source>The second example uses the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> object's <ph id="ph2">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> method to create a new <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> object with the schema of the <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">사용 하 여 두 번째 예제는 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 개체의 <ph id="ph2">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph> 만드는 새 메서드를 <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> 개체의 스키마와는 <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Rows">
          <source>After setting the row values, the row is added to the <ph id="ph1">&lt;xref:System.Data.DataRowCollection&gt;</ph> through the <ph id="ph2">`Add`</ph> method.</source>
          <target state="translated">행 값을 설정한 후에 행이 추가 <ph id="ph1">&lt;xref:System.Data.DataRowCollection&gt;</ph> 통해는 <ph id="ph2">`Add`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>Gets an array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체의 배열을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select">
          <source>Gets an array of all <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects.</source>
          <target state="translated">모든 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체의 배열을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select">
          <source>To ensure the proper sort order, specify sort criteria with <ph id="ph1">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph>.</source>
          <target state="translated">지정 된 정렬 조건을 적절 한 정렬 순서를 보장 하려면 <ph id="ph1">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select">
          <source>The following example returns an array of <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> objects through the <ph id="ph2">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 배열을 반환 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> 통해 개체는 <ph id="ph2">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String)">
          <source>The criteria to use to filter the rows.</source>
          <target state="translated">행을 필터링하기 위해 사용하는 조건입니다.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String)">
          <source>For examples on how to filter rows, see <bpt id="p1">[</bpt>DataView RowFilter Syntax [C#]<ept id="p1">](http://www.csharp-examples.net/dataview-rowfilter/)</ept>.</source>
          <target state="translated">예를 들어, 행을 필터링하는 방법은 <bpt id="p1">[</bpt>DataView RowFilter 구문 [C#]<ept id="p1">](http://www.csharp-examples.net/dataview-rowfilter/)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String)">
          <source>Gets an array of all <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects that match the filter criteria.</source>
          <target state="translated">필터 조건에 맞는 모든 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체의 배열을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String)">
          <source>To create the <ph id="ph1">`filterExpression`</ph> argument, use the same rules that apply to the <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> class's <ph id="ph3">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> property value for creating filters.</source>
          <target state="translated">만들려는 <ph id="ph1">`filterExpression`</ph> 인수를에 적용 되는 동일한 규칙을 사용 하 여는 <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> 클래스의 <ph id="ph3">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> 필터를 만들기 위한 속성 값입니다.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String)">
          <source>To ensure the proper sort order, specify sort criteria with <ph id="ph1">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph>.</source>
          <target state="translated">지정 된 정렬 조건을 적절 한 정렬 순서를 보장 하려면 <ph id="ph1">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String)">
          <source>If the column on the filter contains a null value, it will not be part of the result.</source>
          <target state="translated">필터에 열에 null 값이 포함 된 결과에 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String)">
          <source>The following example uses a filter expression to return an array of <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> objects.</source>
          <target state="translated">다음 예제는 필터 식을 사용 하 여의 배열을 반환할 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String,System.String)">
          <source>The criteria to use to filter the rows.</source>
          <target state="translated">행을 필터링하기 위해 사용하는 조건입니다.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String,System.String)">
          <source>For examples on how to filter rows, see <bpt id="p1">[</bpt>DataView RowFilter Syntax [C#]<ept id="p1">](http://www.csharp-examples.net/dataview-rowfilter/)</ept>.</source>
          <target state="translated">예를 들어, 행을 필터링하는 방법은 <bpt id="p1">[</bpt>DataView RowFilter 구문 [C#]<ept id="p1">](http://www.csharp-examples.net/dataview-rowfilter/)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String,System.String)">
          <source>A string specifying the column and sort direction.</source>
          <target state="translated">열과 정렬 방향을 지정하는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String,System.String)">
          <source>Gets an array of all <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects that match the filter criteria, in the specified sort order.</source>
          <target state="translated">필터 조건에 맞는 모든 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체의 배열을 지정된 정렬 순서대로 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String,System.String)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects matching the filter expression.</source>
          <target state="translated">필터 식에 맞는 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체의 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String,System.String)">
          <source>To form the <ph id="ph1">`filterExpression`</ph> argument, use the same rules for creating the <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> class's <ph id="ph3">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> property value.</source>
          <target state="translated">양식에 <ph id="ph1">`filterExpression`</ph> 인수를 동일한 규칙을 만들기 위한 사용는 <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> 클래스의 <ph id="ph3">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> 속성 값입니다.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String,System.String)">
          <source>The <ph id="ph1">`Sort`</ph> argument also uses the same rules for creating class's <ph id="ph2">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> strings.</source>
          <target state="translated"><ph id="ph1">`Sort`</ph> 인수 클래스의를 만들기 위한 동일한 규칙에도 사용 <ph id="ph2">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String,System.String)">
          <source>If the column on the filter contains a null value, it will not be part of the result.</source>
          <target state="translated">필터에 열에 null 값이 포함 된 결과에 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String,System.String)">
          <source>The following example uses a filter expression to return an array of <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> objects.</source>
          <target state="translated">다음 예제는 필터 식을 사용 하 여의 배열을 반환할 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)">
          <source>The criteria to use to filter the rows.</source>
          <target state="translated">행을 필터링하기 위해 사용하는 조건입니다.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)">
          <source>For examples on how to filter rows, see <bpt id="p1">[</bpt>DataView RowFilter Syntax [C#]<ept id="p1">](http://www.csharp-examples.net/dataview-rowfilter/)</ept>.</source>
          <target state="translated">예를 들어, 행을 필터링하는 방법은 <bpt id="p1">[</bpt>DataView RowFilter 구문 [C#]<ept id="p1">](http://www.csharp-examples.net/dataview-rowfilter/)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)">
          <source>A string specifying the column and sort direction.</source>
          <target state="translated">열과 정렬 방향을 지정하는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.DataViewRowState" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataViewRowState" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)">
          <source>Gets an array of all <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects that match the filter in the order of the sort that match the specified state.</source>
          <target state="translated">필터와 일치하는 모든 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체의 배열을 지정된 상태와 일치하는 정렬 순서대로 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)">
          <source>To form the <ph id="ph1">`filterExpression`</ph> argument, use the same rules for creating the <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> class's <ph id="ph3">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> property value.</source>
          <target state="translated">양식에 <ph id="ph1">`filterExpression`</ph> 인수를 동일한 규칙을 만들기 위한 사용는 <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> 클래스의 <ph id="ph3">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> 속성 값입니다.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)">
          <source>The <ph id="ph1">`Sort`</ph> argument also uses the same rules for creating class's <ph id="ph2">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> strings.</source>
          <target state="translated"><ph id="ph1">`Sort`</ph> 인수 클래스의를 만들기 위한 동일한 규칙에도 사용 <ph id="ph2">&lt;xref:System.Data.DataColumn.Expression%2A&gt;</ph> 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)">
          <source>If the column on the filter contains a null value, it will not be part of the result.</source>
          <target state="translated">필터에 열에 null 값이 포함 된 결과에 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)">
          <source>The following example uses a filter expression and record state to return an array of <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> objects.</source>
          <target state="translated">다음 예제에서는 필터 식과 레코드 상태를 사용 하 여 배열을 반환할 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.Site">
          <source>Gets or sets an <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph>에 대한 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Site">
          <source>An <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph>에 대한 <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.Site">
          <source>Sites bind a <ph id="ph1">&lt;xref:System.ComponentModel.Component&gt;</ph> to a <ph id="ph2">&lt;xref:System.ComponentModel.Container&gt;</ph> and enable communication between them, as well as provide a way for the container to manage its components.</source>
          <target state="translated">사이트 바인딩는 <ph id="ph1">&lt;xref:System.ComponentModel.Component&gt;</ph> 에 <ph id="ph2">&lt;xref:System.ComponentModel.Container&gt;</ph> 서로 통신할 수 있도록 할 뿐만 아니라 컨테이너에서 해당 구성 요소를 관리할 수 있는 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.ComponentModel.IListSource.ContainsListCollection" /&gt;</ph>.</source>
          <target state="translated">이 멤버에 대한 설명은 <ph id="ph1">&lt;see cref="P:System.ComponentModel.IListSource.ContainsListCollection" /&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the collection is a collection of <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph> objects; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">해당 컬렉션이 <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph> 개체의 컬렉션이면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.ComponentModel.IListSource.GetList" /&gt;</ph>.</source>
          <target state="translated">이 멤버에 대한 설명은 <ph id="ph1">&lt;see cref="M:System.ComponentModel.IListSource.GetList" /&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> that can be bound to a data source from the object.</source>
          <target state="translated">해당 개체에서 데이터 소스에 바인딩될 수 있는 <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>.</source>
          <target state="translated">이 멤버에 대한 설명은 <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchema" /&gt;</ph> that describes the XML representation of the object that is produced by the <ph id="ph2">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph> method and consumed by the <ph id="ph3">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchema" /&gt;</ph> 메서드에 의해 생성되고 <ph id="ph2">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph> 메서드가 사용하는 개체의 XML 표현을 설명하는 <ph id="ph3">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>An XmlReader.</source>
          <target state="translated">XmlReader입니다.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph>.</source>
          <target state="translated">이 멤버에 대한 설명은 <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>An XmlWriter.</source>
          <target state="translated">XmlWriter입니다.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph>.</source>
          <target state="translated">이 멤버에 대한 설명은 <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="E:System.Data.DataTable.TableCleared">
          <source>Occurs after a <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> is cleared.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>이 지워진 다음 발생합니다.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.TableCleared">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.TableCleared&gt;</ph> event is fired immediately after all rows have been successfully cleared but before the <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph> method returns control back to the caller.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.TableCleared&gt;</ph> 이벤트가 모든 행이 성공적으로 지워진 하기 전에 직후는 <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph> 메서드 호출자에 게 제어를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.TableCleared">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.TableCleared&gt;</ph> event is not fired if there are any exceptions during the clear operation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.TableCleared&gt;</ph> 지우기 작업 중 모든 예외가 있는 경우에 이벤트가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="E:System.Data.DataTable.TableClearing">
          <source>Occurs when a <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> is cleared.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>이 지워질 때 발생합니다.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.TableClearing">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.TableClearing&gt;</ph> event is fired before processing of the <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph> operation begins.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.TableClearing&gt;</ph> 이벤트가 처리 되기 전에 <ph id="ph2">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph> 작업이 시작 됩니다.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.TableClearing">
          <source>This event is always fired when the <ph id="ph1">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph> method is invoked, even if the table contains zero rows.</source>
          <target state="translated">이 이벤트는 시기는 <ph id="ph1">&lt;xref:System.Data.DataTable.Clear%2A&gt;</ph> 테이블 0 개의 행을 포함 하는 경우에 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.TableName">
          <source>Gets or sets the name of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 이름을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.TableName">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 이름입니다.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.TableName">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.TableName%2A&gt;</ph> is used to return this table from the parent <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object's <ph id="ph3">&lt;xref:System.Data.DataTableCollection&gt;</ph> (returned by the <ph id="ph4">&lt;xref:System.Data.DataSet.Tables%2A&gt;</ph> property).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.TableName%2A&gt;</ph> 부모 개체에서이 테이블을 반환 하는 데 사용 <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> 개체의 <ph id="ph3">&lt;xref:System.Data.DataTableCollection&gt;</ph> (에서 반환 되는 <ph id="ph4">&lt;xref:System.Data.DataSet.Tables%2A&gt;</ph> 속성).</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataTable.TableName">
          <source>The following example prints the <ph id="ph1">&lt;xref:System.Data.DataTable.TableName%2A&gt;</ph> for each table in a collection of <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects.</source>
          <target state="translated">다음 예제에서는 인쇄는 <ph id="ph1">&lt;xref:System.Data.DataTable.TableName%2A&gt;</ph> 컬렉션의 각 테이블에 대해 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.TableName">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> or empty string ("") is passed in and this table belongs to a collection.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> 또는 빈 문자열("")이 전달되고 이 테이블이 컬렉션에 속하는 경우</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.TableName">
          <source>The table belongs to a collection that already has a table with the same name.</source>
          <target state="translated">같은 이름을 가진 테이블이 이미 들어 있는 컬렉션에 테이블이 속한 경우.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="P:System.Data.DataTable.TableName">
          <source>(Comparison is case-sensitive).</source>
          <target state="translated">비교 시 대/소문자가 구분됩니다.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="E:System.Data.DataTable.TableNewRow">
          <source>Occurs when a new <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> is inserted.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph>가 삽입될 때 발생합니다.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.TableNewRow">
          <source>Fires after a new <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> has been created using <ph id="ph2">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph>.</source>
          <target state="translated">발생 한 이후에 새 시작 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> 사용 하 여 만든 <ph id="ph2">&lt;xref:System.Data.DataTable.NewRow%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.TableNewRow">
          <source>This event is fired before the invoked <ph id="ph1">`NewRow`</ph> method returns.</source>
          <target state="translated">이 이벤트가 발생 하기 전에 호출 된 <ph id="ph1">`NewRow`</ph> 메서드 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataTable.TableNewRow">
          <source>The new <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> instance is detached; it has not been added to the collection.</source>
          <target state="translated">새 <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> 컬렉션에 추가 되지 않으면 인스턴스는 분리 합니다.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ToString">
          <source>Gets the <ph id="ph1">&lt;see cref="P:System.Data.DataTable.TableName" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.Data.DataTable.DisplayExpression" /&gt;</ph>, if there is one as a concatenated string.</source>
          <target state="translated">연결된 문자열이 있는 경우 <ph id="ph1">&lt;see cref="P:System.Data.DataTable.TableName" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="P:System.Data.DataTable.DisplayExpression" /&gt;</ph>을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.ToString">
          <source>A string consisting of the <ph id="ph1">&lt;see cref="P:System.Data.DataTable.TableName" /&gt;</ph> and the <ph id="ph2">&lt;see cref="P:System.Data.DataTable.DisplayExpression" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Data.DataTable.TableName" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="P:System.Data.DataTable.DisplayExpression" /&gt;</ph> 값으로 구성된 문자열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ToString">
          <source>Gets the <ph id="ph1">&lt;xref:System.Data.DataTable.TableName%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.DisplayExpression%2A&gt;</ph> for the <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>.</source>
          <target state="translated">가져옵니다는 <ph id="ph1">&lt;xref:System.Data.DataTable.TableName%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.DisplayExpression%2A&gt;</ph> 에 대 한는 <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.ToString">
          <source>The following example returns the <ph id="ph1">&lt;xref:System.Data.DataTable.TableName%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.DisplayExpression%2A&gt;</ph> using the <ph id="ph3">&lt;xref:System.Data.DataTable.ToString%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 반환 된 <ph id="ph1">&lt;xref:System.Data.DataTable.TableName%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.DisplayExpression%2A&gt;</ph> 를 사용 하 여는 <ph id="ph3">&lt;xref:System.Data.DataTable.ToString%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>Writes the current contents of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as XML.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 내용을 XML로 씁니다.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>To write both data and schema, use one of the overloads that include the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The following console application creates two <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances, adds each to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, creates a <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> relating the two tables, and then uses the <ph id="ph4">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method to write the data contained within the parent table to a <ph id="ph5">&lt;xref:System.IO.TextWriter&gt;</ph>.</source>
          <target state="translated">다음 콘솔 응용 프로그램에서는 두 개의 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 인스턴스, 각각을 추가 하는 <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, 만듭니다는 <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> 두 관련 테이블을 선택한 다음 사용 하 여는 <ph id="ph4">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드는 하는부모테이블내에포함된데이터를쓸<ph id="ph5">&lt;xref:System.IO.TextWriter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The example demonstrates the behavior when setting the <ph id="ph1">`writeHierarchy`</ph> parameter to each of its values.</source>
          <target state="translated">이 예제에서는 설정할 때 동작을 보여 줍니다는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수를 각각의 값입니다.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>This example shows how to use one of the overloaded versions of WriteXml.</source>
          <target state="translated">이 예제에는 WriteXml의 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>For other examples that might be available, see the individual overload topics.</source>
          <target state="translated">사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The example displays the following output in the console window:</source>
          <target state="translated">이 예제에서는 콘솔 창에 다음 출력을 표시합니다.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream)">
          <source>The stream to which the data will be written.</source>
          <target state="translated">데이터가 기록될 스트림입니다.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream)">
          <source>Writes the current contents of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as XML using the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>를 사용하여 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 콘텐츠를 XML로 작성합니다.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> with which to write the content.</source>
          <target state="translated">콘텐츠를 쓰는 데 사용할 <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)">
          <source>Writes the current contents of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as XML using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>를 사용하여 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 콘텐츠를 XML로 작성합니다.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String)">
          <source>The file to which to write the XML data.</source>
          <target state="translated">XML 데이터를 기록할 파일입니다.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String)">
          <source>Writes the current contents of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as XML using the specified file.</source>
          <target state="translated">지정된 파일을 사용하여 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 내용을 XML로 씁니다.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> with which to write the contents.</source>
          <target state="translated">내용을 기록하는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)">
          <source>Writes the current contents of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as XML using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>를 사용하여 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 콘텐츠를 XML로 작성합니다.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)">
          <source>To write both data and schema, use one of the overloads that include the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>The stream to which the data will be written.</source>
          <target state="translated">데이터가 기록될 스트림입니다.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the contents of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the data for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 데이터만 씁니다.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>Writes the current contents of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as XML using the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>를 사용하여 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 콘텐츠를 XML로 작성합니다.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>To save the data for the table and all its descendants, set the <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">테이블과 모든 하위 항목의 데이터를 저장하려면 <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> 매개 변수를 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> to an XML document.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 에 대 한 스키마를 작성 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서에 있습니다.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXml`</ph> method writes the data only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXml`</ph> 메서드는 현재 테이블에 대 한 데이터를 씁니다.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>To write the data for the current table and all of its descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>The stream to which the data will be written.</source>
          <target state="translated">데이터가 기록될 스트림입니다.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> to the specified file using the specified <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 지정된 파일에 <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">스키마를 쓰려면 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 매개 변수 값을 <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> with which to write the content.</source>
          <target state="translated">콘텐츠를 쓰는 데 사용할 <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the contents of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the data for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 데이터만 씁니다.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>Writes the current contents of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as XML using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>를 사용하여 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 콘텐츠를 XML로 작성합니다.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>To save the data for the table and all its descendants, set the <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">테이블과 모든 하위 항목의 데이터를 저장하려면 <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> 매개 변수를 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXml`</ph> method writes the data only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXml`</ph> 메서드는 현재 테이블에 대 한 데이터를 씁니다.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>To write the data for the current table and all its descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 모든 하위 항목, 관련 테이블에 대 한 데이터를 작성 하려면이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>The following console application creates two <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances, adds each to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, creates a <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> relating the two tables, and then uses the <ph id="ph4">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method to write the data contained within the parent table to a <ph id="ph5">&lt;xref:System.IO.TextWriter&gt;</ph>.</source>
          <target state="translated">다음 콘솔 응용 프로그램에서는 두 개의 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 인스턴스, 각각을 추가 하는 <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, 만듭니다는 <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> 두 관련 테이블을 선택한 다음 사용 하 여는 <ph id="ph4">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드는 하는부모테이블내에포함된데이터를쓸<ph id="ph5">&lt;xref:System.IO.TextWriter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)">
          <source>The example demonstrates the behavior when setting the <ph id="ph1">`writeHierarchy`</ph> parameter to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">이 예제에서는 설정할 때 동작을 보여 줍니다는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수를 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> used to write the document.</source>
          <target state="translated">문서를 쓰는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>와 <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>를 사용하여 <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">스키마를 쓰려면 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 매개 변수 값을 <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>The file to which to write the XML data.</source>
          <target state="translated">XML 데이터를 기록할 파일입니다.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the contents of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the data for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 데이터만 씁니다.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>Writes the current contents of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as XML using the specified file.</source>
          <target state="translated">지정된 파일을 사용하여 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 내용을 XML로 씁니다.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>To save the data for the table and all its descendants, set the <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">테이블과 모든 하위 항목의 데이터를 저장하려면 <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> 매개 변수를 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXml`</ph> method writes the data only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXml`</ph> 메서드는 현재 테이블에 대 한 데이터를 씁니다.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>To write the data for the current table and all of its descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>The name of the file to which the data will be written.</source>
          <target state="translated">데이터가 기록될 파일의 이름입니다.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified file and <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">지정된 파일과 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>에 대해 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">스키마를 쓰려면 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 매개 변수 값을 <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To write both data and schema, use one of the overloads that include the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> with which to write the contents.</source>
          <target state="translated">내용을 기록하는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the contents of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the data for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 데이터만 씁니다.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>Writes the current contents of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as XML using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>를 사용하여 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 콘텐츠를 XML로 작성합니다.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>To write both data and schema, use one of the overloads that include the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXml`</ph> method writes the data only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXml`</ph> 메서드는 현재 테이블에 대 한 데이터를 씁니다.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>To write the data for the current table and its entire descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 데이터를 작성 하려면이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> used to write the document.</source>
          <target state="translated">문서를 쓰는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>와 <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>를 사용하여 <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">스키마를 쓰려면 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 매개 변수 값을 <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To write both data and schema, use one of the overloads that include the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>The stream to which the data will be written.</source>
          <target state="translated">데이터가 기록될 스트림입니다.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the contents of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the data for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 데이터만 씁니다.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> to the specified file using the specified <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 지정된 파일에 <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">스키마를 쓰려면 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 매개 변수 값을 <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>To save the data for the table and all its descendants, set the <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">테이블과 모든 하위 항목의 데이터를 저장하려면 <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> 매개 변수를 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">`DataTable`</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">`DataTable`</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`XmlWriteMode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">`XmlWriteMode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>Normally, the <ph id="ph1">`WriteXml`</ph> method saves data only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXml`</ph> 메서드는 현재 테이블에 대 한 데이터를 저장 합니다.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">`DataTable`</ph> into an XML document, whereas the <ph id="ph3">`WriteXmlSchema`</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">`WriteXml`</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">`DataTable`</ph> XML 문서로 반면는 <ph id="ph3">`WriteXmlSchema`</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`XmlWriteMode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">`XmlWriteMode`</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXml`</ph> method writes the data only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXml`</ph> 메서드는 현재 테이블에 대 한 데이터를 씁니다.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write the data for the current table and all of its descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> used to write the document.</source>
          <target state="translated">문서를 쓰는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the contents of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the data for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 데이터만 씁니다.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>와 <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>를 사용하여 <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">스키마를 쓰려면 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 매개 변수 값을 <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To save the data for the table and all its descendants, set the <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">테이블과 모든 하위 항목의 데이터를 저장하려면 <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> 매개 변수를 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>Normally, the <ph id="ph1">`WriteXml`</ph> method saves data only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXml`</ph> 메서드는 현재 테이블에 대 한 데이터를 저장 합니다.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXml`</ph> method writes the data only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXml`</ph> 메서드는 현재 테이블에 대 한 데이터를 씁니다.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write the data for the current table and all of its descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 모든 하위 항목에 대 한 데이터를 쓸 관련 테이블,이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>The following console application creates two <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances, adds each to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, creates a <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> relating the two tables, and then uses the <ph id="ph4">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method to write the data contained within the parent table to a <ph id="ph5">&lt;xref:System.IO.TextWriter&gt;</ph>.</source>
          <target state="translated">다음 콘솔 응용 프로그램에서는 두 개의 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 인스턴스, 각각을 추가 하는 <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, 만듭니다는 <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> 두 관련 테이블을 선택한 다음 사용 하 여는 <ph id="ph4">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드는 하는부모테이블내에포함된데이터를쓸<ph id="ph5">&lt;xref:System.IO.TextWriter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>The example demonstrates the behavior when setting the <ph id="ph1">`writeHierarchy`</ph> parameter to each of its values.</source>
          <target state="translated">이 예제에서는 설정할 때 동작을 보여 줍니다는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수를 각각의 값입니다.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>The example displays the following output in the console window:</source>
          <target state="translated">이 예제에서는 콘솔 창에 다음 출력을 표시합니다.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>The name of the file to which the data will be written.</source>
          <target state="translated">데이터가 기록될 파일의 이름입니다.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the contents of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the data for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 데이터만 씁니다.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified file and <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">지정된 파일과 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>에 대해 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">스키마를 쓰려면 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 매개 변수 값을 <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>To save the data for the table and all its descendants, set the <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">테이블과 모든 하위 항목의 데이터를 저장하려면 <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> 매개 변수를 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write both data and schema, use one of the overloads that include the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>Normally, the <ph id="ph1">`WriteXml`</ph> method saves data only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXml`</ph> 메서드는 현재 테이블에 대 한 데이터를 저장 합니다.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>If you want to save the data for the current table and all of schema, the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">현재 테이블 및 모든 스키마에 대 한 데이터를 저장 하려는 경우는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write both data and schema, use one of the overloads that include the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXml`</ph> method writes the data only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXml`</ph> 메서드는 현재 테이블에 대 한 데이터를 씁니다.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write the data for the current table and all descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 모든 하위 항목, 관련 테이블에 대 한 데이터를 작성 하려면이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> used to write the document.</source>
          <target state="translated">문서를 쓰는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the contents of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the data for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 데이터만 씁니다.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>와 <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>를 사용하여 <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">스키마를 쓰려면 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 매개 변수 값을 <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To save the data for the table and all its descendants, set the <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">테이블과 모든 하위 항목의 데이터를 저장하려면 <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> 매개 변수를 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드 데이터와에서 스키마를 모두만 데이터를 작성 하는 방법을 제공는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서로 반면는 <ph id="ph3">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write both data and schema, use one of the overloads that include the <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용는 <ph id="ph1">&lt;xref:System.Data.XmlWriteMode&gt;</ph> 매개 변수를 해당 값을 설정 하 고 <ph id="ph2">`WriteSchema`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">동일한은 대 한 적용 된 <ph id="ph1">&lt;xref:System.Data.DataTable.ReadXml%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Data.DataTable.ReadXmlSchema%2A&gt;</ph> 메서드를 각각.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataTable`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">XML 데이터 또는 둘 다 스키마와 데이터를 읽을 수는 <ph id="ph1">`DataTable`</ph>를 사용 하 여는 <ph id="ph2">`ReadXml`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">사용 하 여 스키마만 읽을 수는 <ph id="ph1">`ReadXmlSchema`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXml`</ph> method writes the data only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXml`</ph> 메서드는 현재 테이블에 대 한 데이터를 씁니다.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>To write the data for the current table and its entire descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 데이터를 작성 하려면이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 경우의 열 유형이 throw 됩니다는 <ph id="ph2">`DataRow`</ph> 에서 읽거나 구현에 기록 되 고 <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> 구현 하지 않으므로 <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="T:System.Data.DataTable">
          <source>Writes the current data structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as an XML schema.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 데이터 구조를 XML 스키마로 씁니다.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> to an XML document.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 에 대 한 스키마를 작성 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서에 있습니다.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The following console application creates two <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances, adds each to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, creates a <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> relating the two tables, and then uses the <ph id="ph4">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the data contained within the parent table to a <ph id="ph5">&lt;xref:System.IO.TextWriter&gt;</ph>.</source>
          <target state="translated">다음 콘솔 응용 프로그램에서는 두 개의 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 인스턴스, 각각을 추가 하는 <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, 만듭니다는 <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> 두 관련 테이블을 선택한 다음 사용 하 여는 <ph id="ph4">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 하는부모테이블내에포함된데이터를쓸<ph id="ph5">&lt;xref:System.IO.TextWriter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The example demonstrates the behavior when setting the <ph id="ph1">`writeHierarchy`</ph> parameter to each of its values.</source>
          <target state="translated">이 예제에서는 설정할 때 동작을 보여 줍니다는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수를 각각의 값입니다.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>This example shows how to use one of the overloaded versions of <ph id="ph1">`WriteXmlSchema`</ph> For other examples that might be available, see the individual overload topics.</source>
          <target state="translated">오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 주는이 예제 <ph id="ph1">`WriteXmlSchema`</ph> 다른 예제를 사용할 수 있는 오버 로드 개별 항목을 참조 합니다.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataTable">
          <source>The example displays the following output in the console window:</source>
          <target state="translated">이 예제에서는 콘솔 창에 다음 출력을 표시합니다.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)">
          <source>The stream to which the XML schema will be written.</source>
          <target state="translated">XML 스키마가 기록될 스트림입니다.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)">
          <source>Writes the current data structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as an XML schema to the specified stream.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 데이터 구조를 지정된 스트림에 XMl 스키마로 씁니다.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> to an XML document.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 에 대 한 스키마를 작성 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서에 있습니다.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> with which to write.</source>
          <target state="translated">쓰기에 사용할 <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)">
          <source>Writes the current data structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as an XML schema using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>의 현재 데이터 구조를 XML 스키마로 씁니다.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> to an XML document.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 에 대 한 스키마를 작성 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서에 있습니다.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.String)">
          <source>The name of the file to use.</source>
          <target state="translated">사용할 파일의 이름입니다.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.String)">
          <source>Writes the current data structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as an XML schema to the specified file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 데이터 구조를 지정된 파일에 XML 스키마로 씁니다.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> to an XML document.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 에 대 한 스키마를 작성 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서에 있습니다.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.String)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.String)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.String)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> to use.</source>
          <target state="translated">사용할 <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>Writes the current data structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as an XML schema using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>의 현재 데이터 구조를 XML 스키마로 씁니다.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> to an XML document.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 에 대 한 스키마를 작성 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서에 있습니다.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)">
          <source>The stream to which the XML schema will be written.</source>
          <target state="translated">XML 스키마가 기록될 스트림입니다.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the schema of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the schema for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)">
          <source>Writes the current data structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as an XML schema to the specified stream.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 데이터 구조를 지정된 스트림에 XMl 스키마로 씁니다.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)">
          <source>To save the schema for the table and all its descendants, set the <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">테이블과 모든 하위 항목의 스키마를 저장하려면 <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> 매개 변수를 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> to an XML document.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 에 대 한 스키마를 작성 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서에 있습니다.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXmlSchema`</ph> method writes the schema only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXmlSchema`</ph> 메서드는 현재 테이블에 대 한 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)">
          <source>To write the schema for the current table and its entire descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> with which to write.</source>
          <target state="translated">쓰기에 사용할 <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the schema of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the schema for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>Writes the current data structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as an XML schema using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>의 현재 데이터 구조를 XML 스키마로 씁니다.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>To save the schema for the table and all its descendants, set the <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">테이블과 모든 하위 항목의 스키마를 저장하려면 <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> 매개 변수를 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> to an XML document.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 에 대 한 스키마를 작성 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서에 있습니다.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXmlSchema`</ph> method writes the schema only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXmlSchema`</ph> 메서드는 현재 테이블에 대 한 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>To write the schema for the current table and its entire descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>The following console application creates two <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances, adds each to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, creates a <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> relating the two tables, and then uses the <ph id="ph4">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the data contained within the parent table to a <ph id="ph5">&lt;xref:System.IO.TextWriter&gt;</ph>.</source>
          <target state="translated">다음 콘솔 응용 프로그램에서는 두 개의 <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> 인스턴스, 각각을 추가 하는 <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, 만듭니다는 <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> 두 관련 테이블을 선택한 다음 사용 하 여는 <ph id="ph4">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 메서드는 하는부모테이블내에포함된데이터를쓸<ph id="ph5">&lt;xref:System.IO.TextWriter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>The example demonstrates the behavior when setting the <ph id="ph1">`writeHierarchy`</ph> parameter to each of its values.</source>
          <target state="translated">이 예제에서는 설정할 때 동작을 보여 줍니다는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수를 각각의 값입니다.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)">
          <source>The example displays the following output in the console window:</source>
          <target state="translated">이 예제에서는 콘솔 창에 다음 출력을 표시합니다.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)">
          <source>The name of the file to use.</source>
          <target state="translated">사용할 파일의 이름입니다.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the schema of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the schema for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)">
          <source>Writes the current data structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as an XML schema to the specified file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>의 현재 데이터 구조를 지정된 파일에 XML 스키마로 씁니다.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)">
          <source>To save the schema for the table and all its descendants, set the <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">테이블과 모든 하위 항목의 스키마를 저장하려면 <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> 매개 변수를 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> to an XML document.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 에 대 한 스키마를 작성 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서에 있습니다.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXmlSchema`</ph> method writes the schema only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXmlSchema`</ph> 메서드는 현재 테이블에 대 한 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)">
          <source>To write the schema for the current table and its entire descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> used to write the document.</source>
          <target state="translated">문서를 쓰는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, write the schema of the current table and all its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph> (the default value), write the schema for the current table only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>(기본값)이면 현재 테이블의 스키마만 씁니다.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)">
          <source>Writes the current data structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> as an XML schema using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>를 사용하여 <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>의 현재 데이터 구조를 XML 스키마로 씁니다.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)">
          <source>To save the schema for the table and all its descendants, set the <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">테이블과 모든 하위 항목의 스키마를 저장하려면 <ph id="ph1">&lt;paramref name="writeHierarchy" /&gt;</ph> 매개 변수를 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> to an XML document.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXmlSchema%2A&gt;</ph> 에 대 한 스키마를 작성 하는 메서드는 <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> XML 문서에 있습니다.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">스키마에 테이블, 관계 및 제약 조건 정의가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">XML 문서에 데이터 쓰기를 사용 하 여는 <ph id="ph1">&lt;xref:System.Data.DataTable.WriteXml%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)">
          <source>Normally the <ph id="ph1">`WriteXmlSchema`</ph> method writes the schema only for the current table.</source>
          <target state="translated">일반적으로 <ph id="ph1">`WriteXmlSchema`</ph> 메서드는 현재 테이블에 대 한 스키마를 씁니다.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)">
          <source>To write the schema for the current table and its entire descendant, related tables, call the method with the <ph id="ph1">`writeHierarchy`</ph> parameter set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출할는 <ph id="ph1">`writeHierarchy`</ph> 매개 변수 설정 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>