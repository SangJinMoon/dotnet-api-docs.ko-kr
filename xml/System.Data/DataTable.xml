<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2b4c6d4eea254ee4906c2c3917cdebe98c32d7df" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="40449617" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataTable = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="0238d-101">메모리 내 데이터의 한 테이블을 나타냅니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0238d-101">Represents one table of in-memory data.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-102"><xref:System.Data.DataTable> ADO.NET 라이브러리의 중앙 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-102">The <xref:System.Data.DataTable> is a central object in the ADO.NET library.</span></span> <span data-ttu-id="0238d-103">사용 하는 다른 개체를 <xref:System.Data.DataTable> 포함 된 <xref:System.Data.DataSet> 및 <xref:System.Data.DataView>.</span><span class="sxs-lookup"><span data-stu-id="0238d-103">Other objects that use the <xref:System.Data.DataTable> include the <xref:System.Data.DataSet> and the <xref:System.Data.DataView>.</span></span>  
  
 <span data-ttu-id="0238d-104">에 액세스할 때 <xref:System.Data.DataTable> 개체, 조건에 따라 대/소문자 구분 되는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-104">When accessing <xref:System.Data.DataTable> objects, note that they are conditionally case sensitive.</span></span> <span data-ttu-id="0238d-105">예를 들어 하나의 <xref:System.Data.DataTable> "mydatatable" 이름은 "Mydatatable" 라는 다른을 사용 하 여 테이블 중 하나에 대 한 검색 문자열로으로 대/소문자 구분 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-105">For example, if one <xref:System.Data.DataTable> is named "mydatatable" and another is named "Mydatatable", a string used to search for one of the tables is regarded as case sensitive.</span></span> <span data-ttu-id="0238d-106">그러나 "mydatatable" 존재 하 고 "Mydatatable" 하지 않습니다, 검색 문자열으로 대/소문자 구분 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-106">However, if "mydatatable" exists and "Mydatatable" does not, the search string is regarded as case insensitive.</span></span> <span data-ttu-id="0238d-107">A <xref:System.Data.DataSet> 두 개를 포함할 수 있습니다 <xref:System.Data.DataTable> 는 동일 개체 <xref:System.Data.DataTable.TableName%2A> 속성 값은 같지만 다른 <xref:System.Data.DataTable.Namespace%2A> 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-107">A <xref:System.Data.DataSet> can contain two <xref:System.Data.DataTable> objects that have the same <xref:System.Data.DataTable.TableName%2A> property value but different <xref:System.Data.DataTable.Namespace%2A> property values.</span></span> <span data-ttu-id="0238d-108">작업에 대 한 자세한 내용은 <xref:System.Data.DataTable> 개체를 참조 하세요 [DataTable 만들기](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-108">For more information about working with <xref:System.Data.DataTable> objects, see [Creating a DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).</span></span>  
  
 <span data-ttu-id="0238d-109">만들려는 경우는 <xref:System.Data.DataTable> 프로그래밍 방식으로 정의 해야 해당 스키마를 추가 하 여 <xref:System.Data.DataColumn> 개체를 <xref:System.Data.DataColumnCollection> (통해 액세스를 <xref:System.Data.DataTable.Columns%2A> 속성).</span><span class="sxs-lookup"><span data-stu-id="0238d-109">If you are creating a <xref:System.Data.DataTable> programmatically, you must first define its schema by adding <xref:System.Data.DataColumn> objects to the <xref:System.Data.DataColumnCollection> (accessed through the <xref:System.Data.DataTable.Columns%2A> property).</span></span> <span data-ttu-id="0238d-110">추가 하는 방법에 대 한 자세한 내용은 <xref:System.Data.DataColumn> 개체를 참조 하세요 [DataTable에 열 추가](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-110">For more information about adding <xref:System.Data.DataColumn> objects, see [Adding Columns to a DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md).</span></span>  
  
 <span data-ttu-id="0238d-111">행을 추가할를 <xref:System.Data.DataTable>를 먼저 사용 해야 합니다 <xref:System.Data.DataTable.NewRow%2A> 새 반환 하는 방법 <xref:System.Data.DataRow> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-111">To add rows to a <xref:System.Data.DataTable>, you must first use the <xref:System.Data.DataTable.NewRow%2A> method to return a new <xref:System.Data.DataRow> object.</span></span> <span data-ttu-id="0238d-112">합니다 <xref:System.Data.DataTable.NewRow%2A> 의 스키마를 사용 하 여 행을 반환 하는 메서드를 <xref:System.Data.DataTable>테이블의 정의 된 대로, <xref:System.Data.DataColumnCollection>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-112">The <xref:System.Data.DataTable.NewRow%2A> method returns a row with the schema of the <xref:System.Data.DataTable>, as it is defined by the table's <xref:System.Data.DataColumnCollection>.</span></span> <span data-ttu-id="0238d-113">최대 행을 <xref:System.Data.DataTable> 수 저장소는 16777216 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-113">The maximum number of rows that a <xref:System.Data.DataTable> can store is 16,777,216.</span></span> <span data-ttu-id="0238d-114">자세한 내용은 [DataTable에 데이터 추가](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-114">For more information, see [Adding Data to a DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md).</span></span>  
  
 <span data-ttu-id="0238d-115">합니다 <xref:System.Data.DataTable> 의 컬렉션도 포함 <xref:System.Data.Constraint> 데이터의 무결성을 확인 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-115">The <xref:System.Data.DataTable> also contains a collection of <xref:System.Data.Constraint> objects that can be used to ensure the integrity of the data.</span></span> <span data-ttu-id="0238d-116">자세한 내용은 [DataTable 제약 조건](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-116">For more information, see [DataTable Constraints](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).</span></span>  
  
 <span data-ttu-id="0238d-117">여러 <xref:System.Data.DataTable> 테이블에 변경 내용이 시기를 결정 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-117">There are many <xref:System.Data.DataTable> events that can be used to determine when changes are made to a table.</span></span> <span data-ttu-id="0238d-118">이것에는 <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting> 및 <xref:System.Data.DataTable.RowDeleted>가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-118">These include <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting>, and <xref:System.Data.DataTable.RowDeleted>.</span></span> <span data-ttu-id="0238d-119">사용 하 여 사용할 수 있는 이벤트에 대 한 자세한를 <xref:System.Data.DataTable>를 참조 하세요 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-119">For more information about the events that can be used with a <xref:System.Data.DataTable>, see [Handling DataTable Events](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).</span></span>  
  
 <span data-ttu-id="0238d-120">인스턴스가 <xref:System.Data.DataTable> 를 만드는 경우 일부의 읽기/쓰기 속성 초기 값으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-120">When an instance of <xref:System.Data.DataTable> is created, some of the read/write properties are set to initial values.</span></span> <span data-ttu-id="0238d-121">이러한 값의 목록을 보려면 참조는 <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> 생성자 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-121">For a list of these values, see the <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> constructor topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-122"><xref:System.Data.DataSet> 및 <xref:System.Data.DataTable> 개체에서 상속 <xref:System.ComponentModel.MarshalByValueComponent>를 지원 하 고는 <xref:System.Runtime.Serialization.ISerializable> .NET Framework remoting에 대 한 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-122">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> objects inherit from <xref:System.ComponentModel.MarshalByValueComponent>, and support the <xref:System.Runtime.Serialization.ISerializable> interface for .NET Framework remoting.</span></span> <span data-ttu-id="0238d-123">이들은.NET Framework remoting에 사용할 수 있는 유일한 ADO.NET 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-123">These are the only ADO.NET objects that you can use for .NET Framework remoting.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-124">다음 예제에서는 두 개의 <xref:System.Data.DataTable> 개체와 하나의 <xref:System.Data.DataRelation> 개체를 새 개체를 추가 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-124">The following example creates two <xref:System.Data.DataTable> objects and one <xref:System.Data.DataRelation> object, and adds the new objects to a <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="0238d-125">테이블에 표시 되는 <xref:System.Windows.Forms.DataGridView> 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-125">The tables are then displayed in a <xref:System.Windows.Forms.DataGridView> control.</span></span>  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 <span data-ttu-id="0238d-126">이 샘플에는 특정 스키마 정의가 포함 된 DataTable를 수동으로 만들어야 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-126">This sample demonstrates how to create a DataTable manually with specific schema definitions:</span></span>  
  
-   <span data-ttu-id="0238d-127">여러 Datatable을 만들고 첫 열을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-127">Create multiple DataTables and define the initial columns.</span></span>  
  
-   <span data-ttu-id="0238d-128">테이블 제약 조건을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-128">Create the table constraints.</span></span>  
  
-   <span data-ttu-id="0238d-129">값을 삽입 하 고 테이블을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-129">Insert the values and display the tables.</span></span>  
  
-   <span data-ttu-id="0238d-130">식 열을 만들고 테이블을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-130">Create the expression columns and display the tables.</span></span>  
  
 <span data-ttu-id="0238d-131">이 코드 샘플을 사용 하 여 C# 및 Visual Basic 프로젝트에서 찾을 수 있습니다 [개발자 코드 샘플](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-131">C# and Visual Basic projects with this code sample can be found on [Developer Code Samples](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).</span></span>  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="0238d-132">이 유형은 다중 스레드 읽기 작업에 안전 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0238d-132">This type is safe for multithreaded read operations.</span>
      </span>
      <span data-ttu-id="0238d-133">모든 쓰기 작업을 동기화 해야 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0238d-133">You must synchronize any write operations.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-134">
            <see cref="T:System.Data.DataTable" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-134">Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-135">인수를 사용하지 않고 <see cref="T:System.Data.DataTable" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-135">Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with no arguments.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-136">모든 속성에 대 한 초기 값을 설정 하는 생성자를 <xref:System.Data.DataTable> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-136">The constructor sets initial values for all properties of the <xref:System.Data.DataTable> object.</span></span> <span data-ttu-id="0238d-137">다음 표에서 속성 및 기본값을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-137">The following table shows the properties and their default values.</span></span> <span data-ttu-id="0238d-138">인스턴스가 <xref:System.Data.DataTable> 만들어지면 다음 읽기/쓰기 속성 초기 값으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-138">When an instance of <xref:System.Data.DataTable> is created, the following read/write properties are set to initial values.</span></span>  
  
|<span data-ttu-id="0238d-139">속성</span><span class="sxs-lookup"><span data-stu-id="0238d-139">Property</span></span>|<span data-ttu-id="0238d-140">기본값</span><span class="sxs-lookup"><span data-stu-id="0238d-140">Default value</span></span>|  
|--------------|-------------------|  
|<span data-ttu-id="0238d-141">**CaseSensitive**</span><span class="sxs-lookup"><span data-stu-id="0238d-141">**CaseSensitive**</span></span>|<span data-ttu-id="0238d-142">부모와 동일한 <xref:System.Data.DataSet>이면 하나에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-142">Same as the parent <xref:System.Data.DataSet>, if it belongs to one.</span></span> <span data-ttu-id="0238d-143">그렇지 않으면 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-143">Otherwise, `false`.</span></span>|  
|<span data-ttu-id="0238d-144">**DisplayExpression**</span><span class="sxs-lookup"><span data-stu-id="0238d-144">**DisplayExpression**</span></span>|<span data-ttu-id="0238d-145">빈 문자열 ("")</span><span class="sxs-lookup"><span data-stu-id="0238d-145">Empty string ("")</span></span>|  
|<span data-ttu-id="0238d-146">**로캘**</span><span class="sxs-lookup"><span data-stu-id="0238d-146">**Locale**</span></span>|<span data-ttu-id="0238d-147">부모와 동일한 <xref:System.Data.DataSet> 개체의 <xref:System.Globalization.CultureInfo> (반환한 합니다 <xref:System.Data.DataSet.Locale%2A> 속성) 부모가 없으면; 기본값은 현재 시스템 <xref:System.Globalization.CultureInfo>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-147">Same as the parent <xref:System.Data.DataSet> object's <xref:System.Globalization.CultureInfo> (returned by the <xref:System.Data.DataSet.Locale%2A> property); if no parent exists, the default is the current system <xref:System.Globalization.CultureInfo>.</span></span>|  
|<span data-ttu-id="0238d-148">**MinimumCapacity**</span><span class="sxs-lookup"><span data-stu-id="0238d-148">**MinimumCapacity**</span></span>|<span data-ttu-id="0238d-149">50 개 행입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-149">50 rows.</span></span>|  
  
 <span data-ttu-id="0238d-150">속성에 별도 호출을 통해 이러한 속성의 값을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-150">You can change the value for any of these properties through a separate call to the property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-151">다음 예제에서는 새 <xref:System.Data.DataTable> 사용 하 여 <xref:System.Data.DataColumn> 하 고 <xref:System.Data.DataRow>를 표시를 <xref:System.Windows.Forms.DataGridView> 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-151">The following example creates a new <xref:System.Data.DataTable> with <xref:System.Data.DataColumn> and <xref:System.Data.DataRow>, and displays it in a <xref:System.Windows.Forms.DataGridView> control.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable tableName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">
          <span data-ttu-id="0238d-152">테이블에 지정할 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-152">The name to give the table.</span>
          </span>
          <span data-ttu-id="0238d-153">
            <c>tableName</c>이 <see langword="null" /> 또는 빈 문자열이면 <see cref="T:System.Data.DataTableCollection" />에 테이블이 추가될 때 기본 이름이 지정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-153">If <c>tableName</c> is <see langword="null" /> or an empty string, a default name is given when added to the <see cref="T:System.Data.DataTableCollection" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-154">지정된 테이블 이름을 사용하여 <see cref="T:System.Data.DataTable" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-154">Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with the specified table name.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0238d-155">다음 예제에서는 한 <xref:System.Data.DataTable> 에 표시를 <xref:System.Windows.Forms.DataGridView> 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-155">The following example creates a <xref:System.Data.DataTable> and displays it in a <xref:System.Windows.Forms.DataGridView> control.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="0238d-156">개체를 serialize 또는 deserialize하는 데 필요한 데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-156">The data needed to serialize or deserialize an object.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="0238d-157">serialize된 특정 스트림의 소스와 대상입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-157">The source and destination of a given serialized stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-158">
            <see cref="T:System.Data.DataTable" />와 <see cref="T:System.Runtime.Serialization.SerializationInfo" />를 사용하여 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-158">Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and the <see cref="T:System.Runtime.Serialization.StreamingContext" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-159">이 구현의 합니다 <xref:System.Data.DataTable> 생성자에 필요 <xref:System.Runtime.Serialization.ISerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-159">This implementation of the <xref:System.Data.DataTable> constructor is required for <xref:System.Runtime.Serialization.ISerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string * string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (tableName, tableNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">
          <span data-ttu-id="0238d-160">테이블에 지정할 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-160">The name to give the table.</span>
          </span>
          <span data-ttu-id="0238d-161">
            <c>tableName</c>이 <see langword="null" /> 또는 빈 문자열이면 <see cref="T:System.Data.DataTableCollection" />에 테이블이 추가될 때 기본 이름이 지정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-161">If <c>tableName</c> is <see langword="null" /> or an empty string, a default name is given when added to the <see cref="T:System.Data.DataTableCollection" />.</span>
          </span>
        </param>
        <param name="tableNamespace">
          <span data-ttu-id="0238d-162">
            <see langword="DataTable" />에 저장된 데이터의 XML 표현에 대한 네임스페이스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-162">The namespace for the XML representation of the data stored in the <see langword="DataTable" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-163">지정된 테이블 이름과 네임스페이스를 사용하여 <see cref="T:System.Data.DataTable" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-163">Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class using the specified table name and namespace.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataTable.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-164">
            <see cref="M:System.Data.DataTable.AcceptChanges" />가 마지막으로 호출된 이후 이 테이블에서 변경된 내용을 모두 커밋합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-164">Commits all the changes made to this table since the last time <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-165">때 <xref:System.Data.DataTable.AcceptChanges%2A> 가 호출 된 <xref:System.Data.DataRow> 아직 편집 모드에에서는 개체의 편집을 성공적으로 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-165">When <xref:System.Data.DataTable.AcceptChanges%2A> is called, any <xref:System.Data.DataRow> object still in edit mode successfully ends its edits.</span></span> <span data-ttu-id="0238d-166">합니다 <xref:System.Data.DataRowState> 도 변경: 모든 `Added` 하 고 `Modified` 될 행 `Unchanged`, 및 `Deleted` 행이 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-166">The <xref:System.Data.DataRowState> also changes: all `Added` and `Modified` rows become `Unchanged`, and `Deleted` rows are removed.</span></span>  
  
 <span data-ttu-id="0238d-167"><xref:System.Data.DataTable.AcceptChanges%2A> 메서드를 일반적으로 호출을 <xref:System.Data.DataTable> 업데이트 하려고 하면 후 합니다 <xref:System.Data.DataSet> 를 사용 하 여를 <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-167">The <xref:System.Data.DataTable.AcceptChanges%2A> method is generally called on a <xref:System.Data.DataTable> after you attempt to update the <xref:System.Data.DataSet> using the <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-168">다음 예제에서는 각 테이블의 오류를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-168">The following example tests each table for errors.</span></span> <span data-ttu-id="0238d-169">(전달 하 여 정의 되지 않은 함수), 테이블의 오류를 해결할 수 있으면 <xref:System.Data.DataTable.AcceptChanges%2A> 이 고, 그렇지 않으면 호출 <xref:System.Data.DataTable.RejectChanges%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-169">If the table's errors can be reconciled (by passing it to an undefined function), <xref:System.Data.DataTable.AcceptChanges%2A> is called; otherwise, <xref:System.Data.DataTable.RejectChanges%2A> is called.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataTable.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-170">폼에 사용되거나 다른 구성 요소에서 사용하는 <see cref="T:System.Data.DataTable" />의 초기화를 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-170">Begins the initialization of a <see cref="T:System.Data.DataTable" /> that is used on a form or used by another component.</span>
          </span>
          <span data-ttu-id="0238d-171">초기화는 런타임에 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-171">The initialization occurs at run time.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-172">Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소의 초기화를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-172">The Visual Studio .NET design environment uses this method to start the initialization of a component that is used on a form or used by another component.</span></span> <span data-ttu-id="0238d-173"><xref:System.Data.DataTable.EndInit%2A> 메서드 초기화를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-173">The <xref:System.Data.DataTable.EndInit%2A> method ends the initialization.</span></span> <span data-ttu-id="0238d-174">사용 하는 <xref:System.Data.DataTable.BeginInit%2A> 및 <xref:System.Data.DataTable.EndInit%2A> 메서드 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-174">Using the <xref:System.Data.DataTable.BeginInit%2A> and <xref:System.Data.DataTable.EndInit%2A> methods prevents the control from being used before it is fully initialized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberSignature Language="F#" Value="member this.BeginLoadData : unit -&gt; unit" Usage="dataTable.BeginLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-175">데이터를 로드하는 동안 알림, 인덱스 유지 관리 및 제약 조건 기능을 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-175">Turns off notifications, index maintenance, and constraints while loading data.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-176">사용 하 여 <xref:System.Data.DataTable.BeginLoadData%2A> 와 함께에서 <xref:System.Data.DataTable.LoadDataRow%2A> 고 <xref:System.Data.DataTable.EndLoadData%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-176">Use <xref:System.Data.DataTable.BeginLoadData%2A> in conjunction with <xref:System.Data.DataTable.LoadDataRow%2A> and <xref:System.Data.DataTable.EndLoadData%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-177">테이블 내의 문자열을 비교할 때 대/소문자를 구분할지 여부를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-177">Indicates whether string comparisons within the table are case-sensitive.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-178">비교할 때 대/소문자를 구분하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-178">
              <see langword="true" /> if the comparison is case-sensitive; otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="0238d-179">기본값은 부모 <see cref="T:System.Data.DataSet" /> 개체의 <see cref="P:System.Data.DataSet.CaseSensitive" /> 속성으로 설정되거나, <see cref="T:System.Data.DataTable" />과 별도로 만들어진 <see cref="T:System.Data.DataSet" />의 경우 <see langword="false" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-179">The default is set to the parent <see cref="T:System.Data.DataSet" /> object's <see cref="P:System.Data.DataSet.CaseSensitive" /> property, or <see langword="false" /> if the <see cref="T:System.Data.DataTable" /> was created independently of a <see cref="T:System.Data.DataSet" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-180"><xref:System.Data.DataTable.CaseSensitive%2A> 문자열 정렬, 검색 및 필터링을 비교 하는 속성에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-180">The <xref:System.Data.DataTable.CaseSensitive%2A> property affects string comparisons in sorting, searching, and filtering.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-181">다음 예제에서는 합니다 <xref:System.Data.DataTable.Select%2A> 메서드를 두 번을 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-181">The following example calls the <xref:System.Data.DataTable.Select%2A> method twice on a <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-182">처음으로는 <xref:System.Data.DataTable.CaseSensitive%2A> 속성이 `false`를 두 번째 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-182">The first time, the <xref:System.Data.DataTable.CaseSensitive%2A> property is set to `false`, the second, to `true`.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableChildRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-183">이 <see cref="T:System.Data.DataTable" />에 대한 자식 관계 컬렉션을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-183">Gets the collection of child relations for this <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-184">테이블의 자식 관계가 포함된 <see cref="T:System.Data.DataRelationCollection" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-184">A <see cref="T:System.Data.DataRelationCollection" /> that contains the child relations for the table.</span>
          </span>
          <span data-ttu-id="0238d-185">
            <see cref="T:System.Data.DataRelation" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-185">An empty collection is returned if no <see cref="T:System.Data.DataRelation" /> objects exist.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-186"><xref:System.Data.DataRelation> 두 테이블 간의 관계를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-186">A <xref:System.Data.DataRelation> defines the relationship between two tables.</span></span> <span data-ttu-id="0238d-187">일반적으로 두 테이블은 동일한 데이터를 포함 하는 단일 필드를 통해 연결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-187">Typically, two tables are linked through a single field that contains the same data.</span></span> <span data-ttu-id="0238d-188">예를 들어 주소 데이터를 포함 하는 테이블에는 국가/지역을 나타내는 코드를 포함 하는 단일 필드가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-188">For example, a table which contains address data may have a single field containing codes that represent countries/regions.</span></span> <span data-ttu-id="0238d-189">국가/지역 데이터를 포함 하는 두 번째 테이블에서 국가/지역을 식별 하는 코드를 포함 하는 단일 필드로 있고이 코드가 첫 번째 테이블의 해당 필드에 삽입 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-189">A second table that contains country/region data will have a single field that contains the code that identifies the country/region, and it is this code which is inserted into the corresponding field in the first table.</span></span> <span data-ttu-id="0238d-190"><xref:System.Data.DataRelation>, 적어도 4 가지 정보를 포함 한: (1) 첫 번째 테이블의 이름, 첫 번째 테이블의 열 이름 (2), (3) 두 번째 테이블의 이름 및 (4) 두 번째 테이블의 열 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-190">A <xref:System.Data.DataRelation>, then, contains at least four pieces of information: (1) the name of the first table, (2) the column name in the first table, (3) the name of the second table, and (4) the column name in the second table.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-191">다음 예제에서는 합니다 <xref:System.Data.DataTable.ChildRelations%2A> 각 자식에 반환할 속성 <xref:System.Data.DataRelation> 에 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-191">The following example uses the <xref:System.Data.DataTable.ChildRelations%2A> property to return each child <xref:System.Data.DataRelation> in a <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-192">각 관계에 대 한 인수로 사용 됩니다는 <xref:System.Data.DataRow.GetChildRows%2A> 메서드는 <xref:System.Data.DataRow> 행의 배열을 반환 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-192">Each relation is then used as an argument in the <xref:System.Data.DataRow.GetChildRows%2A> method of the <xref:System.Data.DataRow> to return an array of rows.</span></span> <span data-ttu-id="0238d-193">행의 각 열 값이 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-193">The value of each column in the row is then printed.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-194">
            <see cref="T:System.Data.DataTable" />의 모든 데이터를 지웁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-194">Clears the <see cref="T:System.Data.DataTable" /> of all data.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-195">모든 테이블의 모든 행이 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-195">All rows in all tables are removed.</span></span> <span data-ttu-id="0238d-196">테이블에 자식 관계가 적용된는 자식 행이 분리 될 경우 예외가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-196">An exception is generated if the table has any enforced child relations that would cause child rows to be orphaned.</span></span>  
  
 <span data-ttu-id="0238d-197">경우는 <xref:System.Data.DataSet> 바인딩되는 <xref:System.Xml.XmlDataDocument>를 호출 <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> 또는 <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> 발생 시킵니다는 <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-197">If the <xref:System.Data.DataSet> is bound to an <xref:System.Xml.XmlDataDocument>, calling <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> or <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> raises the <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="0238d-198">이 상황을 방지 하려면 한 번에 하나씩 행을 제거 하는 각 테이블에 트래버스 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-198">To avoid this situation, traverse each table, removing each row one at a time.</span></span> <span data-ttu-id="0238d-199">사용 하는 경우 <xref:System.Data.DataTable.NewRow%2A> 새 행을 만들려면는 행을 처리 해야 호출 하기 전에 <xref:System.Data.DataTable.Clear%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-199">When you use <xref:System.Data.DataTable.NewRow%2A> to create new rows, the rows must be processed before you call <xref:System.Data.DataTable.Clear%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-200">다음 예제에서는 모든 데이터의 테이블을 지웁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-200">The following example clears the table of all data.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataTable&#xA;override this.Clone : unit -&gt; System.Data.DataTable" Usage="dataTable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-201">모든 <see cref="T:System.Data.DataTable" /> 스키마, 관계 및 제약 조건을 포함하여 <see cref="T:System.Data.DataTable" />의 구조를 복제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-201">Clones the structure of the <see cref="T:System.Data.DataTable" />, including all <see cref="T:System.Data.DataTable" /> schemas and constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-202">현재 <see cref="T:System.Data.DataTable" />과 동일한 스키마를 갖는 새 <see cref="T:System.Data.DataTable" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-202">A new <see cref="T:System.Data.DataTable" /> with the same schema as the current <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-203">이러한 클래스를 파생 된 경우 동일한 파생된 클래스가 복제가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-203">If these classes have been derived, the clone will also be of the same derived classes.</span></span>  
  
 <span data-ttu-id="0238d-204">복제를 만듭니다 <xref:System.Data.DataTable> 와 동일한 구조로 원래 <xref:System.Data.DataTable>, 모든 데이터를 복사 하지 않습니다 (새 <xref:System.Data.DataTable> 포함 되지 것입니다 `DataRows`).</span><span class="sxs-lookup"><span data-stu-id="0238d-204">Clone creates a new <xref:System.Data.DataTable> with the same structure as the original <xref:System.Data.DataTable>, but does not copy any data (the new <xref:System.Data.DataTable> will not contain any `DataRows`).</span></span> <span data-ttu-id="0238d-205">새 구조와 데이터를 복사할 <xref:System.Data.DataTable>를 사용 하 여 <xref:System.Data.DataTable.Copy%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-205">To copy both the structure and data into a new <xref:System.Data.DataTable>, use <xref:System.Data.DataTable.Copy%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-206">다음 샘플 DataTable.Clone 실행 한 후 대상 테이블의 제약 조건을 확인 하 고 구조를 업데이트 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-206">The following sample demonstrates how to update the structure and constraints of the destination table after you execute DataTable.Clone.</span></span> <span data-ttu-id="0238d-207">대상 테이블을 반환 하 고 모든 업데이트 이벤트를 포함 하는 ClonedDataTable 클래스.</span><span class="sxs-lookup"><span data-stu-id="0238d-207">The ClonedDataTable class will return a destination table and includes all the updating events.</span></span> <span data-ttu-id="0238d-208">복제 후 원본 테이블의 구조 변경 내용은 대상 테이블에 반영 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-208">After the clone, structure changes in the source table won’t be reflected in the destination table.</span></span> <span data-ttu-id="0238d-209">특히이 샘플은:</span><span class="sxs-lookup"><span data-stu-id="0238d-209">Specifically, this sample will:</span></span>  
  
-   <span data-ttu-id="0238d-210">원본 테이블의 열 변경 내용을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-210">Update the changes of the columns in source table.</span></span>  
  
-   <span data-ttu-id="0238d-211">원본 테이블에서 UniqueConstraint의 변경 내용을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-211">Update the changes of the UniqueConstraint in source table.</span></span>  
  
-   <span data-ttu-id="0238d-212">원본 테이블의 외래 키의 변경 내용을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-212">Update the changes of the ForeignKeyConstraint in source table.</span></span>  
  
 <span data-ttu-id="0238d-213">이 코드 샘플을 사용 하 여 C# 및 Visual Basic 프로젝트에서 찾을 수 있습니다 [개발자 코드 샘플](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-213">C# and Visual Basic projects with this code sample can be found on [Developer Code Samples](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).</span></span>  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 <span data-ttu-id="0238d-214">이 샘플에서는 DataTable에서 데이터를 수정 하 고 데이터 소스를 업데이트 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-214">This sample shows how to modify data in a DataTable and update the data source.</span></span>  
  
 <span data-ttu-id="0238d-215">먼저 데이터베이스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-215">First, create a database:</span></span>  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 <span data-ttu-id="0238d-216">이제 컴파일 및 샘플을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-216">You can now compile and run the sample.</span></span> <span data-ttu-id="0238d-217">[DataTable에 데이터 원본에 대 한 업데이트는 데이터를 수정 하는 방법](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) 이 샘플의 Visual Basic 및 C# 프로젝트가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-217">[How to modify data in DataTable and update to the data source](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) has Visual Basic and C# projects of this sample.</span></span>  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-218">
            <see cref="T:System.Data.DataColumn" />에 있는 지정된 <see cref="T:System.Data.DataRow" />의 값이 변경된 후 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-218">Occurs after a value has been changed for the specified <see cref="T:System.Data.DataColumn" /> in a <see cref="T:System.Data.DataRow" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-219">자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-219">For more information, see [Handling DataTable Events](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).</span></span>  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-220">
            <see cref="T:System.Data.DataColumn" />에 있는 지정된 <see cref="T:System.Data.DataRow" />의 값이 변경될 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-220">Occurs when a value is being changed for the specified <see cref="T:System.Data.DataColumn" /> in a <see cref="T:System.Data.DataRow" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-221">자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-221">For more information, see [Handling DataTable Events](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).</span></span>  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Columns : System.Data.DataColumnCollection" Usage="System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-222">이 테이블에 속한 열의 컬렉션을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-222">Gets the collection of columns that belong to this table.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-223">테이블의 <see cref="T:System.Data.DataColumnCollection" /> 개체 컬렉션이 포함된 <see cref="T:System.Data.DataColumn" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-223">A <see cref="T:System.Data.DataColumnCollection" /> that contains the collection of <see cref="T:System.Data.DataColumn" /> objects for the table.</span>
          </span>
          <span data-ttu-id="0238d-224">
            <see cref="T:System.Data.DataColumn" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-224">An empty collection is returned if no <see cref="T:System.Data.DataColumn" /> objects exist.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-225"><xref:System.Data.DataColumnCollection> 각 열의 데이터 형식을 정의 하 여 테이블의 스키마를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-225">The <xref:System.Data.DataColumnCollection> determines the schema of a table by defining the data type of each column.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-226">다음 예제에서는 사용 하 여 테이블의 각 행의 값을 출력 합니다 <xref:System.Data.DataTable.Columns%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-226">The following example prints each value of each row in a table using the <xref:System.Data.DataTable.Columns%2A> property.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Compute : string * string -&gt; obj" Usage="dataTable.Compute (expression, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0238d-227">계산할 식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-227">The expression to compute.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="0238d-228">식에서 계산하는 행을 제한할 필터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-228">The filter to limit the rows that evaluate in the expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-229">필터 조건을 전달하는 현재 행에서 지정된 식을 계산합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-229">Computes the given expression on the current rows that pass the filter criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-230">계산 결과로 설정된 <see cref="T:System.Object" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-230">An <see cref="T:System.Object" />, set to the result of the computation.</span>
          </span>
          <span data-ttu-id="0238d-231">식이 null로 평가되는 경우 반환 값은 <see cref="F:System.DBNull.Value" />가 됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-231">If the expression evaluates to null, the return value will be <see cref="F:System.DBNull.Value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-232">`expression` 매개 변수는 집계 함수가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-232">The `expression` parameter requires an aggregate function.</span></span> <span data-ttu-id="0238d-233">예를 들어, 다음은 올바른 식입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-233">For example, the following is a legal expression:</span></span>  
  
 `Count(Quantity)`  
  
 <span data-ttu-id="0238d-234">하지만이 식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-234">But this expression is not:</span></span>  
  
 `Sum (Quantity * UnitPrice)`  
  
 <span data-ttu-id="0238d-235">두 개 이상의 열에 대 한 작업을 수행 해야 하는 경우 만든를 <xref:System.Data.DataColumn>설정, 해당 <xref:System.Data.DataColumn.Expression%2A> 속성을 적절 한 식 및 결과 열에 집계 식 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-235">If you must perform an operation on two or more columns, you should create a <xref:System.Data.DataColumn>, set its <xref:System.Data.DataColumn.Expression%2A> property to an appropriate expression, and use an aggregate expression on the resulting column.</span></span> <span data-ttu-id="0238d-236">지정 된 경우에 <xref:System.Data.DataColumn> 이름 "합계"를 사용 하 여 및 <xref:System.Data.DataColumn.Expression%2A> 이 설정 된 속성:</span><span class="sxs-lookup"><span data-stu-id="0238d-236">In that case, given a <xref:System.Data.DataColumn> with the name "total", and the <xref:System.Data.DataColumn.Expression%2A> property set to this:</span></span>  
  
 `"Quantity * UnitPrice"`  
  
 <span data-ttu-id="0238d-237">에 대 한 expression 인수는 <xref:System.Data.DataTable.Compute%2A> 메서드 같게 됩니다.이:</span><span class="sxs-lookup"><span data-stu-id="0238d-237">The expression argument for the <xref:System.Data.DataTable.Compute%2A> method would then be this:</span></span>  
  
 `Sum(total)`  
  
 <span data-ttu-id="0238d-238">두 번째 매개 변수를 `filter`, 식에 사용 될 행을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-238">The second parameter, `filter`, determines which rows are used in the expression.</span></span> <span data-ttu-id="0238d-239">예를 들어, 테이블 "colDate" 라는 날짜 열에 있으면 다음 식 사용 하 여 행을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-239">For example, if the table contains a date column named "colDate", you could limit the rows with the following expression:</span></span>  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 <span data-ttu-id="0238d-240">두 매개 변수에 대 한 식 작성에서 규칙에 대 한 참조를 <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-240">For rules on creating expressions for both parameters, see the <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-241">다음 예제에서는 해당 id 번호는 5 개 판매 직원에 대 한 "Total" 이라는 열 값을 합산 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-241">The following example sums the values of a column named "Total", for the salesperson whose identification number is five.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraints : System.Data.ConstraintCollection" Usage="System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-242">이 테이블이 유지하는 제약 조건의 컬렉션을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-242">Gets the collection of constraints maintained by this table.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-243">테이블의 <see cref="T:System.Data.ConstraintCollection" /> 개체 컬렉션이 포함된 <see cref="T:System.Data.Constraint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-243">A <see cref="T:System.Data.ConstraintCollection" /> that contains the collection of <see cref="T:System.Data.Constraint" /> objects for the table.</span>
          </span>
          <span data-ttu-id="0238d-244">
            <see cref="T:System.Data.Constraint" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-244">An empty collection is returned if no <see cref="T:System.Data.Constraint" /> objects exist.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-245"><xref:System.Data.ForeignKeyConstraint> 열 (또는 열)의 값이 삭제 되거나 업데이트 될 때 수행 하는 작업을 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-245">A <xref:System.Data.ForeignKeyConstraint> restricts the action performed when a value in a column (or columns) is either deleted or updated.</span></span> <span data-ttu-id="0238d-246">이러한 제약 조건이 기본 키 열과 함께 사용할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-246">Such a constraint is intended to be used with primary key columns.</span></span> <span data-ttu-id="0238d-247">두 테이블 간에 부모/자식 관계에서 부모 테이블에서 값을 삭제할 영향을 줄 수 자식 행에서 다음 방법 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-247">In a parent/child relationship between two tables, deleting a value from the parent table can affect the child rows in one of the following ways.</span></span>  
  
-   <span data-ttu-id="0238d-248">자식 행 수도 있습니다 (연계 동작)를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-248">The child rows can also be deleted (a cascading action).</span></span>  
  
-   <span data-ttu-id="0238d-249">자식 열 (또는 열)의 값은 null 값으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-249">The values in the child column (or columns) can be set to null values.</span></span>  
  
-   <span data-ttu-id="0238d-250">자식 열 (또는 열)의 값을 기본값으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-250">The values in the child column (or columns) can be set to default values.</span></span>  
  
-   <span data-ttu-id="0238d-251">예외를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-251">An exception can be generated.</span></span>  
  
 <span data-ttu-id="0238d-252"><xref:System.Data.UniqueConstraint> 고유 하지 않은 값으로 기본 키에 값을 설정 하려고 할 때 활성화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-252">A <xref:System.Data.UniqueConstraint> becomes active when attempting to set a value in a primary key to a non-unique value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-253">다음 예제에서는 추가 <xref:System.Data.ForeignKeyConstraint> 제약 조건의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-253">The following example adds a <xref:System.Data.ForeignKeyConstraint> to the collection of constraints.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataTable" Usage="dataTable.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-254">이 <see cref="T:System.Data.DataTable" />의 구조와 데이터를 모두 복사합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-254">Copies both the structure and data for this <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-255">이 <see cref="T:System.Data.DataTable" />과 같은 구조(테이블 스키마, 관계, 제약 조건)와 데이터를 가진 새 <see cref="T:System.Data.DataTable" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-255">A new <see cref="T:System.Data.DataTable" /> with the same structure (table schemas and constraints) and data as this <see cref="T:System.Data.DataTable" />.</span>
          </span>
          <span data-ttu-id="0238d-256">이 클래스가 파생된 경우 동일한 파생 클래스가 복사됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-256">If these classes have been derived, the copy will also be of the same derived classes.</span>
          </span>
          <span data-ttu-id="0238d-257">
            <see cref="M:System.Data.DataTable.Copy" />는 원래 <see cref="T:System.Data.DataTable" />과 동일한 구조 및 데이터로 새 <see cref="T:System.Data.DataTable" />를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-257">
              <see cref="M:System.Data.DataTable.Copy" /> creates a new <see cref="T:System.Data.DataTable" /> with the same structure and data as the original <see cref="T:System.Data.DataTable" />.</span>
          </span>
          <span data-ttu-id="0238d-258">구조체를 새 <see cref="T:System.Data.DataTable" />로 복사하고 데이터는 복사하지 않으려면 <see cref="M:System.Data.DataTable.Clone" />을 사용하십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-258">To copy the structure to a new <see cref="T:System.Data.DataTable" />, but not the data, use <see cref="M:System.Data.DataTable.Clone" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0238d-259">다음 예제에서는 합니다 <xref:System.Data.DataTable.Copy%2A> 원래 복사본을 만드는 방법을 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-259">The following example uses the <xref:System.Data.DataTable.Copy%2A> method to create a copy of the original <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-260">부모 로부터 상속 되는 경우에 네임 스페이스 이름을 유지 되지 않습니다 <xref:System.Data.DataTable> 또는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-260">The namespace name is not retained if it is inherited from a parent <xref:System.Data.DataTable> or <xref:System.Data.DataSet>.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataTable.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-261">이 <see cref="T:System.Data.DataTableReader" />의 데이터에 해당하는 <see cref="T:System.Data.DataTable" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-261">Returns a <see cref="T:System.Data.DataTableReader" /> corresponding to the data within this <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-262">결과 집합 하나를 포함하고 소스 <see cref="T:System.Data.DataTableReader" /> 인스턴스에 해당하는 <see cref="T:System.Data.DataTable" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-262">A <see cref="T:System.Data.DataTableReader" /> containing one result set, corresponding to the source <see cref="T:System.Data.DataTable" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0238d-263">다음 콘솔 응용 프로그램에서는 <xref:System.Data.DataTable> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-263">The following console application creates a <xref:System.Data.DataTable> instance.</span></span> <span data-ttu-id="0238d-264">예제는 다음 채워진 전달 <xref:System.Data.DataTable> 호출 된 프로시저에는 <xref:System.Data.DataTable.CreateDataReader%2A> 내에 포함 된 결과 반복 하는 메서드를 <xref:System.Data.DataTableReader>.</span><span class="sxs-lookup"><span data-stu-id="0238d-264">The example then passes the filled <xref:System.Data.DataTable> to a procedure that calls the <xref:System.Data.DataTable.CreateDataReader%2A> method, which iterates through the results contained within the <xref:System.Data.DataTableReader>.</span></span>  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 <span data-ttu-id="0238d-265">이 예제에서는 콘솔 창에 다음 출력을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-265">The example displays the following output in the console window:</span></span>  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : unit -&gt; System.Data.DataTable&#xA;override this.CreateInstance : unit -&gt; System.Data.DataTable" Usage="dataTable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-266">
            <see cref="T:System.Data.DataTable" />의 새 인스턴스를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-266">Creates a new instance of <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-267">새 식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-267">The new expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDataSetDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-268">이 테이블이 속한 <see cref="T:System.Data.DataSet" />을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-268">Gets the <see cref="T:System.Data.DataSet" /> to which this table belongs.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-269">이 테이블이 속한 <see cref="T:System.Data.DataSet" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-269">The <see cref="T:System.Data.DataSet" /> to which this table belongs.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-270">컨트롤은 데이터 바인딩할를 <xref:System.Data.DataTable>, 테이블에 속해를 <xref:System.Data.DataSet>를 가져올 수 있습니다는 <xref:System.Data.DataSet> 이 속성을 통해.</span><span class="sxs-lookup"><span data-stu-id="0238d-270">If a control is data bound to a <xref:System.Data.DataTable>, and the table belongs to a <xref:System.Data.DataSet>, you can get to the <xref:System.Data.DataSet> through this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-271">다음 예제에서는 부모를 반환 합니다. <xref:System.Data.DataSet> 를 통해 지정된 된 테이블의는 <xref:System.Data.DataTable.DataSet%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-271">The following example returns the parent <xref:System.Data.DataSet> of a given table through the <xref:System.Data.DataTable.DataSet%2A> property.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultView : System.Data.DataView" Usage="System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-272">필터링된 뷰를 포함할 수 있는 테이블의 사용자 지정 뷰 또는 커서 위치를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-272">Gets a customized view of the table that may include a filtered view, or a cursor position.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-273">
            <see cref="T:System.Data.DataView" />와 연결된 <see cref="T:System.Data.DataTable" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-273">The <see cref="T:System.Data.DataView" /> associated with the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-274"><xref:System.Data.DataTable.DefaultView%2A> 속성에서 반환을 <xref:System.Data.DataView> 정렬, 필터 및 검색에 사용할 수는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-274">The <xref:System.Data.DataTable.DefaultView%2A> property returns a <xref:System.Data.DataView> you can use to sort, filter, and search a <xref:System.Data.DataTable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-275">속성을 설정 하는 다음 예제는 <xref:System.Data.DataTable> 개체의 <xref:System.Data.DataView> 를 통해를 <xref:System.Data.DataTable.DefaultView%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-275">The following example sets a property of the <xref:System.Data.DataTable> object's <xref:System.Data.DataView> through the <xref:System.Data.DataTable.DefaultView%2A> property.</span></span> <span data-ttu-id="0238d-276">또한이 예에서는 바인딩을 <xref:System.Windows.Forms.DataGridView> 컨트롤을 <xref:System.Data.DataTable> "CompanyName." 라는 열이 포함 된 "공급자" 라는</span><span class="sxs-lookup"><span data-stu-id="0238d-276">The example also shows the binding of a <xref:System.Windows.Forms.DataGridView> control to a <xref:System.Data.DataTable> named "Suppliers" that includes a column named "CompanyName."</span></span>  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayExpression : string with get, set" Usage="System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDisplayExpressionDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-277">이 테이블을 사용자 인터페이스에 나타내는 데 사용되는 값을 반환하는 식을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-277">Gets or sets the expression that returns a value used to represent this table in the user interface.</span>
          </span>
          <span data-ttu-id="0238d-278">
            <see langword="DisplayExpression" /> 속성을 사용하여 이 테이블의 이름을 사용자 인터페이스에 표시할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-278">The <see langword="DisplayExpression" /> property lets you display the name of this table in a user interface.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-279">표시 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-279">A display string.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataTable.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-280">폼에 사용되거나 다른 구성 요소에서 사용하는 <see cref="T:System.Data.DataTable" />의 초기화를 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-280">Ends the initialization of a <see cref="T:System.Data.DataTable" /> that is used on a form or used by another component.</span>
          </span>
          <span data-ttu-id="0238d-281">초기화는 런타임에 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-281">The initialization occurs at run time.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-282">Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소의 초기화를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-282">The Visual Studio .NET design environment uses this method to end the initialization of a component that is used on a form or used by another component.</span></span> <span data-ttu-id="0238d-283"><xref:System.Data.DataTable.BeginInit%2A> 메서드 초기화를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-283">The <xref:System.Data.DataTable.BeginInit%2A> method starts the initialization.</span></span> <span data-ttu-id="0238d-284">사용 하는 <xref:System.Data.DataTable.BeginInit%2A> 및 <xref:System.Data.DataTable.EndInit%2A> 메서드 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-284">Using the <xref:System.Data.DataTable.BeginInit%2A> and <xref:System.Data.DataTable.EndInit%2A> methods prevents the control from being used before it is fully initialized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberSignature Language="F#" Value="member this.EndLoadData : unit -&gt; unit" Usage="dataTable.EndLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-285">데이터를 로드한 후 알림, 인덱스 유지 관리 및 제약 조건 기능을 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-285">Turns on notifications, index maintenance, and constraints after loading data.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-286">사용 하 여 <xref:System.Data.DataTable.EndLoadData%2A> 와 함께에서 <xref:System.Data.DataTable.LoadDataRow%2A> 고 <xref:System.Data.DataTable.BeginLoadData%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-286">Use <xref:System.Data.DataTable.EndLoadData%2A> in conjunction with <xref:System.Data.DataTable.LoadDataRow%2A> and <xref:System.Data.DataTable.BeginLoadData%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-287">사용자 지정 사용자 정보 컬렉션을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-287">Gets the collection of customized user information.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-288">사용자 지정 사용자 정보가 들어 있는 <see cref="T:System.Data.PropertyCollection" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-288">A <see cref="T:System.Data.PropertyCollection" /> that contains custom user information.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-289">사용 합니다 <xref:System.Data.DataTable.ExtendedProperties%2A> 사용자 지정 정보를 추가 하는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-289">Use the <xref:System.Data.DataTable.ExtendedProperties%2A> to add custom information to a <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-290">추가 정보는 `Add` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-290">Add information with the `Add` method.</span></span> <span data-ttu-id="0238d-291">사용 하 여 정보를 검색 합니다 `Item` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-291">Retrieve information with the `Item` method.</span></span>  
  
 <span data-ttu-id="0238d-292">확장된 속성 유형 이어야 <xref:System.String>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-292">Extended properties must be of type <xref:System.String>.</span></span> <span data-ttu-id="0238d-293">문자열 형식이 아닌 속성 유지 되지 않습니다 경우는 <xref:System.Data.DataTable> XML로 작성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-293">Properties that are not of type String are not persisted when the <xref:System.Data.DataTable> is written as XML.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-294">다음 예제에서는 타임 스탬프 값을 추가 합니다 <xref:System.Data.DataTable> 를 통해를 <xref:System.Data.DataTable.ExtendedProperties%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="0238d-294">The following example adds a timestamp value to the <xref:System.Data.DataTable> through the <xref:System.Data.DataTable.ExtendedProperties%2A> property.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberSignature Language="F#" Value="val mutable fInitInProgress : bool" Usage="System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-295">초기화가 진행 중인지 여부를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-295">Checks whether initialization is in progress.</span>
          </span>
          <span data-ttu-id="0238d-296">초기화는 런타임에 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-296">The initialization occurs at run time.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-297">마지막으로 로드되거나 <see cref="T:System.Data.DataTable" />가 호출된 후에 변경된 내용이 모두 들어 있는 <see cref="M:System.Data.DataTable.AcceptChanges" />의 복사본을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-297">Gets a copy of the <see cref="T:System.Data.DataTable" /> containing all changes made to it since it was last loaded, or since <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataTable" Usage="dataTable.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-298">로드되거나 <see cref="T:System.Data.DataTable" />가 마지막으로 호출된 후에 변경된 내용이 모두 들어 있는 <see cref="M:System.Data.DataTable.AcceptChanges" />의 복사본을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-298">Gets a copy of the <see cref="T:System.Data.DataTable" /> that contains all changes made to it since it was loaded or <see cref="M:System.Data.DataTable.AcceptChanges" /> was last called.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-299">이 <see cref="T:System.Data.DataTable" />의 변경 내용의 복사본을 반환하거나, 변경 내용이 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-299">A copy of the changes from this <see cref="T:System.Data.DataTable" />, or <see langword="null" /> if no changes are found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-300">새로 만듭니다 <xref:System.Data.DataSet> 원래의 모든 행의 복사본이 포함 된 <xref:System.Data.DataSet> 보류 중인 변경 내용이 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-300">Creates a new <xref:System.Data.DataSet> containing a copy of all rows in the original <xref:System.Data.DataSet> that have pending changes.</span></span> <span data-ttu-id="0238d-301">관계 제약 조건을 추가할 새 변경 되지 않은 행을 추가 하면 <xref:System.Data.DataSet> 경우 변경 되지 않은 행 변경된 된 행에서 외래 키에 해당 하는 기본 키를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-301">Relationship constraints can cause additional unchanged rows to be added to the new <xref:System.Data.DataSet> if the unchanged rows contain primary keys corresponding to foreign keys in the changed rows.</span></span> <span data-ttu-id="0238d-302">메서드는 반환 `null` (`Nothing` Visual basic에서) 원본에서 행이 없는 경우 <xref:System.Data.DataSet> 사용 하 여 보류 중인 변경 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-302">The method returns `null` (`Nothing` in Visual Basic) if there are no rows in the original <xref:System.Data.DataSet> with pending changes.</span></span>  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataTable" Usage="dataTable.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">
          <span data-ttu-id="0238d-303">
            <see cref="T:System.Data.DataRowState" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-303">One of the <see cref="T:System.Data.DataRowState" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-304">마지막으로 로드되거나 <see cref="T:System.Data.DataTable" />가 호출된 후에 변경되어 <see cref="M:System.Data.DataTable.AcceptChanges" />를 기준으로 필터링된 내용이 모두 들어 있는 <see cref="T:System.Data.DataRowState" />의 복사본을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-304">Gets a copy of the <see cref="T:System.Data.DataTable" /> containing all changes made to it since it was last loaded, or since <see cref="M:System.Data.DataTable.AcceptChanges" /> was called, filtered by <see cref="T:System.Data.DataRowState" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-305">작업을 수행한 다음 <see cref="T:System.Data.DataTable" />를 사용하여 다시 <see cref="T:System.Data.DataTable" />에 병합할 수 있는 경우 <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />의 필터링된 복사본을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-305">A filtered copy of the <see cref="T:System.Data.DataTable" /> that can have actions performed on it, and later be merged back in the <see cref="T:System.Data.DataTable" /> using <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />.</span>
          </span>
          <span data-ttu-id="0238d-306">원하는 <see cref="T:System.Data.DataRowState" /> 행이 없으면 이 메서드는 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-306">If no rows of the desired <see cref="T:System.Data.DataRowState" /> are found, the method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-307">합니다 <xref:System.Data.DataTable.GetChanges%2A> 메서드는 두 번째 생성 데 <xref:System.Data.DataTable> 원래에 도입 된 변경 내용만 포함 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-307">The <xref:System.Data.DataTable.GetChanges%2A> method is used to produce a second <xref:System.Data.DataTable> object that contains only the changes introduced into the original.</span></span> <span data-ttu-id="0238d-308">사용 된 `rowStates` 새 개체에 포함 될 변경 유형을 지정 하는 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-308">Use the `rowStates` argument to specify the type of changes the new object should include.</span></span>  
  
 <span data-ttu-id="0238d-309">관계 제약 조건에는 변경 되지 않은 부모 행이 포함 되도록 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-309">Relationship constraints may cause unchanged parent rows to be included.</span></span>  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataTableSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataTable.GetDataTableSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">
          <span data-ttu-id="0238d-310">
            <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-310">An <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-311">이 메서드는 웹 서비스의 <see cref="T:System.Xml.Schema.XmlSchemaSet" />을 설명하는 WSDL(Web Services Description Language)이 포함된 <see cref="T:System.Data.DataTable" /> 인스턴스를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-311">This method returns an <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance containing the Web Services Description Language (WSDL) that describes the <see cref="T:System.Data.DataTable" /> for Web Services.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-312">
            <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-312">The <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberSignature Language="F#" Value="member this.GetErrors : unit -&gt; System.Data.DataRow[]" Usage="dataTable.GetErrors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-313">오류가 있는 <see cref="T:System.Data.DataRow" /> 개체로 이루어진 배열을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-313">Gets an array of <see cref="T:System.Data.DataRow" /> objects that contain errors.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-314">오류가 있는 <see cref="T:System.Data.DataRow" /> 개체로 이루어진 배열을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-314">An array of <see cref="T:System.Data.DataRow" /> objects that have errors.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-315">목록을 반환 <xref:System.Data.DataRow> 이 있는 개체 <xref:System.Data.DataRow.RowError%2A> 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-315">Returns the list of <xref:System.Data.DataRow> objects that have <xref:System.Data.DataRow.RowError%2A> set.</span></span> <span data-ttu-id="0238d-316">호출할 때 오류가 발생할 수 있습니다 예를 들어 <xref:System.Data.Common.DataAdapter.Update%2A> 사용 하 여 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 로 설정 **true**합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-316">For example, errors can occur when calling <xref:System.Data.Common.DataAdapter.Update%2A> with <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> set to **true**.</span></span> <span data-ttu-id="0238d-317">호출 하지 마십시오 <xref:System.Data.DataTable.AcceptChanges%2A> 에 <xref:System.Data.DataTable> 모든 오류를 해결 하 고 다시 전송 될 때까지 <xref:System.Data.DataSet> 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-317">Do not invoke <xref:System.Data.DataTable.AcceptChanges%2A> on the <xref:System.Data.DataTable> until you resolve all errors and resubmit the <xref:System.Data.DataSet> for updating.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-318">다음 예제에서는 합니다 <xref:System.Data.DataTable.GetErrors%2A> 배열을 반환 하는 방법 <xref:System.Data.DataRow> 오류가 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-318">The following example uses the <xref:System.Data.DataTable.GetErrors%2A> method to return an array of <xref:System.Data.DataRow> objects that have errors.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataTable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="0238d-319">
            <see cref="T:System.Runtime.Serialization.SerializationInfo" />과 관련된 serialize된 개체가 들어 있는 <see cref="T:System.Data.DataTable" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-319">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that holds the serialized data associated with the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="0238d-320">
            <see cref="T:System.Runtime.Serialization.StreamingContext" />과 관련된 serialize된 스트림의 소스와 대상이 들어 있는 <see cref="T:System.Data.DataTable" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-320">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains the source and destination of the serialized stream associated with the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-321">
            <see cref="T:System.Data.DataTable" />을 serialize하는 데 필요한 데이터로 serialization 정보 개체를 채웁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-321">Populates a serialization information object with the data needed to serialize the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0238d-322">
            <paramref name="info" />매개 변수가 null 참조(Visual Basic에서는 <see langword="Nothing" />)인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-322">The <paramref name="info" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberSignature Language="F#" Value="abstract member GetRowType : unit -&gt; Type&#xA;override this.GetRowType : unit -&gt; Type" Usage="dataTable.GetRowType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-323">행 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-323">Gets the row type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-324">
            <see cref="T:System.Data.DataRow" />의 형식을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-324">Returns the type of the <see cref="T:System.Data.DataRow" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberSignature Language="F#" Value="abstract member GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataTable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-325">이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />를 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-325">For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-326">
            <see cref="T:System.Xml.Schema.XmlSchema" /> 메서드에 의해 생성되고 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> 메서드가 사용하는 개체의 XML 표현을 설명하는 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-326">An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-327">해당 테이블이 속하는 <see cref="T:System.Data.DataSet" />의 테이블에 있는 행에 오류가 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-327">Gets a value indicating whether there are errors in any of the rows in any of the tables of the <see cref="T:System.Data.DataSet" /> to which the table belongs.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-328">오류가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-328">
              <see langword="true" /> if errors exist; otherwise <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-329">사용자 작업에 포함 된 데이터 집합에는 <xref:System.Data.DataTable>, 변경으로 인해 일부 유효성 검사 실패 하는 경우 각 변경에 오류를 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-329">As users work on a set of data contained in a <xref:System.Data.DataTable>, you can mark each change with an error if the change causes some validation failure.</span></span> <span data-ttu-id="0238d-330">전체를 표시할 수 있습니다 <xref:System.Data.DataRow> 사용 하 여 오류 메시지는 <xref:System.Data.DataRow.RowError%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-330">You can mark an entire <xref:System.Data.DataRow> with an error message using the <xref:System.Data.DataRow.RowError%2A> property.</span></span> <span data-ttu-id="0238d-331">오류가 있는 행의 각 열에 설정할 수도 있습니다는 <xref:System.Data.DataRow.SetColumnError%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-331">You can also set errors on each column of the row with the <xref:System.Data.DataRow.SetColumnError%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-332">데이터 소스를 업데이트 하기 전에 <xref:System.Data.DataSet>를 먼저 호출 하는 것이 좋습니다는 <xref:System.Data.DataSet.GetChanges%2A> 대상 메서드 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-332">Before updating a data source with a <xref:System.Data.DataSet>, it's recommended that you first invoke the <xref:System.Data.DataSet.GetChanges%2A> method on the target <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="0238d-333">메서드 결과 <xref:System.Data.DataSet> 원본에 대 한 변경 내용만 포함 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-333">The method results in a <xref:System.Data.DataSet> that contains only the changes made to the original.</span></span> <span data-ttu-id="0238d-334">보내기 전에 <xref:System.Data.DataSet> 업데이트에 대 한 데이터 원본에 확인을 <xref:System.Data.DataTable.HasErrors%2A> 오류 행 이나 행의 열에 연결 되는 경우를 확인 하려면 각 테이블의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-334">Before sending the <xref:System.Data.DataSet> to the data source for updating, check the <xref:System.Data.DataTable.HasErrors%2A> property of each table to see if any errors have been attached to the rows or columns in the rows.</span></span>  
  
 <span data-ttu-id="0238d-335">각 오류를 해결 한 후 사용 하 여 오류를 지울 합니다 <xref:System.Data.DataRow.ClearErrors%2A> 메서드는 `DataRow`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-335">After reconciling each error, clear the errors with the <xref:System.Data.DataRow.ClearErrors%2A> method of the `DataRow`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-336">다음 예제에서는 <xref:System.Data.DataTable.HasErrors%2A> 속성을 테이블에 오류가 포함 되어 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-336">The following example uses the <xref:System.Data.DataTable.HasErrors%2A> property to check if a table contains errors.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberSignature Language="F#" Value="member this.ImportRow : System.Data.DataRow -&gt; unit" Usage="dataTable.ImportRow row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">
          <span data-ttu-id="0238d-337">가져올 <see cref="T:System.Data.DataRow" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-337">The <see cref="T:System.Data.DataRow" /> to be imported.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-338">원래 값 및 현재 값과 모든 속성 설정을 그대로 유지한 상태로 <see cref="T:System.Data.DataRow" />를 <see cref="T:System.Data.DataTable" />에 복사합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-338">Copies a <see cref="T:System.Data.DataRow" /> into a <see cref="T:System.Data.DataTable" />, preserving any property settings, as well as original and current values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-339">호출 <xref:System.Data.DataTable.NewRow%2A> 기존 테이블 스키마를 사용 하 여 테이블에 있지만 행에 대 한 기본값을 사용 하 여 행을 추가 하 고 설정 합니다 <xref:System.Data.DataRowState> 에 `Detached`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-339">Calling <xref:System.Data.DataTable.NewRow%2A> adds a row to the table using the existing table schema, but with default values for the row, and sets the <xref:System.Data.DataRowState> to `Detached`.</span></span> <span data-ttu-id="0238d-340">호출 <xref:System.Data.DataTable.ImportRow%2A> 기존 유지 <xref:System.Data.DataRowState> 행의 다른 값과 함께 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-340">Calling <xref:System.Data.DataTable.ImportRow%2A> preserves the existing <xref:System.Data.DataRowState> along with other values in the row.</span></span> <span data-ttu-id="0238d-341">경우는 `DataRow` 전달 된 분리 된 상태의 매개 변수는는 무시 되 고 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-341">If the `DataRow` that is passed as a parameter is in a detached state, it is ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="0238d-342">새 행을 데이터 테이블의 끝에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-342">The new row will be added to the end of the data table.</span></span>  
  
 <span data-ttu-id="0238d-343">새 행에는 제약 조건을 위반 하는 경우에 데이터 테이블에 추가할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-343">If the new row violates a Constraint it won’t be added to the data table.</span></span>  
  
 <span data-ttu-id="0238d-344">DataTable.Rows.Find DataTable.Rows.IndexOf로 사용 하 여 새 행의 인덱스를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-344">You can get the index of the new row with as DataTable.Rows.Find and DataTable.Rows.IndexOf.</span></span> <span data-ttu-id="0238d-345">자세한 내용은 <xref:System.Data.DataRowCollection> 및 <xref:System.Data.DataTable.Rows%2A>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0238d-345">See <xref:System.Data.DataRowCollection> and <xref:System.Data.DataTable.Rows%2A> for more information.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-346">
            <see cref="T:System.Data.DataTable" />이 초기화된 후 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-346">Occurs after the <see cref="T:System.Data.DataTable" /> is initialized.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-347">자세한 내용은 <xref:System.Data.DataTable.IsInitialized%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0238d-347">For more information, see <xref:System.Data.DataTable.IsInitialized%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-348">
            <see cref="T:System.Data.DataTable" />이 초기화되어 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-348">Gets a value that indicates whether the <see cref="T:System.Data.DataTable" /> is initialized.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-349">구성 요소의 초기화가 완료되었음을 나타내려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-349">
              <see langword="true" /> to indicate the component has completed initialization; otherwise <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-350">상태를 반환 하는 <xref:System.Data.DataTable> 이 생성 되, 예를 들어 Visual Studio에서 하는 동안.</span><span class="sxs-lookup"><span data-stu-id="0238d-350">Returns the status of the <xref:System.Data.DataTable> while it’s being constructed, for instance by Visual Studio.</span></span> <span data-ttu-id="0238d-351">합니다 <xref:System.Data.DataTable.BeginInit%2A> 메서드를 설정 `false` 하 고 <xref:System.Data.DataTable.EndInit%2A> 메서드를 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-351">The <xref:System.Data.DataTable.BeginInit%2A> method sets it to `false` and <xref:System.Data.DataTable.EndInit%2A> method sets it to `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-352">제공된 <see cref="T:System.Data.DataTable" />를 사용해서 <see cref="T:System.Data.IDataReader" />을 데이터 소스의 값으로 채웁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-352">Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />.</span>
          </span>
          <span data-ttu-id="0238d-353">
            <see langword="DataTable" />에 이미 행이 포함되어 있으면 데이터 소스에서 들어오는 데이터가 기존 행과 병합됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-353">If the <see langword="DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-354">`Load` 몇 가지 일반적인 시나리오는 지정 된 데이터 원본에서 데이터 가져오기 및 현재 데이터 컨테이너에 추가에서 메서드를 사용할 수 있습니다 (이 경우에 `DataTable`).</span><span class="sxs-lookup"><span data-stu-id="0238d-354">The `Load` method can be used in several common scenarios, all centered around getting data from a specified data source and adding it to the current data container (in this case, a `DataTable`).</span></span> <span data-ttu-id="0238d-355">에 대 한 일반 사용법을 설명 하는 이러한 시나리오는 `DataTable`, 해당 업데이트를 설명 하 고 병합 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-355">These scenarios describe standard usage for a `DataTable`, describing its update and merge behavior.</span></span>  
  
 <span data-ttu-id="0238d-356">`DataTable` 동기화 하거나 단일 기본 데이터 원본을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-356">A `DataTable` synchronizes or updates with a single primary data source.</span></span> <span data-ttu-id="0238d-357">`DataTable` 기본 데이터 소스와 동기화 할 수 있도록 변경 내용을 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-357">The `DataTable` tracks changes, allowing synchronization with the primary data source.</span></span> <span data-ttu-id="0238d-358">또한는 `DataTable` 하나 이상의 보조 데이터 원본의 증분 데이터를 허용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-358">In addition, a `DataTable` can accept incremental data from one or more secondary data sources.</span></span> <span data-ttu-id="0238d-359">`DataTable` 보조 데이터 원본과 동기화를 허용 하기 위해 변경 내용 추적에 대 한 책임을 지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-359">The `DataTable` isn't responsible for tracking changes in order to allow synchronization with the secondary data source.</span></span>  
  
 <span data-ttu-id="0238d-360">이러한 두 가상 데이터 원본 지정 되 면 사용자가 다음 동작 중 하나 필요로 할:</span><span class="sxs-lookup"><span data-stu-id="0238d-360">Given these two hypothetical data sources, a user is likely to require one of the following behaviors:</span></span>  
  
-   <span data-ttu-id="0238d-361">초기화 `DataTable` 주 데이터 원본에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-361">Initialize `DataTable` from a primary data source.</span></span> <span data-ttu-id="0238d-362">이 시나리오에서는 사용자가 빈 초기화 `DataTable` 주 데이터 원본에서 값을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-362">In this scenario, the user wants to initialize an empty `DataTable` with values from the primary data source.</span></span> <span data-ttu-id="0238d-363">사용자는 나중에 다시 기본 데이터 소스에 변경 내용을 전파 하는입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-363">Later the user intends to propagate changes back to the primary data source.</span></span>  
  
-   <span data-ttu-id="0238d-364">변경 내용을 유지 하 고 기본 데이터 원본에서 다시 동기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-364">Preserve changes and re-synchronize from the primary data source.</span></span> <span data-ttu-id="0238d-365">이 시나리오에서는 사용자가 수행 합니다 `DataTable` 이전 시나리오에서 입력 하 고 기본 데이터 원본에서 변경 내용을 유지를 사용 하 여 증분 동기화를 수행 합니다 `DataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-365">In this scenario, the user wants to take the `DataTable` filled in the previous scenario and perform an incremental synchronization with the primary data source, preserving modifications made in the `DataTable`.</span></span>  
  
-   <span data-ttu-id="0238d-366">증분 데이터를 보조 데이터 원본에서 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-366">Incremental data feed from secondary data sources.</span></span> <span data-ttu-id="0238d-367">이 시나리오에서는 사용자가 하나 이상의 보조 데이터 원본에서 변경 내용을 병합 하 여 이러한 변경 내용을 주 데이터 원본에 다시 전파 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-367">In this scenario, the user wants to merge changes from one or more secondary data sources, and propagate those changes back to the primary data source.</span></span>  
  
 <span data-ttu-id="0238d-368">`Load` 메서드 수 있게 이러한 모든 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-368">The `Load` method makes all these scenarios possible.</span></span> <span data-ttu-id="0238d-369">하나를 제외한 모든 오버 로드 중에이 메서드를 사용 하면 부하 옵션 매개 변수를 지정할 수 있습니다를 나타내는 방법에 있는 행을 <xref:System.Data.DataTable> 로드 중인 행과 결합 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-369">All but one of the overloads for this method allows you to specify a load option parameter, indicating how rows already in a <xref:System.Data.DataTable> combine with rows being loaded.</span></span> <span data-ttu-id="0238d-370">(오버 로드의 동작을 지정할 수는 기본 로드 옵션을 사용 합니다.) 다음 표에에서 제공 하는 다음 세 가지 로드 옵션은 <xref:System.Data.LoadOption> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-370">(The overload that doesn't allow you to specify the behavior uses the default load option.) The following table describes the three load options provided by the <xref:System.Data.LoadOption> enumeration.</span></span> <span data-ttu-id="0238d-371">각 예에서 설명 들어오는 데이터의 행의 기본 키가 기존 행의 기본 키와 일치 하는 경우 동작을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-371">In each case, the description indicates the behavior when the primary key of a row in the incoming data matches the primary key of an existing row.</span></span>  
  
|<span data-ttu-id="0238d-372">로드 옵션</span><span class="sxs-lookup"><span data-stu-id="0238d-372">Load Option</span></span>|<span data-ttu-id="0238d-373">설명</span><span class="sxs-lookup"><span data-stu-id="0238d-373">Description</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="0238d-374">`PreserveChanges`(기본값)</span><span class="sxs-lookup"><span data-stu-id="0238d-374">`PreserveChanges` (default)</span></span>|<span data-ttu-id="0238d-375">들어오는 행의 값을 사용 하 여 행의 원래 버전을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-375">Updates the original version of the row with the value of the incoming row.</span></span>|  
|`OverwriteChanges`|<span data-ttu-id="0238d-376">들어오는 행의 값을 사용 하 여 행의 현재 버전과 원래 버전을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-376">Updates the current and original versions of the row with the value of the incoming row.</span></span>|  
|`Upsert`|<span data-ttu-id="0238d-377">들어오는 행의 값을 사용 하 여 행의 현재 버전을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-377">Updates the current version of the row with the value of the incoming row.</span></span>|  
  
 <span data-ttu-id="0238d-378">일반적으로 `PreserveChanges` 하 고 `OverwriteChanges` 사용자를 동기화 해야 하는 시나리오에 대 한 옵션은는 `DataSet` 및 기본 데이터 소스를 사용 하 여 해당 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-378">In general, the `PreserveChanges` and `OverwriteChanges` options are intended for scenarios in which the user needs to synchronize the `DataSet` and its changes with the primary data source.</span></span> <span data-ttu-id="0238d-379">`Upsert` 옵션에 하나 이상의 보조 데이터 원본에서 집계 변경 용이 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-379">The `Upsert` option facilitates aggregating changes from one or more secondary data sources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-380">다음 예제에서는 다양 한 호출을 사용 하 여 관련 된 문제는 <xref:System.Data.DataTable.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-380">The following example demonstrates several of the issues involved with calling the <xref:System.Data.DataTable.Load%2A> method.</span></span> <span data-ttu-id="0238d-381">예제에서 로드 된 스키마를 유추 등의 스키마 문제에 집중 하는 먼저 <xref:System.Data.IDataReader>, 및 다음 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-381">First, the example focuses on schema issues, including inferring a schema from the loaded <xref:System.Data.IDataReader>, and then handling incompatible schemas, and schemas with missing or additional columns.</span></span> <span data-ttu-id="0238d-382">이 예제에서는 다음 데이터 문제를 포함 하 여 다양 한 로드 옵션에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-382">The example then focuses on data issues, including handling the various loading options.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-383">이 예제에서는 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다 `Load`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-383">This example shows how to use one of the overloaded versions of `Load`.</span></span> <span data-ttu-id="0238d-384">사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="0238d-384">For other examples that might be available, see the individual overload topics.</span></span>  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader -&gt; unit" Usage="dataTable.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="0238d-385">결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-385">An <see cref="T:System.Data.IDataReader" /> that provides a result set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-386">제공된 <see cref="T:System.Data.DataTable" />를 사용해서 <see cref="T:System.Data.IDataReader" />을 데이터 소스의 값으로 채웁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-386">Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />.</span>
          </span>
          <span data-ttu-id="0238d-387">
            <see cref="T:System.Data.DataTable" />에 이미 행이 포함되어 있으면 데이터 소스에서 들어오는 데이터가 기존 행과 병합됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-387">If the <see cref="T:System.Data.DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-388">합니다 <xref:System.Data.DataTable.Load%2A> 첫 번째 결과 집합의 로드를 사용 하는 메서드 <xref:System.Data.IDataReader>를 성공적으로 완료 한 후 설정 판독기의 위치를 다음 결과 집합에 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="0238d-388">The <xref:System.Data.DataTable.Load%2A> method consumes the first result set from the loaded <xref:System.Data.IDataReader>, and after successful completion, sets the reader's position to the next result set, if any.</span></span> <span data-ttu-id="0238d-389">데이터를 변환 하는 경우는 `Load` 와 같은 변환 규칙을 사용 하는 메서드를 <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-389">When converting data, the `Load` method uses the same conversion rules as the <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="0238d-390">합니다 <xref:System.Data.DataTable.Load%2A> 메서드를 고려해 야 합니다 세 가지 특정 문제에서 데이터를 로드 하는 경우는 <xref:System.Data.IDataReader> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-390">The <xref:System.Data.DataTable.Load%2A> method must take into account three specific issues when loading the data from an <xref:System.Data.IDataReader> instance: schema, data, and event operations.</span></span> <span data-ttu-id="0238d-391">스키마를 사용 하 여 작업 하는 경우는 <xref:System.Data.DataTable.Load%2A> 메서드는 다음 표에 설명 된 대로 조건이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-391">When working with the schema, the <xref:System.Data.DataTable.Load%2A> method may encounter conditions as described in the following table.</span></span> <span data-ttu-id="0238d-392">스키마 작업 수행도 포함 하는 데이터가 없는 모든 가져온된 결과 집합에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-392">The schema operations take place for all imported result sets, even those containing no data.</span></span>  
  
|<span data-ttu-id="0238d-393">조건</span><span class="sxs-lookup"><span data-stu-id="0238d-393">Condition</span></span>|<span data-ttu-id="0238d-394">동작</span><span class="sxs-lookup"><span data-stu-id="0238d-394">Behavior</span></span>|  
|---------------|--------------|  
|<span data-ttu-id="0238d-395"><xref:System.Data.DataTable> 에 스키마가 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-395">The <xref:System.Data.DataTable> has no schema.</span></span>|<span data-ttu-id="0238d-396">합니다 <xref:System.Data.DataTable.Load%2A> 메서드는 가져온에서 결과 집합에 따라 스키마를 유추 <xref:System.Data.IDataReader>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-396">The <xref:System.Data.DataTable.Load%2A> method infers the schema based on the result set from the imported <xref:System.Data.IDataReader>.</span></span>|  
|<span data-ttu-id="0238d-397"><xref:System.Data.DataTable> 스키마를 갖지만 로드 된 스키마와 호환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-397">The <xref:System.Data.DataTable> has a schema, but it is incompatible with the loaded schema.</span></span>|<span data-ttu-id="0238d-398"><xref:System.Data.DataTable.Load%2A> 메서드 호환 되지 않는 스키마로 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-398">The <xref:System.Data.DataTable.Load%2A> method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.</span></span>|  
|<span data-ttu-id="0238d-399">스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 된 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-399">The schemas are compatible, but the loaded result set schema contains columns that do not exist in the <xref:System.Data.DataTable>.</span></span>|<span data-ttu-id="0238d-400">합니다 <xref:System.Data.DataTable.Load%2A> 추가 열을 추가 하는 메서드 `DataTable`의 스키마입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-400">The <xref:System.Data.DataTable.Load%2A> method adds the extra columns to `DataTable`'s schema.</span></span> <span data-ttu-id="0238d-401">메서드는 해당 하는 경우 예외를 throw에서 열을 <xref:System.Data.DataTable> 로드 된 결과 집합 값이 서로 호환 되지 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-401">The method throws an exception if corresponding columns in the <xref:System.Data.DataTable> and the loaded result set are not value compatible.</span></span> <span data-ttu-id="0238d-402">또한 메서드는 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-402">The method also retrieves constraint information from the result set for all added columns.</span></span> <span data-ttu-id="0238d-403">Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보는 경우에 현재 <xref:System.Data.DataTable> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-403">Except for the case of Primary Key constraint, this constraint information is used only if the current <xref:System.Data.DataTable> does not contain any columns at the start of the load operation.</span></span>|  
|<span data-ttu-id="0238d-404">스키마가 호환 되지만 보다 적은 개수의 열을 포함 하는 로드 된 결과 집합 스키마에는 `DataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-404">The schemas are compatible, but the loaded result set schema contains fewer columns than does the `DataTable`.</span></span>|<span data-ttu-id="0238d-405">누락 된 열에 기본값이 정의 또는 열의 데이터 형식이 null을 허용 하는 경우는 <xref:System.Data.DataTable.Load%2A> 메서드를 사용 하면 행에 추가 하려면 기본 대체 또는 `null` 는 누락 된 열에 대 한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-405">If a missing column has a default value defined or the column's data type is nullable, the <xref:System.Data.DataTable.Load%2A> method allows the rows to be added, substituting the default or `null` value for the missing column.</span></span> <span data-ttu-id="0238d-406">경우 기본값은 없습니다 또는 `null` 사용할 수는 `Load` 메서드에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-406">If no default value or `null` can be used, then the `Load` method throws an exception.</span></span> <span data-ttu-id="0238d-407">특정 기본 값을 제공 하는 경우는 `Load` 메서드는 `null` 암시 된 기본값으로 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-407">If no specific default value has been supplied, the `Load` method uses the `null` value as the implied default value.</span></span>|  
  
 <span data-ttu-id="0238d-408">동작을 고려 하기 전에 합니다 `Load` 데이터 작업을 기준으로 메서드는 것이 좋습니다 각 내에서 행을 <xref:System.Data.DataTable> 현재 값과 각 열에 대 한 원래 값을 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-408">Before considering the behavior of the `Load` method in terms of data operations, consider that each row within a <xref:System.Data.DataTable> maintains both the current value and the original value for each column.</span></span> <span data-ttu-id="0238d-409">이러한 값 같을 수도 있지만, 또는 행의 데이터를 채운 이후에 변경 된 경우에 다를 수 여 `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="0238d-409">These values may be equivalent, or may be different if the data in the row has been changed since filling the `DataTable`.</span></span>  <span data-ttu-id="0238d-410">자세한 내용은 [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-410">For more information, see [Row States and Row Versions](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).</span></span>  
  
 <span data-ttu-id="0238d-411">이 버전의는 `Load` 메서드는 원래 값을 그대로 두고 각 행의 현재 값을 유지 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-411">This version of the `Load` method attempts to preserve the current values in each row, leaving the original value intact.</span></span> <span data-ttu-id="0238d-412">(들어오는 데이터의 동작을 보다 세부적으로 제어를 원한다 면 참조 <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) 기존 행과 들어오는 행에 해당 기본 키 값이 없으면 행의 현재 행 상태 값을 사용 하 여 처리 됩니다, 그리고 그렇지 않으면 새 행으로 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-412">(If you want finer control over the behavior of incoming data, see <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.</span></span>  
  
 <span data-ttu-id="0238d-413">이벤트 작업의 경우는 <xref:System.Data.DataTable.RowChanging> 각 행이 변경 되기 전에 이벤트가 발생 하며 <xref:System.Data.DataTable.RowChanged> 이벤트는 각 행이 변경 된 후 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-413">In terms of event operations, the <xref:System.Data.DataTable.RowChanging> event occurs before each row is changed, and the <xref:System.Data.DataTable.RowChanged> event occurs after each row has been changed.</span></span> <span data-ttu-id="0238d-414">각각의 경우에서는 <xref:System.Data.DataRowChangeEventArgs.Action%2A> 속성의는 <xref:System.Data.DataRowChangeEventArgs> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 연결 된 특정 작업에 대 한 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-414">In each case, the <xref:System.Data.DataRowChangeEventArgs.Action%2A> property of the <xref:System.Data.DataRowChangeEventArgs> instance passed to the event handler contains information about the particular action associated with the event.</span></span> <span data-ttu-id="0238d-415">동작 값이 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-415">This action value depends on the state of the row before the load operation.</span></span> <span data-ttu-id="0238d-416">각각의 경우에서 두 이벤트가 발생 하 고 작업을 각각에 대해 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-416">In each case, both events occur, and the action is the same for each.</span></span> <span data-ttu-id="0238d-417">작업은 각 행의 현재 또는 원래 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-417">The action may be applied to either the current or original version of each row, or both, depending on the current row state.</span></span>  
  
 <span data-ttu-id="0238d-418">다음 표에서 동작을 보여 줍니다는 `Load` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-418">The following table displays behavior for the `Load` method.</span></span> <span data-ttu-id="0238d-419">("(없음)" 라는) 마지막 행을 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-419">The final row (labeled "(Not present)") describes the behavior for incoming rows that don't match any existing row.</span></span> <span data-ttu-id="0238d-420">이 테이블의 각 셀과 함께 행의 필드에 대 한 현재 및 원래 값을 설명 합니다는 <xref:System.Data.DataRowState> 후의 값에 대 한는 `Load` 메서드가 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-420">Each cell in this table describes the current and original value for a field within a row, along with the <xref:System.Data.DataRowState> for the value after the `Load` method has completed.</span></span> <span data-ttu-id="0238d-421">메서드 로드 옵션을 지정할 수 없습니다 및 기본값을 사용 하 여이 예제의 경우 `PreserveChanges`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-421">In this case, the method doesn't allow you to indicate the load option, and uses the default, `PreserveChanges`.</span></span>  
  
|<span data-ttu-id="0238d-422">기존 DataRowState</span><span class="sxs-lookup"><span data-stu-id="0238d-422">Existing DataRowState</span></span>|<span data-ttu-id="0238d-423">값 `Load` 메서드 및 이벤트 작업</span><span class="sxs-lookup"><span data-stu-id="0238d-423">Values after `Load` method, and event action</span></span>|  
|---------------------------|--------------------------------------------------|  
|<span data-ttu-id="0238d-424">추가됨</span><span class="sxs-lookup"><span data-stu-id="0238d-424">Added</span></span>|<span data-ttu-id="0238d-425">현재 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-425">Current = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-426">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-426">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-427">상태 = \<수정 ></span><span class="sxs-lookup"><span data-stu-id="0238d-427">State = \<Modified></span></span><br /><br /> <span data-ttu-id="0238d-428">RowAction = ChangeOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-428">RowAction = ChangeOriginal</span></span>|  
|<span data-ttu-id="0238d-429">수정한 날짜</span><span class="sxs-lookup"><span data-stu-id="0238d-429">Modified</span></span>|<span data-ttu-id="0238d-430">현재 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-430">Current = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-431">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-431">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-432">상태 = \<수정 ></span><span class="sxs-lookup"><span data-stu-id="0238d-432">State = \<Modified></span></span><br /><br /> <span data-ttu-id="0238d-433">RowAction = ChangeOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-433">RowAction = ChangeOriginal</span></span>|  
|<span data-ttu-id="0238d-434">삭제됨</span><span class="sxs-lookup"><span data-stu-id="0238d-434">Deleted</span></span>|<span data-ttu-id="0238d-435">현재 = \<없음 ></span><span class="sxs-lookup"><span data-stu-id="0238d-435">Current = \<Not available></span></span><br /><br /> <span data-ttu-id="0238d-436">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-436">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-437">상태 = \<삭제 ></span><span class="sxs-lookup"><span data-stu-id="0238d-437">State = \<Deleted></span></span><br /><br /> <span data-ttu-id="0238d-438">RowAction = ChangeOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-438">RowAction = ChangeOriginal</span></span>|  
|<span data-ttu-id="0238d-439">Unchanged</span><span class="sxs-lookup"><span data-stu-id="0238d-439">Unchanged</span></span>|<span data-ttu-id="0238d-440">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-440">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-441">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-441">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-442">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-442">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-443">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-443">RowAction = ChangeCurrentAndOriginal</span></span>|  
|<span data-ttu-id="0238d-444">(없음)</span><span class="sxs-lookup"><span data-stu-id="0238d-444">(Not present)</span></span>|<span data-ttu-id="0238d-445">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-445">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-446">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-446">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-447">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-447">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-448">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-448">RowAction = ChangeCurrentAndOriginal</span></span>|  
  
 <span data-ttu-id="0238d-449">값을 <xref:System.Data.DataColumn> 와 같은 속성을 사용 하 여 제한할 수 있습니다 <xref:System.Data.DataColumn.ReadOnly%2A> 고 <xref:System.Data.DataColumn.AutoIncrement%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-449">Values in a <xref:System.Data.DataColumn> can be constrained through use of properties such as <xref:System.Data.DataColumn.ReadOnly%2A> and <xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="0238d-450">`Load` 메서드 열의 속성에 의해 정의 된 동작을 사용 하 여 일치 하는 방식으로 해당 열을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-450">The `Load` method handles such columns in a manner that is consistent with the behavior defined by the column's properties.</span></span> <span data-ttu-id="0238d-451">읽기 전용 제약을 <xref:System.Data.DataColumn> 메모리에서 발생 하는 변경에만 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-451">The read only constraint on a <xref:System.Data.DataColumn> is applicable only for changes that occur in memory.</span></span> <span data-ttu-id="0238d-452">`Load` 메서드는 필요한 경우 읽기 전용으로 열 값을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-452">The `Load` method's overwrites the read-only column values, if needed.</span></span>  
  
 <span data-ttu-id="0238d-453">현재 행과 들어오는 행을 비교 하는 데 사용 하 여 기본 키 필드의 버전을 확인 하는 `Load` 메서드 존재 하는 경우 행의 기본 키 값의 원래 버전을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-453">To determine which version of the primary key field to use for comparing the current row with an incoming row, the `Load` method uses the original version of the primary key value within a row, if it exists.</span></span> <span data-ttu-id="0238d-454">이 고, 그렇지는 `Load` 메서드는 기본 키 필드의 현재 버전을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-454">Otherwise, the `Load` method uses the current version of the primary key field.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-455">다음 예제에서는 다양 한 호출을 사용 하 여 관련 된 문제는 <xref:System.Data.DataTable.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-455">The following example demonstrates several of the issues involved with calling the <xref:System.Data.DataTable.Load%2A> method.</span></span> <span data-ttu-id="0238d-456">예제에서 로드 된 스키마를 유추 등의 스키마 문제에 집중 하는 먼저 <xref:System.Data.IDataReader>, 및 다음 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-456">First, the example focuses on schema issues, including inferring a schema from the loaded <xref:System.Data.IDataReader>, and then handling incompatible schemas, and schemas with missing or additional columns.</span></span> <span data-ttu-id="0238d-457">호출 예제는 `Load` 메서드를 로드 작업 전후에 데이터를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-457">The example then calls the `Load` method, displaying the data both before and after the load operation.</span></span>  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption -&gt; unit" Usage="dataTable.Load (reader, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="0238d-458">하나 이상의 결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-458">An <see cref="T:System.Data.IDataReader" /> that provides one or more result sets.</span>
          </span>
        </param>
        <param name="loadOption">
          <span data-ttu-id="0238d-459">
            <see cref="T:System.Data.LoadOption" /> 열거형의 값으로서, 이미 <see cref="T:System.Data.DataTable" />에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-459">A value from the <see cref="T:System.Data.LoadOption" /> enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" /> are combined with incoming rows that share the same primary key.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-460">제공된 <see cref="T:System.Data.DataTable" />를 사용해서 <see cref="T:System.Data.IDataReader" />을 데이터 소스의 값으로 채웁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-460">Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />.</span>
          </span>
          <span data-ttu-id="0238d-461">
            <see langword="DataTable" />에 이미 행이 포함되어 있으면 데이터 소스에서 들어오는 데이터는 <paramref name="loadOption" /> 매개 변수의 값에 따라 기존 행과 병합됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-461">If the <see langword="DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows according to the value of the <paramref name="loadOption" /> parameter.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-462">합니다 `Load` 첫 번째 결과 집합의 로드를 사용 하는 메서드 <xref:System.Data.IDataReader>를 성공적으로 완료 한 후 설정 판독기의 위치를 다음 결과 집합에 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="0238d-462">The `Load` method consumes the first result set from the loaded <xref:System.Data.IDataReader>, and after successful completion, sets the reader's position to the next result set, if any.</span></span> <span data-ttu-id="0238d-463">데이터를 변환 하는 경우는 `Load` 와 같은 변환 규칙을 사용 하는 메서드를 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-463">When converting data, the `Load` method uses the same conversion rules as the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-464">합니다 `Load` 메서드를 고려해 야 합니다 세 가지 특정 문제에서 데이터를 로드 하는 경우는 <xref:System.Data.IDataReader> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-464">The `Load` method must take into account three specific issues when loading the data from an <xref:System.Data.IDataReader> instance: schema, data, and event operations.</span></span> <span data-ttu-id="0238d-465">스키마를 사용 하 여 작업 하는 경우는 `Load` 메서드는 다음 표에 설명 된 대로 조건이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-465">When working with the schema, the `Load` method may encounter conditions as described in the following table.</span></span> <span data-ttu-id="0238d-466">스키마 작업 수행도 포함 하는 데이터가 없는 모든 가져온된 결과 집합에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-466">The schema operations take place for all imported result sets, even those containing no data.</span></span>  
  
|<span data-ttu-id="0238d-467">조건</span><span class="sxs-lookup"><span data-stu-id="0238d-467">Condition</span></span>|<span data-ttu-id="0238d-468">동작</span><span class="sxs-lookup"><span data-stu-id="0238d-468">Behavior</span></span>|  
|---------------|--------------|  
|<span data-ttu-id="0238d-469"><xref:System.Data.DataTable> 에 스키마가 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-469">The <xref:System.Data.DataTable> has no schema.</span></span>|<span data-ttu-id="0238d-470">합니다 `Load` 메서드는 가져온에서 결과 집합에 따라 스키마를 유추 <xref:System.Data.IDataReader>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-470">The `Load` method infers the schema based on the result set from the imported <xref:System.Data.IDataReader>.</span></span>|  
|<span data-ttu-id="0238d-471"><xref:System.Data.DataTable> 스키마를 갖지만 로드 된 스키마와 호환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-471">The <xref:System.Data.DataTable> has a schema, but it is incompatible with the loaded schema.</span></span>|<span data-ttu-id="0238d-472">`Load` 메서드 호환 되지 않는 스키마로 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-472">The `Load` method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.</span></span>|  
|<span data-ttu-id="0238d-473">스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 된 `DataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-473">The schemas are compatible, but the loaded result set schema contains columns that don't exist in the `DataTable`.</span></span>|<span data-ttu-id="0238d-474">합니다 `Load` 추가 열을 추가 하는 메서드 `DataTable`의 스키마입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-474">The `Load` method adds the extra columns to `DataTable`’s schema.</span></span> <span data-ttu-id="0238d-475">메서드는 해당 하는 경우 예외를 throw에서 열을 <xref:System.Data.DataTable> 로드 된 결과 집합 값이 서로 호환 되지 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-475">The method throws an exception if corresponding columns in the <xref:System.Data.DataTable> and the loaded result set are not value compatible.</span></span> <span data-ttu-id="0238d-476">또한 메서드는 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-476">The method also retrieves constraint information from the result set for all added columns.</span></span> <span data-ttu-id="0238d-477">Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보는 경우에 현재 <xref:System.Data.DataTable> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-477">Except for the case of Primary Key constraint, this constraint information is used only if the current <xref:System.Data.DataTable> does not contain any columns at the start of the load operation.</span></span>|  
|<span data-ttu-id="0238d-478">스키마가 호환 되지만 보다 적은 개수의 열을 포함 하는 로드 된 결과 집합 스키마에는 `DataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-478">The schemas are compatible, but the loaded result set schema contains fewer columns than does the `DataTable`.</span></span>|<span data-ttu-id="0238d-479">누락 된 열에 기본값이 정의 또는 열의 데이터 형식이 null을 허용 하는 경우는 `Load` 메서드를 사용 하면 행을 추가할 수는 누락 된 열에 대 한 default 또는 null 값을 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-479">If a missing column has a default value defined or the column's data type is nullable, the `Load` method allows the rows to be added, substituting the default or null value for the missing column.</span></span> <span data-ttu-id="0238d-480">기본값 또는 null 없습니다 사용할 수 있습니다 하는 경우 해당 `Load` 메서드에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-480">If no default value or null can be used, then the `Load` method throws an exception.</span></span> <span data-ttu-id="0238d-481">특정 기본 값을 제공 하는 경우는 `Load` 메서드 묵시적된 기본 값으로 null 값을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-481">If no specific default value has been supplied, the `Load` method uses the null value as the implied default value.</span></span>|  
  
 <span data-ttu-id="0238d-482">동작을 고려 하기 전에 합니다 `Load` 데이터 작업을 기준으로 메서드는 것이 좋습니다 각 내에서 행을 <xref:System.Data.DataTable> 현재 값과 각 열에 대 한 원래 값을 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-482">Before considering the behavior of the `Load` method in terms of data operations, consider that each row within a <xref:System.Data.DataTable> maintains both the current value and the original value for each column.</span></span> <span data-ttu-id="0238d-483">이러한 값 같을 수도 있지만, 또는 행의 데이터를 채운 이후에 변경 된 경우에 다를 수 여 `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="0238d-483">These values may be equivalent, or may be different if the data in the row has been changed since filling the `DataTable`.</span></span> <span data-ttu-id="0238d-484">참조 [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) 자세한 내용은 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-484">See [Row States and Row Versions](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) for more information.</span></span>  
  
 <span data-ttu-id="0238d-485">이 메서드 호출에서 지정 된 <xref:System.Data.LoadOption> 매개 변수는 들어오는 데이터의 처리에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-485">In this method call, the specified <xref:System.Data.LoadOption> parameter influences the processing of the incoming data.</span></span> <span data-ttu-id="0238d-486">Load 메서드는 기존 행으로 동일한 기본 키가 있는 행을 로드할을 처리 하는 방법</span><span class="sxs-lookup"><span data-stu-id="0238d-486">How should the Load method handle loading rows that have the same primary key as existing rows?</span></span> <span data-ttu-id="0238d-487">현재 값, 원래 값 또는 둘 다 수정 해야?</span><span class="sxs-lookup"><span data-stu-id="0238d-487">Should it modify current values, original values, or both?</span></span> <span data-ttu-id="0238d-488">이러한 문제 및 자세한에 의해 제어 되는 `loadOption` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-488">These issues, and more, are controlled by the `loadOption` parameter.</span></span>  
  
 <span data-ttu-id="0238d-489">기존 행과 들어오는 행에 해당 기본 키 값이 없으면 행의 현재 행 상태 값을 사용 하 여 처리 됩니다, 그리고 그렇지 않으면 새 행으로 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-489">If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.</span></span>  
  
 <span data-ttu-id="0238d-490">이벤트 작업의 경우는 <xref:System.Data.DataTable.RowChanging> 각 행이 변경 되기 전에 이벤트가 발생 하며 <xref:System.Data.DataTable.RowChanged> 이벤트는 각 행이 변경 된 후 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-490">In terms of event operations, the <xref:System.Data.DataTable.RowChanging> event occurs before each row is changed, and the <xref:System.Data.DataTable.RowChanged> event occurs after each row has been changed.</span></span> <span data-ttu-id="0238d-491">각각의 경우에서는 <xref:System.Data.DataRowChangeEventArgs.Action%2A> 속성의는 <xref:System.Data.DataRowChangeEventArgs> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 연결 된 특정 작업에 대 한 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-491">In each case, the <xref:System.Data.DataRowChangeEventArgs.Action%2A> property of the <xref:System.Data.DataRowChangeEventArgs> instance passed to the event handler contains information about the particular action associated with the event.</span></span> <span data-ttu-id="0238d-492">동작 값이 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-492">This action value varies, depending on the state of the row before the load operation.</span></span> <span data-ttu-id="0238d-493">각각의 경우에서 두 이벤트가 발생 하 고 작업을 각각에 대해 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-493">In each case, both events occur, and the action is the same for each.</span></span> <span data-ttu-id="0238d-494">작업은 각 행의 현재 또는 원래 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-494">The action may be applied to either the current or original version of each row, or both, depending on the current row state.</span></span>  
  
 <span data-ttu-id="0238d-495">다음 표에 각를 사용 하 여 호출 하는 경우 Load 메서드에 대 한 동작을 `LoadOption` 값 및 값 로드 중인 행에 대 한 행 상태와 상호 작용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-495">The following table displays behavior for the Load method when called with each of the `LoadOption` values, and also shows how the values interact with the row state for the row being loaded.</span></span> <span data-ttu-id="0238d-496">("(없음)" 라는) 마지막 행을 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-496">The final row (labeled "(Not present)") describes the behavior for incoming rows that don't match any existing row.</span></span> <span data-ttu-id="0238d-497">이 테이블의 각 셀과 함께 행의 필드에 대 한 현재 및 원래 값을 설명 합니다는 <xref:System.Data.DataRowState> 후의 값에 대 한는 `Load` 메서드가 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-497">Each cell in this table describes the current and original value for a field within a row, along with the <xref:System.Data.DataRowState> for the value after the `Load` method has completed.</span></span>  
  
|<span data-ttu-id="0238d-498">기존 DataRowState</span><span class="sxs-lookup"><span data-stu-id="0238d-498">Existing DataRowState</span></span>|<span data-ttu-id="0238d-499">Upsert</span><span class="sxs-lookup"><span data-stu-id="0238d-499">Upsert</span></span>|<span data-ttu-id="0238d-500">OverwriteChanges</span><span class="sxs-lookup"><span data-stu-id="0238d-500">OverwriteChanges</span></span>|<span data-ttu-id="0238d-501">PreserveChanges (기본 동작)</span><span class="sxs-lookup"><span data-stu-id="0238d-501">PreserveChanges (Default behavior)</span></span>|  
|---------------------------|------------|----------------------|------------------------------------------|  
|<span data-ttu-id="0238d-502">추가됨</span><span class="sxs-lookup"><span data-stu-id="0238d-502">Added</span></span>|<span data-ttu-id="0238d-503">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-503">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-504">원래 =-\<없음 ></span><span class="sxs-lookup"><span data-stu-id="0238d-504">Original = -\<Not available></span></span><br /><br /> <span data-ttu-id="0238d-505">상태 = \<추가 ></span><span class="sxs-lookup"><span data-stu-id="0238d-505">State = \<Added></span></span><br /><br /> <span data-ttu-id="0238d-506">RowAction = 변경</span><span class="sxs-lookup"><span data-stu-id="0238d-506">RowAction = Change</span></span>|<span data-ttu-id="0238d-507">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-507">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-508">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-508">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-509">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-509">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-510">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-510">RowAction = ChangeCurrentAndOriginal</span></span>|<span data-ttu-id="0238d-511">현재 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-511">Current = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-512">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-512">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-513">상태 = \<수정 ></span><span class="sxs-lookup"><span data-stu-id="0238d-513">State = \<Modified></span></span><br /><br /> <span data-ttu-id="0238d-514">RowAction = ChangeOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-514">RowAction = ChangeOriginal</span></span>|  
|<span data-ttu-id="0238d-515">수정한 날짜</span><span class="sxs-lookup"><span data-stu-id="0238d-515">Modified</span></span>|<span data-ttu-id="0238d-516">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-516">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-517">원래 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-517">Original = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-518">상태 = \<수정 ></span><span class="sxs-lookup"><span data-stu-id="0238d-518">State = \<Modified></span></span><br /><br /> <span data-ttu-id="0238d-519">RowAction = 변경</span><span class="sxs-lookup"><span data-stu-id="0238d-519">RowAction = Change</span></span>|<span data-ttu-id="0238d-520">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-520">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-521">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-521">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-522">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-522">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-523">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-523">RowAction = ChangeCurrentAndOriginal</span></span>|<span data-ttu-id="0238d-524">현재 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-524">Current = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-525">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-525">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-526">상태 = \<수정 ></span><span class="sxs-lookup"><span data-stu-id="0238d-526">State = \<Modified></span></span><br /><br /> <span data-ttu-id="0238d-527">RowAction =ChangeOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-527">RowAction =ChangeOriginal</span></span>|  
<span data-ttu-id="0238d-528">파일과</span><span class="sxs-lookup"><span data-stu-id="0238d-528">eleted</span></span>|<span data-ttu-id="0238d-529">(부하는 행을 삭제 하는 영향을 하지 않습니다)</span><span class="sxs-lookup"><span data-stu-id="0238d-529">(Load does not affect deleted rows)</span></span><br /><br /> <span data-ttu-id="0238d-530">현재 =--</span><span class="sxs-lookup"><span data-stu-id="0238d-530">Current = ---</span></span><br /><br /> <span data-ttu-id="0238d-531">원래 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-531">Original = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-532">상태 = \<삭제 ></span><span class="sxs-lookup"><span data-stu-id="0238d-532">State = \<Deleted></span></span><br /><br /> <span data-ttu-id="0238d-533">(다음 특징을 가진 새 행이 추가 됨)</span><span class="sxs-lookup"><span data-stu-id="0238d-533">(New row is added with the following characteristics)</span></span><br /><br /> <span data-ttu-id="0238d-534">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-534">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-535">원래 = \<없음 ></span><span class="sxs-lookup"><span data-stu-id="0238d-535">Original = \<Not available></span></span><br /><br /> <span data-ttu-id="0238d-536">상태 = \<추가 ></span><span class="sxs-lookup"><span data-stu-id="0238d-536">State = \<Added></span></span><br /><br /> <span data-ttu-id="0238d-537">RowAction = 추가</span><span class="sxs-lookup"><span data-stu-id="0238d-537">RowAction = Add</span></span>|<span data-ttu-id="0238d-538">삭제 취소 하 고</span><span class="sxs-lookup"><span data-stu-id="0238d-538">Undo delete and</span></span><br /><br /> <span data-ttu-id="0238d-539">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-539">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-540">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-540">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-541">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-541">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-542">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-542">RowAction = ChangeCurrentAndOriginal</span></span>|<span data-ttu-id="0238d-543">현재 = \<없음 ></span><span class="sxs-lookup"><span data-stu-id="0238d-543">Current = \<Not available></span></span><br /><br /> <span data-ttu-id="0238d-544">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-544">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-545">상태 = \<삭제 ></span><span class="sxs-lookup"><span data-stu-id="0238d-545">State = \<Deleted></span></span><br /><br /> <span data-ttu-id="0238d-546">RowAction = ChangeOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-546">RowAction = ChangeOriginal</span></span>|  
|<span data-ttu-id="0238d-547">Unchanged</span><span class="sxs-lookup"><span data-stu-id="0238d-547">Unchanged</span></span>|<span data-ttu-id="0238d-548">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-548">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-549">원래 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-549">Original = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-550">새 값 이면 기존 값과 같은 경우</span><span class="sxs-lookup"><span data-stu-id="0238d-550">If new value is the same as the existing value then</span></span><br /><br /> <span data-ttu-id="0238d-551">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-551">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-552">RowAction = Nothing</span><span class="sxs-lookup"><span data-stu-id="0238d-552">RowAction = Nothing</span></span><br /><br /> <span data-ttu-id="0238d-553">Else</span><span class="sxs-lookup"><span data-stu-id="0238d-553">Else</span></span><br /><br /> <span data-ttu-id="0238d-554">상태 = \<수정 ></span><span class="sxs-lookup"><span data-stu-id="0238d-554">State = \<Modified></span></span><br /><br /> <span data-ttu-id="0238d-555">RowAction = 변경</span><span class="sxs-lookup"><span data-stu-id="0238d-555">RowAction = Change</span></span>|<span data-ttu-id="0238d-556">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-556">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-557">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-557">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-558">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-558">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-559">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-559">RowAction = ChangeCurrentAndOriginal</span></span>|<span data-ttu-id="0238d-560">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-560">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-561">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-561">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-562">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-562">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-563">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-563">RowAction = ChangeCurrentAndOriginal</span></span>|  
<span data-ttu-id="0238d-564">없음)</span><span class="sxs-lookup"><span data-stu-id="0238d-564">Not present)</span></span>|<span data-ttu-id="0238d-565">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-565">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-566">원래 = \<없음 ></span><span class="sxs-lookup"><span data-stu-id="0238d-566">Original = \<Not available></span></span><br /><br /> <span data-ttu-id="0238d-567">상태 = \<추가 ></span><span class="sxs-lookup"><span data-stu-id="0238d-567">State = \<Added></span></span><br /><br /> <span data-ttu-id="0238d-568">RowAction = 추가</span><span class="sxs-lookup"><span data-stu-id="0238d-568">RowAction = Add</span></span>|<span data-ttu-id="0238d-569">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-569">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-570">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-570">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-571">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-571">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-572">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-572">RowAction = ChangeCurrentAndOriginal</span></span>|<span data-ttu-id="0238d-573">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-573">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-574">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-574">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-575">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-575">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-576">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-576">RowAction = ChangeCurrentAndOriginal</span></span>|  
  
 <span data-ttu-id="0238d-577">값을 <xref:System.Data.DataColumn> 와 같은 속성을 사용 하 여 제한할 수 있습니다 <xref:System.Data.DataColumn.ReadOnly%2A> 고 <xref:System.Data.DataColumn.AutoIncrement%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-577">Values in a <xref:System.Data.DataColumn> can be constrained through use of properties such as <xref:System.Data.DataColumn.ReadOnly%2A> and <xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="0238d-578">`Load` 메서드 열의 속성에 의해 정의 된 동작을 사용 하 여 일치 하는 방식으로 해당 열을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-578">The `Load` method handles such columns in a manner that is consistent with the behavior defined by the column's properties.</span></span> <span data-ttu-id="0238d-579">읽기 전용 제약을 <xref:System.Data.DataColumn> 메모리에서 발생 하는 변경에만 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-579">The read only constraint on a <xref:System.Data.DataColumn> is applicable only for changes that occur in memory.</span></span> <span data-ttu-id="0238d-580">`Load` 메서드는 필요한 경우 읽기 전용으로 열 값을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-580">The `Load` method's overwrites the read-only column values, if needed.</span></span>  
  
 <span data-ttu-id="0238d-581">호출할 때 OverwriteChanges 또는 PreserveChanges 옵션을 지정 하는 경우는 `Load` 메서드를 다음 가정에서 들어오는 데이터가 제공 되는 수행 되는 `DataTable`의 주 데이터 원본 및 데이터 테이블의 변경 내용을 추적 및 전파 될 수 있습니다 변경 내용을 다시 데이터 원본입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-581">If you specify the OverwriteChanges or PreserveChanges options when calling the `Load` method, then the assumption is made that the incoming data is coming from the `DataTable`'s primary data source, and the DataTable tracks changes and can propagate the changes back to the data source.</span></span> <span data-ttu-id="0238d-582">Upsert 옵션을 선택 하면 사용자에 의해 변경 된 중간 계층 구성 요소에서 제공 하는 데이터와 같은 보조 데이터 원본 중 하나에서 데이터가 제공 되는 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-582">If you select the Upsert option, it is assumed that the data is coming from one of a secondary data source, such as data provided by a middle-tier component, perhaps altered by a user.</span></span> <span data-ttu-id="0238d-583">가정에서 하나 이상의 데이터 원본에서 데이터를 집계 하기 위한 것은 예제의 경우는 `DataTable`, 다음 아마도 주 데이터 원본에 데이터를 전파 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-583">In this case, the assumption is that the intent is to aggregate data from one or more data sources in the `DataTable`, and then perhaps propagate the data back to the primary data source.</span></span> <span data-ttu-id="0238d-584"><xref:System.Data.LoadOption> 매개 변수는 기본 키 비교에 사용할 행의 특정 버전을 결정 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-584">The <xref:System.Data.LoadOption> parameter is used for determining the specific version of the row that is to be used for primary key comparison.</span></span> <span data-ttu-id="0238d-585">아래 표에서 세부 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-585">The table below provides the details.</span></span>  
  
|<span data-ttu-id="0238d-586">로드 옵션</span><span class="sxs-lookup"><span data-stu-id="0238d-586">Load option</span></span>|<span data-ttu-id="0238d-587">기본 키 비교에 사용 되는 DataRow 버전</span><span class="sxs-lookup"><span data-stu-id="0238d-587">DataRow version used for primary key comparison</span></span>|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|<span data-ttu-id="0238d-588">원래 버전에 있는 경우, 그렇지 않으면 현재 버전</span><span class="sxs-lookup"><span data-stu-id="0238d-588">Original version, if it exists, otherwise Current version</span></span>|  
|`PreserveChanges`|<span data-ttu-id="0238d-589">원래 버전에 있는 경우, 그렇지 않으면 현재 버전</span><span class="sxs-lookup"><span data-stu-id="0238d-589">Original version, if it exists, otherwise Current version</span></span>|  
|`Upsert`|<span data-ttu-id="0238d-590">현재 버전에 있는 경우, 그렇지 않으면 원래 버전</span><span class="sxs-lookup"><span data-stu-id="0238d-590">Current version, if it exists, otherwise Original version</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="0238d-591">다음 예제에서는 다양 한 호출을 사용 하 여 관련 된 문제는 <xref:System.Data.DataTable.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-591">The following example demonstrates several of the issues involved with calling the <xref:System.Data.DataTable.Load%2A> method.</span></span> <span data-ttu-id="0238d-592">예제에서 로드 된 스키마를 유추 등의 스키마 문제에 집중 하는 먼저 <xref:System.Data.IDataReader>, 및 다음 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-592">First, the example focuses on schema issues, including inferring a schema from the loaded <xref:System.Data.IDataReader>, and then handling incompatible schemas, and schemas with missing or additional columns.</span></span> <span data-ttu-id="0238d-593">이 예제에서는 다음 데이터 문제를 포함 하 여 다양 한 로드 옵션에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-593">The example then focuses on data issues, including handling the various loading options.</span></span>  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit" Usage="dataTable.Load (reader, loadOption, errorHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="0238d-594">결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-594">A <see cref="T:System.Data.IDataReader" /> that provides a result set.</span>
          </span>
        </param>
        <param name="loadOption">
          <span data-ttu-id="0238d-595">
            <see cref="T:System.Data.LoadOption" /> 열거형의 값으로서, 이미 <see cref="T:System.Data.DataTable" />에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-595">A value from the <see cref="T:System.Data.LoadOption" /> enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" /> are combined with incoming rows that share the same primary key.</span>
          </span>
        </param>
        <param name="errorHandler">
          <span data-ttu-id="0238d-596">데이터를 로드하는 동안 오류가 발생하면 호출할 <see cref="T:System.Data.FillErrorEventHandler" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-596">A <see cref="T:System.Data.FillErrorEventHandler" /> delegate to call when an error occurs while loading data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-597">오류 처리 대리자를 사용하는 제공된 <see cref="T:System.Data.DataTable" />를 사용해서 <see cref="T:System.Data.IDataReader" />을 데이터 소스의 값으로 채웁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-597">Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" /> using an error-handling delegate.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-598">합니다 `Load` 첫 번째 결과 집합의 로드를 사용 하는 메서드 <xref:System.Data.IDataReader>를 성공적으로 완료 한 후 설정 판독기의 위치를 다음 결과 집합에 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="0238d-598">The `Load` method consumes the first result set from the loaded <xref:System.Data.IDataReader>, and after successful completion, sets the reader's position to the next result set, if any.</span></span> <span data-ttu-id="0238d-599">데이터를 변환 하는 경우는 `Load` 와 같은 변환 규칙을 사용 하는 메서드를 <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-599">When converting data, the `Load` method uses the same conversion rules as the <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="0238d-600">합니다 `Load` 메서드를 고려해 야 합니다 세 가지 특정 문제에서 데이터를 로드 하는 경우는 <xref:System.Data.IDataReader> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-600">The `Load` method must take into account three specific issues when loading the data from an <xref:System.Data.IDataReader> instance: schema, data, and event operations.</span></span> <span data-ttu-id="0238d-601">스키마를 사용 하 여 작업 하는 경우는 `Load` 메서드는 다음 표에 설명 된 대로 조건이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-601">When working with the schema, the `Load` method may encounter conditions as described in the following table.</span></span> <span data-ttu-id="0238d-602">스키마 작업 수행도 포함 하는 데이터가 없는 모든 가져온된 결과 집합에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-602">The schema operations take place for all imported result sets, even those containing no data.</span></span>  
  
|<span data-ttu-id="0238d-603">조건</span><span class="sxs-lookup"><span data-stu-id="0238d-603">Condition</span></span>|<span data-ttu-id="0238d-604">동작</span><span class="sxs-lookup"><span data-stu-id="0238d-604">Behavior</span></span>|  
|---------------|--------------|  
|<span data-ttu-id="0238d-605"><xref:System.Data.DataTable> 에 스키마가 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-605">The <xref:System.Data.DataTable> has no schema.</span></span>|<span data-ttu-id="0238d-606">합니다 `Load` 메서드는 가져온에서 결과 집합에 따라 스키마를 유추 <xref:System.Data.IDataReader>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-606">The `Load` method infers the schema based on the result set from the imported <xref:System.Data.IDataReader>.</span></span>|  
|<span data-ttu-id="0238d-607"><xref:System.Data.DataTable> 스키마를 갖지만 로드 된 스키마와 호환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-607">The <xref:System.Data.DataTable> has a schema, but it is incompatible with the loaded schema.</span></span>|<span data-ttu-id="0238d-608">`Load` 메서드 호환 되지 않는 스키마로 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-608">The `Load` method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.</span></span>|  
|<span data-ttu-id="0238d-609">스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 된 `DataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-609">The schemas are compatible, but the loaded result set schema contains columns that don't exist in the `DataTable`.</span></span>|<span data-ttu-id="0238d-610">합니다 `Load` 추가 열을 추가 하는 메서드 `DataTable`의 스키마입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-610">The `Load` method adds the extra column(s) to `DataTable`’s schema.</span></span> <span data-ttu-id="0238d-611">메서드는 해당 하는 경우 예외를 throw에서 열을 <xref:System.Data.DataTable> 로드 된 결과 집합 값이 서로 호환 되지 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-611">The method throws an exception if corresponding columns in the <xref:System.Data.DataTable> and the loaded result set are not value compatible.</span></span> <span data-ttu-id="0238d-612">또한 메서드는 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-612">The method also retrieves constraint information from the result set for all added columns.</span></span> <span data-ttu-id="0238d-613">Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보는 경우에 현재 <xref:System.Data.DataTable> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-613">Except for the case of Primary Key constraint, this constraint information is used only if the current <xref:System.Data.DataTable> does not contain any columns at the start of the load operation.</span></span>|  
|<span data-ttu-id="0238d-614">스키마가 호환 되지만 보다 적은 개수의 열을 포함 하는 로드 된 결과 집합 스키마에는 `DataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-614">The schemas are compatible, but the loaded result set schema contains fewer columns than does the `DataTable`.</span></span>|<span data-ttu-id="0238d-615">누락 된 열에 기본값이 정의 또는 열의 데이터 형식이 null을 허용 하는 경우는 `Load` 메서드를 사용 하면 행을 추가할 수는 누락 된 열에 대 한 default 또는 null 값을 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-615">If a missing column has a default value defined or the column's data type is nullable, the `Load` method allows the rows to be added, substituting the default or null value for the missing column.</span></span> <span data-ttu-id="0238d-616">기본값 또는 null 없습니다 사용할 수 있습니다 하는 경우 해당 `Load` 메서드에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-616">If no default value or null can be used, then the `Load` method throws an exception.</span></span> <span data-ttu-id="0238d-617">특정 기본 값을 제공 하는 경우는 `Load` 메서드 묵시적된 기본 값으로 null 값을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-617">If no specific default value has been supplied, the `Load` method uses the null value as the implied default value.</span></span>|  
  
 <span data-ttu-id="0238d-618">동작을 고려 하기 전에 합니다 `Load` 데이터 작업을 기준으로 메서드는 것이 좋습니다 각 내에서 행을 <xref:System.Data.DataTable> 현재 값과 각 열에 대 한 원래 값을 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-618">Before considering the behavior of the `Load` method in terms of data operations, consider that each row within a <xref:System.Data.DataTable> maintains both the current value and the original value for each column.</span></span> <span data-ttu-id="0238d-619">이러한 값 같을 수도 있지만, 또는 행의 데이터를 채운 이후에 변경 된 경우에 다를 수 여 `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="0238d-619">These values may be equivalent, or may be different if the data in the row has been changed since filling the `DataTable`.</span></span> <span data-ttu-id="0238d-620">참조 [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) 자세한 내용은 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-620">See [Row States and Row Versions](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) for more information.</span></span>  
  
 <span data-ttu-id="0238d-621">이 메서드 호출에서 지정 된 <xref:System.Data.LoadOption> 매개 변수는 들어오는 데이터의 처리에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-621">In this method call, the specified <xref:System.Data.LoadOption> parameter influences the processing of the incoming data.</span></span> <span data-ttu-id="0238d-622">Load 메서드는 기존 행으로 동일한 기본 키가 있는 행을 로드할을 처리 하는 방법</span><span class="sxs-lookup"><span data-stu-id="0238d-622">How should the Load method handle loading rows that have the same primary key as existing rows?</span></span> <span data-ttu-id="0238d-623">현재 값, 원래 값 또는 둘 다 수정 해야?</span><span class="sxs-lookup"><span data-stu-id="0238d-623">Should it modify current values, original values, or both?</span></span> <span data-ttu-id="0238d-624">이러한 문제 및 자세한에 의해 제어 되는 `loadOption` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-624">These issues, and more, are controlled by the `loadOption` parameter.</span></span>  
  
 <span data-ttu-id="0238d-625">기존 행과 들어오는 행에 해당 기본 키 값이 없으면 행의 현재 행 상태 값을 사용 하 여 처리 됩니다, 그리고 그렇지 않으면 새 행으로 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-625">If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.</span></span>  
  
 <span data-ttu-id="0238d-626">이벤트 작업의 경우는 <xref:System.Data.DataTable.RowChanging> 각 행이 변경 되기 전에 이벤트가 발생 하며 <xref:System.Data.DataTable.RowChanged> 이벤트는 각 행이 변경 된 후 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-626">In terms of event operations, the <xref:System.Data.DataTable.RowChanging> event occurs before each row is changed, and the <xref:System.Data.DataTable.RowChanged> event occurs after each row has been changed.</span></span> <span data-ttu-id="0238d-627">각각의 경우에서는 <xref:System.Data.DataRowChangeEventArgs.Action%2A> 속성의는 <xref:System.Data.DataRowChangeEventArgs> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 연결 된 특정 작업에 대 한 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-627">In each case, the <xref:System.Data.DataRowChangeEventArgs.Action%2A> property of the <xref:System.Data.DataRowChangeEventArgs> instance passed to the event handler contains information about the particular action associated with the event.</span></span> <span data-ttu-id="0238d-628">동작 값이 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-628">This action value varies, depending on the state of the row before the load operation.</span></span> <span data-ttu-id="0238d-629">각각의 경우에서 두 이벤트가 발생 하 고 작업을 각각에 대해 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-629">In each case, both events occur, and the action is the same for each.</span></span> <span data-ttu-id="0238d-630">작업은 각 행의 현재 또는 원래 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-630">The action may be applied to either the current or original version of each row, or both, depending on the current row state.</span></span>  
  
 <span data-ttu-id="0238d-631">다음 표에 각를 사용 하 여 호출 하는 경우 Load 메서드에 대 한 동작을 `LoadOption` 값 및 값 로드 중인 행에 대 한 행 상태와 상호 작용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-631">The following table displays behavior for the Load method when called with each of the `LoadOption` values, and also shows how the values interact with the row state for the row being loaded.</span></span> <span data-ttu-id="0238d-632">("(없음)" 라는) 마지막 행을 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-632">The final row (labeled "(Not present)") describes the behavior for incoming rows that don't match any existing row.</span></span> <span data-ttu-id="0238d-633">이 테이블의 각 셀과 함께 행의 필드에 대 한 현재 및 원래 값을 설명 합니다는 <xref:System.Data.DataRowState> 후의 값에 대 한는 `Load` 메서드가 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-633">Each cell in this table describes the current and original value for a field within a row, along with the <xref:System.Data.DataRowState> for the value after the `Load` method has completed.</span></span>  
  
|<span data-ttu-id="0238d-634">기존 DataRowState</span><span class="sxs-lookup"><span data-stu-id="0238d-634">Existing DataRowState</span></span>|<span data-ttu-id="0238d-635">Upsert</span><span class="sxs-lookup"><span data-stu-id="0238d-635">Upsert</span></span>|<span data-ttu-id="0238d-636">OverwriteChanges</span><span class="sxs-lookup"><span data-stu-id="0238d-636">OverwriteChanges</span></span>|<span data-ttu-id="0238d-637">PreserveChanges (기본 동작)</span><span class="sxs-lookup"><span data-stu-id="0238d-637">PreserveChanges (Default behavior)</span></span>|  
|---------------------------|------------|----------------------|------------------------------------------|  
|<span data-ttu-id="0238d-638">추가됨</span><span class="sxs-lookup"><span data-stu-id="0238d-638">Added</span></span>|<span data-ttu-id="0238d-639">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-639">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-640">원래 =-\<없음 ></span><span class="sxs-lookup"><span data-stu-id="0238d-640">Original = -\<Not available></span></span><br /><br /> <span data-ttu-id="0238d-641">상태 = \<추가 ></span><span class="sxs-lookup"><span data-stu-id="0238d-641">State = \<Added></span></span><br /><br /> <span data-ttu-id="0238d-642">RowAction = 변경</span><span class="sxs-lookup"><span data-stu-id="0238d-642">RowAction = Change</span></span>|<span data-ttu-id="0238d-643">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-643">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-644">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-644">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-645">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-645">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-646">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-646">RowAction = ChangeCurrentAndOriginal</span></span>|<span data-ttu-id="0238d-647">현재 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-647">Current = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-648">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-648">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-649">상태 = \<수정 ></span><span class="sxs-lookup"><span data-stu-id="0238d-649">State = \<Modified></span></span><br /><br /> <span data-ttu-id="0238d-650">RowAction = ChangeOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-650">RowAction = ChangeOriginal</span></span>|  
|<span data-ttu-id="0238d-651">수정한 날짜</span><span class="sxs-lookup"><span data-stu-id="0238d-651">Modified</span></span>|<span data-ttu-id="0238d-652">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-652">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-653">원래 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-653">Original = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-654">상태 = \<수정 ></span><span class="sxs-lookup"><span data-stu-id="0238d-654">State = \<Modified></span></span><br /><br /> <span data-ttu-id="0238d-655">RowAction = 변경</span><span class="sxs-lookup"><span data-stu-id="0238d-655">RowAction = Change</span></span>|<span data-ttu-id="0238d-656">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-656">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-657">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-657">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-658">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-658">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-659">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-659">RowAction = ChangeCurrentAndOriginal</span></span>|<span data-ttu-id="0238d-660">현재 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-660">Current = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-661">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-661">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-662">상태 = \<수정 ></span><span class="sxs-lookup"><span data-stu-id="0238d-662">State = \<Modified></span></span><br /><br /> <span data-ttu-id="0238d-663">RowAction =ChangeOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-663">RowAction =ChangeOriginal</span></span>|  
<span data-ttu-id="0238d-664">파일과</span><span class="sxs-lookup"><span data-stu-id="0238d-664">eleted</span></span>|<span data-ttu-id="0238d-665">(부하는 행을 삭제 하는 영향을 하지 않습니다)</span><span class="sxs-lookup"><span data-stu-id="0238d-665">(Load does not affect deleted rows)</span></span><br /><br /> <span data-ttu-id="0238d-666">현재 =--</span><span class="sxs-lookup"><span data-stu-id="0238d-666">Current = ---</span></span><br /><br /> <span data-ttu-id="0238d-667">원래 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-667">Original = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-668">상태 = \<삭제 ></span><span class="sxs-lookup"><span data-stu-id="0238d-668">State = \<Deleted></span></span><br /><br /> <span data-ttu-id="0238d-669">(다음 특징을 가진 새 행이 추가 됨)</span><span class="sxs-lookup"><span data-stu-id="0238d-669">(New row is added with the following characteristics)</span></span><br /><br /> <span data-ttu-id="0238d-670">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-670">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-671">원래 = \<없음 ></span><span class="sxs-lookup"><span data-stu-id="0238d-671">Original = \<Not available></span></span><br /><br /> <span data-ttu-id="0238d-672">상태 = \<추가 ></span><span class="sxs-lookup"><span data-stu-id="0238d-672">State = \<Added></span></span><br /><br /> <span data-ttu-id="0238d-673">RowAction = 추가</span><span class="sxs-lookup"><span data-stu-id="0238d-673">RowAction = Add</span></span>|<span data-ttu-id="0238d-674">삭제 취소 하 고</span><span class="sxs-lookup"><span data-stu-id="0238d-674">Undo delete and</span></span><br /><br /> <span data-ttu-id="0238d-675">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-675">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-676">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-676">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-677">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-677">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-678">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-678">RowAction = ChangeCurrentAndOriginal</span></span>|<span data-ttu-id="0238d-679">현재 = \<없음 ></span><span class="sxs-lookup"><span data-stu-id="0238d-679">Current = \<Not available></span></span><br /><br /> <span data-ttu-id="0238d-680">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-680">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-681">상태 = \<삭제 ></span><span class="sxs-lookup"><span data-stu-id="0238d-681">State = \<Deleted></span></span><br /><br /> <span data-ttu-id="0238d-682">RowAction = ChangeOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-682">RowAction = ChangeOriginal</span></span>|  
|<span data-ttu-id="0238d-683">Unchanged</span><span class="sxs-lookup"><span data-stu-id="0238d-683">Unchanged</span></span>|<span data-ttu-id="0238d-684">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-684">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-685">원래 = \<기존 ></span><span class="sxs-lookup"><span data-stu-id="0238d-685">Original = \<Existing></span></span><br /><br /> <span data-ttu-id="0238d-686">새 값 이면 기존 값과 같은 경우</span><span class="sxs-lookup"><span data-stu-id="0238d-686">If new value is the same as the existing value then</span></span><br /><br /> <span data-ttu-id="0238d-687">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-687">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-688">RowAction = Nothing</span><span class="sxs-lookup"><span data-stu-id="0238d-688">RowAction = Nothing</span></span><br /><br /> <span data-ttu-id="0238d-689">Else</span><span class="sxs-lookup"><span data-stu-id="0238d-689">Else</span></span><br /><br /> <span data-ttu-id="0238d-690">상태 = \<수정 ></span><span class="sxs-lookup"><span data-stu-id="0238d-690">State = \<Modified></span></span><br /><br /> <span data-ttu-id="0238d-691">RowAction = 변경</span><span class="sxs-lookup"><span data-stu-id="0238d-691">RowAction = Change</span></span>|<span data-ttu-id="0238d-692">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-692">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-693">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-693">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-694">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-694">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-695">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-695">RowAction = ChangeCurrentAndOriginal</span></span>|<span data-ttu-id="0238d-696">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-696">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-697">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-697">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-698">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-698">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-699">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-699">RowAction = ChangeCurrentAndOriginal</span></span>|  
<span data-ttu-id="0238d-700">없음)</span><span class="sxs-lookup"><span data-stu-id="0238d-700">Not present)</span></span>|<span data-ttu-id="0238d-701">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-701">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-702">원래 = \<없음 ></span><span class="sxs-lookup"><span data-stu-id="0238d-702">Original = \<Not available></span></span><br /><br /> <span data-ttu-id="0238d-703">상태 = \<추가 ></span><span class="sxs-lookup"><span data-stu-id="0238d-703">State = \<Added></span></span><br /><br /> <span data-ttu-id="0238d-704">RowAction = 추가</span><span class="sxs-lookup"><span data-stu-id="0238d-704">RowAction = Add</span></span>|<span data-ttu-id="0238d-705">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-705">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-706">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-706">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-707">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-707">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-708">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-708">RowAction = ChangeCurrentAndOriginal</span></span>|<span data-ttu-id="0238d-709">현재 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-709">Current = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-710">원래 = \<들어오는 ></span><span class="sxs-lookup"><span data-stu-id="0238d-710">Original = \<Incoming></span></span><br /><br /> <span data-ttu-id="0238d-711">상태 = \<변경 되지 않은 ></span><span class="sxs-lookup"><span data-stu-id="0238d-711">State = \<Unchanged></span></span><br /><br /> <span data-ttu-id="0238d-712">RowAction = ChangeCurrentAndOriginal</span><span class="sxs-lookup"><span data-stu-id="0238d-712">RowAction = ChangeCurrentAndOriginal</span></span>|  
  
 <span data-ttu-id="0238d-713">값을 <xref:System.Data.DataColumn> 와 같은 속성을 사용 하 여 제한할 수 있습니다 <xref:System.Data.DataColumn.ReadOnly%2A> 고 <xref:System.Data.DataColumn.AutoIncrement%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-713">Values in a <xref:System.Data.DataColumn> can be constrained through use of properties such as <xref:System.Data.DataColumn.ReadOnly%2A> and <xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="0238d-714">`Load` 메서드 열의 속성에 의해 정의 된 동작을 사용 하 여 일치 하는 방식으로 해당 열을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-714">The `Load` method handles such columns in a manner that is consistent with the behavior defined by the column's properties.</span></span> <span data-ttu-id="0238d-715">읽기 전용 제약을 <xref:System.Data.DataColumn> 메모리에서 발생 하는 변경에만 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-715">The read only constraint on a <xref:System.Data.DataColumn> is applicable only for changes that occur in memory.</span></span> <span data-ttu-id="0238d-716">`Load` 메서드는 필요한 경우 읽기 전용으로 열 값을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-716">The `Load` method's overwrites the read-only column values, if needed.</span></span>  
  
 <span data-ttu-id="0238d-717">호출할 때 OverwriteChanges 또는 PreserveChanges 옵션을 지정 하는 경우는 `Load` 메서드를 다음 가정에서 들어오는 데이터가 제공 되는 수행 되는 `DataTable`의 주 데이터 원본 및 데이터 테이블의 변경 내용을 추적 및 전파 될 수 있습니다 변경 내용을 다시 데이터 원본입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-717">If you specify the OverwriteChanges or PreserveChanges options when calling the `Load` method, then the assumption is made that the incoming data is coming from the `DataTable`'s primary data source, and the DataTable tracks changes and can propagate the changes back to the data source.</span></span> <span data-ttu-id="0238d-718">Upsert 옵션을 선택 하면 사용자에 의해 변경 된 중간 계층 구성 요소에서 제공 하는 데이터와 같은 보조 데이터 원본 중 하나에서 데이터가 제공 되는 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-718">If you select the Upsert option, it is assumed that the data is coming from one of a secondary data source, such as data provided by a middle-tier component, perhaps altered by a user.</span></span> <span data-ttu-id="0238d-719">가정에서 하나 이상의 데이터 원본에서 데이터를 집계 하기 위한 것은 예제의 경우는 `DataTable`, 다음 아마도 주 데이터 원본에 데이터를 전파 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-719">In this case, the assumption is that the intent is to aggregate data from one or more data sources in the `DataTable`, and then perhaps propagate the data back to the primary data source.</span></span> <span data-ttu-id="0238d-720"><xref:System.Data.LoadOption> 매개 변수는 기본 키 비교에 사용할 행의 특정 버전을 결정 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-720">The <xref:System.Data.LoadOption> parameter is used for determining the specific version of the row that is to be used for primary key comparison.</span></span> <span data-ttu-id="0238d-721">아래 표에서 세부 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-721">The table below provides the details.</span></span>  
  
|<span data-ttu-id="0238d-722">로드 옵션</span><span class="sxs-lookup"><span data-stu-id="0238d-722">Load option</span></span>|<span data-ttu-id="0238d-723">기본 키 비교에 사용 되는 DataRow 버전</span><span class="sxs-lookup"><span data-stu-id="0238d-723">DataRow version used for primary key comparison</span></span>|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|<span data-ttu-id="0238d-724">원래 버전에 있는 경우, 그렇지 않으면 현재 버전</span><span class="sxs-lookup"><span data-stu-id="0238d-724">Original version, if it exists, otherwise Current version</span></span>|  
|`PreserveChanges`|<span data-ttu-id="0238d-725">원래 버전에 있는 경우, 그렇지 않으면 현재 버전</span><span class="sxs-lookup"><span data-stu-id="0238d-725">Original version, if it exists, otherwise Current version</span></span>|  
|`Upsert`|<span data-ttu-id="0238d-726">현재 버전에 있는 경우, 그렇지 않으면 원래 버전</span><span class="sxs-lookup"><span data-stu-id="0238d-726">Current version, if it exists, otherwise Original version</span></span>|  
  
 <span data-ttu-id="0238d-727">합니다 `errorHandler` 매개 변수는 한 <xref:System.Data.FillErrorEventHandler> 데이터를 로드 하는 동안 오류가 발생 하면 호출 되는 프로시저를 참조 하는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-727">The `errorHandler` parameter is a <xref:System.Data.FillErrorEventHandler> delegate that refers to a procedure that is called when an error occurs while loading data.</span></span> <span data-ttu-id="0238d-728">합니다 <xref:System.Data.FillErrorEventArgs> 발생 한 오류, 데이터의 현재 행에 대 한 정보를 검색할 수 있는 속성을 제공 하는 프로시저에 전달 된 매개 변수 및 <xref:System.Data.DataTable> 채워지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-728">The <xref:System.Data.FillErrorEventArgs> parameter passed to the procedure provides properties that allow you to retrieve information about the error that occurred, the current row of data, and the <xref:System.Data.DataTable> being filled.</span></span> <span data-ttu-id="0238d-729">이 대리자 메커니즘을 사용 하 여, 대신 간단한 try/catch 블록을 오류를 확인할 수 있습니다 상황을 처리 한 원하는 경우 처리를 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-729">Using this delegate mechanism, rather than a simpler try/catch block, allows you to determine the error, handle the situation, and continue processing if you like.</span></span> <span data-ttu-id="0238d-730">합니다 <xref:System.Data.FillErrorEventArgs> 매개 변수를 제공을 <xref:System.Data.FillErrorEventArgs.Continue%2A> 속성:이 속성을 설정 `true` 오류를 처리 하 고 처리를 계속 하려면.</span><span class="sxs-lookup"><span data-stu-id="0238d-730">The <xref:System.Data.FillErrorEventArgs> parameter supplies a <xref:System.Data.FillErrorEventArgs.Continue%2A> property: set this property to `true` to indicate that you have handled the error and wish to continue processing.</span></span> <span data-ttu-id="0238d-731">속성을 설정 `false` 처리를 중단 하려는 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-731">Set the property to `false` to indicate that you wish to halt processing.</span></span> <span data-ttu-id="0238d-732">주의 해당 속성을 설정 `false` 예외를 throw 하려면 문제를 트리거한 코드를 사용 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-732">Be aware that setting the property to `false` causes the code that triggered the problem to throw an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-733">특정 행을 찾아 업데이트합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-733">Finds and updates a specific row.</span>
          </span>
          <span data-ttu-id="0238d-734">일치하는 행을 찾지 못하면 지정된 값을 사용하여 새 행을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-734">If no matching row is found, a new row is created using the given values.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * bool -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, fAcceptChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">
          <span data-ttu-id="0238d-735">새 행을 만드는 데 사용되는 값 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-735">An array of values used to create the new row.</span>
          </span>
        </param>
        <param name="fAcceptChanges">
          <span data-ttu-id="0238d-736">변경 사항을 적용하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-736">
              <see langword="true" /> to accept changes; otherwise <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-737">특정 행을 찾아 업데이트합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-737">Finds and updates a specific row.</span>
          </span>
          <span data-ttu-id="0238d-738">일치하는 행을 찾지 못하면 지정된 값을 사용하여 새 행을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-738">If no matching row is found, a new row is created using the given values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-739">새 <see cref="T:System.Data.DataRow" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-739">The new <see cref="T:System.Data.DataRow" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-740"><xref:System.Data.DataTable.LoadDataRow%2A> 메서드 값의 배열을 사용 하 고 기본 키 열에서 일치 하는 값을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-740">The <xref:System.Data.DataTable.LoadDataRow%2A> method takes an array of values and finds the matching value(s) in the primary key column(s).</span></span>  
  
 <span data-ttu-id="0238d-741">열에 기본값이 있으면 해당 열에 대 한 기본 값을 설정 하려면 배열에 null 값을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-741">If a column has a default value, pass a null value in the array to set the default value for that column.</span></span> <span data-ttu-id="0238d-742">마찬가지로, 열에 있으면 해당 <xref:System.Data.DataColumn.AutoIncrement%2A> 설정을 true로 행에 대해 자동으로 생성 된 값을 설정 하는 배열에 null 값을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-742">Similarly, if a column has its <xref:System.Data.DataColumn.AutoIncrement%2A> property set to true, pass a null value in the array to set the automatically generated value for the row.</span></span>  
  
 <span data-ttu-id="0238d-743">경우는 `fAcceptChanges` 매개 변수는 `true` 지정 하지 않으면 새 데이터가 추가 됩니다 또는 차례로 <xref:System.Data.DataTable.AcceptChanges%2A> 에서 모든 변경 내용을 적용 하기 위해 호출 됩니다는 <xref:System.Data.DataTable>인수가; `false`, 새로 추가 된 행이 삽입 및 변경 내용으로 표시 된 기존 행 수정으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-743">If the `fAcceptChanges` parameter is `true` or not specified, the new data is added and then <xref:System.Data.DataTable.AcceptChanges%2A> is called to accept all changes in the <xref:System.Data.DataTable>; if the argument is `false`, newly added rows are marked as insertions, and changes to existing rows are marked as modifications.</span></span>  
  
 <span data-ttu-id="0238d-744">예외도 수행 하는 동안 발생할 수 있습니다는 <xref:System.Data.DataTable.ColumnChanging> 또는 <xref:System.Data.DataTable.RowChanging> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-744">Exceptions can also occur during either a <xref:System.Data.DataTable.ColumnChanging> or <xref:System.Data.DataTable.RowChanging> event.</span></span> <span data-ttu-id="0238d-745">예외가 발생 하는 경우 테이블에 행 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-745">If an exception occurs, the row is not added to the table.</span></span>  
  
 <span data-ttu-id="0238d-746">사용 하 여 <xref:System.Data.DataTable.LoadDataRow%2A> 와 함께에서 <xref:System.Data.DataTable.BeginLoadData%2A> 고 <xref:System.Data.DataTable.EndLoadData%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-746">Use <xref:System.Data.DataTable.LoadDataRow%2A> in conjunction with <xref:System.Data.DataTable.BeginLoadData%2A> and <xref:System.Data.DataTable.EndLoadData%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-747">다음 예제에서는 <xref:System.Data.DataTable.LoadDataRow%2A> 행을 찾으려고 시도 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-747">The following example uses the <xref:System.Data.DataTable.LoadDataRow%2A> method to attempt to find a row.</span></span> <span data-ttu-id="0238d-748">이러한 행에 없으면 새 행을 만들고 값이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-748">If no such row is found, the values are used to create a new row.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0238d-749">배열이 테이블의 열 수보다 큰 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-749">The array is larger than the number of columns in the table.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="0238d-750">값이 해당 열 형식과 일치하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-750">A value doesn't match its respective column type.</span>
          </span>
        </exception>
        <exception cref="T:System.Data.ConstraintException">
          <span data-ttu-id="0238d-751">행을 추가하여 제약 조건을 무효화한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-751">Adding the row invalidates a constraint.</span>
          </span>
        </exception>
        <exception cref="T:System.Data.NoNullAllowedException">
          <span data-ttu-id="0238d-752">
            <see cref="P:System.Data.DataColumn.AllowDBNull" />이 false인 열에 null을 설정하려는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-752">Attempting to put a null in a column where <see cref="P:System.Data.DataColumn.AllowDBNull" /> is false.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * System.Data.LoadOption -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">
          <span data-ttu-id="0238d-753">새 행을 만드는 데 사용되는 값 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-753">An array of values used to create the new row.</span>
          </span>
        </param>
        <param name="loadOption">
          <span data-ttu-id="0238d-754">배열 값이 기존 행의 해당 값에 적용되는 방식을 결정하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-754">Used to determine how the array values are applied to the corresponding values in an existing row.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-755">특정 행을 찾아 업데이트합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-755">Finds and updates a specific row.</span>
          </span>
          <span data-ttu-id="0238d-756">일치하는 행을 찾지 못하면 지정된 값을 사용하여 새 행을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-756">If no matching row is found, a new row is created using the given values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-757">새 <see cref="T:System.Data.DataRow" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-757">The new <see cref="T:System.Data.DataRow" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-758"><xref:System.Data.DataTable.LoadDataRow%2A> 메서드 값의 배열을 사용 하 고 기본 키 열에서 일치 하는 값을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-758">The <xref:System.Data.DataTable.LoadDataRow%2A> method takes an array of values and finds the matching value(s) in the primary key column(s).</span></span>  
  
 <span data-ttu-id="0238d-759">열에 기본값이 있으면 해당 열에 대 한 기본 값을 설정 하려면 배열에 null 값을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-759">If a column has a default value, pass a null value in the array to set the default value for that column.</span></span> <span data-ttu-id="0238d-760">마찬가지로, 열에 있으면 해당 <xref:System.Data.DataColumn.AutoIncrement%2A> 설정을 true로 행에 대해 자동으로 생성 된 값을 설정 하는 배열에 null 값을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-760">Similarly, if a column has its <xref:System.Data.DataColumn.AutoIncrement%2A> property set to true, pass a null value in the array to set the automatically generated value for the row.</span></span>  
  
 <span data-ttu-id="0238d-761">값을 `loadOption` 매개 변수는 배열에 값이 기존 행에 적용 되는 방식을 확인 하려면 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-761">The value of the `loadOption` parameter is used to determine how the values in the array are applied to an existing row.</span></span> <span data-ttu-id="0238d-762">예를 들어 경우 `loadOption` 로 설정 된 `OverwriteChanges`의 `Original` 및 `Current` 각 열의 값은 들어오는 행의 값으로 바뀝니다 및 `RowState` 속성이 `Unchanged`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-762">For example, if `loadOption` is set to `OverwriteChanges`, the `Original` and `Current` values of each column are replaced with the values in the incoming row and the `RowState` property is set to `Unchanged`.</span></span>  
  
 <span data-ttu-id="0238d-763">예외도 수행 하는 동안 발생할 수 있습니다는 <xref:System.Data.DataTable.ColumnChanging> 또는 <xref:System.Data.DataTable.RowChanging> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-763">Exceptions can also occur during either a <xref:System.Data.DataTable.ColumnChanging> or <xref:System.Data.DataTable.RowChanging> event.</span></span> <span data-ttu-id="0238d-764">예외가 발생 하는 경우 테이블에 행 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-764">If an exception occurs, the row is not added to the table.</span></span>  
  
 <span data-ttu-id="0238d-765">사용 하 여 <xref:System.Data.DataTable.LoadDataRow%2A> 와 함께에서 <xref:System.Data.DataTable.BeginLoadData%2A> 고 <xref:System.Data.DataTable.EndLoadData%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-765">Use <xref:System.Data.DataTable.LoadDataRow%2A> in conjunction with <xref:System.Data.DataTable.BeginLoadData%2A> and <xref:System.Data.DataTable.EndLoadData%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-766">테이블 내의 문자열을 비교하는 데 사용되는 로캘 정보를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-766">Gets or sets the locale information used to compare strings within the table.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-767">사용자의 컴퓨터 로캘에 대한 데이터가 들어 있는 <see cref="T:System.Globalization.CultureInfo" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-767">A <see cref="T:System.Globalization.CultureInfo" /> that contains data about the user's machine locale.</span>
          </span>
          <span data-ttu-id="0238d-768">기본값은 <see cref="T:System.Data.DataSet" />이 속해 있으며 <see cref="T:System.Globalization.CultureInfo" /> 속성에 의해 반환되는 <see cref="P:System.Data.DataSet.Locale" /> 개체의 <see cref="T:System.Data.DataTable" />이거나, 테이블이 <see cref="T:System.Data.DataSet" />에 속하지 않은 경우 현재 시스템의 <see cref="T:System.Globalization.CultureInfo" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-768">The default is the <see cref="T:System.Data.DataSet" /> object's <see cref="T:System.Globalization.CultureInfo" /> (returned by the <see cref="P:System.Data.DataSet.Locale" /> property) to which the <see cref="T:System.Data.DataTable" /> belongs; if the table doesn't belong to a <see cref="T:System.Data.DataSet" />, the default is the current system <see cref="T:System.Globalization.CultureInfo" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-769"><xref:System.Globalization.CultureInfo> 는 특정 문화권 또는 커뮤니티의 소프트웨어 기본 설정을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-769">A <xref:System.Globalization.CultureInfo> represents the software preferences of a particular culture or community.</span></span>  
  
 <span data-ttu-id="0238d-770">문자열 비교에 사용 되는 경우는 <xref:System.Globalization.CultureInfo> 비교, 정렬 및 필터링에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-770">When used for string comparisons, the <xref:System.Globalization.CultureInfo> affects sorting, comparisons, and filtering.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-771">식이 포함 된 열에는 <xref:System.StringComparison.InvariantCulture> 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-771">In columns that contain expressions, the <xref:System.StringComparison.InvariantCulture> is used.</span></span> <span data-ttu-id="0238d-772"><xref:System.StringComparison.CurrentCulture> 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-772">The <xref:System.StringComparison.CurrentCulture> is ignored.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-773">다음 예제에서는 합니다 <xref:System.Globalization.CultureInfo> 를 통해를 <xref:System.Data.DataTable.Locale%2A> ISO 언어 이름을 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-773">The following example sets the <xref:System.Globalization.CultureInfo> through the <xref:System.Data.DataTable.Locale%2A> and prints the ISO language name.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-774">지정된 <see cref="T:System.Data.DataTable" />을 현재 <see cref="T:System.Data.DataTable" />과 병합합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-774">Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-775">합니다 `Merge` 메서드는 두 개의 병합 데 <xref:System.Data.DataTable> 아주 비슷한 스키마가 포함 된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-775">The `Merge` method is used to merge two <xref:System.Data.DataTable> objects that have largely similar schemas.</span></span> <span data-ttu-id="0238d-776">병합을 일반적으로 사용 됩니다 클라이언트 응용 프로그램에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-776">A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-777">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-777">This allows the client application to have a refreshed <xref:System.Data.DataTable> with the latest data from the data source.</span></span>  
  
 <span data-ttu-id="0238d-778">병합 작업은 원래 테이블만 및 병합할 테이블 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-778">The merge operation takes into account only the original table, and the table to be merged.</span></span> <span data-ttu-id="0238d-779">자식 테이블을 받는 되지 않거나 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-779">Child tables are not affected or included.</span></span> <span data-ttu-id="0238d-780">테이블 관계의 일부로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블을 개별적으로 병합 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-780">If a table has one or more child tables, defined as part of a relationship, each child table must be merged individually.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-781">다음 콘솔 응용 프로그램의 동작을 보여 줍니다.는 `missingSchemaAction` 의 매개 변수는 <xref:System.Data.DataTable.Merge%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-781">The following console application demonstrates the behavior of the `missingSchemaAction` parameter of the <xref:System.Data.DataTable.Merge%2A> method.</span></span> <span data-ttu-id="0238d-782">이 예제에서는 두 번째 버전에 대 한 스키마를 수정 하는 동일한 테이블의 두 버전을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-782">This example creates two versions of the same table, modifying the schema for the second version.</span></span> <span data-ttu-id="0238d-783">코드를 첫 번째 두 번째 테이블을 병합 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-783">The code then attempts to merge the second table into the first.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-784">이 예에서는 병합의 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-784">This example shows how to use one of the overloaded versions of Merge.</span></span> <span data-ttu-id="0238d-785">사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="0238d-785">For other examples that might be available, see the individual overload topics.</span></span>  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataTable.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <span data-ttu-id="0238d-786">현재 <see cref="T:System.Data.DataTable" />과 병합할 <see cref="T:System.Data.DataTable" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-786">The <see cref="T:System.Data.DataTable" /> to be merged with the current <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-787">지정된 <see cref="T:System.Data.DataTable" />을 현재 <see cref="T:System.Data.DataTable" />과 병합합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-787">Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-788">Merge 메서드는 두 개의 병합 데 <xref:System.Data.DataTable> 아주 비슷한 스키마가 포함 된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-788">The Merge method is used to merge two <xref:System.Data.DataTable> objects that have largely similar schemas.</span></span> <span data-ttu-id="0238d-789">병합을 일반적으로 사용 됩니다 클라이언트 응용 프로그램에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-789">A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-790">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-790">This allows the client application to have a refreshed <xref:System.Data.DataTable> with the latest data from the data source.</span></span>  
  
 <span data-ttu-id="0238d-791">병합 작업은 원래 테이블만 및 병합할 테이블 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-791">The merge operation takes into account only the original table, and the table to be merged.</span></span> <span data-ttu-id="0238d-792">자식 테이블을 받는 되지 않거나 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-792">Child tables are not affected or included.</span></span> <span data-ttu-id="0238d-793">테이블 관계의 일부로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블을 개별적으로 병합 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-793">If a table has one or more child tables, defined as part of a relationship, each child table must be merged individually.</span></span>  
  
 <span data-ttu-id="0238d-794">합니다 `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-794">The `Merge` method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="0238d-795">병합을 수행할 때 기존 데이터를 병합 하기 전에 변경 내용은 병합 작업 하는 동안 기본적으로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-795">When performing a merge, changes made to the existing data before the merge are preserved by default during the merge operation.</span></span> <span data-ttu-id="0238d-796">개발자는이 메서드에 대 한 다른 두 개의 오버 로드 중 하나를 호출 하 고 false 값을 지정 하 여이 동작을 수정할 수는 `preserveChanges` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-796">Developers can modify this behavior by calling one of the other two overloads for this method, and specifying a false value for the `preserveChanges` parameter.</span></span>  
  
 <span data-ttu-id="0238d-797">클라이언트 응용 프로그램에서는 단일 하는 단추가 사용자가 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 데 평소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-797">In a client application, it is usual to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle tier component.</span></span> <span data-ttu-id="0238d-798">이 시나리오에서는 <xref:System.Data.DataTable.GetChanges%2A> 메서드가 먼저 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-798">In this scenario, the <xref:System.Data.DataTable.GetChanges%2A> method is first invoked.</span></span> <span data-ttu-id="0238d-799">이 메서드는 두 번째 <xref:System.Data.DataTable> 유효성 검사 및 병합에 대해 최적화 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-799">That method returns a second <xref:System.Data.DataTable> optimized for validating and merging.</span></span> <span data-ttu-id="0238d-800">이 두 번째 <xref:System.Data.DataTable> 개체만 포함 된 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-800">This second <xref:System.Data.DataTable> object contains only the <xref:System.Data.DataRow> objects that were changed, resulting in a subset of the original <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-801">이 하위 집합은 일반적으로 크기가 작기 때문에 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-801">This subset is generally smaller and thus more efficiently passed back to a middle tier component.</span></span> <span data-ttu-id="0238d-802">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-802">The middle tier component then updates the original data source with the changes through stored procedures.</span></span> <span data-ttu-id="0238d-803">중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-803">The middle tier can then send back either a new <xref:System.Data.DataTable> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</span></span> <span data-ttu-id="0238d-804">(예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataTable> 사용 하 여는 <xref:System.Data.DataTable.Merge%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-804">(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <xref:System.Data.DataTable> can be merged back into the client application's original <xref:System.Data.DataTable> with the <xref:System.Data.DataTable.Merge%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-805">새 소스를 병합할 때 <xref:System.Data.DataTable> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted`, 동일한 기본 키 값을 사용 하 여 대상 행과 일치 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-805">When merging a new source <xref:System.Data.DataTable> into the target, any source rows with a <xref:System.Data.DataRowState> value of `Unchanged`, `Modified`, or `Deleted`, is matched to target rows with the same primary key values.</span></span> <span data-ttu-id="0238d-806">소스 행을 <xref:System.Data.DataRowState> 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-806">Source rows with a <xref:System.Data.DataRowState> value of `Added` are matched to new target rows with the same primary key values as the new source rows.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-807">다음 콘솔 응용 프로그램을 만드는 간단한 <xref:System.Data.DataTable> 데이터 테이블에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-807">The following console application creates a simple <xref:System.Data.DataTable> and adds data to the table.</span></span> <span data-ttu-id="0238d-808">다음 예제에서는 행 복사본에 추가 테이블의 복사본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-808">The example then creates a copy of the table, adding rows to the copy.</span></span> <span data-ttu-id="0238d-809">마지막으로 호출 하 여는 <xref:System.Data.DataTable.Merge%2A> 첫 번째 테이블의 데이터를 사용 하 여 두 번째 테이블의 데이터를 병합 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-809">Finally, the example calls the <xref:System.Data.DataTable.Merge%2A> method to merge the data in the second table with the data in the first table.</span></span>  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool -&gt; unit" Usage="dataTable.Merge (table, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">
          <span data-ttu-id="0238d-810">현재 <see langword="DataTable" />과 병합할 <see langword="DataTable" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-810">The <see langword="DataTable" /> to be merged with the current <see langword="DataTable" />.</span>
          </span>
        </param>
        <param name="preserveChanges">
          <span data-ttu-id="0238d-811">현재 <see langword="true" />의 변경 내용을 유지하려면 <see langword="DataTable" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-811">
              <see langword="true" />, to preserve changes in the current <see langword="DataTable" />; otherwise <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-812">지정된 <see cref="T:System.Data.DataTable" />을 현재 <see langword="DataTable" />과 병합하여 현재 <see langword="DataTable" />에서 변경 내용을 유지할지 여부를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-812">Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see langword="DataTable" />, indicating whether to preserve changes in the current <see langword="DataTable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-813">Merge 메서드는 두 개의 병합 데 <xref:System.Data.DataTable> 아주 비슷한 스키마가 포함 된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-813">The Merge method is used to merge two <xref:System.Data.DataTable> objects that have largely similar schemas.</span></span> <span data-ttu-id="0238d-814">병합을 일반적으로 사용 됩니다 클라이언트 응용 프로그램에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-814">A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-815">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-815">This allows the client application to have a refreshed <xref:System.Data.DataTable> with the latest data from the data source.</span></span>  
  
 <span data-ttu-id="0238d-816">병합 작업은 원래 테이블만 및 병합할 테이블 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-816">The merge operation takes into account only the original table, and the table to be merged.</span></span> <span data-ttu-id="0238d-817">자식 테이블을 받는 되지 않거나 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-817">Child tables are not affected or included.</span></span> <span data-ttu-id="0238d-818">테이블 관계의 일부로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블을 개별적으로 병합 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-818">If a table has one or more child tables, defined as part of a relationship, each child table must be merged individually.</span></span>  
  
 <span data-ttu-id="0238d-819">합니다 `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-819">The `Merge` method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="0238d-820">개발자에 대해서는 false를 지정 하지 않은 경우 병합 하기 전에 기존 데이터에 대 한 변경 내용을 병합 작업 동안 유지 됩니다 병합을 수행 하는 경우는 `preserveChanges` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-820">When performing a merge, changes made to the existing data before the merge are preserved during the merge operation unless the developer specifies false for the `preserveChanges` parameter.</span></span> <span data-ttu-id="0238d-821">경우는 `preserveChanges` 매개 변수는 설정 `true`을 들어오는 값이 기존 행의 현재 행 버전의 기존 값을 덮어쓰지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-821">If the `preserveChanges` parameter is set to `true`, incoming values do not overwrite existing values in the Current row version of the existing row.</span></span> <span data-ttu-id="0238d-822">경우는 `preserveChanges` 매개 변수는 설정 `false`을 들어오는 값이 기존 행의 현재 행 버전의 기존 값을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-822">If the `preserveChanges` parameter is set to `false`, incoming values do overwrite the existing values in the Current row version of the existing row.</span></span> <span data-ttu-id="0238d-823">행 버전에 대 한 자세한 내용은 참조 하세요. [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-823">For more information about row versions, see [Row States and Row Versions](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).</span></span>  
  
 <span data-ttu-id="0238d-824">클라이언트 응용 프로그램에서는 단일 하는 단추가 사용자가 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 데 평소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-824">In a client application, it is usual to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle tier component.</span></span> <span data-ttu-id="0238d-825">이 시나리오에서는 <xref:System.Data.DataTable.GetChanges%2A> 메서드가 먼저 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-825">In this scenario, the <xref:System.Data.DataTable.GetChanges%2A> method is first invoked.</span></span> <span data-ttu-id="0238d-826">이 메서드는 두 번째 <xref:System.Data.DataTable> 유효성 검사 및 병합에 대해 최적화 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-826">That method returns a second <xref:System.Data.DataTable> optimized for validating and merging.</span></span> <span data-ttu-id="0238d-827">이 두 번째 <xref:System.Data.DataTable> 개체만 포함 된 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-827">This second <xref:System.Data.DataTable> object contains only the <xref:System.Data.DataTable> and <xref:System.Data.DataRow> objects that were changed, resulting in a subset of the original <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-828">이 하위 집합은 일반적으로 작은 및 따라서이 하위 집합은 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-828">This subset is generally smaller, and thus this subset is more efficiently passed back to a middle tier component.</span></span> <span data-ttu-id="0238d-829">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-829">The middle tier component then updates the original data source with the changes through stored procedures.</span></span> <span data-ttu-id="0238d-830">중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-830">The middle tier can then send back either a new <xref:System.Data.DataTable> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</span></span> <span data-ttu-id="0238d-831">(예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataTable> 사용 하 여는 <xref:System.Data.DataTable.Merge%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-831">(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <xref:System.Data.DataTable> can be merged back into the client application's original <xref:System.Data.DataTable> with the <xref:System.Data.DataTable.Merge%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-832">새 소스를 병합할 때 <xref:System.Data.DataTable> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted` 동일한 기본 키 값을 사용 하 여 대상 행에 일치 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-832">When merging a new source <xref:System.Data.DataTable> into the target, any source rows with a <xref:System.Data.DataRowState> value of `Unchanged`, `Modified`, or `Deleted` are matched to target rows with the same primary key values.</span></span> <span data-ttu-id="0238d-833">소스 행을 <xref:System.Data.DataRowState> 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-833">Source rows with a <xref:System.Data.DataRowState> value of `Added` are matched to new target rows with the same primary key values as the new source rows.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-834">다음 콘솔 응용 프로그램을 만듭니다는 <xref:System.Data.DataTable> 해당 행의 데이터 중 일부를 수정 행을 포함 하 고 다른 데이터를 병합 하려고 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-834">The following console application creates a <xref:System.Data.DataTable> containing rows, modifies some of the data in those rows, and attempts to merge data from a different <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-835">예제에 대 한 다양 한 동작에는 `preserveChanges` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-835">The example demonstrates the different behaviors for the `preserveChanges` parameter.</span></span>  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataTable.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">
          <span data-ttu-id="0238d-836">현재 <see cref="T:System.Data.DataTable" />과 병합할 <see cref="T:System.Data.DataTable" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-836">The <see cref="T:System.Data.DataTable" /> to be merged with the current <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </param>
        <param name="preserveChanges">
          <span data-ttu-id="0238d-837">현재 <see langword="true" />의 변경 내용을 유지하려면 <see cref="T:System.Data.DataTable" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-837">
              <see langword="true" />, to preserve changes in the current <see cref="T:System.Data.DataTable" />; otherwise <see langword="false" />.</span>
          </span>
        </param>
        <param name="missingSchemaAction">
          <span data-ttu-id="0238d-838">
            <see cref="T:System.Data.MissingSchemaAction" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-838">One of the <see cref="T:System.Data.MissingSchemaAction" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-839">지정된 <see cref="T:System.Data.DataTable" />을 현재 <see langword="DataTable" />과 병합하여, 변경 내용을 유지할지 여부와 현재 <see langword="DataTable" />의 누락된 스키마 처리 방식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-839">Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see langword="DataTable" />, indicating whether to preserve changes and how to handle missing schema in the current <see langword="DataTable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-840">합니다 `Merge` 메서드는 두 개의 병합 데 <xref:System.Data.DataTable> 아주 비슷한 스키마가 포함 된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-840">The `Merge` method is used to merge two <xref:System.Data.DataTable> objects that have largely similar schemas.</span></span> <span data-ttu-id="0238d-841">병합을 일반적으로 사용 됩니다 클라이언트 응용 프로그램에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-841">A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-842">이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-842">This allows the client application to have a refreshed <xref:System.Data.DataTable> with the latest data from the data source.</span></span>  
  
 <span data-ttu-id="0238d-843">병합 작업은 원래 테이블만 및 병합할 테이블 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-843">The merge operation takes into account only the original table, and the table to be merged.</span></span> <span data-ttu-id="0238d-844">자식 테이블을 받는 되지 않거나 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-844">Child tables are not affected or included.</span></span> <span data-ttu-id="0238d-845">테이블 관계의 일부로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블을 개별적으로 병합 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-845">If a table has one or more child tables, defined as part of a relationship, each child table must be merged individually.</span></span>  
  
 <span data-ttu-id="0238d-846">합니다 `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-846">The `Merge` method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="0238d-847">개발자에 대해서는 false를 지정 하지 않은 경우 병합 하기 전에 기존 데이터에 대 한 변경 내용을 병합 작업 동안 유지 됩니다 병합을 수행 하는 경우는 `preserveChanges` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-847">When performing a merge, changes made to the existing data before the merge are preserved during the merge operation unless the developer specifies false for the `preserveChanges` parameter.</span></span> <span data-ttu-id="0238d-848">경우는 `preserveChanges` 매개 변수는 설정 `true`을 들어오는 값이 기존 행의 현재 행 버전의 기존 값을 덮어쓰지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-848">If the `preserveChanges` parameter is set to `true`, incoming values do not overwrite existing values in the Current row version of the existing row.</span></span> <span data-ttu-id="0238d-849">경우는 `preserveChanges` 매개 변수는 설정 `false`을 들어오는 값이 기존 행의 현재 행 버전의 기존 값을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-849">If the `preserveChanges` parameter is set to `false`, incoming values do overwrite the existing values in the Current row version of the existing row.</span></span> <span data-ttu-id="0238d-850">행 버전에 대 한 자세한 내용은 참조 하세요. [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-850">For more information about row versions, see [Row States and Row Versions](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).</span></span>  
  
 <span data-ttu-id="0238d-851">클라이언트 응용 프로그램에서는 단일 하는 단추가 사용자가 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 데 평소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-851">In a client application, it is usual to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle tier component.</span></span> <span data-ttu-id="0238d-852">이 시나리오에서는 <xref:System.Data.DataTable.GetChanges%2A> 메서드가 먼저 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-852">In this scenario, the <xref:System.Data.DataTable.GetChanges%2A> method is first invoked.</span></span> <span data-ttu-id="0238d-853">이 메서드는 두 번째 <xref:System.Data.DataTable> 유효성 검사 및 병합에 대해 최적화 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-853">That method returns a second <xref:System.Data.DataTable> optimized for validating and merging.</span></span> <span data-ttu-id="0238d-854">이 두 번째 <xref:System.Data.DataTable> 개체만 포함 된 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-854">This second <xref:System.Data.DataTable> object contains only the <xref:System.Data.DataTable> and <xref:System.Data.DataRow> objects that were changed, resulting in a subset of the original <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-855">이 하위 집합은 일반적으로 작은 및 따라서이 하위 집합은 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-855">This subset is generally smaller, and thus this subset is more efficiently passed back to a middle tier component.</span></span> <span data-ttu-id="0238d-856">중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-856">The middle tier component then updates the original data source with the changes through stored procedures.</span></span> <span data-ttu-id="0238d-857">중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-857">The middle tier can then send back either a new <xref:System.Data.DataTable> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</span></span> <span data-ttu-id="0238d-858">(예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataTable> 사용 하 여는 <xref:System.Data.DataTable.Merge%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-858">(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <xref:System.Data.DataTable> can be merged back into the client application's original <xref:System.Data.DataTable> with the <xref:System.Data.DataTable.Merge%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-859">경우는 <xref:System.Data.DataTable.Merge%2A> 메서드가 호출 되는 두 스키마 <xref:System.Data.DataTable> 개체는 스키마 변경 수 있기 때문에 비교 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-859">When the <xref:System.Data.DataTable.Merge%2A> method is called, the schemas of the two <xref:System.Data.DataTable> objects are compared, because it is possible that the schemas may have been changed.</span></span> <span data-ttu-id="0238d-860">예를 들어, 기업 간 시나리오에서 새 열 추가한 XML 스키마에 자동화 된 프로세스에 의해 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-860">For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</span></span> <span data-ttu-id="0238d-861">하는 경우 원본 <xref:System.Data.DataTable> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된를 설정 하 여 대상 스키마 요소를 추가할 수 있습니다 합니다 `missingSchemaAction` 인수를 `MissingSchemaAction.Add`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-861">If the source <xref:System.Data.DataTable> contains schema elements (added <xref:System.Data.DataColumn> objects) that are missing in the target, the schema elements can be added to the target by setting the `missingSchemaAction` argument to `MissingSchemaAction.Add`.</span></span> <span data-ttu-id="0238d-862">병합 된 경우에서 <xref:System.Data.DataTable> 추가 된 스키마 및 데이터를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-862">In that case, the merged <xref:System.Data.DataTable> contains the added schema and data.</span></span>  
  
 <span data-ttu-id="0238d-863">스키마를 병합 한 후 데이터를 병합 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-863">After merging schemas, the data is merged.</span></span>  
  
 <span data-ttu-id="0238d-864">새 소스를 병합할 때 <xref:System.Data.DataTable> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted` 동일한 기본 키 값을 사용 하 여 대상 행에 일치 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-864">When merging a new source <xref:System.Data.DataTable> into the target, any source rows with a <xref:System.Data.DataRowState> value of `Unchanged`, `Modified`, or `Deleted` are matched to target rows with the same primary key values.</span></span> <span data-ttu-id="0238d-865">소스 행을 <xref:System.Data.DataRowState> 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-865">Source rows with a <xref:System.Data.DataRowState> value of `Added` are matched to new target rows with the same primary key values as the new source rows.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-866">다음 콘솔 응용 프로그램의 동작을 보여 줍니다.는 `missingSchemaAction` 의 매개 변수는 <xref:System.Data.DataTable.Merge%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-866">The following console application demonstrates the behavior of the `missingSchemaAction` parameter of the <xref:System.Data.DataTable.Merge%2A> method.</span></span> <span data-ttu-id="0238d-867">이 예제에서는 두 번째 버전에 대 한 스키마를 수정 하는 동일한 테이블의 두 버전을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-867">This example creates two versions of the same table, modifying the schema for the second version.</span></span> <span data-ttu-id="0238d-868">코드를 첫 번째 두 번째 테이블을 병합 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-868">The code then attempts to merge the second table into the first.</span></span>  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumCapacity : int with get, set" Usage="System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableMinimumCapacityDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-869">이 테이블에 대한 초기 시작 크기를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-869">Gets or sets the initial starting size for this table.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-870">이 테이블에 있는 행의 초기 시작 크기입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-870">The initial starting size in rows of this table.</span>
          </span>
          <span data-ttu-id="0238d-871">기본값은 50입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-871">The default is 50.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-872"><xref:System.Data.DataTable.MinimumCapacity%2A> 시스템에 데이터를 인출 하기 전에 적절 한 리소스 집합을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-872">The <xref:System.Data.DataTable.MinimumCapacity%2A> allows the system to create an appropriate set of resources before fetching data.</span></span> <span data-ttu-id="0238d-873">상황에서이 속성을 설정할 성능이 중요 한 경우 성능을 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-873">In a situation when performance is critical, setting this property can optimize performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-874">다음 예제에서는 합니다 <xref:System.Data.DataTable.MinimumCapacity%2A> 의 한 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-874">The following example sets the <xref:System.Data.DataTable.MinimumCapacity%2A> of a <xref:System.Data.DataTable>.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-875">
            <see cref="T:System.Data.DataTable" />에 저장된 데이터의 XML 표현에 대한 네임스페이스를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-875">Gets or sets the namespace for the XML representation of the data stored in the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-876">
            <see cref="T:System.Data.DataTable" />의 네임스페이스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-876">The namespace of the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberSignature Language="F#" Value="member this.NewRow : unit -&gt; System.Data.DataRow" Usage="dataTable.NewRow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-877">테이블과 동일한 스키마를 갖는 새 <see cref="T:System.Data.DataRow" />를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-877">Creates a new <see cref="T:System.Data.DataRow" /> with the same schema as the table.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-878">
            <see cref="T:System.Data.DataRow" />과 동일한 스키마를 갖는 <see cref="T:System.Data.DataTable" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-878">A <see cref="T:System.Data.DataRow" /> with the same schema as the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-879">사용 해야 합니다는 <xref:System.Data.DataTable.NewRow%2A> 새로 만들기 방법 <xref:System.Data.DataRow> 와 동일한 스키마를 사용 하 여 개체를 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-879">You must use the <xref:System.Data.DataTable.NewRow%2A> method to create new <xref:System.Data.DataRow> objects with the same schema as the <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-880">만든 후는 <xref:System.Data.DataRow>를 추가할 수 있습니다는 <xref:System.Data.DataRowCollection>을 통해 합니다 <xref:System.Data.DataTable> 개체의 <xref:System.Data.DataTable.Rows%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="0238d-880">After creating a <xref:System.Data.DataRow>, you can add it to the <xref:System.Data.DataRowCollection>, through the <xref:System.Data.DataTable> object's <xref:System.Data.DataTable.Rows%2A> property.</span></span> <span data-ttu-id="0238d-881">사용 하는 경우 <xref:System.Data.DataTable.NewRow%2A> 새 행을 만들려면 행에 추가 하거나 삭제 해야 데이터 테이블에서 호출 하기 전에 <xref:System.Data.DataTable.Clear%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-881">When you use <xref:System.Data.DataTable.NewRow%2A> to create new rows, the rows must be added to or deleted from the data table before you call <xref:System.Data.DataTable.Clear%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-882">다음 예제에서는 <xref:System.Data.DataTable>, 두 개 더한 <xref:System.Data.DataColumn> 개체는 테이블의 스키마를 확인 하 고 여러 만듭니다 <xref:System.Data.DataRow> 사용 하 여 개체를 <xref:System.Data.DataTable.NewRow%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-882">The following example creates a <xref:System.Data.DataTable>, adds two <xref:System.Data.DataColumn> objects that determine the table's schema, and creates several new <xref:System.Data.DataRow> objects using the <xref:System.Data.DataTable.NewRow%2A> method.</span></span> <span data-ttu-id="0238d-883">이러한 <xref:System.Data.DataRow> 개체에 추가 됩니다 합니다 <xref:System.Data.DataRowCollection> 사용 하 여를 <xref:System.Data.DataRowCollection.Add%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-883">Those <xref:System.Data.DataRow> objects are then added to the <xref:System.Data.DataRowCollection> using the <xref:System.Data.DataRowCollection.Add%2A> method.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberSignature Language="F#" Value="member this.NewRowArray : int -&gt; System.Data.DataRow[]" Usage="dataTable.NewRowArray size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">
          <span data-ttu-id="0238d-884">배열의 크기를 설명하는 <see cref="T:System.Int32" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-884">A <see cref="T:System.Int32" /> value that describes the size of the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-885">
            <see cref="T:System.Data.DataRow" />의 배열을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-885">Returns an array of <see cref="T:System.Data.DataRow" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-886">새 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-886">The new array.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow&#xA;override this.NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow" Usage="dataTable.NewRowFromBuilder builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">
          <span data-ttu-id="0238d-887">
            <see cref="T:System.Data.DataRowBuilder" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-887">A <see cref="T:System.Data.DataRowBuilder" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-888">기존 행에서 새 행을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-888">Creates a new row from an existing row.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-889">
            <see cref="T:System.Data.DataRow" /> 파생 클래스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-889">A <see cref="T:System.Data.DataRow" /> derived class.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="0238d-890">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataColumnChangeEventArgs" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-890">A <see cref="T:System.Data.DataColumnChangeEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-891">
            <see cref="E:System.Data.DataTable.ColumnChanged" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-891">Raises the <see cref="E:System.Data.DataTable.ColumnChanged" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-892">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-892">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="0238d-893">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-893">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="0238d-894">
            <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-894">
              <para>When overriding <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="0238d-895">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataColumnChangeEventArgs" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-895">A <see cref="T:System.Data.DataColumnChangeEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-896">
            <see cref="E:System.Data.DataTable.ColumnChanging" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-896">Raises the <see cref="E:System.Data.DataTable.ColumnChanging" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-897">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-897">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="0238d-898">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-898">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="0238d-899">
            <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-899">
              <para>When overriding <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataTable.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">
          <span data-ttu-id="0238d-900">이벤트 데이터를 포함하는 <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-900">A <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-901">
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-901">Raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-902">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-902">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="0238d-903">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-903">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="0238d-904">
            <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-904">
              <para>When overriding <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveColumn : System.Data.DataColumn -&gt; unit&#xA;override this.OnRemoveColumn : System.Data.DataColumn -&gt; unit" Usage="dataTable.OnRemoveColumn column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">
          <span data-ttu-id="0238d-905">제거 중인 <see cref="T:System.Data.DataColumn" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-905">The <see cref="T:System.Data.DataColumn" /> being removed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-906">
            <see cref="T:System.Data.DataTable" />이 제거 중임을 <see cref="T:System.Data.DataColumn" />에 알립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-906">Notifies the <see cref="T:System.Data.DataTable" /> that a <see cref="T:System.Data.DataColumn" /> is being removed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-907">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-907">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="0238d-908">자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-908">For more information, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="0238d-909">
            <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-909">
              <para>When overriding <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="0238d-910">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataRowChangeEventArgs" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-910">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-911">
            <see cref="E:System.Data.DataTable.RowChanged" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-911">Raises the <see cref="E:System.Data.DataTable.RowChanged" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-912">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-912">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="0238d-913">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-913">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="0238d-914">
            <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-914">
              <para>When overriding <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="0238d-915">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataRowChangeEventArgs" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-915">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-916">
            <see cref="E:System.Data.DataTable.RowChanging" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-916">Raises the <see cref="E:System.Data.DataTable.RowChanging" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-917">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-917">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="0238d-918">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-918">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="0238d-919">
            <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-919">
              <para>When overriding <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="0238d-920">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataRowChangeEventArgs" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-920">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-921">
            <see cref="E:System.Data.DataTable.RowDeleted" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-921">Raises the <see cref="E:System.Data.DataTable.RowDeleted" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-922">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-922">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="0238d-923">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-923">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="0238d-924">
            <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-924">
              <para>When overriding <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="0238d-925">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataRowChangeEventArgs" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-925">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-926">
            <see cref="E:System.Data.DataTable.RowDeleting" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-926">Raises the <see cref="E:System.Data.DataTable.RowDeleting" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-927">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-927">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="0238d-928">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-928">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="0238d-929">
            <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-929">
              <para>When overriding <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableCleared e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="0238d-930">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataTableClearEventArgs" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-930">A <see cref="T:System.Data.DataTableClearEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-931">
            <see cref="E:System.Data.DataTable.TableCleared" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-931">Raises the <see cref="E:System.Data.DataTable.TableCleared" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-932">발생 합니다 <xref:System.Data.DataTable.TableCleared> 모든 행이 성공적으로 지워진 전에 직후 발생 하는 이벤트를 <xref:System.Data.DataTable.Clear%2A> 메서드 호출자에 게 컨트롤을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-932">Raises the <xref:System.Data.DataTable.TableCleared> event, which is fired immediately after all rows have been successfully cleared but before the <xref:System.Data.DataTable.Clear%2A> method returns control back to the caller.</span></span>  
  
 <span data-ttu-id="0238d-933">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-933">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="0238d-934">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-934">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableClearing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="0238d-935">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataTableClearEventArgs" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-935">A <see cref="T:System.Data.DataTableClearEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-936">
            <see cref="E:System.Data.DataTable.TableClearing" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-936">Raises the <see cref="E:System.Data.DataTable.TableClearing" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-937">발생 합니다 <xref:System.Data.DataTable.TableClearing> 처리 되기 전에 발생 하는 이벤트를 <xref:System.Data.DataTable.Clear%2A> 작업이 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-937">Raises the <xref:System.Data.DataTable.TableClearing> event, which is fired before processing of the <xref:System.Data.DataTable.Clear%2A> operation begins.</span></span>  
  
 <span data-ttu-id="0238d-938">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-938">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="0238d-939">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-939">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit&#xA;override this.OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit" Usage="dataTable.OnTableNewRow e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="0238d-940">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataTableNewRowEventArgs" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-940">A <see cref="T:System.Data.DataTableNewRowEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-941">
            <see cref="E:System.Data.DataTable.TableNewRow" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-941">Raises the <see cref="E:System.Data.DataTable.TableNewRow" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-942">발생 합니다 <xref:System.Data.DataTable.TableNewRow> 새 후 발생 하는 이벤트 <xref:System.Data.DataRow> 사용 하 여 만든 <xref:System.Data.DataTable.NewRow%2A>.</span><span class="sxs-lookup"><span data-stu-id="0238d-942">Raises the <xref:System.Data.DataTable.TableNewRow> event, which fires after a new <xref:System.Data.DataRow> has been created using <xref:System.Data.DataTable.NewRow%2A>.</span></span>  
  
 <span data-ttu-id="0238d-943">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-943">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="0238d-944">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-944">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableParentRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-945">이 <see cref="T:System.Data.DataTable" />에 대한 부모 관계 컬렉션을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-945">Gets the collection of parent relations for this <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-946">테이블의 부모 관계가 포함된 <see cref="T:System.Data.DataRelationCollection" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-946">A <see cref="T:System.Data.DataRelationCollection" /> that contains the parent relations for the table.</span>
          </span>
          <span data-ttu-id="0238d-947">
            <see cref="T:System.Data.DataRelation" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-947">An empty collection is returned if no <see cref="T:System.Data.DataRelation" /> objects exist.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0238d-948">다음 예제에서는 합니다 <xref:System.Data.DataTable.ParentRelations%2A> 각 부모를 반환 하도록 속성 <xref:System.Data.DataRelation> 에 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-948">The following example uses the <xref:System.Data.DataTable.ParentRelations%2A> property to return each parent <xref:System.Data.DataRelation> in a <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-949">각 관계에 대 한 인수로 사용 됩니다는 <xref:System.Data.DataRow.GetParentRows%2A> 메서드는 <xref:System.Data.DataRow> 행의 배열을 반환 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-949">Each relation is then used as an argument in the <xref:System.Data.DataRow.GetParentRows%2A> method of the <xref:System.Data.DataRow> to return an array of rows.</span></span> <span data-ttu-id="0238d-950">행의 각 열 값이 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-950">The value of each column in the row is then printed.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-951">
            <see cref="T:System.Data.DataTable" />에 저장된 데이터의 XML 표현에 대한 네임스페이스를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-951">Gets or sets the namespace for the XML representation of the data stored in the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-952">
            <see cref="T:System.Data.DataTable" />의 접두사입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-952">The prefix of the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : System.Data.DataColumn[] with get, set" Usage="System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrimaryKeyDescr")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-953">데이터 테이블에 대한 기본 키로 사용되는 열의 배열을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-953">Gets or sets an array of columns that function as primary keys for the data table.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-954">
            <see cref="T:System.Data.DataColumn" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-954">An array of <see cref="T:System.Data.DataColumn" /> objects.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-955">테이블의 기본 키 테이블의 레코드를 식별 하는 고유 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-955">The primary key of a table must be unique to identify the record in the table.</span></span> <span data-ttu-id="0238d-956">두 개 이상의 열으로 구성 하는 기본 키를 사용 하 여 테이블을 가질 수 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-956">It's also possible to have a table with a primary key made up of two or more columns.</span></span> <span data-ttu-id="0238d-957">이 단일 열 충분 한 고유 값을 포함할 수 없는 경우 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-957">This occurs when a single column can't contain enough unique values.</span></span> <span data-ttu-id="0238d-958">예를 들어 두 개의 열 기본 키를 "FirstName" 및 "LastName" 열의 구성 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-958">For example, a two column primary key might consist of a "FirstName" and "LastName" column.</span></span> <span data-ttu-id="0238d-959">기본 키 둘 이상의 열을 구성할 수 있으므로 합니다 <xref:System.Data.DataTable.PrimaryKey%2A> 속성의 배열로 구성 됩니다 <xref:System.Data.DataColumn> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-959">Because primary keys can be made up of more than one column, the <xref:System.Data.DataTable.PrimaryKey%2A> property consists of an array of <xref:System.Data.DataColumn> objects.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-960">첫 번째 예제에 대 한 기본 키 열을 반환 하는 방법을 보여 줍니다는 <xref:System.Data.DataTable> 에 표시 되는 `DataGrid`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-960">The first example shows how to return the primary key columns for a <xref:System.Data.DataTable> displayed in a `DataGrid`.</span></span> <span data-ttu-id="0238d-961">두 번째 예제에 대 한 기본 키 열을 설정 하는 방법에 설명 된 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-961">The second example demonstrates how to set the primary key columns for a <xref:System.Data.DataTable>.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">
          <span data-ttu-id="0238d-962">해당 키가 외래 키인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-962">The key is a foreign key.</span>
          </span>
        </exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-963">XML 스키마와 데이터를 <see cref="T:System.Data.DataTable" />으로 읽어옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-963">Reads XML schema and data into the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-964">합니다 <xref:System.Data.DataTable.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataTable> XML 문서에서 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-964">The <xref:System.Data.DataTable.ReadXml%2A> method provides a way to read either data only, or both data and schema into a <xref:System.Data.DataTable> from an XML document, whereas the <xref:System.Data.DataTable.ReadXmlSchema%2A> method reads only the schema.</span></span> <span data-ttu-id="0238d-965">읽기 데이터와 스키마 중 하나를 사용 합니다 `ReadXML` 포함 하는 오버 로드는 `XmlReadMode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-965">To read both data and schema, use one of the `ReadXML` overloads that include the `XmlReadMode` parameter, and set its value to `ReadSchema`.</span></span>  
  
 <span data-ttu-id="0238d-966">True는 동일 합니다 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-966">Note that the same is true for the <xref:System.Data.DataTable.WriteXml%2A> and <xref:System.Data.DataTable.WriteXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-967">XML 데이터 또는 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여를 `WriteXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-967">To write XML data, or both schema and data from the `DataTable`, use the `WriteXml` method.</span></span> <span data-ttu-id="0238d-968">스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-968">To write just the schema, use the `WriteXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-969"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-969">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="0238d-970">
            <see cref="T:System.IO.Stream" />에서 파생되는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-970">An object that derives from <see cref="T:System.IO.Stream" /></span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-971">지정된 <see cref="T:System.Data.DataTable" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.IO.Stream" />으로 읽어옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-971">Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.Stream" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-972">데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-972">The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-973">현재 <xref:System.Data.DataTable> 제공 된 데이터를 사용 하 여 해당 하위 항목이 로드 되 고 <xref:System.IO.Stream>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-973">The current <xref:System.Data.DataTable> and its descendents are loaded with the data from the supplied <xref:System.IO.Stream>.</span></span> <span data-ttu-id="0238d-974">이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> 이 경우에 데이터를 제외 하 고 메서드는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-974">The behavior of this method is identical to that of the <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> method, except that in this case, data is loaded only for the current table and its descendants.</span></span>  
  
 <span data-ttu-id="0238d-975">합니다 <xref:System.Data.DataTable.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataTable> XML 문서에서 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-975">The <xref:System.Data.DataTable.ReadXml%2A> method provides a way to read either data only, or both data and schema into a <xref:System.Data.DataTable> from an XML document, whereas the <xref:System.Data.DataTable.ReadXmlSchema%2A> method reads only the schema.</span></span>  
  
 <span data-ttu-id="0238d-976">True는 동일 합니다 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-976">Note that the same is true for the <xref:System.Data.DataTable.WriteXml%2A> and <xref:System.Data.DataTable.WriteXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-977">XML 데이터 또는 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여를 `WriteXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-977">To write XML data, or both schema and data from the `DataTable`, use the `WriteXml` method.</span></span> <span data-ttu-id="0238d-978">스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-978">To write just the schema, use the `WriteXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-979"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-979">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 <span data-ttu-id="0238d-980">인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-980">If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</span></span> <span data-ttu-id="0238d-981">모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-981">If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</span></span>  
  
 <span data-ttu-id="0238d-982">없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-982">If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</span></span> <span data-ttu-id="0238d-983">스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-983">If the schema cannot be extended through inference in order to expose all data, an exception is raised.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-984">합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="0238d-984">The `DataSet` does not associate an XML element with its corresponding `DataColumn` or `DataTable` when legal XML characters like ("_") are escaped in the serialized XML.</span></span> <span data-ttu-id="0238d-985">`DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-985">The `DataSet` itself only escapes illegal XML characters in XML element names and hence can only consume the same.</span></span> <span data-ttu-id="0238d-986">XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-986">When legal characters in XML element name are escaped, the element is ignored while processing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-987">다음 예제에서는 <xref:System.Data.DataTable> 두 개의 열과 10 개의 행을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-987">The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows.</span></span> <span data-ttu-id="0238d-988">이 예제에서는 기록 합니다 <xref:System.Data.DataTable> 스키마 및 데이터를 메모리 스트림으로 호출 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-988">The example writes the <xref:System.Data.DataTable> schema and data to a memory stream, by invoking the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span> <span data-ttu-id="0238d-989">이 예에서는 두 번째를 만듭니다 <xref:System.Data.DataTable> 호출을 <xref:System.Data.DataTable.ReadXml%2A> 스키마 및 데이터를 사용 하 여 입력 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-989">The example creates a second <xref:System.Data.DataTable> and calls the <xref:System.Data.DataTable.ReadXml%2A> method to fill it with schema and data.</span></span>  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="0238d-990">데이터를 읽는 데 사용할 <see cref="T:System.IO.TextReader" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-990">The <see cref="T:System.IO.TextReader" /> that will be used to read the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-991">지정된 <see cref="T:System.Data.DataTable" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.IO.TextReader" />으로 읽어옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-991">Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextReader" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-992">데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-992">The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-993">현재 <xref:System.Data.DataTable> 제공 된 데이터를 사용 하 여 해당 하위 항목이 로드 되 고 <xref:System.IO.TextReader>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-993">The current <xref:System.Data.DataTable> and its descendents are loaded with the data from the supplied <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="0238d-994">이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> 이 경우에 데이터를 제외 하 고 메서드는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-994">The behavior of this method is identical to that of the <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> method, except that in this case, data is loaded only for the current table and its descendants.</span></span>  
  
 <span data-ttu-id="0238d-995">합니다 <xref:System.Data.DataTable.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataTable> XML 문서에서 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-995">The <xref:System.Data.DataTable.ReadXml%2A> method provides a way to read either data only, or both data and schema into a <xref:System.Data.DataTable> from an XML document, whereas the <xref:System.Data.DataTable.ReadXmlSchema%2A> method reads only the schema.</span></span>  
  
 <span data-ttu-id="0238d-996">True는 동일 합니다 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-996">Note that the same is true for the <xref:System.Data.DataTable.WriteXml%2A> and <xref:System.Data.DataTable.WriteXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-997">XML 데이터 또는 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여를 `WriteXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-997">To write XML data, or both schema and data from the `DataTable`, use the `WriteXml` method.</span></span> <span data-ttu-id="0238d-998">스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-998">To write just the schema, use the `WriteXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-999"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-999">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 <span data-ttu-id="0238d-1000">인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1000">If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</span></span> <span data-ttu-id="0238d-1001">모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1001">If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</span></span>  
  
 <span data-ttu-id="0238d-1002">없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1002">If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</span></span> <span data-ttu-id="0238d-1003">스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1003">If the schema cannot be extended through inference in order to expose all data, an exception is raised.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1004">합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="0238d-1004">The `DataSet` does not associate an XML element with its corresponding `DataColumn` or `DataTable` when legal XML characters like ("_") are escaped in the serialized XML.</span></span> <span data-ttu-id="0238d-1005">`DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1005">The `DataSet` itself only escapes illegal XML characters in XML element names and hence can only consume the same.</span></span> <span data-ttu-id="0238d-1006">XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1006">When legal characters in XML element name are escaped, the element is ignored while processing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1007">다음 예제에서는 <xref:System.Data.DataTable> 두 개의 열과 10 개의 행을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1007">The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows.</span></span> <span data-ttu-id="0238d-1008">이 예제에서는 기록 합니다 <xref:System.Data.DataTable> 스키마 및 데이터를 메모리 스트림으로 호출 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1008">The example writes the <xref:System.Data.DataTable> schema and data to a memory stream, by invoking the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span> <span data-ttu-id="0238d-1009">이 예에서는 두 번째를 만듭니다 <xref:System.Data.DataTable> 호출을 <xref:System.Data.DataTable.ReadXml%2A> 스키마 및 데이터를 사용 하 여 입력 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1009">The example creates a second <xref:System.Data.DataTable> and calls the <xref:System.Data.DataTable.ReadXml%2A> method to fill it with schema and data.</span></span>  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0238d-1010">데이터를 읽을 파일의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1010">The name of the file from which to read the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1011">지정된 파일로부터 XML 스키마와 데이터를 <see cref="T:System.Data.DataTable" />로 읽어옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1011">Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> from the specified file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-1012">데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1012">The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1013">현재 <xref:System.Data.DataTable> 해당 하위 항목에 제공 된 명명 된 파일에서 데이터를 사용 하 여 로드 되 고 <xref:System.String>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1013">The current <xref:System.Data.DataTable> and its descendents are loaded with the data from the file named in the supplied <xref:System.String>.</span></span> <span data-ttu-id="0238d-1014">이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> 이 경우에 데이터를 제외 하 고 메서드는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1014">The behavior of this method is identical to that of the <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> method, except that in this case, data is loaded only for the current table and its descendants.</span></span>  
  
 <span data-ttu-id="0238d-1015">합니다 <xref:System.Data.DataTable.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataTable> XML 문서에서 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1015">The <xref:System.Data.DataTable.ReadXml%2A> method provides a way to read either data only, or both data and schema into a <xref:System.Data.DataTable> from an XML document, whereas the <xref:System.Data.DataTable.ReadXmlSchema%2A> method reads only the schema.</span></span>  
  
 <span data-ttu-id="0238d-1016">True는 동일 합니다 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1016">Note that the same is true for the <xref:System.Data.DataTable.WriteXml%2A> and <xref:System.Data.DataTable.WriteXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1017">XML 데이터 또는 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여를 `WriteXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1017">To write XML data, or both schema and data from the `DataTable`, use the `WriteXml` method.</span></span> <span data-ttu-id="0238d-1018">스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1018">To write just the schema, use the `WriteXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1019"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1019">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 <span data-ttu-id="0238d-1020">인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1020">If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</span></span> <span data-ttu-id="0238d-1021">모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1021">If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</span></span>  
  
 <span data-ttu-id="0238d-1022">없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1022">If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</span></span> <span data-ttu-id="0238d-1023">스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1023">If the schema cannot be extended through inference in order to expose all data, an exception is raised.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1024">합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="0238d-1024">The `DataSet` does not associate an XML element with its corresponding `DataColumn` or `DataTable` when legal XML characters like ("_") are escaped in the serialized XML.</span></span> <span data-ttu-id="0238d-1025">`DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1025">The `DataSet` itself only escapes illegal XML characters in XML element names and hence can only consume the same.</span></span> <span data-ttu-id="0238d-1026">XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1026">When legal characters in XML element name are escaped, the element is ignored while processing.</span></span>  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1027">다음 예제에서는 <xref:System.Data.DataTable> 두 개의 열과 10 개의 행을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1027">The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows.</span></span> <span data-ttu-id="0238d-1028">예제에서는 기록 된 <xref:System.Data.DataTable> 스키마와 데이터 디스크를 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1028">The example writes the <xref:System.Data.DataTable> schema and data to disk.</span></span> <span data-ttu-id="0238d-1029">이 예에서는 두 번째를 만듭니다 <xref:System.Data.DataTable> 호출을 <xref:System.Data.DataTable.ReadXml%2A> 스키마 및 데이터를 사용 하 여 입력 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1029">The example creates a second <xref:System.Data.DataTable> and calls the <xref:System.Data.DataTable.ReadXml%2A> method to fill it with schema and data.</span></span>  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="0238d-1030">데이터를 읽는 데 사용할 <see cref="T:System.Xml.XmlReader" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1030">The <see cref="T:System.Xml.XmlReader" /> that will be used to read the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1031">지정된 <see cref="T:System.Data.DataTable" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Xml.XmlReader" />로 읽어옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1031">Reads XML Schema and Data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlReader" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-1032">데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1032">The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1033">현재 <xref:System.Data.DataTable> 해당 하위 항목에 제공 된 명명 된 파일에서 데이터를 사용 하 여 로드 되 고 <xref:System.Xml.XmlReader>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1033">The current <xref:System.Data.DataTable> and its descendents are loaded with the data from the file named in the supplied <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="0238d-1034">이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataTable.ReadXml%2A> 이 경우에 데이터를 제외 하 고 메서드는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1034">The behavior of this method is identical to that of the <xref:System.Data.DataTable.ReadXml%2A> method, except that in this case, data is loaded only for the current table and its descendants.</span></span>  
  
 <span data-ttu-id="0238d-1035">합니다 <xref:System.Data.DataTable.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataTable> XML 문서에서 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1035">The <xref:System.Data.DataTable.ReadXml%2A> method provides a way to read either data only, or both data and schema into a <xref:System.Data.DataTable> from an XML document, whereas the <xref:System.Data.DataTable.ReadXmlSchema%2A> method reads only the schema.</span></span>  
  
 <span data-ttu-id="0238d-1036">True는 동일 합니다 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1036">Note that the same is true for the <xref:System.Data.DataTable.WriteXml%2A> and <xref:System.Data.DataTable.WriteXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1037">XML 데이터 또는 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여를 `WriteXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1037">To write XML data, or both schema and data from the `DataTable`, use the `WriteXml` method.</span></span> <span data-ttu-id="0238d-1038">스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1038">To write just the schema, use the `WriteXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1039"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1039">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 <span data-ttu-id="0238d-1040">인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1040">If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</span></span> <span data-ttu-id="0238d-1041">모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1041">If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</span></span>  
  
 <span data-ttu-id="0238d-1042">없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1042">If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</span></span> <span data-ttu-id="0238d-1043">스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1043">If the schema cannot be extended through inference in order to expose all data, an exception is raised.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1044">합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="0238d-1044">The `DataSet` does not associate an XML element with its corresponding `DataColumn` or `DataTable` when legal XML characters like ("_") are escaped in the serialized XML.</span></span> <span data-ttu-id="0238d-1045">`DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1045">The `DataSet` itself only escapes illegal XML characters in XML element names and hence can only consume the same.</span></span> <span data-ttu-id="0238d-1046">XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1046">When legal characters in XML element name are escaped, the element is ignored while processing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1047">다음 예제에서는 <xref:System.Data.DataTable> 두 개의 열과 10 개의 행을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1047">The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows.</span></span> <span data-ttu-id="0238d-1048">이 예제에서는 기록 합니다 <xref:System.Data.DataTable> 스키마와 데이터를는 <xref:System.Xml.XmlReader>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1048">The example writes the <xref:System.Data.DataTable> schema and data to an <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="0238d-1049">이 예에서는 두 번째를 만듭니다 <xref:System.Data.DataTable> 호출을 <xref:System.Data.DataTable.ReadXml%2A> 스키마와 데이터로 채우는 방법은 <xref:System.Xml.XmlReader> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="0238d-1049">The example creates a second <xref:System.Data.DataTable> and calls the <xref:System.Data.DataTable.ReadXml%2A> method to fill it with schema and data from the <xref:System.Xml.XmlReader> instance.</span></span>  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1050">XML 스키마를 <see cref="T:System.Data.DataTable" />으로 읽어옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1050">Reads an XML schema into the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1051">사용 하 여는 `ReadXmlSchema` 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1051">Use the `ReadXmlSchema` method to create the schema for a <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-1052">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1052">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1053">스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1053">To write a schema to an XML document, use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-1054">XML 스키마는 XSD 표준에 따라 해석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1054">The XML schema is interpreted according to the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1055">합니다 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1055">The `ReadXmlSchema` method is generally invoked before invoking the <xref:System.Data.DataTable.ReadXml%2A> method which is used to fill the <xref:System.Data.DataTable>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="0238d-1056">스키마를 읽는 데 사용되는 스트림입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1056">The stream used to read the schema.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1057">지정된 스트림을 사용하여 XML 스키마를 <see cref="T:System.Data.DataTable" />로 읽어옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1057">Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1058">사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1058">Use the <xref:System.Data.DataTable.ReadXmlSchema%2A> method to create the schema for a <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-1059">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1059">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1060">스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1060">To write a schema to an XML document, use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-1061">XML 스키마는 XSD 표준에 따라 해석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1061">The XML schema is interpreted according to the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1062">Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1062">Data corruption can occur if the msdata:DataType and the xs:type types do not match.</span></span> <span data-ttu-id="0238d-1063">예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1063">No exception will be thrown.</span></span>  
  
 <span data-ttu-id="0238d-1064">합니다 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1064">The `ReadXmlSchema` method is generally invoked before invoking the <xref:System.Data.DataTable.ReadXml%2A> method which is used to fill the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="0238d-1065">XML 스키마를 사용 하 여 중첩 된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1065">To create a nested relation using XML schema, use implicit nested elements.</span></span> <span data-ttu-id="0238d-1066">또한 명시적 열 이름을 사용 하 여 중첩 된 관계를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1066">You can also configure the nested relation to use explicit column names.</span></span> <span data-ttu-id="0238d-1067">요소 중첩된 관계에 참여 하려면 해당 Datatable에서 암시적으로 중첩 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1067">Elements must be implicitly nested in order for the corresponding DataTables to participate in a nested relation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1068">다음 콘솔 응용 프로그램을 만듭니다 <xref:System.Data.DataTable>에 쓰고 해당 테이블에 대 한 스키마를 <xref:System.IO.MemoryStream>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1068">The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a <xref:System.IO.MemoryStream>.</span></span> <span data-ttu-id="0238d-1069">그런 다음 예제에서는 새 <xref:System.Data.DataTable> 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1069">Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema.</span></span>  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="0238d-1070">스키마 정보를 읽는 데 사용되는 <see cref="T:System.IO.TextReader" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1070">The <see cref="T:System.IO.TextReader" /> used to read the schema information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1071">지정된 <see cref="T:System.Data.DataTable" />를 사용하여 XML 스키마를 <see cref="T:System.IO.TextReader" />로 읽어옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1071">Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextReader" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1072">사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1072">Use the <xref:System.Data.DataTable.ReadXmlSchema%2A> method to create the schema for a <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-1073">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1073">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1074">스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1074">To write a schema to an XML document, use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-1075">XML 스키마는 XSD 표준에 따라 해석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1075">The XML schema is interpreted according to the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1076">Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1076">Data corruption can occur if the msdata:DataType and the xs:type types do not match.</span></span> <span data-ttu-id="0238d-1077">예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1077">No exception will be thrown.</span></span>  
  
 <span data-ttu-id="0238d-1078">합니다 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1078">The `ReadXmlSchema` method is generally invoked before invoking the <xref:System.Data.DataTable.ReadXml%2A> method which is used to fill the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="0238d-1079">XML 스키마를 사용 하 여 중첩 된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1079">To create a nested relation using XML schema, use implicit nested elements.</span></span> <span data-ttu-id="0238d-1080">또한 명시적 열 이름을 사용 하 여 중첩 된 관계를 재구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1080">You can also reconfigure the nested relation to use explicit column names.</span></span> <span data-ttu-id="0238d-1081">요소 중첩된 관계에 참여 하려면 해당 Datatable에서 암시적으로 중첩 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1081">Elements must be implicitly nested in order for the corresponding DataTables to participate in a nested relation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1082">다음 콘솔 응용 프로그램을 만듭니다 <xref:System.Data.DataTable>에 쓰고 해당 테이블에 대 한 스키마를 <xref:System.IO.MemoryStream>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1082">The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a <xref:System.IO.MemoryStream>.</span></span> <span data-ttu-id="0238d-1083">그런 다음 예제에서는 새 <xref:System.Data.DataTable> 하 고 저장된 된 XML 스키마에서 해당 스키마를 읽고 사용 하는 <xref:System.IO.StreamReader> (에서 상속 하는 <xref:System.IO.TextReader>) 해당 원본으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1083">Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema, using a <xref:System.IO.StreamReader> (which inherits from <xref:System.IO.TextReader>) as its source.</span></span>  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataTable.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0238d-1084">스키마 정보를 읽을 파일의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1084">The name of the file from which to read the schema information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1085">지정된 파일로부터 XML 스키마를 <see cref="T:System.Data.DataTable" />로 읽어옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1085">Reads an XML schema into the <see cref="T:System.Data.DataTable" /> from the specified file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1086">사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1086">Use the <xref:System.Data.DataTable.ReadXmlSchema%2A> method to create the schema for a <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-1087">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1087">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1088">스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1088">To write a schema to an XML document, use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-1089">XML 스키마는 XSD 표준에 따라 해석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1089">The XML schema is interpreted according to the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1090">Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1090">Data corruption can occur if the msdata:DataType and the xs:type types do not match.</span></span> <span data-ttu-id="0238d-1091">예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1091">No exception will be thrown.</span></span>  
  
 <span data-ttu-id="0238d-1092">합니다 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 `DataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1092">The `ReadXmlSchema` method is generally invoked before invoking the <xref:System.Data.DataTable.ReadXml%2A> method which is used to fill the `DataTable`.</span></span>  
  
 <span data-ttu-id="0238d-1093">XML 스키마를 사용 하 여 중첩 된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1093">To create a nested relation using XML schema, use implicit nested elements.</span></span> <span data-ttu-id="0238d-1094">또한 명시적 열 이름을 사용 하 여 중첩 된 관계를 재구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1094">You can also reconfigure the nested relation to use explicit column names.</span></span> <span data-ttu-id="0238d-1095">요소 중첩된 관계에 참여 하려면 해당 Datatable에서 암시적으로 중첩 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1095">Elements must be implicitly nested in order for the corresponding DataTables to participate in a nested relation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1096">다음 콘솔 응용 프로그램에서는 새 <xref:System.Data.DataTable>, 파일을 해당 테이블의 스키마를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1096">The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a file.</span></span> <span data-ttu-id="0238d-1097">그런 다음 예제에서는 새 <xref:System.Data.DataTable> 및 파일을 사용 하 여 해당 원본으로 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1097">Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema, using the file as its source.</span></span>  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="0238d-1098">스키마 정보를 읽는 데 사용되는 <see cref="T:System.Xml.XmlReader" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1098">The <see cref="T:System.Xml.XmlReader" /> used to read the schema information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1099">지정된 <see cref="T:System.Data.DataTable" />를 사용하여 XML 스키마를 <see cref="T:System.Xml.XmlReader" />로 읽어옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1099">Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlReader" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1100">사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1100">Use the <xref:System.Data.DataTable.ReadXmlSchema%2A> method to create the schema for a <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-1101">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1101">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1102">스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1102">To write a schema to an XML document, use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-1103">XML 스키마는 XSD 표준에 따라 해석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1103">The XML schema is interpreted according to the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1104">Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1104">Data corruption can occur if the msdata:DataType and the xs:type types do not match.</span></span> <span data-ttu-id="0238d-1105">예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1105">No exception will be thrown.</span></span>  
  
 <span data-ttu-id="0238d-1106">합니다 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1106">The `ReadXmlSchema` method is generally invoked before invoking the <xref:System.Data.DataTable.ReadXml%2A> method which is used to fill the <xref:System.Data.DataTable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1107">XML 스키마를 사용 하 여 중첩 된 관계를 만드는 방법은 암시적 중첩 된 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1107">The way to create a nested relation using XML schema is to have implicit nested elements.</span></span> <span data-ttu-id="0238d-1108">또한 중첩된 관계 명시적 열 이름을 사용 하도록 다시 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1108">Additionally, the nested relation could be re-wired, to use explicit column names.</span></span> <span data-ttu-id="0238d-1109">요소가 중첩된 관계에 참여 하려면 해당 Datatable에 대 한 암시적으로 중첩 될 수는 것이 반드시 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1109">It is mandatory for elements to be implicitly nested for the corresponding DataTables to participate in a nested relation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1110">다음 콘솔 응용 프로그램을 만듭니다 <xref:System.Data.DataTable>에 쓰고 해당 테이블에 대 한 스키마를 <xref:System.IO.MemoryStream>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1110">The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a <xref:System.IO.MemoryStream>.</span></span> <span data-ttu-id="0238d-1111">그런 다음 예제에서는 새 <xref:System.Data.DataTable> 하 고 저장된 된 XML 스키마에서 해당 스키마를 읽고 사용 하는 <xref:System.Xml.XmlTextReader> (에서 상속 하는 <xref:System.Xml.XmlReader>) 해당 원본으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1111">Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema, using a <xref:System.Xml.XmlTextReader> (which inherits from <xref:System.Xml.XmlReader>) as its source.</span></span>  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="0238d-1112">
            <see cref="T:System.Xml.XmlReader" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1112">A <see cref="T:System.Xml.XmlReader" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1113">XML 스트림에서 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1113">Reads from an XML stream.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberSignature Language="F#" Value="member this.RejectChanges : unit -&gt; unit" Usage="dataTable.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1114">테이블이 로드된 이후 또는 <see cref="M:System.Data.DataTable.AcceptChanges" />가 마지막으로 호출된 이후에 변경된 내용을 모두 롤백합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1114">Rolls back all changes that have been made to the table since it was loaded, or the last time <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1115">때 <xref:System.Data.DataTable.RejectChanges%2A> 가 호출 된 <xref:System.Data.DataRow> 아직 편집 모드에에서 있는 개체의 편집이 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1115">When <xref:System.Data.DataTable.RejectChanges%2A> is called, any <xref:System.Data.DataRow> objects that are still in edit-mode cancel their edits.</span></span> <span data-ttu-id="0238d-1116">새 행이 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1116">New rows are removed.</span></span> <span data-ttu-id="0238d-1117">사용 하 여 행을 <xref:System.Data.DataRowState> 로 설정 `Modified` 또는 `Deleted` 원래 상태로 다시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1117">Rows with the <xref:System.Data.DataRowState> set to `Modified` or `Deleted` return back to their original state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1118">다음 예제에서는 몇 가지 변경 내용에는 <xref:System.Data.DataTable>, 하지만 호출 하 여 변경 내용을 거부를 <xref:System.Data.DataTable.RejectChanges%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1118">The following example makes several changes to a <xref:System.Data.DataTable>, but rejects the changes by invoking the <xref:System.Data.DataTable.RejectChanges%2A> method.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1119">serialization 형식을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1119">Gets or sets the serialization format.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-1120">
            <see langword="Binary" /> 또는 <see langword="Xml" /> serialization을 지정하는 <see cref="T:System.Data.SerializationFormat" /> 열거형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1120">A <see cref="T:System.Data.SerializationFormat" /> enumeration specifying either <see langword="Binary" /> or <see langword="Xml" /> serialization.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataTable.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1121">
            <see cref="T:System.Data.DataTable" />을 원래 상태로 다시 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1121">Resets the <see cref="T:System.Data.DataTable" /> to its original state.</span>
          </span>
          <span data-ttu-id="0238d-1122">다시 설정은 테이블의 모든 데이터, 인덱스, 관계 및 열을 제거합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1122">Reset removes all data, indexes, relations, and columns of the table.</span>
          </span>
          <span data-ttu-id="0238d-1123">DataSet에 DataTable이 포함된 경우 테이블을 다시 설정한 후 테이블은 DataSet의 일부가 됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1123">If a DataSet includes a DataTable, the table will still be part of the DataSet after the table is reset.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberSignature Language="F#" Value="member this.RowChanged : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanged : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1124">
            <see cref="T:System.Data.DataRow" />가 변경된 후에 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1124">Occurs after a <see cref="T:System.Data.DataRow" /> has been changed successfully.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1125">자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1125">For more information, see [Handling DataTable Events](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).</span></span>  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberSignature Language="F#" Value="member this.RowChanging : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanging : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1126">
            <see cref="T:System.Data.DataRow" />가 변경될 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1126">Occurs when a <see cref="T:System.Data.DataRow" /> is changing.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1127">자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1127">For more information, see [Handling DataTable Events](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).</span></span>  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberSignature Language="F#" Value="member this.RowDeleted : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleted : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1128">테이블의 행이 삭제된 후 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1128">Occurs after a row in the table has been deleted.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1129">자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1129">For more information, see [Handling DataTable Events](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).</span></span>  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberSignature Language="F#" Value="member this.RowDeleting : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleting : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1130">테이블의 행이 삭제되기 직전에 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1130">Occurs before a row in the table is about to be deleted.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1131">자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1131">For more information, see [Handling DataTable Events](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).</span></span>  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Rows : System.Data.DataRowCollection" Usage="System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1132">이 테이블에 속한 행의 컬렉션을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1132">Gets the collection of rows that belong to this table.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-1133">
            <see cref="T:System.Data.DataRowCollection" /> 개체가 포함된 <see cref="T:System.Data.DataRow" />이거나, <see cref="T:System.Data.DataRow" /> 개체가 없으면 null 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1133">A <see cref="T:System.Data.DataRowCollection" /> that contains <see cref="T:System.Data.DataRow" /> objects; otherwise a null value if no <see cref="T:System.Data.DataRow" /> objects exist.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1134">새로 만들 <xref:System.Data.DataRow>를 사용 해야 합니다는 <xref:System.Data.DataTable.NewRow%2A> 새 개체를 반환 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1134">To create a new <xref:System.Data.DataRow>, you must use the <xref:System.Data.DataTable.NewRow%2A> method to return a new object.</span></span> <span data-ttu-id="0238d-1135">이러한 개체에 대해 정의 된 스키마에 따라 자동으로 구성 됩니다 합니다 <xref:System.Data.DataTable> 의 컬렉션을 통해 <xref:System.Data.DataColumn> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1135">Such an object is automatically configured according to the schema defined for the <xref:System.Data.DataTable> through its collection of <xref:System.Data.DataColumn> objects.</span></span> <span data-ttu-id="0238d-1136">새 행을 만들고 행의 각 열에 대 한 값을 설정 후 행을 추가 합니다 <xref:System.Data.DataRowCollection> 를 사용 하 여를 `Add` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1136">After creating a new row and setting the values for each column in the row, add the row to the <xref:System.Data.DataRowCollection> using the `Add` method.</span></span>  
  
 <span data-ttu-id="0238d-1137">각 <xref:System.Data.DataRow> 컬렉션에 있는 테이블의 데이터 행을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1137">Each <xref:System.Data.DataRow> in the collection represents a row of data in the table.</span></span> <span data-ttu-id="0238d-1138">행의 열 값으로 변경 내용을 커밋합니다을 호출 해야 합니다 <xref:System.Data.DataTable.AcceptChanges%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1138">To commit a change to the value of a column in the row, you must invoke the <xref:System.Data.DataTable.AcceptChanges%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1139">다음 반환 하 고 행을 설정 하는 두 가지 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1139">The following shows two examples of returning and setting rows.</span></span> <span data-ttu-id="0238d-1140">사용 하 여 첫 번째 예제는 <xref:System.Data.DataTable.Rows%2A> 속성 하 고 모든 행에 대 한 각 열의 값을 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1140">The first example uses the <xref:System.Data.DataTable.Rows%2A> property and prints the value of each column for every row.</span></span> <span data-ttu-id="0238d-1141">사용 하 여 두 번째 예제는 <xref:System.Data.DataTable> 개체의 <xref:System.Data.DataTable.NewRow%2A> 새 메서드 <xref:System.Data.DataRow> 의 스키마를 사용 하 여 개체를 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1141">The second example uses the <xref:System.Data.DataTable> object's <xref:System.Data.DataTable.NewRow%2A> method to create a new <xref:System.Data.DataRow> object with the schema of the <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="0238d-1142">행 값으로 설정한 후에 행이 추가 된 <xref:System.Data.DataRowCollection> 를 통해를 `Add` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1142">After setting the row values, the row is added to the <xref:System.Data.DataRowCollection> through the `Add` method.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1143">
            <see cref="T:System.Data.DataRow" /> 개체의 배열을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1143">Gets an array of <see cref="T:System.Data.DataRow" /> objects.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; System.Data.DataRow[]" Usage="dataTable.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1144">모든 <see cref="T:System.Data.DataRow" /> 개체의 배열을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1144">Gets an array of all <see cref="T:System.Data.DataRow" /> objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-1145">
            <see cref="T:System.Data.DataRow" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1145">An array of <see cref="T:System.Data.DataRow" /> objects.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1146">적절 한 정렬 순서를 지정 정렬 조건 <xref:System.Data.DataTable.Select%2A> 또는 <xref:System.Data.DataTable.Select%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1146">To ensure the proper sort order, specify sort criteria with <xref:System.Data.DataTable.Select%2A> or <xref:System.Data.DataTable.Select%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1147">다음 예제에서는 배열을 반환 <xref:System.Data.DataRow> 를 통해 개체를 <xref:System.Data.DataTable.Select%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1147">The following example returns an array of <xref:System.Data.DataRow> objects through the <xref:System.Data.DataTable.Select%2A> method.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberSignature Language="F#" Value="member this.Select : string -&gt; System.Data.DataRow[]" Usage="dataTable.Select filterExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">
          <span data-ttu-id="0238d-1148">행을 필터링하기 위해 사용하는 조건입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1148">The criteria to use to filter the rows.</span>
          </span>
          <span data-ttu-id="0238d-1149">예를 들어, 행을 필터링하는 방법은 [DataView RowFilter 구문 [C#]](http://www.csharp-examples.net/dataview-rowfilter/)을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1149">For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1150">필터 조건에 맞는 모든 <see cref="T:System.Data.DataRow" /> 개체의 배열을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1150">Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-1151">
            <see cref="T:System.Data.DataRow" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1151">An array of <see cref="T:System.Data.DataRow" /> objects.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1152">만들려면를 `filterExpression` 인수에 적용 되는 동일한 규칙을 사용 합니다 <xref:System.Data.DataColumn> 클래스의 <xref:System.Data.DataColumn.Expression%2A> 필터 만들기에 대 한 속성 값.</span><span class="sxs-lookup"><span data-stu-id="0238d-1152">To create the `filterExpression` argument, use the same rules that apply to the <xref:System.Data.DataColumn> class's <xref:System.Data.DataColumn.Expression%2A> property value for creating filters.</span></span>  
  
 <span data-ttu-id="0238d-1153">적절 한 정렬 순서를 지정 정렬 조건 <xref:System.Data.DataTable.Select%2A> 또는 <xref:System.Data.DataTable.Select%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1153">To ensure the proper sort order, specify sort criteria with <xref:System.Data.DataTable.Select%2A> or <xref:System.Data.DataTable.Select%2A>.</span></span>  
  
 <span data-ttu-id="0238d-1154">열 필터에 null 값이 있으면 결과 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1154">If the column on the filter contains a null value, it will not be part of the result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1155">배열을 반환 하도록 필터 식을 사용 하는 다음 예제에서는 <xref:System.Data.DataRow> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1155">The following example uses a filter expression to return an array of <xref:System.Data.DataRow> objects.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">
          <span data-ttu-id="0238d-1156">행을 필터링하기 위해 사용하는 조건입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1156">The criteria to use to filter the rows.</span>
          </span>
          <span data-ttu-id="0238d-1157">예를 들어, 행을 필터링하는 방법은 [DataView RowFilter 구문 [C#]](http://www.csharp-examples.net/dataview-rowfilter/)을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1157">For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</span>
          </span>
        </param>
        <param name="sort">
          <span data-ttu-id="0238d-1158">열과 정렬 방향을 지정하는 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1158">A string specifying the column and sort direction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1159">필터 조건에 맞는 모든 <see cref="T:System.Data.DataRow" /> 개체의 배열을 지정된 정렬 순서대로 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1159">Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter criteria, in the specified sort order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-1160">필터 식에 맞는 <see cref="T:System.Data.DataRow" /> 개체의 배열을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1160">An array of <see cref="T:System.Data.DataRow" /> objects matching the filter expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1161">폼에는 `filterExpression` 인수를 만들기에 대 한 동일한 규칙을 사용 합니다 <xref:System.Data.DataColumn> 클래스의 <xref:System.Data.DataColumn.Expression%2A> 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1161">To form the `filterExpression` argument, use the same rules for creating the <xref:System.Data.DataColumn> class's <xref:System.Data.DataColumn.Expression%2A> property value.</span></span> <span data-ttu-id="0238d-1162">합니다 `Sort` 클래스의 만들기에 대 한 인수 또한 사용 하 여 동일한 규칙 <xref:System.Data.DataColumn.Expression%2A> 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1162">The `Sort` argument also uses the same rules for creating class's <xref:System.Data.DataColumn.Expression%2A> strings.</span></span>  
  
 <span data-ttu-id="0238d-1163">열 필터에 null 값이 있으면 결과 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1163">If the column on the filter contains a null value, it will not be part of the result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1164">배열을 반환 하도록 필터 식을 사용 하는 다음 예제에서는 <xref:System.Data.DataRow> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1164">The following example uses a filter expression to return an array of <xref:System.Data.DataRow> objects.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string * System.Data.DataViewRowState -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort, recordStates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">
          <span data-ttu-id="0238d-1165">행을 필터링하기 위해 사용하는 조건입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1165">The criteria to use to filter the rows.</span>
          </span>
          <span data-ttu-id="0238d-1166">예를 들어, 행을 필터링하는 방법은 [DataView RowFilter 구문 [C#]](http://www.csharp-examples.net/dataview-rowfilter/)을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1166">For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</span>
          </span>
        </param>
        <param name="sort">
          <span data-ttu-id="0238d-1167">열과 정렬 방향을 지정하는 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1167">A string specifying the column and sort direction.</span>
          </span>
        </param>
        <param name="recordStates">
          <span data-ttu-id="0238d-1168">
            <see cref="T:System.Data.DataViewRowState" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1168">One of the <see cref="T:System.Data.DataViewRowState" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1169">필터와 일치하는 모든 <see cref="T:System.Data.DataRow" /> 개체의 배열을 지정된 상태와 일치하는 정렬 순서대로 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1169">Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter in the order of the sort that match the specified state.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-1170">
            <see cref="T:System.Data.DataRow" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1170">An array of <see cref="T:System.Data.DataRow" /> objects.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1171">폼에는 `filterExpression` 인수를 만들기에 대 한 동일한 규칙을 사용 합니다 <xref:System.Data.DataColumn> 클래스의 <xref:System.Data.DataColumn.Expression%2A> 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1171">To form the `filterExpression` argument, use the same rules for creating the <xref:System.Data.DataColumn> class's <xref:System.Data.DataColumn.Expression%2A> property value.</span></span> <span data-ttu-id="0238d-1172">합니다 `Sort` 클래스의 만들기에 대 한 인수 또한 사용 하 여 동일한 규칙 <xref:System.Data.DataColumn.Expression%2A> 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1172">The `Sort` argument also uses the same rules for creating class's <xref:System.Data.DataColumn.Expression%2A> strings.</span></span>  
  
 <span data-ttu-id="0238d-1173">열 필터에 null 값이 있으면 결과 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1173">If the column on the filter contains a null value, it will not be part of the result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1174">다음 예제에서는 필터 식과 레코드 상태를 사용 하 여 배열을 반환할 <xref:System.Data.DataRow> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1174">The following example uses a filter expression and record state to return an array of <xref:System.Data.DataRow> objects.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1175">
            <see cref="T:System.ComponentModel.ISite" />에 대한 <see cref="T:System.Data.DataTable" />를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1175">Gets or sets an <see cref="T:System.ComponentModel.ISite" /> for the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-1176">
            <see cref="T:System.ComponentModel.ISite" />에 대한 <see cref="T:System.Data.DataTable" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1176">An <see cref="T:System.ComponentModel.ISite" /> for the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1177">사이트 바인딩를 <xref:System.ComponentModel.Component> 에 <xref:System.ComponentModel.Container> 서로 통신할 수 있도록 할 뿐만 아니라 컨테이너에서 해당 구성 요소를 관리할 수 있는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1177">Sites bind a <xref:System.ComponentModel.Component> to a <xref:System.ComponentModel.Container> and enable communication between them, as well as provide a way for the container to manage its components.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1178">이 멤버에 대한 설명은 <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />를 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1178">For a description of this member, see <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-1179">해당 컬렉션이 <see cref="T:System.Collections.IList" /> 개체의 컬렉션이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1179">
              <see langword="true" /> if the collection is a collection of <see cref="T:System.Collections.IList" /> objects; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1180">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="0238d-1180">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0238d-1181"><xref:System.Data.DataTable> 인스턴스가 <xref:System.ComponentModel.IListSource> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1181">It can be used only when the <xref:System.Data.DataTable> instance is cast to an <xref:System.ComponentModel.IListSource> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1182">이 멤버에 대한 설명은 <see cref="M:System.ComponentModel.IListSource.GetList" />를 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1182">For a description of this member, see <see cref="M:System.ComponentModel.IListSource.GetList" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-1183">해당 개체에서 데이터 소스에 바인딩될 수 있는 <see cref="T:System.Collections.IList" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1183">An <see cref="T:System.Collections.IList" /> that can be bound to a data source from the object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1184">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="0238d-1184">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0238d-1185"><xref:System.Data.DataTable> 인스턴스가 <xref:System.ComponentModel.IListSource> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1185">It can be used only when the <xref:System.Data.DataTable> instance is cast to an <xref:System.ComponentModel.IListSource> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1186">이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />를 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1186">For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-1187">
            <see cref="T:System.Xml.Schema.XmlSchema" /> 메서드에 의해 생성되고 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> 메서드가 사용하는 개체의 XML 표현을 설명하는 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1187">An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1188">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="0238d-1188">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0238d-1189"><xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1189">It can be used only when the <xref:System.Data.DataSet> instance is cast to an <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="0238d-1190">XmlReader입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1190">An XmlReader.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1191">이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />를 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1191">For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1192">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="0238d-1192">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0238d-1193"><xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1193">It can be used only when the <xref:System.Data.DataSet> instance is cast to an <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1194">XmlWriter입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1194">An XmlWriter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1195">이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />를 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1195">For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1196">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="0238d-1196">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0238d-1197"><xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1197">It can be used only when the <xref:System.Data.DataSet> instance is cast to an <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberSignature Language="F#" Value="member this.TableCleared : System.Data.DataTableClearEventHandler " Usage="member this.TableCleared : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1198">
            <see cref="T:System.Data.DataTable" />이 지워진 다음 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1198">Occurs after a <see cref="T:System.Data.DataTable" /> is cleared.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1199">합니다 <xref:System.Data.DataTable.TableCleared> 이벤트는 모든 행이 성공적으로 지워진 전에 직후 발생 합니다.는 <xref:System.Data.DataTable.Clear%2A> 메서드 호출자에 게 컨트롤을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1199">The <xref:System.Data.DataTable.TableCleared> event is fired immediately after all rows have been successfully cleared but before the <xref:System.Data.DataTable.Clear%2A> method returns control back to the caller.</span></span> <span data-ttu-id="0238d-1200"><xref:System.Data.DataTable.TableCleared> 지우기 작업 하는 동안 모든 예외가 있는 경우 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1200">The <xref:System.Data.DataTable.TableCleared> event is not fired if there are any exceptions during the clear operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberSignature Language="F#" Value="member this.TableClearing : System.Data.DataTableClearEventHandler " Usage="member this.TableClearing : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1201">
            <see cref="T:System.Data.DataTable" />이 지워질 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1201">Occurs when a <see cref="T:System.Data.DataTable" /> is cleared.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1202"><xref:System.Data.DataTable.TableClearing> 이벤트가 처리 되기 전에 <xref:System.Data.DataTable.Clear%2A> 작업이 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1202">The <xref:System.Data.DataTable.TableClearing> event is fired before processing of the <xref:System.Data.DataTable.Clear%2A> operation begins.</span></span> <span data-ttu-id="0238d-1203">이 이벤트는 때를 <xref:System.Data.DataTable.Clear%2A> 테이블 0 개의 행을 포함 하는 경우에 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1203">This event is always fired when the <xref:System.Data.DataTable.Clear%2A> method is invoked, even if the table contains zero rows.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableTableNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1204">
            <see cref="T:System.Data.DataTable" />의 이름을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1204">Gets or sets the name of the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0238d-1205">
            <see cref="T:System.Data.DataTable" />의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1205">The name of the <see cref="T:System.Data.DataTable" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1206">합니다 <xref:System.Data.DataTable.TableName%2A> 부모에서이 테이블을 반환 하는 데 사용 됩니다 <xref:System.Data.DataSet> 개체의 <xref:System.Data.DataTableCollection> (반환한는 <xref:System.Data.DataSet.Tables%2A> 속성).</span><span class="sxs-lookup"><span data-stu-id="0238d-1206">The <xref:System.Data.DataTable.TableName%2A> is used to return this table from the parent <xref:System.Data.DataSet> object's <xref:System.Data.DataTableCollection> (returned by the <xref:System.Data.DataSet.Tables%2A> property).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1207">다음 예제에서는 인쇄 합니다 <xref:System.Data.DataTable.TableName%2A> 컬렉션의 각 테이블에 대해 <xref:System.Data.DataTable> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1207">The following example prints the <xref:System.Data.DataTable.TableName%2A> for each table in a collection of <xref:System.Data.DataTable> objects.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0238d-1208">
            <see langword="null" /> 또는 빈 문자열("")이 전달되고 이 테이블이 컬렉션에 속하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1208">
              <see langword="null" /> or empty string ("") is passed in and this table belongs to a collection.</span>
          </span>
        </exception>
        <exception cref="T:System.Data.DuplicateNameException">
          <span data-ttu-id="0238d-1209">같은 이름을 가진 테이블이 이미 들어 있는 컬렉션에 테이블이 속한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1209">The table belongs to a collection that already has a table with the same name.</span>
          </span>
          <span data-ttu-id="0238d-1210">비교 시 대/소문자가 구분됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1210">(Comparison is case-sensitive).</span>
          </span>
        </exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberSignature Language="F#" Value="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " Usage="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1211">새 <see cref="T:System.Data.DataRow" />가 삽입될 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1211">Occurs when a new <see cref="T:System.Data.DataRow" /> is inserted.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1212">새 한 후에 발생 <xref:System.Data.DataRow> 사용 하 여 만들어진 <xref:System.Data.DataTable.NewRow%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1212">Fires after a new <xref:System.Data.DataRow> has been created using <xref:System.Data.DataTable.NewRow%2A>.</span></span> <span data-ttu-id="0238d-1213">이 이벤트가 발생 하기 전에 호출 된 `NewRow` 메서드 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1213">This event is fired before the invoked `NewRow` method returns.</span></span> <span data-ttu-id="0238d-1214">새 <xref:System.Data.DataRow> 인스턴스는 분리 되어; 컬렉션에 추가하지 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1214">The new <xref:System.Data.DataRow> instance is detached; it has not been added to the collection.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="dataTable.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1215">연결된 문자열이 있는 경우 <see cref="P:System.Data.DataTable.TableName" /> 및 <see cref="P:System.Data.DataTable.DisplayExpression" />을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1215">Gets the <see cref="P:System.Data.DataTable.TableName" /> and <see cref="P:System.Data.DataTable.DisplayExpression" />, if there is one as a concatenated string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0238d-1216">
            <see cref="P:System.Data.DataTable.TableName" /> 및 <see cref="P:System.Data.DataTable.DisplayExpression" /> 값으로 구성된 문자열을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1216">A string consisting of the <see cref="P:System.Data.DataTable.TableName" /> and the <see cref="P:System.Data.DataTable.DisplayExpression" /> values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1217">가져옵니다 합니다 <xref:System.Data.DataTable.TableName%2A> 하 고 <xref:System.Data.DataTable.DisplayExpression%2A> 에 대 한는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1217">Gets the <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.DisplayExpression%2A> for the <xref:System.Data.DataTable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1218">다음 예제에서는 반환 된 <xref:System.Data.DataTable.TableName%2A> 및 <xref:System.Data.DataTable.DisplayExpression%2A> 사용 하 여를 <xref:System.Data.DataTable.ToString%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1218">The following example returns the <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.DisplayExpression%2A> using the <xref:System.Data.DataTable.ToString%2A> method.</span></span>  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1219">
            <see cref="T:System.Data.DataTable" />의 현재 내용을 XML로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1219">Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1220">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1220">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1221">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1221">To write both data and schema, use one of the overloads that include the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1222">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1222">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1223">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1223">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1224">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1224">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1225"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1225">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1226">다음 콘솔 응용 프로그램 두 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스, 각 추가 <xref:System.Data.DataSet>를 만듭니다를 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 는부모테이블내에포함된데이터를쓸메서드<xref:System.IO.TextWriter>.</span><span class="sxs-lookup"><span data-stu-id="0238d-1226">The following console application creates two <xref:System.Data.DataTable> instances, adds each to a <xref:System.Data.DataSet>, creates a <xref:System.Data.DataRelation> relating the two tables, and then uses the <xref:System.Data.DataTable.WriteXml%2A> method to write the data contained within the parent table to a <xref:System.IO.TextWriter>.</span></span> <span data-ttu-id="0238d-1227">이 예제에서는 설정 하는 경우 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1227">The example demonstrates the behavior when setting the `writeHierarchy` parameter to each of its values.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1228">이 예제에서는 WriteXml의 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1228">This example shows how to use one of the overloaded versions of WriteXml.</span></span> <span data-ttu-id="0238d-1229">사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="0238d-1229">For other examples that might be available, see the individual overload topics.</span></span>  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 <span data-ttu-id="0238d-1230">이 예제에서는 콘솔 창에 다음 출력을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1230">The example displays the following output in the console window:</span></span>  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="0238d-1231">데이터가 기록될 스트림입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1231">The stream to which the data will be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1232">지정된 <see cref="T:System.IO.Stream" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1232">Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.Stream" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1233">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1233">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1234">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1234">To write both data and schema, use one of the overloads that includes the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1235">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1235">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1236">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1236">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1237">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1237">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1238"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1238">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1239">콘텐츠를 쓰는 데 사용할 <see cref="T:System.IO.TextWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1239">The <see cref="T:System.IO.TextWriter" /> with which to write the content.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1240">지정된 <see cref="T:System.IO.TextWriter" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1240">Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.TextWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1241">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1241">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1242">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1242">To write both data and schema, use one of the overloads that includes the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1243">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1243">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1244">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1244">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1245">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1245">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1246"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1246">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataTable.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0238d-1247">XML 데이터를 기록할 파일입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1247">The file to which to write the XML data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1248">지정된 파일을 사용하여 <see cref="T:System.Data.DataTable" />의 현재 내용을 XML로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1248">Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1249">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1249">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1250">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1250">To write both data and schema, use one of the overloads that includes the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1251">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1251">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1252">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1252">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1253">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1253">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1254"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1254">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1255">내용을 기록하는 데 사용할 <see cref="T:System.Xml.XmlWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1255">The <see cref="T:System.Xml.XmlWriter" /> with which to write the contents.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1256">지정된 <see cref="T:System.Xml.XmlWriter" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1256">Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1257">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1257">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1258">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1258">To write both data and schema, use one of the overloads that include the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1259">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1259">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1260">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1260">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1261">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1261">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1262"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1262">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXml (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="0238d-1263">데이터가 기록될 스트림입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1263">The stream to which the data will be written.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1264">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1264">If <see langword="true" />, write the contents of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1265">
            <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1265">If <see langword="false" /> (the default value), write the data for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1266">지정된 <see cref="T:System.IO.Stream" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1266">Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.Stream" />.</span>
          </span>
          <span data-ttu-id="0238d-1267">테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1267">To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1268">사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1268">Use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the schema for a <xref:System.Data.DataTable> to an XML document.</span></span> <span data-ttu-id="0238d-1269">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1269">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1270">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1270">The XML schema is written using the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1271">XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1271">To write the data to an XML document, use the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-1272">일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1272">Normally the `WriteXml` method writes the data only for the current table.</span></span> <span data-ttu-id="0238d-1273">관련 테이블이 현재 테이블과 모든 하위 항목에 대 한 데이터를 쓰는 데 사용 하 여 메서드를 호출 합니다는 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1273">To write the data for the current table and all of its descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1274"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1274">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="0238d-1275">데이터가 기록될 스트림입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1275">The stream to which the data will be written.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="0238d-1276">
            <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1276">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1277">지정된 <see cref="T:System.Data.DataTable" />를 사용하여 지정된 파일에 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1277">Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> to the specified file using the specified <see cref="T:System.Data.XmlWriteMode" />.</span>
          </span>
          <span data-ttu-id="0238d-1278">스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1278">To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1279">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1279">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1280">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1280">To write both data and schema, use one of the overloads that includes the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1281">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1281">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1282">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1282">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1283">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1283">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1284"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1284">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1285">콘텐츠를 쓰는 데 사용할 <see cref="T:System.IO.TextWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1285">The <see cref="T:System.IO.TextWriter" /> with which to write the content.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1286">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1286">If <see langword="true" />, write the contents of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1287">
            <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1287">If <see langword="false" /> (the default value), write the data for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1288">지정된 <see cref="T:System.IO.TextWriter" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1288">Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.TextWriter" />.</span>
          </span>
          <span data-ttu-id="0238d-1289">테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1289">To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1290">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1290">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1291">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1291">To write both data and schema, use one of the overloads that includes the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1292">일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1292">Normally the `WriteXml` method writes the data only for the current table.</span></span> <span data-ttu-id="0238d-1293">현재 테이블과 모든 하위 항목, 관련 테이블에 대 한 데이터를 작성 하려면 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1293">To write the data for the current table and all its descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1294"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1294">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1295">다음 콘솔 응용 프로그램 두 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스, 각 추가 <xref:System.Data.DataSet>를 만듭니다를 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 는부모테이블내에포함된데이터를쓸메서드<xref:System.IO.TextWriter>.</span><span class="sxs-lookup"><span data-stu-id="0238d-1295">The following console application creates two <xref:System.Data.DataTable> instances, adds each to a <xref:System.Data.DataSet>, creates a <xref:System.Data.DataRelation> relating the two tables, and then uses the <xref:System.Data.DataTable.WriteXml%2A> method to write the data contained within the parent table to a <xref:System.IO.TextWriter>.</span></span> <span data-ttu-id="0238d-1296">이 예제에서는 설정 하는 경우 동작을 보여 줍니다 합니다 `writeHierarchy` 매개 변수를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1296">The example demonstrates the behavior when setting the `writeHierarchy` parameter to `true`.</span></span>  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1297">문서를 쓰는 데 사용되는 <see cref="T:System.IO.TextWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1297">The <see cref="T:System.IO.TextWriter" /> used to write the document.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="0238d-1298">
            <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1298">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1299">지정된 <see cref="T:System.Data.DataTable" />와 <see cref="T:System.IO.TextWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1299">Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextWriter" /> and <see cref="T:System.Data.XmlWriteMode" />.</span>
          </span>
          <span data-ttu-id="0238d-1300">스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1300">To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1301">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1301">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1302">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1302">To write both data and schema, use one of the overloads that includes the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1303">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1303">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1304">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1304">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1305">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1305">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1306"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1306">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0238d-1307">XML 데이터를 기록할 파일입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1307">The file to which to write the XML data.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1308">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1308">If <see langword="true" />, write the contents of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1309">
            <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1309">If <see langword="false" /> (the default value), write the data for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1310">지정된 파일을 사용하여 <see cref="T:System.Data.DataTable" />의 현재 내용을 XML로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1310">Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified file.</span>
          </span>
          <span data-ttu-id="0238d-1311">테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1311">To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1312">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1312">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1313">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1313">To write both data and schema, use one of the overloads that includes the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1314">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1314">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1315">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1315">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1316">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1316">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
 <span data-ttu-id="0238d-1317">일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1317">Normally the `WriteXml` method writes the data only for the current table.</span></span> <span data-ttu-id="0238d-1318">관련 테이블이 현재 테이블과 모든 하위 항목에 대 한 데이터를 쓰는 데 사용 하 여 메서드를 호출 합니다는 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1318">To write the data for the current table and all of its descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1319"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1319">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0238d-1320">데이터가 기록될 파일의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1320">The name of the file to which the data will be written.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="0238d-1321">
            <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1321">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1322">지정된 파일과 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />에 대해 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1322">Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified file and <see cref="T:System.Data.XmlWriteMode" />.</span>
          </span>
          <span data-ttu-id="0238d-1323">스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1323">To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1324">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1324">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1325">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1325">To write both data and schema, use one of the overloads that include the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1326">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1326">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1327">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1327">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1328">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1328">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1329"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1329">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1330">내용을 기록하는 데 사용할 <see cref="T:System.Xml.XmlWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1330">The <see cref="T:System.Xml.XmlWriter" /> with which to write the contents.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1331">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1331">If <see langword="true" />, write the contents of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1332">
            <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1332">If <see langword="false" /> (the default value), write the data for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1333">지정된 <see cref="T:System.Xml.XmlWriter" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1333">Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1334">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1334">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1335">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1335">To write both data and schema, use one of the overloads that include the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1336">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1336">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1337">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1337">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1338">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1338">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
 <span data-ttu-id="0238d-1339">일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1339">Normally the `WriteXml` method writes the data only for the current table.</span></span> <span data-ttu-id="0238d-1340">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체 데이터를 작성 하려면 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1340">To write the data for the current table and its entire descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1341"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1341">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1342">문서를 쓰는 데 사용되는 <see cref="T:System.Xml.XmlWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1342">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="0238d-1343">
            <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1343">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1344">지정된 <see cref="T:System.Data.DataTable" />와 <see cref="T:System.Xml.XmlWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1344">Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlWriter" /> and <see cref="T:System.Data.XmlWriteMode" />.</span>
          </span>
          <span data-ttu-id="0238d-1345">스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1345">To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1346">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1346">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1347">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1347">To write both data and schema, use one of the overloads that include the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1348">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1348">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1349">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1349">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1350">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1350">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1351"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1351">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (stream, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="0238d-1352">데이터가 기록될 스트림입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1352">The stream to which the data will be written.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="0238d-1353">
            <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1353">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1354">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1354">If <see langword="true" />, write the contents of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1355">
            <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1355">If <see langword="false" /> (the default value), write the data for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1356">지정된 <see cref="T:System.Data.DataTable" />를 사용하여 지정된 파일에 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1356">Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> to the specified file using the specified <see cref="T:System.Data.XmlWriteMode" />.</span>
          </span>
          <span data-ttu-id="0238d-1357">스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1357">To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</span>
          </span>
          <span data-ttu-id="0238d-1358">테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1358">To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1359">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 `DataTable` XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1359">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a `DataTable` into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1360">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 `XmlWriteMode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1360">To write both data and schema, use one of the overloads that includes the `XmlWriteMode` parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1361">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1361">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1362">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1362">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1363">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1363">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
 <span data-ttu-id="0238d-1364">일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터만 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1364">Normally, the `WriteXml` method saves data only for the current table.</span></span> <span data-ttu-id="0238d-1365">합니다 `WriteXml` 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 `DataTable` XML 문서로 반면는 `WriteXmlSchema` 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1365">The `WriteXml` method provides a way to write either data only, or both data and schema from a `DataTable` into an XML document, whereas the `WriteXmlSchema` method writes only the schema.</span></span> <span data-ttu-id="0238d-1366">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 `XmlWriteMode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1366">To write both data and schema, use one of the overloads that includes the `XmlWriteMode` parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1367">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1367">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1368">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1368">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1369">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1369">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
 <span data-ttu-id="0238d-1370">일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1370">Normally the `WriteXml` method writes the data only for the current table.</span></span> <span data-ttu-id="0238d-1371">관련 테이블이 현재 테이블과 모든 하위 항목에 대 한 데이터를 쓰는 데 사용 하 여 메서드를 호출 합니다는 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1371">To write the data for the current table and all of its descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1372"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1372">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1373">문서를 쓰는 데 사용되는 <see cref="T:System.IO.TextWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1373">The <see cref="T:System.IO.TextWriter" /> used to write the document.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="0238d-1374">
            <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1374">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1375">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1375">If <see langword="true" />, write the contents of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1376">
            <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1376">If <see langword="false" /> (the default value), write the data for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1377">지정된 <see cref="T:System.Data.DataTable" />와 <see cref="T:System.IO.TextWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1377">Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextWriter" /> and <see cref="T:System.Data.XmlWriteMode" />.</span>
          </span>
          <span data-ttu-id="0238d-1378">스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1378">To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</span>
          </span>
          <span data-ttu-id="0238d-1379">테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1379">To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1380">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1380">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1381">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1381">To write both data and schema, use one of the overloads that includes the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1382">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1382">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1383">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1383">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1384">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1384">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
 <span data-ttu-id="0238d-1385">일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터만 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1385">Normally, the `WriteXml` method saves data only for the current table.</span></span> <span data-ttu-id="0238d-1386">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1386">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1387">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1387">To write both data and schema, use one of the overloads that includes the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1388">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1388">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1389">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1389">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1390">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1390">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
 <span data-ttu-id="0238d-1391">일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1391">Normally the `WriteXml` method writes the data only for the current table.</span></span> <span data-ttu-id="0238d-1392">관련 테이블이 현재 테이블과 모든 하위 항목에 대 한 데이터를 쓰는 데 사용 하 여 메서드를 호출 합니다는 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1392">To write the data for the current table and all of its descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1393"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1393">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1394">다음 콘솔 응용 프로그램 두 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스, 각 추가 <xref:System.Data.DataSet>를 만듭니다를 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 는부모테이블내에포함된데이터를쓸메서드<xref:System.IO.TextWriter>.</span><span class="sxs-lookup"><span data-stu-id="0238d-1394">The following console application creates two <xref:System.Data.DataTable> instances, adds each to a <xref:System.Data.DataSet>, creates a <xref:System.Data.DataRelation> relating the two tables, and then uses the <xref:System.Data.DataTable.WriteXml%2A> method to write the data contained within the parent table to a <xref:System.IO.TextWriter>.</span></span> <span data-ttu-id="0238d-1395">이 예제에서는 설정 하는 경우 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1395">The example demonstrates the behavior when setting the `writeHierarchy` parameter to each of its values.</span></span>  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 <span data-ttu-id="0238d-1396">이 예제에서는 콘솔 창에 다음 출력을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1396">The example displays the following output in the console window:</span></span>  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0238d-1397">데이터가 기록될 파일의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1397">The name of the file to which the data will be written.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="0238d-1398">
            <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1398">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1399">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1399">If <see langword="true" />, write the contents of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1400">
            <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1400">If <see langword="false" /> (the default value), write the data for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1401">지정된 파일과 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />에 대해 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1401">Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified file and <see cref="T:System.Data.XmlWriteMode" />.</span>
          </span>
          <span data-ttu-id="0238d-1402">스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1402">To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</span>
          </span>
          <span data-ttu-id="0238d-1403">테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1403">To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1404">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1404">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1405">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1405">To write both data and schema, use one of the overloads that include the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1406">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1406">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1407">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1407">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1408">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1408">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
 <span data-ttu-id="0238d-1409">일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터만 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1409">Normally, the `WriteXml` method saves data only for the current table.</span></span> <span data-ttu-id="0238d-1410">현재 테이블 및 스키마의 모든 데이터를 저장 하려는 경우는 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1410">If you want to save the data for the current table and all of schema, the <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1411">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1411">To write both data and schema, use one of the overloads that include the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1412">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1412">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1413">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1413">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1414">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1414">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
 <span data-ttu-id="0238d-1415">일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1415">Normally the `WriteXml` method writes the data only for the current table.</span></span> <span data-ttu-id="0238d-1416">에 현재 테이블과 모든 하위 항목, 관련 테이블에 대 한 데이터 쓰기를 사용 하 여 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1416">To write the data for the current table and all descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1417"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1417">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1418">문서를 쓰는 데 사용되는 <see cref="T:System.Xml.XmlWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1418">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="0238d-1419">
            <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1419">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1420">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1420">If <see langword="true" />, write the contents of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1421">
            <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1421">If <see langword="false" /> (the default value), write the data for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1422">지정된 <see cref="T:System.Data.DataTable" />와 <see cref="T:System.Xml.XmlWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1422">Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlWriter" /> and <see cref="T:System.Data.XmlWriteMode" />.</span>
          </span>
          <span data-ttu-id="0238d-1423">스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1423">To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</span>
          </span>
          <span data-ttu-id="0238d-1424">테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1424">To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1425">합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1425">The <xref:System.Data.DataTable.WriteXml%2A> method provides a way to write either data only, or both data and schema from a <xref:System.Data.DataTable> into an XML document, whereas the <xref:System.Data.DataTable.WriteXmlSchema%2A> method writes only the schema.</span></span> <span data-ttu-id="0238d-1426">데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1426">To write both data and schema, use one of the overloads that include the <xref:System.Data.XmlWriteMode> parameter, and set its value to `WriteSchema`.</span></span>  
  
 <span data-ttu-id="0238d-1427">True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="0238d-1427">Note that the same is true for the <xref:System.Data.DataTable.ReadXml%2A> and <xref:System.Data.DataTable.ReadXmlSchema%2A> methods, respectively.</span></span> <span data-ttu-id="0238d-1428">XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1428">To read XML data, or both schema and data into the `DataTable`, use the `ReadXml` method.</span></span> <span data-ttu-id="0238d-1429">스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1429">To read just the schema, use the `ReadXmlSchema` method.</span></span>  
  
 <span data-ttu-id="0238d-1430">일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1430">Normally the `WriteXml` method writes the data only for the current table.</span></span> <span data-ttu-id="0238d-1431">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체 데이터를 작성 하려면 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1431">To write the data for the current table and its entire descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1432"><xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1432">An <xref:System.InvalidOperationException> will be thrown if a column type in the `DataRow` being read from or written to implements <xref:System.Dynamic.IDynamicMetaObjectProvider> and does not implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0238d-1433">
            <see cref="T:System.Data.DataTable" />의 현재 데이터 구조를 XML 스키마로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1433">Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1434">사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1434">Use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the schema for a <xref:System.Data.DataTable> to an XML document.</span></span> <span data-ttu-id="0238d-1435">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1435">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1436">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1436">The XML schema is written using the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1437">XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1437">To write the data to an XML document, use the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1438">다음 콘솔 응용 프로그램 두 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스, 각 추가 <xref:System.Data.DataSet>를 만듭니다를 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 는부모테이블내에포함된데이터를쓸메서드<xref:System.IO.TextWriter>.</span><span class="sxs-lookup"><span data-stu-id="0238d-1438">The following console application creates two <xref:System.Data.DataTable> instances, adds each to a <xref:System.Data.DataSet>, creates a <xref:System.Data.DataRelation> relating the two tables, and then uses the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the data contained within the parent table to a <xref:System.IO.TextWriter>.</span></span> <span data-ttu-id="0238d-1439">이 예제에서는 설정 하는 경우 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1439">The example demonstrates the behavior when setting the `writeHierarchy` parameter to each of its values.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0238d-1440">이 예제에서는 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다 `WriteXmlSchema` 다른 예제를 사용할 수 있는 오버 로드 개별 항목을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1440">This example shows how to use one of the overloaded versions of `WriteXmlSchema` For other examples that might be available, see the individual overload topics.</span></span>  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 <span data-ttu-id="0238d-1441">이 예제에서는 콘솔 창에 다음 출력을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1441">The example displays the following output in the console window:</span></span>  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="0238d-1442">XML 스키마가 기록될 스트림입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1442">The stream to which the XML schema will be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1443">
            <see cref="T:System.Data.DataTable" />의 현재 데이터 구조를 지정된 스트림에 XMl 스키마로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1443">Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1444">사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1444">Use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the schema for a <xref:System.Data.DataTable> to an XML document.</span></span> <span data-ttu-id="0238d-1445">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1445">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1446">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1446">The XML schema is written using the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1447">XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1447">To write the data to an XML document, use the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1448">쓰기에 사용할 <see cref="T:System.IO.TextWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1448">The <see cref="T:System.IO.TextWriter" /> with which to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1449">지정된 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.IO.TextWriter" />의 현재 데이터 구조를 XML 스키마로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1449">Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.IO.TextWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1450">사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1450">Use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the schema for a <xref:System.Data.DataTable> to an XML document.</span></span> <span data-ttu-id="0238d-1451">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1451">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1452">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1452">The XML schema is written using the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1453">XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1453">To write the data to an XML document, use the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataTable.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0238d-1454">사용할 파일의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1454">The name of the file to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1455">
            <see cref="T:System.Data.DataTable" />의 현재 데이터 구조를 지정된 파일에 XML 스키마로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1455">Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1456">사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1456">Use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the schema for a <xref:System.Data.DataTable> to an XML document.</span></span> <span data-ttu-id="0238d-1457">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1457">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1458">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1458">The XML schema is written using the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1459">XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1459">To write the data to an XML document, use the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1460">사용할 <see cref="T:System.Xml.XmlWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1460">The <see cref="T:System.Xml.XmlWriter" /> to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1461">지정된 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.Xml.XmlWriter" />의 현재 데이터 구조를 XML 스키마로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1461">Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1462">사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1462">Use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the schema for a <xref:System.Data.DataTable> to an XML document.</span></span> <span data-ttu-id="0238d-1463">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1463">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1464">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1464">The XML schema is written using the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1465">XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1465">To write the data to an XML document, use the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="0238d-1466">XML 스키마가 기록될 스트림입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1466">The stream to which the XML schema will be written.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1467">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1467">If <see langword="true" />, write the schema of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1468">
            <see langword="false" />(기본값)이면 현재 테이블의 스키마만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1468">If <see langword="false" /> (the default value), write the schema for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1469">
            <see cref="T:System.Data.DataTable" />의 현재 데이터 구조를 지정된 스트림에 XMl 스키마로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1469">Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified stream.</span>
          </span>
          <span data-ttu-id="0238d-1470">테이블과 모든 하위 항목의 스키마를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1470">To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1471">사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1471">Use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the schema for a <xref:System.Data.DataTable> to an XML document.</span></span> <span data-ttu-id="0238d-1472">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1472">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1473">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1473">The XML schema is written using the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1474">XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1474">To write the data to an XML document, use the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-1475">일반적으로 `WriteXmlSchema` 메서드는 현재 테이블의 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1475">Normally the `WriteXmlSchema` method writes the schema only for the current table.</span></span> <span data-ttu-id="0238d-1476">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1476">To write the schema for the current table and its entire descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1477">쓰기에 사용할 <see cref="T:System.IO.TextWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1477">The <see cref="T:System.IO.TextWriter" /> with which to write.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1478">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1478">If <see langword="true" />, write the schema of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1479">
            <see langword="false" />(기본값)이면 현재 테이블의 스키마만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1479">If <see langword="false" /> (the default value), write the schema for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1480">지정된 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.IO.TextWriter" />의 현재 데이터 구조를 XML 스키마로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1480">Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.IO.TextWriter" />.</span>
          </span>
          <span data-ttu-id="0238d-1481">테이블과 모든 하위 항목의 스키마를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1481">To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1482">사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1482">Use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the schema for a <xref:System.Data.DataTable> to an XML document.</span></span> <span data-ttu-id="0238d-1483">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1483">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1484">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1484">The XML schema is written using the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1485">XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1485">To write the data to an XML document, use the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-1486">일반적으로 `WriteXmlSchema` 메서드는 현재 테이블의 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1486">Normally the `WriteXmlSchema` method writes the schema only for the current table.</span></span> <span data-ttu-id="0238d-1487">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1487">To write the schema for the current table and its entire descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0238d-1488">다음 콘솔 응용 프로그램 두 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스, 각 추가 <xref:System.Data.DataSet>를 만듭니다를 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 는부모테이블내에포함된데이터를쓸메서드<xref:System.IO.TextWriter>.</span><span class="sxs-lookup"><span data-stu-id="0238d-1488">The following console application creates two <xref:System.Data.DataTable> instances, adds each to a <xref:System.Data.DataSet>, creates a <xref:System.Data.DataRelation> relating the two tables, and then uses the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the data contained within the parent table to a <xref:System.IO.TextWriter>.</span></span> <span data-ttu-id="0238d-1489">이 예제에서는 설정 하는 경우 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1489">The example demonstrates the behavior when setting the `writeHierarchy` parameter to each of its values.</span></span>  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 <span data-ttu-id="0238d-1490">이 예제에서는 콘솔 창에 다음 출력을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1490">The example displays the following output in the console window:</span></span>  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0238d-1491">사용할 파일의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1491">The name of the file to use.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1492">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1492">If <see langword="true" />, write the schema of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1493">
            <see langword="false" />(기본값)이면 현재 테이블의 스키마만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1493">If <see langword="false" /> (the default value), write the schema for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1494">
            <see cref="T:System.Data.DataTable" />의 현재 데이터 구조를 지정된 파일에 XML 스키마로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1494">Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified file.</span>
          </span>
          <span data-ttu-id="0238d-1495">테이블과 모든 하위 항목의 스키마를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1495">To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1496">사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1496">Use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the schema for a <xref:System.Data.DataTable> to an XML document.</span></span> <span data-ttu-id="0238d-1497">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1497">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1498">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1498">The XML schema is written using the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1499">XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1499">To write the data to an XML document, use the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-1500">일반적으로 `WriteXmlSchema` 메서드는 현재 테이블의 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1500">Normally the `WriteXmlSchema` method writes the schema only for the current table.</span></span> <span data-ttu-id="0238d-1501">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1501">To write the schema for the current table and its entire descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="0238d-1502">문서를 쓰는 데 사용되는 <see cref="T:System.Xml.XmlWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1502">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</span>
          </span>
        </param>
        <param name="writeHierarchy">
          <span data-ttu-id="0238d-1503">
            <see langword="true" />이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1503">If <see langword="true" />, write the schema of the current table and all its descendants.</span>
          </span>
          <span data-ttu-id="0238d-1504">
            <see langword="false" />(기본값)이면 현재 테이블의 스키마만 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1504">If <see langword="false" /> (the default value), write the schema for the current table only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0238d-1505">지정된 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.Xml.XmlWriter" />의 현재 데이터 구조를 XML 스키마로 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1505">Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
          <span data-ttu-id="0238d-1506">테이블과 모든 하위 항목의 스키마를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0238d-1506">To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0238d-1507">사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1507">Use the <xref:System.Data.DataTable.WriteXmlSchema%2A> method to write the schema for a <xref:System.Data.DataTable> to an XML document.</span></span> <span data-ttu-id="0238d-1508">스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1508">The schema includes table, relation, and constraint definitions.</span></span>  
  
 <span data-ttu-id="0238d-1509">XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1509">The XML schema is written using the XSD standard.</span></span>  
  
 <span data-ttu-id="0238d-1510">XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0238d-1510">To write the data to an XML document, use the <xref:System.Data.DataTable.WriteXml%2A> method.</span></span>  
  
 <span data-ttu-id="0238d-1511">일반적으로 `WriteXmlSchema` 메서드는 현재 테이블의 스키마만 씁니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1511">Normally the `WriteXmlSchema` method writes the schema only for the current table.</span></span> <span data-ttu-id="0238d-1512">현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0238d-1512">To write the schema for the current table and its entire descendant, related tables, call the method with the `writeHierarchy` parameter set to `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>