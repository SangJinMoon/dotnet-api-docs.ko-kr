<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="BindingOperations.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b6d6ad02d9cad5d3fea47f68a5d2f16bfb2f4a51.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b6d6ad02d9cad5d3fea47f68a5d2f16bfb2f4a51</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.Data.BindingOperations">
          <source>Provides static methods to manipulate bindings, including <ph id="ph1">&lt;see cref="T:System.Windows.Data.Binding" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Windows.Data.MultiBinding" /&gt;</ph>, and <ph id="ph3">&lt;see cref="T:System.Windows.Data.PriorityBinding" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Data.Binding" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Windows.Data.MultiBinding" /&gt;</ph> 및 <ph id="ph3">&lt;see cref="T:System.Windows.Data.PriorityBinding" /&gt;</ph> 개체를 비롯하여 바인딩을 조작하는 정적 메서드를 제공합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>This class exposes a set of static methods that serve as helper operations for data bindings.</source>
          <target state="translated">이 클래스에 대 한 데이터 바인딩의 도우미 작업으로 사용 하는 정적 메서드 집합을 노출 합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.AccessCollection(System.Collections.IEnumerable,System.Action,System.Boolean)">
          <source>The collection to access.</source>
          <target state="translated">액세스할 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.AccessCollection(System.Collections.IEnumerable,System.Action,System.Boolean)">
          <source>The action to perform on the collection.</source>
          <target state="translated">컬렉션에 수행할 작업입니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.AccessCollection(System.Collections.IEnumerable,System.Action,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>accessMethod<ept id="p1">&lt;/c&gt;</ept> will write to the collection; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>accessMethod<ept id="p1">&lt;/c&gt;</ept>가 컬렉션에 쓰면 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.AccessCollection(System.Collections.IEnumerable,System.Action,System.Boolean)">
          <source>Provides access to a collection by using the synchronization mechanism that the application specified when it called EnableCollectionSynchronization.</source>
          <target state="translated">EnableCollectionSynchronization으로 호출되면 응용 프로그램에서 지정한 동기화 메커니즘을 사용하여 컬렉션에 대한 액세스 권한을 부여합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.ClearAllBindings(System.Windows.DependencyObject)">
          <source>The object from which to remove bindings.</source>
          <target state="translated">바인딩을 제거할 개체입니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.ClearAllBindings(System.Windows.DependencyObject)">
          <source>Removes all bindings, including bindings of type <ph id="ph1">&lt;see cref="T:System.Windows.Data.Binding" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Windows.Data.MultiBinding" /&gt;</ph>, and <ph id="ph3">&lt;see cref="T:System.Windows.Data.PriorityBinding" /&gt;</ph>, from the specified <ph id="ph4">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph4">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>에서 <ph id="ph1">&lt;see cref="T:System.Windows.Data.Binding" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Windows.Data.MultiBinding" /&gt;</ph> 및 <ph id="ph3">&lt;see cref="T:System.Windows.Data.PriorityBinding" /&gt;</ph> 형식의 바인딩을 포함한 모든 바인딩을 제거합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.ClearAllBindings(System.Windows.DependencyObject)">
          <source>If the specified object is not data-bound, this method has no effect.</source>
          <target state="translated">지정된 된 개체 데이터 바인딩된 없으면이 메서드는 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.ClearAllBindings(System.Windows.DependencyObject)">
          <source>If <ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>이 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우입니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The object from which to remove the binding.</source>
          <target state="translated">바인딩을 제거할 개체입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The dependency property from which to remove the binding.</source>
          <target state="translated">바인딩을 제거할 종속성 속성입니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>Removes the binding from a property if there is one.</source>
          <target state="translated">있는 경우 속성에서 바인딩을 제거합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>If the given property is data-bound with a <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph>, this method removes the corresponding binding expression and restores the value of the property to what it was before any local value was set through the binding.</source>
          <target state="translated">지정된 된 속성은 데이터 바인딩 사용 하는 경우는 <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>, 또는 <ph id="ph3">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph>,이 메서드는 해당 바인딩 식 및 바인딩을 통해 전에 지역 값 속성의 값이 설정으로 복원 제거 합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>If the given property is not data-bound, this method has no effect.</source>
          <target state="translated">지정된 된 속성 데이터 바인딩된 없으면이 메서드는 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> and <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> parameters cannot be <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 매개 변수는 <ph id="ph3">&lt;see langword="null" /&gt;</ph>일 수 없습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="E:System.Windows.Data.BindingOperations.CollectionRegistering">
          <source>Occurs when the data-binding system notices a collection.</source>
          <target state="translated">데이터 바인딩 시스템에서 컬렉션을 통지하는 경우 발생합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="E:System.Windows.Data.BindingOperations.CollectionViewRegistering">
          <source>Occurs when the data-binding system notices a collection view.</source>
          <target state="translated">데이터 바인딩 시스템에서 컬렉션 뷰를 통지하는 경우 발생합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.DisableCollectionSynchronization(System.Collections.IEnumerable)">
          <source>The collection to remove synchronized access from.</source>
          <target state="translated">동기화된 액세스를 제거하는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.DisableCollectionSynchronization(System.Collections.IEnumerable)">
          <source>Remove the synchronization registered for the specified collection.</source>
          <target state="translated">지정된 컬렉션에 등록된 동기화를 제거합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="P:System.Windows.Data.BindingOperations.DisconnectedSource">
          <source>Gets an object that replaces the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.DataContext" /&gt;</ph> when an item container is removed from the visual tree.</source>
          <target state="translated">항목 컨테이너가 시각적 트리에서 제거될 때 <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.DataContext" /&gt;</ph>를 대체하는 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Data.BindingOperations.DisconnectedSource">
          <source>An object that replaces the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.DataContext" /&gt;</ph> when an item container is removed from the visual tree.</source>
          <target state="translated">항목 컨테이너가 시각적 트리에서 제거될 때 <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.DataContext" /&gt;</ph>를 대체하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Data.BindingOperations.DisconnectedSource">
          <source>Use this property if you need to deal with the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> of an item container.</source>
          <target state="translated">처리 하는 경우이 속성을 사용 하 여는 <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> 항목 컨테이너의 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Data.BindingOperations.DisconnectedSource">
          <source>An item container is the UI element that displays an item in an <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>.</source>
          <target state="translated">항목 컨테이너에 있는 항목을 표시 하는 UI 요소는 한 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Data.BindingOperations.DisconnectedSource">
          <source>When an <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> is data bound to a collection, an item container is generated for each item.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> 는 데이터 컬렉션에 바인딩된 항목 컨테이너는 각 항목에 대해 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Data.BindingOperations.DisconnectedSource">
          <source>In some cases, item containers are removed from the visual tree.</source>
          <target state="translated">경우에 따라 항목 컨테이너는 시각적 트리에서 제거됩니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Data.BindingOperations.DisconnectedSource">
          <source>Two typical cases where an item container is removed are when an item is removed from the underlying collection and when virtualization is enabled on the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>.</source>
          <target state="translated">기본 컬렉션에서 항목이 제거 될 때 및에서 가상화가 사용 하는 경우 항목 컨테이너 제거 되는 두 가지 일반적인 경우는는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Data.BindingOperations.DisconnectedSource">
          <source>In these cases, the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> property of the item container will be set to the <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A&gt;</ph> property  You should check whether the <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> is equal to the <ph id="ph4">&lt;xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A&gt;</ph> before accessing the <ph id="ph5">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> in the <ph id="ph6">&lt;xref:System.Windows.FrameworkElement.DataContextChanged&gt;</ph> event for item containers.</source>
          <target state="translated">이러한 경우에는 <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> 항목 컨테이너의 속성으로 설정 됩니다는 <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A&gt;</ph> 속성을 확인 해야 하는지 여부를 <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> 같은지를 <ph id="ph4">&lt;xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A&gt;</ph> 에 액세스 하기 전에 <ph id="ph5">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> 에 <ph id="ph6">&lt;xref:System.Windows.FrameworkElement.DataContextChanged&gt;</ph> 항목에 대 한 이벤트 다시 설정 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Data.BindingOperations.DisconnectedSource">
          <source>For more information about item containers and virtualization, see the remarks in the <ph id="ph1">&lt;xref:System.Windows.Controls.VirtualizingStackPanel&gt;</ph> class.</source>
          <target state="translated">컨테이너의 항목 및 가상화에 대 한 자세한 내용은의 설명을 참조는 <ph id="ph1">&lt;xref:System.Windows.Controls.VirtualizingStackPanel&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="T:System.Windows.Data.BindingOperations">
          <source>Enables a <ph id="ph1">&lt;see cref="T:System.Windows.Data.CollectionView" /&gt;</ph> object to participate in synchronized access to a collection that is used on multiple threads.</source>
          <target state="translated">여러 스레드에 사용된 컬렉션에 대한 동기화된 액세스에 참여하도록 <ph id="ph1">&lt;see cref="T:System.Windows.Data.CollectionView" /&gt;</ph> 개체를 활성화합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>A WPF application can display a collection of data using an <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> or one of its subclasses (<ph id="ph2">&lt;xref:System.Windows.Controls.ListBox&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.DataGrid&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Controls.TreeView&gt;</ph>, <ph id="ph5">&lt;xref:System.Windows.Controls.ListView&gt;</ph>, etc.).</source>
          <target state="translated">WPF 응용 프로그램 컬렉션을 사용 하 여 데이터를 표시할 수는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> 또는 해당 서브 클래스 중 하나 (<ph id="ph2">&lt;xref:System.Windows.Controls.ListBox&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.DataGrid&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Controls.TreeView&gt;</ph>, <ph id="ph5">&lt;xref:System.Windows.Controls.ListView&gt;</ph>등.).</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>WPF channels all its access to the collection through a subclass of <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>.</source>
          <target state="translated">WPF의 서브 클래스를 통해 컬렉션의 모든 액세스 채널 <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>Both the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> and the <ph id="ph2">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> have affinity to the thread on which the <ph id="ph3">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> was created, meaning that using them on a different thread is forbidden and throws an exception.</source>
          <target state="translated">둘 다는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> 기반이 스레드에 선호도는 <ph id="ph3">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> 만들어진, 즉 다른 스레드에서 사용 하 여는 금지 되 고 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>In effect, this restriction applies to the collection as well.</source>
          <target state="translated">실제로 이러한 제한도 컬렉션에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>You may want to use the collection on multiple threads.</source>
          <target state="translated">여러 스레드에서 컬렉션을 사용 하도록 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>For example, you want to update the collection (add or remove items) on a "data-gathering" thread, while displaying the results on a "user interface" thread, so that the UI remains responsive while data-gathering is happening.</source>
          <target state="translated">예를 들어 컬렉션을 업데이트 하려면 (추가 또는 제거 항목) "데이터 수집" 스레드에서 "사용자 인터페이스" 스레드에서 결과 표시 하는 동안 UI 하는 동안 응답 가능한 상태로 유지 되도록 데이터 수집 발생 합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>In such a situation, you are responsible for ensuring synchronized ("thread-safe") access to the collection.</source>
          <target state="translated">이러한 경우 책임이 있습니다 컬렉션에 동기화 된 ("스레드로부터 안전한") 액세스를 보장 합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>This is typically done using either a simple lock mechanism or a more elaborate synchronization mechanism such as semaphores, reset events, etc.</source>
          <target state="translated">일반적으로 이렇게와 같은 간단한 잠금 메커니즘 또는 보다 세밀 하 게 동기화 메커니즘을 사용 하 여 세마포, 이벤트 등을 다시 설정 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>While you must synchronize your application's access to the collection, you must also guarantee that access from WPF (specifically from <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>) participates in the same synchronization mechanism.</source>
          <target state="translated">액세스 하는 WPF에서도 보장 해야 컬렉션에 대 한 응용 프로그램의 액세스를 동기화 해야 하는 동안 (특히에서 <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>) 같은 동기화 메커니즘에 참여 합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>You do this by calling the <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A&gt;</ph> method.</source>
          <target state="translated">이 작업은 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A&gt;</ph> 메서드를 호출하여 수행합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>To use a collection on multiple threads, one of which is the UI thread that owns the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, an application has the following responsibilities:</source>
          <target state="translated">여러 스레드에서 컬렉션을 사용 하려면 그 중 하나는 소유 하는 UI 스레드는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, 응용 프로그램에 다음을 수행 해야 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>Choose a synchronization mechanism.</source>
          <target state="translated">동기화 메커니즘을 선택 합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>Synchronize all access from the application to the collection using that mechanism.</source>
          <target state="translated">해당 메커니즘을 사용 하 여 컬렉션에 응용 프로그램에서 모든 액세스를 동기화 합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>Call <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A&gt;</ph> to inform WPF of the mechanism.</source>
          <target state="translated">호출 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A&gt;</ph> 메커니즘의 WPF 알릴 수 있습니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>The call must occur on the UI thread.</source>
          <target state="translated">호출이 UI 스레드에서 발생 해야 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>The call must occur before using the collection on a different thread or before attaching the collection to the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, whichever is later.</source>
          <target state="translated">컬렉션에 연결 하기 전에 또는 다른 스레드에서 컬렉션을 사용 하기 전에 호출이 발생 해야 합니다는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, 중에서 더 이상.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)&gt;</ph> overload if using a simple lock mechanism; call the <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)&gt;</ph> overload if using a more elaborate mechanism.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)&gt;</ph> 간단한 잠금 메커니즘을 사용 하는 경우 오버 로드; 호출은 <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)&gt;</ph> 보다 세밀 하 게 메커니즘을 사용 하는 경우 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>Ensure that a change to the collection and the notification of that change (through <ph id="ph1">&lt;xref:System.Collections.Specialized.INotifyCollectionChanged&gt;</ph>) are atomic; no access from other threads can intervene.</source>
          <target state="translated">컬렉션 및 해당 변경 내용에 대 한 알림을에 대 한 변경 되도록 (통해 <ph id="ph1">&lt;xref:System.Collections.Specialized.INotifyCollectionChanged&gt;</ph>)은 다른 스레드에서 액세스할 수 없는 사용자가 개입할 수 원자성입니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>(This is usually free.</source>
          <target state="translated">(일반적으로 무료입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>For instance, <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ObservableCollection%601&gt;</ph> guarantees this, provided that all changes are protected by synchronization.)</source>
          <target state="translated">For instance, <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ObservableCollection%601&gt;</ph> 모든 변경 내용을 동기화에 의해 보호 되는이 보장 합니다.)</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>If you call <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, that call must also occur on the UI thread.</source>
          <target state="translated">호출 하는 경우 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, 호출이 UI 스레드에서 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>If you want to use the same collection on multiple UI threads, you must call <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A&gt;</ph> (and <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, if needed) separately on each UI thread.</source>
          <target state="translated">여러 UI 스레드에서 동일한 컬렉션을 사용 하려면 호출 해야 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A&gt;</ph> (및 <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, 필요한 경우) 각 UI 스레드에서 별도로 합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>Avoid deadlock.</source>
          <target state="translated">교착 상태를 방지 합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>This is already the application's responsibility once it chooses to use synchronization, but it must also take into account WPF's participation in the synchronization, as discussed in the following paragraph.</source>
          <target state="translated">이 이미 응용 프로그램의 역할 계정 WPF의 참여는 동기화에 사용 해야 하지만, 동기화를 사용 하도록 선택 되 면 다음 단락에서 설명한입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>In return, WPF provides the following behavior:</source>
          <target state="translated">WPF는 다음 동작을 제공합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> accesses the collection using the given synchronization mechanism.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> 지정 된 동기화 메커니즘을 사용 하 여 컬렉션에 액세스 합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> maintains a "shadow copy" of the collection for use on the UI thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> "의 섀도 복사본"의 컬렉션을 사용 하 여 UI 스레드에서 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView.CollectionChanged&gt;</ph> events are queued up as they arrive (on any thread).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView.CollectionChanged&gt;</ph> (모든 스레드)에 도착 하면 이벤트 대기 합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>Pending events are applied to the shadow copy asynchronously on the UI thread when it has the opportunity to do so.</source>
          <target state="translated">보류 중인 이벤트에 적용 됩니다는 UI 스레드에서 비동기적으로 섀도 복사본 작업을 수행 하는 경우.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> won't directly use any other synchronization mechanism visible to the application.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> 응용 프로그램에 표시 다른 동기화 메커니즘을 직접 사용 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>This is WPF's way of helping to avoid deadlock (see the previous item 7).</source>
          <target state="translated">이 방법은 WPF의 작동에 교착 상태에 (7 이전 항목 참조).</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>The net effect is that you can change the collection on any thread, and those changes eventually appear in the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> when the UI thread has time to "catch up".</source>
          <target state="translated">하 한 순수 효과 모든 스레드에서 컬렉션을 변경할 수 있으며에 변경 내용이 결국 표시는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> UI 스레드 시간 "동기화"를 하는 경우.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Data.BindingOperations">
          <source>The implementation has been tuned to throttle the rate that changes flow into the UI thread to keep background threads from saturating the UI thread and starving the response to normal user input.</source>
          <target state="translated">구현은 스로틀 포화 UI 스레드를 일반 사용자 입력에 응답 함으로써 스레드 수 변경 내용을에 UI 스레드 백그라운드 유지를 보내야 하는 속도를 조정 되었습니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>The collection that needs synchronized access.</source>
          <target state="translated">동기화된 액세스가 필요한 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>The object to lock when accessing the collection.</source>
          <target state="translated">컬렉션에 액세스할 때 잠글 개체입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>Enables a <ph id="ph1">&lt;see cref="T:System.Windows.Data.CollectionView" /&gt;</ph> object to participate in synchronized access to a collection used on multiple threads by using a simple locking mechanism.</source>
          <target state="translated">간단한 잠금 메커니즘을 사용하여 여러 스레드에 용된 컬렉션에 대한 동기화된 액세스에 참여하도록 <ph id="ph1">&lt;see cref="T:System.Windows.Data.CollectionView" /&gt;</ph> 개체를 활성화합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>A WPF application can display a collection of data using an <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> or one of its subclasses (<ph id="ph2">&lt;xref:System.Windows.Controls.ListBox&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.DataGrid&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Controls.TreeView&gt;</ph>, <ph id="ph5">&lt;xref:System.Windows.Controls.ListView&gt;</ph>, etc.).</source>
          <target state="translated">WPF 응용 프로그램 컬렉션을 사용 하 여 데이터를 표시할 수는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> 또는 해당 서브 클래스 중 하나 (<ph id="ph2">&lt;xref:System.Windows.Controls.ListBox&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.DataGrid&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Controls.TreeView&gt;</ph>, <ph id="ph5">&lt;xref:System.Windows.Controls.ListView&gt;</ph>등.).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>WPF channels all its access to the collection through a subclass of <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>.</source>
          <target state="translated">WPF의 서브 클래스를 통해 컬렉션의 모든 액세스 채널 <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>Both the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> and the <ph id="ph2">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> have affinity to the thread on which the <ph id="ph3">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> was created, meaning that using them on a different thread is forbidden and throws an exception.</source>
          <target state="translated">둘 다는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> 기반이 스레드에 선호도는 <ph id="ph3">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> 만들어진, 즉 다른 스레드에서 사용 하 여는 금지 되 고 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>In effect, this restriction applies to the collection as well.</source>
          <target state="translated">실제로 이러한 제한도 컬렉션에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>You may want to use the collection on multiple threads.</source>
          <target state="translated">여러 스레드에서 컬렉션을 사용 하도록 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>For example, you want to update the collection (add or remove items) on a "data-gathering" thread, while displaying the results on a "user interface" thread, so that the UI remains responsive while data-gathering is happening.</source>
          <target state="translated">예를 들어 컬렉션을 업데이트 하려면 (추가 또는 제거 항목) "데이터 수집" 스레드에서 "사용자 인터페이스" 스레드에서 결과 표시 하는 동안 UI 하는 동안 응답 가능한 상태로 유지 되도록 데이터 수집 발생 합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>In such a situation, you are responsible for ensuring synchronized ("thread-safe") access to the collection and for guaranteeing that access from WPF (specifically from <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>) participates in the same synchronization mechanism.</source>
          <target state="translated">이러한 경우 사용자가 컬렉션에 액세스 하는 WPF에서 보장 하는 것에 대 한 액세스 ("스레드로부터 안전한")이 동기화 되었는지 확인 (구체적으로 로부터 <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>) 같은 동기화 메커니즘에 참여 합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>By calling the <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)&gt;</ph> method, you can do this by using a simple lock mechanism.</source>
          <target state="translated">호출 하 여는 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)&gt;</ph> 메서드를 할 수 있는이 간단한 잠금 메커니즘을 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>To use a collection on multiple threads, one of which is the UI thread that owns the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, you must do the following:</source>
          <target state="translated">여러 스레드에서 컬렉션을 사용 하려면 그 중 하나는 소유 하는 UI 스레드는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>에서 다음을 수행 해야 합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>Instantiate an object to lock when accessing the collection.</source>
          <target state="translated">컬렉션에 액세스할 때 잠글 개체를를 인스턴스화하십시오.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>Synchronize all access from the application to the collection by locking that object.</source>
          <target state="translated">해당 개체를 잠가 컬렉션에 응용 프로그램에서 모든 액세스를 동기화 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>Call <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)&gt;</ph> to inform WPF that you are using a simple lock mechanism.</source>
          <target state="translated">호출 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)&gt;</ph> 간단한 잠금 메커니즘을 사용 하는 WPF를 알릴 수 있습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>The call must occur on the UI thread.</source>
          <target state="translated">호출이 UI 스레드에서 발생 해야 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>The call must occur before using the collection on a different thread or before attaching the collection to the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, whichever is later.</source>
          <target state="translated">컬렉션에 연결 하기 전에 또는 다른 스레드에서 컬렉션을 사용 하기 전에 호출이 발생 해야 합니다는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, 중에서 더 이상.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>Ensure that a change to the collection and the notification of that change (through <ph id="ph1">&lt;xref:System.Collections.Specialized.INotifyCollectionChanged&gt;</ph>) are atomic; no access from other threads can intervene.</source>
          <target state="translated">컬렉션 및 해당 변경 내용에 대 한 알림을에 대 한 변경 되도록 (통해 <ph id="ph1">&lt;xref:System.Collections.Specialized.INotifyCollectionChanged&gt;</ph>)은 다른 스레드에서 액세스할 수 없는 사용자가 개입할 수 원자성입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>(This is usually free.</source>
          <target state="translated">(일반적으로 무료입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>For instance, <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ObservableCollection%601&gt;</ph> guarantees this, provided that all changes are protected by synchronization.)</source>
          <target state="translated">For instance, <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ObservableCollection%601&gt;</ph> 모든 변경 내용을 동기화에 의해 보호 되는이 보장 합니다.)</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>If you call <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, that call must also occur on the UI thread.</source>
          <target state="translated">호출 하는 경우 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, 호출이 UI 스레드에서 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>If you want to use the same collection on multiple UI threads, you must call <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A&gt;</ph> (and <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, if needed) separately on each UI thread.</source>
          <target state="translated">여러 UI 스레드에서 동일한 컬렉션을 사용 하려면 호출 해야 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A&gt;</ph> (및 <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, 필요한 경우) 각 UI 스레드에서 별도로 합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>Avoid deadlock.</source>
          <target state="translated">교착 상태를 방지 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>This is already the application's responsibility once it chooses to use synchronization, but it must also take into account WPF's participation in the synchronization.</source>
          <target state="translated">동기화를 사용 하도록 선택 되지만 것도 고려해 야 동기화에 WPF의 참여에 응용 프로그램의 역할 이미입니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>(See more, below.)</source>
          <target state="translated">(참조, 아래).</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>In return, WPF provides the following behavior:</source>
          <target state="translated">WPF는 다음 동작을 제공합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> accesses the collection using the locking mechanism.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> 잠금 메커니즘을 사용 하 여 컬렉션에 액세스 합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> maintains a "shadow copy" of the collection for use on the UI thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> "의 섀도 복사본"의 컬렉션을 사용 하 여 UI 스레드에서 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView.CollectionChanged&gt;</ph> events are queued up as they arrive (on any thread).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView.CollectionChanged&gt;</ph> (모든 스레드)에 도착 하면 이벤트 대기 합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>Pending events are applied to the shadow copy asynchronously on the UI thread when it has the opportunity to do so.</source>
          <target state="translated">보류 중인 이벤트에 적용 됩니다는 UI 스레드에서 비동기적으로 섀도 복사본 작업을 수행 하는 경우.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> will not directly use any other synchronization mechanism visible to the application.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> 가 직접 사용 응용 프로그램에 표시 다른 동기화 메커니즘입니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>This is WPF's way of helping to avoid deadlock (see the previous item 7).</source>
          <target state="translated">이 방법은 WPF의 작동에 교착 상태에 (7 이전 항목 참조).</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>The net effect is that you can change the collection on any thread, and those changes eventually appear in the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> when the UI thread has time to "catch up".</source>
          <target state="translated">하 한 순수 효과 모든 스레드에서 컬렉션을 변경할 수 있으며에 변경 내용이 결국 표시는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> UI 스레드 시간 "동기화"를 하는 경우.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)">
          <source>The implementation has been tuned to throttle the rate that changes flow into the UI thread to keep background threads from saturating the UI thread and starving the response to normal user input.</source>
          <target state="translated">구현은 스로틀 포화 UI 스레드를 일반 사용자 입력에 응답 함으로써 스레드 수 변경 내용을에 UI 스레드 백그라운드 유지를 보내야 하는 속도를 조정 되었습니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>The collection that needs synchronized access.</source>
          <target state="translated">동기화된 액세스가 필요한 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>An object that is passed to the callback.</source>
          <target state="translated">콜백에 전달되는 개체입니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>The callback that is invoked whenever access to the collection is required.</source>
          <target state="translated">컬렉션에 대한 액세스가 필요할 때마다 호출되는 콜백입니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>You can use it to ensure that the collection is accessed by one thread at a time.</source>
          <target state="translated">한 번 하나의 스레드가 해당 컬렉션에 액세스하도록 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>Enables a <ph id="ph1">&lt;see cref="T:System.Windows.Data.CollectionView" /&gt;</ph> object to participate in synchronized access to a collection used on multiple threads by using a mechanism other than a simple lock.</source>
          <target state="translated">간단한 잠금 이외의 메커니즘을 사용하여 여러 스레드에 사용된 컬렉션에 대한 동기화된 액세스에 참여하도록 <ph id="ph1">&lt;see cref="T:System.Windows.Data.CollectionView" /&gt;</ph> 개체를 활성화합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>A WPF application can display a collection of data using an <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> or one of its subclasses (<ph id="ph2">&lt;xref:System.Windows.Controls.ListBox&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.DataGrid&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Controls.TreeView&gt;</ph>, <ph id="ph5">&lt;xref:System.Windows.Controls.ListView&gt;</ph>, etc.).</source>
          <target state="translated">WPF 응용 프로그램 컬렉션을 사용 하 여 데이터를 표시할 수는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> 또는 해당 서브 클래스 중 하나 (<ph id="ph2">&lt;xref:System.Windows.Controls.ListBox&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.DataGrid&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Controls.TreeView&gt;</ph>, <ph id="ph5">&lt;xref:System.Windows.Controls.ListView&gt;</ph>등.).</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>WPF channels all its access to the collection through a subclass of <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>.</source>
          <target state="translated">WPF의 서브 클래스를 통해 컬렉션의 모든 액세스 채널 <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>Both the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> and the <ph id="ph2">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> have affinity to the thread on which the <ph id="ph3">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> was created, meaning that using them on a different thread is forbidden and throws an exception.</source>
          <target state="translated">둘 다는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> 기반이 스레드에 선호도는 <ph id="ph3">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> 만들어진, 즉 다른 스레드에서 사용 하 여는 금지 되 고 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>In effect, this restriction applies to the collection as well.</source>
          <target state="translated">실제로 이러한 제한도 컬렉션에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>You may want to use the collection on multiple threads.</source>
          <target state="translated">여러 스레드에서 컬렉션을 사용 하도록 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>For example, you want to update the collection (add or remove items) on a "data-gathering" thread, while displaying the results on a "user interface" thread, so that the UI remains responsive while data-gathering is happening.</source>
          <target state="translated">예를 들어 컬렉션을 업데이트 하려면 (추가 또는 제거 항목) "데이터 수집" 스레드에서 "사용자 인터페이스" 스레드에서 결과 표시 하는 동안 UI 하는 동안 응답 가능한 상태로 유지 되도록 데이터 수집 발생 합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>In such a situation, you are responsible for ensuring synchronized ("thread-safe") access to the collection and for guaranteeing that access from WPF (specifically from <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>) participates in the same synchronization mechanism.</source>
          <target state="translated">이러한 경우 사용자가 컬렉션에 액세스 하는 WPF에서 보장 하는 것에 대 한 액세스 ("스레드로부터 안전한")이 동기화 되었는지 확인 (구체적으로 로부터 <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph>) 같은 동기화 메커니즘에 참여 합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>By calling the <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)&gt;</ph> method, you can do this by using a synchronization mechanism such as a semaphores, a reset event, etc.</source>
          <target state="translated">호출 하 여는 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)&gt;</ph> 메서드, 이렇게 하려면 세마포는, 다시 설정 이벤트 등 같은 동기화 메커니즘을 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>To use a collection on multiple threads, one of which is the UI thread that owns the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, you must do the following:</source>
          <target state="translated">여러 스레드에서 컬렉션을 사용 하려면 그 중 하나는 소유 하는 UI 스레드는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>에서 다음을 수행 해야 합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>Choose a synchronization mechanism.</source>
          <target state="translated">동기화 메커니즘을 선택 합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>Synchronize all access from the application to the collection using that mechanism.</source>
          <target state="translated">해당 메커니즘을 사용 하 여 컬렉션에 응용 프로그램에서 모든 액세스를 동기화 합니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)&gt;</ph> overload to inform WPF that you are using a mechanism other than simple locking.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)&gt;</ph> 간단한 잠금 이외의 다른 메커니즘을 사용 하는 WPF를 알리기 위해 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>The call must occur on the UI thread.</source>
          <target state="translated">호출이 UI 스레드에서 발생 해야 합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>The call must occur before using the collection on a different thread or before attaching the collection to the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, whichever is later.</source>
          <target state="translated">컬렉션에 연결 하기 전에 또는 다른 스레드에서 컬렉션을 사용 하기 전에 호출이 발생 해야 합니다는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, 중에서 더 이상.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>Ensure that a change to the collection and the notification of that change (through <ph id="ph1">&lt;xref:System.Collections.Specialized.INotifyCollectionChanged&gt;</ph>) are atomic; no access from other threads can intervene.</source>
          <target state="translated">컬렉션 및 해당 변경 내용에 대 한 알림을에 대 한 변경 되도록 (통해 <ph id="ph1">&lt;xref:System.Collections.Specialized.INotifyCollectionChanged&gt;</ph>)은 다른 스레드에서 액세스할 수 없는 사용자가 개입할 수 원자성입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>(This is usually free.</source>
          <target state="translated">(일반적으로 무료입니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>For instance, <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ObservableCollection%601&gt;</ph> guarantees this, provided that all changes are protected by synchronization.)</source>
          <target state="translated">For instance, <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ObservableCollection%601&gt;</ph> 모든 변경 내용을 동기화에 의해 보호 되는이 보장 합니다.)</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>If you call <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, that call must also occur on the UI thread.</source>
          <target state="translated">호출 하는 경우 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, 호출이 UI 스레드에서 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>If you want to use the same collection on multiple UI threads, you must call <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A&gt;</ph> (and <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, if needed) separately on each UI thread.</source>
          <target state="translated">여러 UI 스레드에서 동일한 컬렉션을 사용 하려면 호출 해야 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A&gt;</ph> (및 <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A&gt;</ph>, 필요한 경우) 각 UI 스레드에서 별도로 합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>Avoid deadlock.</source>
          <target state="translated">교착 상태를 방지 합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>This is already the application's responsibility once it chooses to use synchronization, but it must also take into account WPF's participation in the synchronization.</source>
          <target state="translated">동기화를 사용 하도록 선택 되지만 것도 고려해 야 동기화에 WPF의 참여에 응용 프로그램의 역할 이미입니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>(See more, below.)</source>
          <target state="translated">(참조, 아래).</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>In return, WPF provides the following behavior:</source>
          <target state="translated">WPF는 다음 동작을 제공합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> accesses the collection by calling the registered <ph id="ph2">&lt;xref:System.Windows.Data.CollectionSynchronizationCallback&gt;</ph> with the following arguments:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> 등록 된 호출 하 여 컬렉션에 액세스 <ph id="ph2">&lt;xref:System.Windows.Data.CollectionSynchronizationCallback&gt;</ph> 다음 인수:</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source><ph id="ph1">`collection`</ph>: the collection of interest.</source>
          <target state="translated"><ph id="ph1">`collection`</ph>: 대상의 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source><ph id="ph1">`context`</ph>: the registered context object.</source>
          <target state="translated"><ph id="ph1">`context`</ph>: 등록 된 컨텍스트 개체입니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source><ph id="ph1">`accessMethod`</ph>: a delegate that performs the actual access.</source>
          <target state="translated"><ph id="ph1">`accessMethod`</ph>: 실제 액세스를 수행 하는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source><ph id="ph1">`writeAccess`</ph>: <ph id="ph2">`true`</ph> if the delegate will modify the collection; <ph id="ph3">`false`</ph> otherwise.</source>
          <target state="translated"><ph id="ph1">`writeAccess`</ph>: <ph id="ph2">`true`</ph> 대리자는 컬렉션을 수정 하는 경우 <ph id="ph3">`false`</ph> 그렇지 않은 경우.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>Your <ph id="ph1">&lt;xref:System.Windows.Data.CollectionSynchronizationCallback&gt;</ph> should establish synchronization on the collection (using the <ph id="ph2">`context`</ph> object and the <ph id="ph3">`writeAccess`</ph> value, as appropriate), call the <ph id="ph4">`accessMethod`</ph>, then release synchronization.</source>
          <target state="translated">프로그램 <ph id="ph1">&lt;xref:System.Windows.Data.CollectionSynchronizationCallback&gt;</ph> 컬렉션에 동기화를 설정 해야 (사용 하 여는 <ph id="ph2">`context`</ph> 개체 및 <ph id="ph3">`writeAccess`</ph> 적절 하 게 값), 호출는 <ph id="ph4">`accessMethod`</ph>, 다음 동기화를 놓습니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> maintains a "shadow copy" of the collection for use on the UI thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> "의 섀도 복사본"의 컬렉션을 사용 하 여 UI 스레드에서 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView.CollectionChanged&gt;</ph> events are queued up as they arrive (on any thread).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView.CollectionChanged&gt;</ph> (모든 스레드)에 도착 하면 이벤트 대기 합니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>Pending events are applied to the shadow copy asynchronously on the UI thread when it has the opportunity to do so.</source>
          <target state="translated">보류 중인 이벤트에 적용 됩니다는 UI 스레드에서 비동기적으로 섀도 복사본 작업을 수행 하는 경우.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> will not directly use any other synchronization mechanism visible to the application.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.CollectionView&gt;</ph> 가 직접 사용 응용 프로그램에 표시 다른 동기화 메커니즘입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>This is WPF's way of helping to avoid deadlock (see the previous item 7).</source>
          <target state="translated">이 방법은 WPF의 작동에 교착 상태에 (7 이전 항목 참조).</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>The net effect is that you can change the collection on any thread, and those changes eventually appear in the <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> when the UI thread has time to "catch up".</source>
          <target state="translated">하 한 순수 효과 모든 스레드에서 컬렉션을 변경할 수 있으며에 변경 내용이 결국 표시는 <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> UI 스레드 시간 "동기화"를 하는 경우.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>The implementation has been tuned to throttle the rate that changes flow into the UI thread to keep background threads from saturating the UI thread and starving the response to normal user input.</source>
          <target state="translated">구현은 스로틀 포화 UI 스레드를 일반 사용자 입력에 응답 함으로써 스레드 수 변경 내용을에 UI 스레드 백그라운드 유지를 보내야 하는 속도를 조정 되었습니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>The <ph id="ph1">`context`</ph> parameter is an arbitrary object that is passed to the <ph id="ph2">`callback`</ph>.</source>
          <target state="translated"><ph id="ph1">`context`</ph> 매개 변수는 임의의 개체에 전달 되는 <ph id="ph2">`callback`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source>You can use it to determine the synchronization mechanism used to control access to <ph id="ph1">`collection`</ph>.</source>
          <target state="translated">에 대 한 액세스를 제어 하는 데는 동기화 메커니즘을 결정 하는 데 사용할 수 <ph id="ph1">`collection`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)">
          <source><ph id="ph1">`Context`</ph> can be <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`Context`</ph> 수 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The object where <bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept> is.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept>가 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The binding target property from which to retrieve the binding.</source>
          <target state="translated">바인딩을 검색할 바인딩 대상 속성입니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>Retrieves the <ph id="ph1">&lt;see cref="T:System.Windows.Data.Binding" /&gt;</ph> object that is set on the specified property.</source>
          <target state="translated">지정된 속성에 설정된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.Binding" /&gt;</ph> 개체를 검색합니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.Binding" /&gt;</ph> object set on the given property or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no <ph id="ph3">&lt;see cref="T:System.Windows.Data.Binding" /&gt;</ph> object has been set.</source>
          <target state="translated">지정된 속성에 설정된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.Binding" /&gt;</ph> 개체입니다. <ph id="ph3">&lt;see cref="T:System.Windows.Data.Binding" /&gt;</ph> 개체가 설정되지 않은 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> and <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> parameters cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 매개 변수가 null인 경우</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The object where <bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept> is.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept>가 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The binding target property from which to retrieve the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingBase" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingBase" /&gt;</ph> 개체를 검색할 바인딩 대상 속성입니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>Retrieves the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingBase" /&gt;</ph> object that is set on the specified property.</source>
          <target state="translated">지정된 속성에 설정된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingBase" /&gt;</ph> 개체를 검색합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingBase" /&gt;</ph> object that is set on the given property or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no binding object has been set.</source>
          <target state="translated">지정된 속성에 설정된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingBase" /&gt;</ph> 개체입니다. 바인딩 개체가 설정되지 않은 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> class is the common base class for the <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>, and <ph id="ph4">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> classes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> 클래스에 대 한 공통 기본 클래스는는 <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>, 및 <ph id="ph4">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.GetBinding%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.GetPriorityBinding%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.Data.BindingOperations.GetMultiBinding%2A&gt;</ph> methods if you know in advance the type of binding that is set on the property.</source>
          <target state="translated">사용할 수는 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.GetBinding%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.GetPriorityBinding%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.Windows.Data.BindingOperations.GetMultiBinding%2A&gt;</ph> 된 바인딩 형식을 미리 알고 있으면 메서드는 속성에 설정 합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> and <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> parameters cannot be <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 매개 변수는 <ph id="ph3">&lt;see langword="null" /&gt;</ph>일 수 없습니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The binding target object where <bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept> is.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept>가 있는 바인딩 대상 개체입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The binding target property from which to retrieve the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> 개체를 검색할 바인딩 대상 속성입니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> object associated with the specified binding target property on the specified object.</source>
          <target state="translated">지정한 개체에서 지정한 바인딩 대상 속성에 연결된 된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> object associated with the given property or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if none exists.</source>
          <target state="translated">지정된 속성에 연결된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> 개체입니다. 개체가 없는 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>If a <ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBindingExpression" /&gt;</ph> object is set on the property, the <ph id="ph2">&lt;see cref="P:System.Windows.Data.PriorityBindingExpression.ActiveBindingExpression" /&gt;</ph> is returned.</source>
          <target state="translated">속성에 <ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBindingExpression" /&gt;</ph> 개체가 설정된 경우 <ph id="ph2">&lt;see cref="P:System.Windows.Data.PriorityBindingExpression.ActiveBindingExpression" /&gt;</ph>이 반환됩니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.BindingExpression&gt;</ph> object maintains the connection between the binding source and the binding target.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.BindingExpression&gt;</ph> 개체 바인딩 소스에서 바인딩 대상 사이의 연결을 유지 합니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>You can obtain the <ph id="ph1">&lt;xref:System.Windows.Data.BindingExpression&gt;</ph> object by calling this static method or by calling the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.GetBindingExpression%2A&gt;</ph> method on a data-bound <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> object.</source>
          <target state="translated">가져올 수 있습니다는 <ph id="ph1">&lt;xref:System.Windows.Data.BindingExpression&gt;</ph> 이 정적 메서드를 호출 하 여 또는 호출 하 여 개체는 <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.GetBindingExpression%2A&gt;</ph> 메서드를 데이터 바인딩된 <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph> 또는 <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The following example shows the implementation of a <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event handler that uses the <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A&gt;</ph> method to obtain the <ph id="ph3">&lt;xref:System.Windows.Data.BindingExpression&gt;</ph> and then calls the <ph id="ph4">&lt;xref:System.Windows.Data.BindingExpression.DataItem%2A&gt;</ph> property to access the binding source object.</source>
          <target state="translated">다음 예제에서는 구현은 <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> 이벤트 처리기를 사용 하는 <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A&gt;</ph> 를 얻는 메서드를는 <ph id="ph3">&lt;xref:System.Windows.Data.BindingExpression&gt;</ph> 를 호출 하는 <ph id="ph4">&lt;xref:System.Windows.Data.BindingExpression.DataItem%2A&gt;</ph> 바인딩 소스 개체에 액세스 하는 속성입니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph><ph id="ph2">`SavingsText`</ph> is the binding target object and <ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock.Text%2A&gt;</ph> is the binding target property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> <ph id="ph2">`SavingsText`</ph> 는 바인딩 대상 개체 및 <ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock.Text%2A&gt;</ph> 바인딩 대상 속성입니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> and <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> parameters cannot be <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 매개 변수는 <ph id="ph3">&lt;see langword="null" /&gt;</ph>일 수 없습니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The object where <bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept> is.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept>가 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The binding target property from which to retrieve the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> 개체를 검색할 바인딩 대상 속성입니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>Retrieves the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> object that is set on the specified property.</source>
          <target state="translated">지정된 속성에 설정된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> 개체를 검색합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> object that is set on the given property or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no binding object has been set.</source>
          <target state="translated">지정된 속성에 설정된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> 개체입니다. 바인딩 개체가 설정되지 않은 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.BindingExpressionBase&gt;</ph> class is the common base class for the <ph id="ph2">&lt;xref:System.Windows.Data.BindingExpression&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.PriorityBindingExpression&gt;</ph>, and <ph id="ph4">&lt;xref:System.Windows.Data.MultiBindingExpression&gt;</ph> classes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Data.BindingExpressionBase&gt;</ph> 클래스에 대 한 공통 기본 클래스는는 <ph id="ph2">&lt;xref:System.Windows.Data.BindingExpression&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.PriorityBindingExpression&gt;</ph>, 및 <ph id="ph4">&lt;xref:System.Windows.Data.MultiBindingExpression&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.GetPriorityBindingExpression%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.Data.BindingOperations.GetMultiBindingExpression%2A&gt;</ph> methods if you know in advance type of binding that is set on the property.</source>
          <target state="translated">사용할 수는 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Data.BindingOperations.GetPriorityBindingExpression%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.Windows.Data.BindingOperations.GetMultiBindingExpression%2A&gt;</ph> 방법을 알고 있는 경우 미리 하는 속성에 설정 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> and <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> parameters cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 매개 변수가 null인 경우</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The object where <bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept> is.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept>가 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The binding target property from which to retrieve the binding.</source>
          <target state="translated">바인딩을 검색할 바인딩 대상 속성입니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>Retrieves the <ph id="ph1">&lt;see cref="T:System.Windows.Data.MultiBinding" /&gt;</ph> object that is set on the specified property.</source>
          <target state="translated">지정된 속성에 설정된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.MultiBinding" /&gt;</ph> 개체를 검색합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.MultiBinding" /&gt;</ph> object set on the given property or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no <ph id="ph3">&lt;see cref="T:System.Windows.Data.MultiBinding" /&gt;</ph> object has been set.</source>
          <target state="translated">지정된 속성에 설정된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.MultiBinding" /&gt;</ph> 개체입니다. <ph id="ph3">&lt;see cref="T:System.Windows.Data.MultiBinding" /&gt;</ph> 개체가 설정되지 않은 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> and <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> parameters cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 매개 변수가 null인 경우</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The binding target object where <bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept> is.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept>가 있는 바인딩 대상 개체입니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The binding target property from which to retrieve the <ph id="ph1">&lt;see cref="T:System.Windows.Data.MultiBindingExpression" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Data.MultiBindingExpression" /&gt;</ph> 개체를 검색할 바인딩 대상 속성입니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Windows.Data.MultiBindingExpression" /&gt;</ph> object associated with the specified binding target property on the specified object.</source>
          <target state="translated">지정한 개체에서 지정한 바인딩 대상 속성에 연결된 된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.MultiBindingExpression" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.MultiBindingExpression" /&gt;</ph> object associated with the given property or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if none exists.</source>
          <target state="translated">지정된 속성에 연결된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.MultiBindingExpression" /&gt;</ph> 개체입니다. 개체가 없는 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Data.MultiBindingExpression&gt;</ph> object associated with the given property or <ph id="ph2">`null`</ph> if none exists.</source>
          <target state="translated">지정된 속성에 연결된 <ph id="ph1">&lt;xref:System.Windows.Data.MultiBindingExpression&gt;</ph> 개체입니다. 개체가 없는 경우 <ph id="ph2">`null`</ph>입니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> and <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> parameters cannot be <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 매개 변수는 <ph id="ph3">&lt;see langword="null" /&gt;</ph>일 수 없습니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The object where <bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept> is.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept>가 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The binding target property from which to retrieve the binding.</source>
          <target state="translated">바인딩을 검색할 바인딩 대상 속성입니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>Retrieves the <ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBinding" /&gt;</ph> object that is set on the specified property.</source>
          <target state="translated">지정된 속성에 설정된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBinding" /&gt;</ph> 개체를 검색합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBinding" /&gt;</ph> object set on the given property or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no <ph id="ph3">&lt;see cref="T:System.Windows.Data.PriorityBinding" /&gt;</ph> object has been set.</source>
          <target state="translated">지정된 속성에 설정된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBinding" /&gt;</ph> 개체입니다. <ph id="ph3">&lt;see cref="T:System.Windows.Data.PriorityBinding" /&gt;</ph> 개체가 설정되지 않은 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> and <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> parameters cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 매개 변수가 null인 경우</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The binding target object where <bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept> is.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept>가 있는 바인딩 대상 개체입니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The binding target property from which to retrieve the <ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBindingExpression" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBindingExpression" /&gt;</ph> 개체를 검색할 바인딩 대상 속성입니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBindingExpression" /&gt;</ph> object associated with the specified binding target property on the specified object.</source>
          <target state="translated">지정한 개체에서 지정한 바인딩 대상 속성에 연결된 된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBindingExpression" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBindingExpression" /&gt;</ph> object associated with the given property or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if none exists.</source>
          <target state="translated">지정된 속성에 연결된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.PriorityBindingExpression" /&gt;</ph> 개체입니다. 개체가 없는 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> and <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> parameters cannot be <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 매개 변수는 <ph id="ph3">&lt;see langword="null" /&gt;</ph>일 수 없습니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups(System.Windows.DependencyObject)">
          <source>The root <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> to get binding groups for.</source>
          <target state="translated">바인딩 그룹을 가져올 루트 <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups(System.Windows.DependencyObject)">
          <source>This method returns <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> objects that are associated with this element or its descendant elements.</source>
          <target state="translated">이 메서드는 이 요소 또는 해당 하위 항목 요소와 연결된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups(System.Windows.DependencyObject)">
          <source>Gets all <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> objects that have invalid values or target values have not been updated the source.</source>
          <target state="translated">잘못된 값이 있거나 대상 값이 소스를 업데이트하지 않은 모든 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups(System.Windows.DependencyObject)">
          <source>A collection of <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> objects that are associated with the specified element and have invalid values or target values have not been updated the source.</source>
          <target state="translated">지정된 요소와 연결되었고 값이 유효하지 않거나 대상 값이 소스를 업데이트하지 않은 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> 개체의 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups(System.Windows.DependencyObject)">
          <source>If <ph id="ph1">`root`</ph> is <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups%2A&gt;</ph> returns all <ph id="ph4">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> objects that are invalid or have not been updated.</source>
          <target state="translated">경우 <ph id="ph1">`root`</ph> 은 <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups%2A&gt;</ph> 모두 반환 <ph id="ph4">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> 유효 하지 않거나 업데이트 되지 않은 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings(System.Windows.DependencyObject)">
          <source>The root <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> to get binding groups for.</source>
          <target state="translated">바인딩 그룹을 가져올 루트 <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings(System.Windows.DependencyObject)">
          <source>This method returns <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> objects that are associated with this element or its descendant elements.</source>
          <target state="translated">이 메서드는 이 요소 또는 해당 하위 항목 요소와 연결된 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings(System.Windows.DependencyObject)">
          <source>Gets all <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> objects that have invalid values or target values have not been updated the source.</source>
          <target state="translated">잘못된 값이 있거나 대상 값이 소스를 업데이트하지 않은 모든 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings(System.Windows.DependencyObject)">
          <source>A collection of <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> objects that are associated with the specified element and have invalid values or target values have not been updated the source.</source>
          <target state="translated">지정된 요소와 연결되었고 값이 유효하지 않거나 대상 값이 소스를 업데이트하지 않은 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> 개체의 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings(System.Windows.DependencyObject)">
          <source>If <ph id="ph1">`root`</ph> is <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings%2A&gt;</ph> returns all <ph id="ph4">&lt;xref:System.Windows.Data.BindingExpressionBase&gt;</ph> objects that are invalid or have not been updated.</source>
          <target state="translated">경우 <ph id="ph1">`root`</ph> 은 <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings%2A&gt;</ph> 모두 반환 <ph id="ph4">&lt;xref:System.Windows.Data.BindingExpressionBase&gt;</ph> 유효 하지 않거나 업데이트 되지 않은 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.IsDataBound(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The object where <bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept> is.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>dp<ept id="p1">&lt;/c&gt;</ept>가 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.IsDataBound(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>The dependency property to check.</source>
          <target state="translated">확인할 종속성 속성입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.IsDataBound(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>Returns a value that indicates whether the specified property is currently data-bound.</source>
          <target state="translated">지정된 속성이 현재 데이터 바인딩되어 있는지 여부를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.IsDataBound(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified property is data-bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">지정된 속성이 데이터 바인딩되어 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.IsDataBound(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
          <source>If <ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>이 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우입니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The binding target of the binding.</source>
          <target state="translated">바인딩의 바인딩 대상입니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The target property of the binding.</source>
          <target state="translated">바인딩의 대상 속성입니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingBase" /&gt;</ph> object that describes the binding.</source>
          <target state="translated">바인딩을 설명하는 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingBase" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Creates and associates a new instance of <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> with the specified binding target property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph>의 새 인스턴스를 만들어 지정된 바인딩 대상 속성과 연결합니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The instance of <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> created for and associated with the specified property.</source>
          <target state="translated">지정된 속성을 사용하여 만들고 연결하는 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph>의 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> class is the base class of <ph id="ph2">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph>, <ph id="ph3">&lt;see cref="T:System.Windows.Data.MultiBindingExpression" /&gt;</ph>, and <ph id="ph4">&lt;see cref="T:System.Windows.Data.PriorityBindingExpression" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpressionBase" /&gt;</ph> 클래스는 <ph id="ph2">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph>, <ph id="ph3">&lt;see cref="T:System.Windows.Data.MultiBindingExpression" /&gt;</ph> 및 <ph id="ph4">&lt;see cref="T:System.Windows.Data.PriorityBindingExpression" /&gt;</ph>의 기본 클래스입니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This method creates a new instance of a <ph id="ph1">&lt;xref:System.Windows.Data.BindingExpressionBase&gt;</ph> and associates the instance with the given dependency property of the given object.</source>
          <target state="translated">이 메서드는의 새 인스턴스를 만듭니다는 <ph id="ph1">&lt;xref:System.Windows.Data.BindingExpressionBase&gt;</ph> 특정된 종속성 속성이 지정된 된 개체의 인스턴스를 연결 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This method is the way to attach a binding to an arbitrary <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> that may not expose its own SetBinding method.</source>
          <target state="translated">이 메서드는 임의의에 바인딩을 연결 하는 방법은 <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> 자체 SetBinding 메서드를 노출 하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The following example shows how to use this method to set a binding.</source>
          <target state="translated">다음 예제에서는이 메서드를 사용 하 여 바인딩을 설정 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>In this example, <ph id="ph1">`myNewBindDef`</ph> is a <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> object that describes the binding.</source>
          <target state="translated">이 예제에서는 <ph id="ph1">`myNewBindDef`</ph> 는 <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> 바인딩을 설명 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The binding target is <ph id="ph1">`myDateText`</ph>, an instance of the <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> class.</source>
          <target state="translated">바인딩 대상이 <ph id="ph1">`myDateText`</ph>의 인스턴스는 <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The <ph id="ph1">&lt;paramref name="binding" /&gt;</ph> parameter cannot be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="binding" /&gt;</ph> 매개 변수는 <ph id="ph2">&lt;see langword="null" /&gt;</ph>일 수 없습니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>