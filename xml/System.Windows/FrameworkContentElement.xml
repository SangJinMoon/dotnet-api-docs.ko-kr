<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FrameworkContentElement.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b891ec5d-4b60-42d7-ac21-95eab9e3ef82615425e7a431643682b3286cc26cb17aa80cb9d4.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">615425e7a431643682b3286cc26cb17aa80cb9d4</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">058bfa0b75b777d3171411d35da8f11617fc06b0</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/04/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is the WPF framework-level implementation and expansion of the <ph id="ph2">&lt;see cref="T:System.Windows.ContentElement" /&gt;</ph> base class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>는 <ph id="ph2">&lt;see cref="T:System.Windows.ContentElement" /&gt;</ph> 기본 클래스의 WPF 프레임워크 수준 구현 및 확장입니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>는 데이터 바인딩, 스타일 지원 및 논리적 트리 도우미 API를 위한 데이터 컨텍스트, 스토리보드 및 추가 입력 API(도구 설명 및 상황에 맞는 메뉴 포함)에 대한 지원을 추가합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> does not yet define its own rendering behavior; instantiating an actual <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> class instance in code or markup is possible but displays nothing in a <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> application <ph id="ph4">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 고유한 렌더링 동작; 아직 정의 하지 않습니다. 실제 인스턴스화 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 코드 또는 태그의 클래스 인스턴스 수는 있지만에 아무 것도 표시는 <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> 응용 프로그램 <ph id="ph4">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Rendering logic must be provided by classes that take <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> child elements as part of their content model, or in <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes.</source>
          <target state="translated">사용 하는 클래스에서 제공 되어야 렌더링 논리 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 일부로 또는 콘텐츠 모델의 자식 요소 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 파생 클래스입니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> deliberately parallels many of the same <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> as <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 동일한 의도적 <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> 으로 <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Note that certain <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> found on <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> will not have a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> equivalent.</source>
          <target state="translated">특정 참고 <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> 에 <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> 체계가 없습니다는 <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 해당 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Several of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> are for functionality such as geometry representation or layout, which are not relevant for a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
          <target state="translated">몇 가지는 <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> 에 관련이 없는는 기 하 도형 표현 또는 레이아웃을와 같은 기능에는 한 <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>The majority of existing <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes will be found in the <ph id="ph2">&lt;xref:System.Windows.Documents&gt;</ph> namespace.</source>
          <target state="translated">대부분의 기존 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 파생된 클래스에서 섹션의 <ph id="ph2">&lt;xref:System.Windows.Documents&gt;</ph> 네임 스페이스입니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Many of these derived classes implement elements for the flow document model.</source>
          <target state="translated">파생된 클래스는 대부분 흐름 문서 모델에 대 한 요소를 구현합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Certain derived classes such as <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> have some control-like functionality, but are derived from <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> such that the control-like elements can still participate in the flow document model.</source>
          <target state="translated">와 같은 특정 파생된 클래스 <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> 일부 컨트롤과 비슷한 기능이 같지만에서 파생 된 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 컨트롤 형식 요소의 흐름 문서 모델에 참가할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>The child element to be added.</source>
          <target state="translated">추가될 자식 요소입니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Adds the provided element as a child of this element.</source>
          <target state="translated">이 요소의 자식으로 제공된 요소를 추가합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>This method can throw an exception if called at a time when the logical tree is being iterated by another process.</source>
          <target state="translated">이 메서드는 논리적 트리를 다른 프로세스에 의해 반복 중일 때 한 번에 메서드를 호출 하면 예외를 throw 수 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Most <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes expose dedicated collections that are responsible for containment (for example, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> class; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> on the <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> class).</source>
          <target state="translated">대부분 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 포함에 대 한 역할을 하는 전용된 컬렉션을 노출 하는 파생 된 클래스 (예를 들어 <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> 에 <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> 클래스입니다. <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> 에 <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> 클래스).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</source>
          <target state="translated">일반적으로 이러한 클래스에서 파생 하는 경우 논리적 트리를 직접 조작 필요를 방지할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that acts as the parent rendering element (content host).</source>
          <target state="translated">콘텐츠 요소에 대 한 논리 트리 사용은 특별 한 파서 또는 특수화 된 필요할 수 있는 고급 시나리오 <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> 부모 렌더링 요소 (콘텐츠 호스트)로 역할을 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>For more information about how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">사용 하는 방법에 대 한 자세한 내용은 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, 참조 <bpt id="p1">[</bpt>In WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Called before an element is initialized.</source>
          <target state="translated">요소를 초기화하기 전에 호출됩니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Override this method to provide special handling that should occur before your element is initialized during the element loading process.</source>
          <target state="translated">요소 로드 프로세스 중에 요소를 초기화 하기 전에 수행 해야 하는 특수 한 처리를 제공 하려면이 메서드를 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">(기본값) 기본 구현을 초기화를 추적 하기 위해 일부 내부 플래그를 설정 하기 때문에 구현에서 기본 구현을 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>The base implementation will throw an exception if <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.BeginInit" /&gt;</ph> is called more than one time on the same element prior to reaching <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>.</source>
          <target state="translated">기본 구현 하는 경우 예외가 throw 됩니다 <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.BeginInit" /&gt;</ph> 도달 하기 전에 같은 요소에 한 번 이상 라고 <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source>Begins the sequence of actions that are contained in the provided storyboard.</source>
          <target state="translated">제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>The storyboard to begin.</source>
          <target state="translated">시작할 Storyboard입니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Begins the sequence of actions that are contained in the provided storyboard.</source>
          <target state="translated">제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">사용 하지 않는 서명을 위한는 <ph id="ph1">`isControllable`</ph>, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 <ph id="ph2">`false`</ph>, 연결 된 애니메이션 시간 표시 막대 clock "전체" 기간의 끝에 도달 하는 즉시 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">애니메이션을 제어 또한을 사용 하려면 명명 된 인스턴스나 인스턴스로 코드에서 액세스할 수 있는 스토리 보드 되도록 note 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The storyboard to begin.</source>
          <target state="translated">시작할 Storyboard입니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</source>
          <target state="translated">Storyboard에 설명되어 있는 속성에 이미 애니메이션이 적용되어 있는 경우에 사용할 동작을 설명하는 열거형의 값입니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</source>
          <target state="translated">속성에 이미 애니메이션이 적용되어 있는 경우 수행할 작업에 대해 지정된 옵션을 사용하여 제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">사용 하지 않는 서명을 위한는 <ph id="ph1">`isControllable`</ph>, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 <ph id="ph2">`false`</ph>, 연결 된 애니메이션 시간 표시 막대 clock "전체" 기간의 끝에 도달 하는 즉시 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">애니메이션을 제어 또한을 사용 하려면 명명 된 인스턴스나 인스턴스로 코드에서 액세스할 수 있는 스토리 보드 되도록 note 합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">사용 하 여 HandoffBehavior 작성</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</source>
          <target state="translated">적용 하는 경우는 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, 또는 <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> 를 사용 하 여 속성에는 <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>있으면 모든 <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> 이전에 해당 속성과 연관 된 개체를 계속 시스템 리소스를 사용 하 고 타이밍 시스템 않습니다 시계를 자동으로 제거 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">사용 하 여 많은 수의 clock 적용할 때 성능 문제를 방지 하려면 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>를 완성 한 후 속성에서 구성 중인 clock를 제거 해야 합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">클록을 제거 하는 방법은 여러 가지가 있습니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">에서 제거 하려면 모든 clock 속성을 사용 하 여는 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> 애니메이션된 된 개체의 메서드.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 <ph id="ph1">`null`</ph> 를 두 번째입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">그러면 모든 애니메이션 클록 속성에서 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">특정을 제거 하려면 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> 클록 목록에서 사용 하 여는 <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> 속성의는 <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> 검색 하는 <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, 호출는 <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> 의 메서드는 <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">이 일반적으로 수행 된 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> 클록에 대 한 이벤트 처리기입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">유일한 루트 클록을 제어할 수 있는 참고는 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> 자식 클록의 속성을 반환 <ph id="ph3">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">또한는 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> 클록의 유효 기간이 무제한 인 경우 이벤트가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">사용자를 호출 하는 시기를 결정 해야 경우 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">이것은 주로 수명이 긴 개체에 대한 애니메이션에서 문제가 됩니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">개체가 가비지 수집 된 경우 해당 clock도 연결이 끊어지고 가비지 수집.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">클록 개체에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>애니메이션 및 타이밍 시스템 개요<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>The storyboard to begin.</source>
          <target state="translated">시작할 Storyboard입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</source>
          <target state="translated">스토리보드에 설명되어 있는 속성에 이미 애니메이션이 적용되어 있는 경우에 사용할 동작을 설명하는 열거형의 값입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Declares whether the animation is controllable (can be paused) after it is started.</source>
          <target state="translated">애니메이션을 시작한 후 제어(일시 중지)할 수 있는지 여부를 선언합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</source>
          <target state="translated">애니메이션이 시작된 후 제어하기 위한 지정된 상태를 사용하여 제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">사용 하지 않는 서명을 위한는 <ph id="ph1">`isControllable`</ph>, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 <ph id="ph2">`false`</ph>, 연결 된 애니메이션 시간 표시 막대 clock "전체" 기간의 끝에 도달 하는 즉시 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">애니메이션을 제어 또한을 사용 하려면 명명 된 인스턴스나 인스턴스로 코드에서 액세스할 수 있는 스토리 보드 되도록 note 합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">사용 하 여 HandoffBehavior 작성</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</source>
          <target state="translated">적용 하는 경우는 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, 또는 <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> 를 사용 하 여 속성에는 <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>있으면 모든 <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> 이전에 해당 속성과 연관 된 개체를 계속 시스템 리소스를 사용 하 고 타이밍 시스템 않습니다 이러한 clock를 자동으로 제거 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">사용 하 여 많은 수의 clock 적용할 때 성능 문제를 방지 하려면 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>를 완성 한 후 속성에서 구성 중인 clock를 제거 해야 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">클록을 제거 하는 방법은 여러 가지가 있습니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">에서 제거 하려면 모든 clock 속성을 사용 하 여는 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> 애니메이션된 된 개체의 메서드.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 <ph id="ph1">`null`</ph> 를 두 번째입니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">그러면 모든 애니메이션 클록 속성에서 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">특정을 제거 하려면 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> 클록 목록에서 사용 하 여는 <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> 속성의는 <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> 검색 하는 <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, 호출는 <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> 의 메서드는 <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">이 일반적으로 수행 된 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> 클록에 대 한 이벤트 처리기입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">유일한 루트 클록을 제어할 수 있는 참고는 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> 자식 클록의 속성을 반환 <ph id="ph3">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">또한는 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> 클록의 유효 기간이 무제한 인 경우 이벤트가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">사용자를 호출 하는 시기를 결정 해야 경우 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">이것은 주로 수명이 긴 개체에 대한 애니메이션에서 문제가 됩니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">개체가 가비지 수집 된 경우 해당 clock도 연결이 끊어지고 가비지 수집.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">클록 개체에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>애니메이션 및 타이밍 시스템 개요<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">요소에 사용되는 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph>을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">요소에 사용되는 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> can be used to validate the values of multiple properties of an object.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> 개체의 여러 속성 값의 유효성 검사를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>For example, suppose that an application prompts the user to enter an address and then populates an object of type <ph id="ph1">`Address`</ph>, which has the properties <ph id="ph2">`Street`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`ZipCode`</ph>, and <ph id="ph5">`Country`</ph>, with the values that the user provided.</source>
          <target state="translated">예를 들어 응용 프로그램 주소를 입력 하 라는 메시지를 표시 하 고 다음 유형의 개체를 채웁니다 <ph id="ph1">`Address`</ph>, 속성이 있는 <ph id="ph2">`Street`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`ZipCode`</ph>, 및 <ph id="ph5">`Country`</ph>, 값을 사용 하는 사용자 제공 됩니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>The application has a panel that contains four <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> controls, each of which is bound to one of the object’s properties.</source>
          <target state="translated">응용 프로그램에 4 개를 포함 하는 패널 <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> 개체의 속성 중 하나에 바인딩되는 컨트롤입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>You can use a <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> in a <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> to validate the <ph id="ph3">`Address`</ph> object.</source>
          <target state="translated">사용할 수 있습니다는 <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> 에 <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> 유효성을 검사 하 여 <ph id="ph3">`Address`</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> can ensure that the zip code is valid for the country of the address.</source>
          <target state="translated">예를 들어는 <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> 우편 번호 주소 국가 대 한 유효한 되는지 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Child elements inherit the <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> from their parent elements, just as with any other inheritable property.</source>
          <target state="translated">자식 요소를 상속 된 <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> 다른 상속 가능한 속성 경우와 마찬가지로, 부모 요소 로부터 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Metadata properties set to <bpt id="p1">**</bpt>true<ept id="p1">**</ept></source>
          <target state="translated">메타 데이터 속성이 <bpt id="p1">**</bpt>true<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.BindingGroupProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>Attempts to bring this element into view, within any scrollable regions it is contained within.</source>
          <target state="translated">이 요소를 포함된 스크롤 가능한 영역 내에서 뷰에 표시하려고 합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>By calling this method, you effectively will call <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> on any parent scrollable area that contains the element (the parent may very well be a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, not a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>).</source>
          <target state="translated">이 메서드를 호출 하면 호출 됩니다 <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> 요소가 포함 된 부모 스크롤 가능한 영역에서 (부모 수 있을 것을 <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>이 아니라는 <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</source>
          <target state="translated">이 요소는 스크롤 가능한 영역에 포함 되지 않은, 이벤트가 계속 되지만 아무런 영향을 주지 됩니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Gets or sets the context menu element that should appear whenever the context menu is requested via <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> from within this element.</source>
          <target state="translated">이 요소 내에서 <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>를 통해 상황에 맞는 메뉴를 요청할 때마다 표시되는 상황에 맞는 메뉴 요소를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>The context menu that this element uses.</source>
          <target state="translated">이 요소가 사용하는 상황에 맞는 메뉴입니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>None</source>
          <target state="translated">없음</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>The following example places a <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> on a <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 위치는 <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> 에 <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Occurs just before any context menu on the element is closed.</source>
          <target state="translated">요소의 상황에 맞는 메뉴를 닫기 직전에 발생합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>To suppress closing context menus, handlers of the event should mark it as handled.</source>
          <target state="translated">닫히지 않도록 하려면 상황에 맞는 메뉴는 이벤트 처리기로 표시 해야 처리.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying service event identifier:</source>
          <target state="translated">이 이벤트로 사용 하는 <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> 스타일에서 기본 서비스 이벤트 식별자를 참조 해야 합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> that exposes the underlying service event does not correctly map the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuClosing&gt;</ph> identifier for use in triggers).</source>
          <target state="translated">(때문에이 사용은 필수에서 이벤트를 구현 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 있는지 노출 기본 서비스 이벤트 올바르게 매핑되지 않습니다는 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuClosing&gt;</ph> 트리거에 사용할 식별자)입니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Routed Event Information</source>
          <target state="translated">라우팅 이벤트 정보</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Routing strategy</source>
          <target state="translated">라우팅 전략</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Bubbling</source>
          <target state="translated">버블링</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Delegate</source>
          <target state="translated">대리자</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>The following example implements a handler that changes the cursor over a named region <ph id="ph1">`DisplayArea`</ph> (not shown).</source>
          <target state="translated">다음 예제에서는 명명 된 영역 위에 커서를 변경 하는 처리기를 구현 <ph id="ph1">`DisplayArea`</ph> (표시 되지 않음).</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>The comment hints at a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> usage, but in fact this sample would be identical if <ph id="ph2">`DisplayArea`</ph> were a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
          <target state="translated">주석 힌트가 <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> 사용 뿐만 아니라 실제로이 예제와 동일한 경우 <ph id="ph2">`DisplayArea`</ph> 된는 <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> <bpt id="p1">[</bpt>라우트된 이벤트 개요<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>를 식별합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Occurs when any context menu on the element is opened.</source>
          <target state="translated">요소의 상황에 맞는 메뉴를 열 때 발생합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>To manually open context menus, handlers of the events should mark the relevant event as handled.</source>
          <target state="translated">상황에 맞는 메뉴를 열어야 하는 처리 된 것으로 이벤트의 처리기 관련 이벤트를 표시 해야 합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Otherwise, the existing value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> property will be used to automatically open a context menu.</source>
          <target state="translated">그렇지 않은 경우의 기존 값에서 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> 를 자동으로 상황에 맞는 메뉴를 열려면 속성을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> property and then open the new <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
          <target state="translated">이벤트를 처리 된을 효과적으로 기본 작업을 취소 하 고 수 값을 다시 설정 하는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> 속성을 열고 새 <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>However, there is a timing issue you should be aware of.</source>
          <target state="translated">그러나은 알고 있어야 하는 타이밍 문제입니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>In order to completely replace the context menu through a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> handler, the initial context menu must not be null / empty.</source>
          <target state="translated">통해 상황에 맞는 메뉴를 완전히 바꾸기 위해는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> 처리기를 초기 상황에 맞는 메뉴 않아야 null 이거나 비어 있습니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Alternatively, you might need to handle the event and then manually open a new context menu.</source>
          <target state="translated">또는 이벤트를 처리 한 다음 수동으로 새 상황에 맞는 메뉴를 엽니다. 해야 합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>For details, see <bpt id="p1">[</bpt>How to: Handle the ContextMenuOpening Event<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>하는 방법: ContextMenuOpening 이벤트를 처리할<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying service event identifier:</source>
          <target state="translated">이 이벤트로 사용 하는 <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> 스타일에서 기본 서비스 이벤트 식별자를 참조 해야 합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> that exposes the underlying service event does not correctly map the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> identifier for use in triggers).</source>
          <target state="translated">(때문에이 사용은 필수에서 이벤트를 구현 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 있는지 노출 기본 서비스 이벤트 올바르게 매핑되지 않습니다는 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> 트리거에 사용할 식별자)입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Routed Event Information</source>
          <target state="translated">라우팅 이벤트 정보</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Routing strategy</source>
          <target state="translated">라우팅 전략</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Bubbling</source>
          <target state="translated">버블링</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Delegate</source>
          <target state="translated">대리자</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> <bpt id="p1">[</bpt>라우트된 이벤트 개요<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>를 식별합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Gets or sets the cursor that displays when the mouse pointer is over this element.</source>
          <target state="translated">마우스 포인터가 이 요소 위에 있을 때 표시되는 커서를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The cursor to display.</source>
          <target state="translated">표시할 커서입니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The default value is defined as <ph id="ph1">&lt;see langword="null" /&gt;</ph> per this dependency property.</source>
          <target state="translated">기본값은 이 종속성 속성마다 <ph id="ph1">&lt;see langword="null" /&gt;</ph>로 정의됩니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>However, the practical default at run time will come from a variety of factors.</source>
          <target state="translated">그러나 런타임 시 실제 기본값은 다양한 요소에서 비롯됩니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>When setting this property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> processor relies on type conversion for the <ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph> class to evaluate the string.</source>
          <target state="translated">이 속성을 설정할 때 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> 형식 변환에 대 한 프로세서 사용의 <ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph> 문자열을 평가 하는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The provided string should evaluate to a <ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph> value.</source>
          <target state="translated">제공 된 문자열에 <ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph> 값입니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> for details.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> property.</source>
          <target state="translated">이 속성에서 설정한 커서가 여부 마우스 포인터가이 요소 위에 있을 때 표시 되지 것입니다의 값에 따라 결정 됩니다.는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</source>
          <target state="translated">또한는 활성 끌기, 마우스 캡처, 컨트롤 및 등 내의 텍스트 편집 모드와 같은 이벤트 관련 고려 사항 보다 우선 순위가 높은 사용자가이 속성에 지정한 값 보다 커서를 적용도 됩니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>To revert the behavior of setting this property to the eventual default, set it to <ph id="ph1">`null`</ph> again.</source>
          <target state="translated">최종 기본적으로이 속성을 설정 하는 동작을 되돌리려면로 설정 <ph id="ph1">`null`</ph> 다시 합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The <ph id="ph1">`null`</ph> default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</source>
          <target state="translated"><ph id="ph1">`null`</ph> 실제 커서 값의 결정 지연 시키고 다른 곳에서 가져올 기본값인 의미 합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If presented with no programmatic values from any source, the default cursor over a <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> application will be an arrow.</source>
          <target state="translated">위에 표시 된 기본 커서 모든 소스에서 프로그래밍 방식으로 값이 없는 경우는 <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> 응용 프로그램에 화살표가 됩니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Each movement of the mouse over a <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> application raises a <ph id="ph2">&lt;xref:System.Windows.ContentElement.QueryCursor&gt;</ph> event.</source>
          <target state="translated">각 위로 마우스를 움직일은 <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> 발생 한 <ph id="ph2">&lt;xref:System.Windows.ContentElement.QueryCursor&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</source>
          <target state="translated">이벤트 버블 및 경로 따라 모든 요소에는 이벤트를 처리 하 고이 이벤트의 인수를 통해 커서의 값을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph> property at any level, unless <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> is set.</source>
          <target state="translated">이렇게 되 면 이벤트를 처리 하 고 인수에서 변경 된 값은 우선의 값은 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph> 모든 수준에서 속성 하지 않는 한 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If not creating a custom cursor, typically you set this property to a static property value of the <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> class.</source>
          <target state="translated">사용자 지정 커서를 만들지, 경우에 일반적으로이 속성 값으로 설정 하면는 정적 속성의는 <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Setting the <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> to a custom value is not enabled in partial trust.</source>
          <target state="translated">설정의 <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> 사용자 지정 값으로 설정 되지 않은 부분 신뢰 합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>For more information on custom cursors, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">사용자 지정 커서에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>입력 개요<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>None</source>
          <target state="translated">없음</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The following example sets the cursor to a custom value.</source>
          <target state="translated">다음 예제에서는 사용자 지정 값으로 커서를 설정합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.CursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Gets or sets the data context for an element when it participates in data binding.</source>
          <target state="translated">데이터 바인딩에 참여할 때 요소에 대한 데이터 컨텍스트를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The object to use as data context.</source>
          <target state="translated">데이터 컨텍스트로 사용할 개체입니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>Data context<ept id="p1">*</ept> is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</source>
          <target state="translated"><bpt id="p1">*</bpt>데이터 컨텍스트<ept id="p1">*</ept> 정보 바인딩 뿐만 아니라 경로 같은 바인딩의 다른 특성에 사용 되는 바인딩 소스에 대 한 부모 요소 로부터 상속할 수 있도록 하는 개념은 합니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Data context can be set directly to a <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> object, with the bindings evaluating to properties of that object.</source>
          <target state="translated">데이터 컨텍스트를 직접 설정할 수는 <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> 바인딩 해당 개체의 속성을 사용 하 여 개체입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, you can set the data context to a <ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph> object.</source>
          <target state="translated">또는 데이터 컨텍스트 설정할 수는 <ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>This dependency property inherits property values.</source>
          <target state="translated">속성 값이 종속성 속성을 상속 합니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">에 대 한 다른 값이 없는 자식 요소가 많은 경우 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정 수는 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, you can use one of the following properties of the <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> class to specify the binding source explicitly: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>.</source>
          <target state="translated">다음 속성 중 하나를 사용할 수 있습니다 또는 <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> 바인딩 소스를 명시적으로 지정 하려면 클래스: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>, 또는 <ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Specify the Binding Source<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>하는 방법: 바인딩 소스를 지정<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> is most commonly set to as a <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> declaration.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> 가장 일반적으로으로 설정 된 <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> 선언 합니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>You can use either property element syntax or attribute syntax.</source>
          <target state="translated">속성 요소 구문 또는 특성 구문 중 하나를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Attribute syntax is shown in the example on this page.</source>
          <target state="translated">특성 구문은이 페이지에 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>You can also set <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> in code.</source>
          <target state="translated">설정할 수도 있습니다 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> 코드에서입니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Property Element Usage</source>
          <target state="translated">XAML 속성 요소 사용</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 특성 사용</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Values</source>
          <target state="translated">XAML 값</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>A directly embedded object that serves as data context for any bindings within the parent element.</source>
          <target state="translated">부모 요소 내에서 모든 바인딩에 대 한 데이터 컨텍스트 역할을 하는 직접 포함 된 개체입니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Typically, this object is a <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> or another <ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> subclass.</source>
          <target state="translated">이 개체는 일반적으로 <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> 또는 다른 <ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> 하위 클래스입니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, raw data of any <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> object type intended for binding may be placed here, with the actual bindings defined later.</source>
          <target state="translated">또는 원시 데이터 <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> 개체 바인딩 나중에 정의 된 실제 바인딩은 여기서 배치 될 수 있습니다에 사용 되는 형식입니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>A binding usage that evaluates to an appropriate data context.</source>
          <target state="translated">적절 한 데이터 컨텍스트로 계산 되는 바인딩 사용 합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>For details, see <bpt id="p1">[</bpt>Binding Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>Binding 태그 확장<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>One of the following: <ph id="ph1">`StaticResource`</ph>, or <ph id="ph2">`DynamicResource`</ph>.</source>
          <target state="translated">다음 중 하나: <ph id="ph1">`StaticResource`</ph>, 또는 <ph id="ph2">`DynamicResource`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>This usage is used when referring to raw data defined as an object in resources.</source>
          <target state="translated">리소스에는 개체로 정의 하는 원시 데이터를 참조할 때 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>XAML 리소스<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The key identifier for the object being requested from within a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">내에서 요청 된 개체에 대 한 키 식별자는 <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new custom data object, establishing that object as <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, and setting the binding path to a property within it.</source>
          <target state="translated">다음 예제에서는 대 한 바인딩을 설정는 <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> 요소와 해당 개체는 새 사용자 지정 데이터 개체를 만들어 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, 바인딩 경로 내에 속성을 설정 합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>Occurs when this element's data context changes.</source>
          <target state="translated">이 요소의 데이터 컨텍스트가 변경될 때 발생합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>For an explanation of data contexts and data binding, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</source>
          <target state="translated">참조에 대 한 데이터 컨텍스트 및 데이터 바인딩에 설명은 <bpt id="p1">[</bpt>데이터 바인딩 개요<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>When an element's <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> changes, all data-bound properties on this element are potentially affected.</source>
          <target state="translated">요소의 경우 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> 변경,이 요소에 모든 데이터 바인딩 속성은 영향을 받을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</source>
          <target state="translated">이 모든 요소는 데이터 컨텍스트를 상속 하는 현재 요소의 하위 요소를 서로 그리고 현재 요소 자체에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>All such bindings re-interpret the new <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> to reflect the new value in bindings.</source>
          <target state="translated">이러한 모든 바인딩은 다시 새 해석 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> 바인딩에 새 값을 반영 합니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>There is no guarantee made about the order of these changes relative to the raising of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContextChanged&gt;</ph> event.</source>
          <target state="translated">이러한 변경의 발생을 기준으로 하는 순서는 보장 되지 않습니다는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContextChanged&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>The changes can occur before the event, after the event, or in any mixture.</source>
          <target state="translated">혼합 또는 이벤트 이후에 변경 이벤트 전에 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.DataContextProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DataContext" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DataContext" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Gets or sets the key to use to find the style template for this control in themes.</source>
          <target state="translated">테마에서 이 컨트롤에 대해 스타일 템플릿을 찾는 데 사용할 키를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>The style key.</source>
          <target state="translated">스타일 키입니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>To work correctly as part of theme style lookup, this value is expected to be the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the element being styled.</source>
          <target state="translated">테마 스타일 조회의 일부로 올바르게 사용하려면 이 값은 스타일을 지정할 요소의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>이어야 합니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> is an accepted value for a certain case.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> 특정 사례에 대해 허용 된 값이입니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>This property is typically not set through any of its direct setters.</source>
          <target state="translated">이 속성은 일반적으로 직접 setter 통해 설정 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</source>
          <target state="translated">대신, 새 하위 클래스를 만들 때마다이 종속성 속성의 유형별 메타 데이터를 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>When you subclass, call the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method against the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty&gt;</ph> identifier, within the static constructor of the control subclass.</source>
          <target state="translated">때 하면 하위 클래스, 호출의 <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> 에 대해 메서드는 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty&gt;</ph> 제어 하위 클래스의 정적 생성자 내에서 식별자입니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>For instance, an inline class such as <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> actually has very little implementation beyond overriding the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> metadata in its static constructor, and exposing several instance constructors.</source>
          <target state="translated">예를 들어, 인라인 클래스와 같은 <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> 재정의 외에 거의 구현 권한이 실제로 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> 메타 데이터에 해당 정적 생성자 및 여러 인스턴스 생성자를 노출 합니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>The fact that elements surrounded by the <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> tag gain a <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.FontWeight%2A&gt;</ph> property of <ph id="ph3">&lt;xref:System.Windows.FontWeights.Bold%2A&gt;</ph> is implemented within the theme style that was referenced by setting the default value of <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> to <ph id="ph5">`typeof(Bold)`</ph>.</source>
          <target state="translated">팩트로 묶인 요소는 <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> 이득 태그는 <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.FontWeight%2A&gt;</ph> 속성 <ph id="ph3">&lt;xref:System.Windows.FontWeights.Bold%2A&gt;</ph> 의 기본값을 설정 하 여 참조 되는 테마 스타일 내에서 구현 되 <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> 를 <ph id="ph5">`typeof(Bold)`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>If you want your element or control to deliberately not use theme styles, set the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">테마 스타일을 사용 하지 않도록 신중 하 게 컨트롤을 하려는 경우 설정의 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A&gt;</ph> 속성을 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Called immediately after an element is initialized.</source>
          <target state="translated">요소를 초기화한 후에 바로 호출됩니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</source>
          <target state="translated">요소를 로드 프로세스 중 요소를 초기화 하는 경우 수행 해야 하는 특수 처리를 제공 하려면이 메서드를 구현 합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">(기본값) 기본 구현을 초기화를 추적 하기 위해 일부 내부 플래그를 설정 하기 때문에 구현에서 기본 구현을 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>If <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was previously called, the base implementation will raise the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Initialized&gt;</ph> event.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> 가 이전에 호출, 기본 구현에서 발생 된 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Initialized&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Otherwise, if <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was not called or it could not be determined whether <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was called, the event is not raised.</source>
          <target state="translated">그렇지 않은 경우, <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> 를 호출 하지 않았습니다 수 없는 또는 되었는지를 확인할 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> 가 호출 된 이벤트가 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>Name of the element to search for.</source>
          <target state="translated">검색할 요소의 이름입니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>Finds an element that has the provided identifier name.</source>
          <target state="translated">제공된 식별자 이름의 요소를 찾습니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>The requested element.</source>
          <target state="translated">요청한 요소입니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>May be <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching element was found.</source>
          <target state="translated">일치하는 요소를 찾을 수 없으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>If this element has child elements, these child elements are all searched recursively for the requested named element.</source>
          <target state="translated">이 요소에 자식 요소가 있으면 이러한 자식 요소는 요청 된 명명 된 요소에 대 한 모든 검색 결과 재귀적으로.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>The following example sets a property on an element found by name within a referenced <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> on a page.</source>
          <target state="translated">내에서 참조 된 이름으로 검색 되는 요소에 속성을 설정 하는 다음 예제에서는 <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> 페이지에 있습니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Key identifier of the resource to be found.</source>
          <target state="translated">찾을 리소스의 키 식별자입니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</source>
          <target state="translated">지정된 키를 사용하여 리소스를 검색하고, 요청된 리소스가 없으면 예외를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The found resource, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching resource was found (but will also throw an exception if <ph id="ph2">&lt;see langword="null" /&gt;</ph>).</source>
          <target state="translated">찾은 리소스이거나, 일치하는 리소스가 없는 경우 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다. <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우 예외가 throw될 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If you call this method for a key that cannot be found, an exception is thrown.</source>
          <target state="translated">이 메서드를 찾을 수 없는 키에 대 한를 호출 하면 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If you do not want to handle exceptions for this case, you should instead call <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph>.</source>
          <target state="translated">대신 호출 해야이 있는 경우 예외를 처리 하지 않을 경우 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph> returns <ph id="ph2">`null`</ph> when no resource is found, and does not throw an exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph> 반환 <ph id="ph2">`null`</ph> 리소스가 발견 되 고 예외를 throw 하지 않는 경우.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</source>
          <target state="translated">호출 하는 요소에는 리소스를 찾을 수 없습니다, 논리적 트리를 사용 하 여 부모 트리를 검색 하는 경우는 트리 수와 동일한 방식으로 리소스는 이상인 경우 검색된 실행 시 키에 의해 요청 된.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</source>
          <target state="translated">일반적으로 반환 값을 반환 되는 리소스 값으로 설정 하 려 했던 하는 속성의 형식 캐스팅 즉시 것입니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</source>
          <target state="translated">다음 예제에서는 태그에서 정의 된 대로 리소스를 찾아 특정 라우트된 이벤트에 대 한 응답에 있는 요소의 속성에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The requested resource key was not found.</source>
          <target state="translated">요청된 리소스 키가 없는 경우</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</source>
          <target state="translated">키보드 포커스를 캡처할 때 이 요소에 적용되는 모양, 효과 또는 기타 스타일 특성을 사용자 지정할 수 있는 개체를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The desired style to apply on focus.</source>
          <target state="translated">포커스에 적용하려는 스타일입니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The default value as declared in the dependency property is an empty static <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph>.</source>
          <target state="translated">종속성 속성에 선언되어 있는 기본값은 빈 정적 <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</source>
          <target state="translated">그러나 런타임 시 유효 값은 대체로(항상 그렇지는 않음) 컨트롤에 대한 테마 지원에서 제공되는 스타일입니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>When setting this property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <ph id="ph2">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph>.</source>
          <target state="translated">이 속성을 설정할 때 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>스타일은 인라인 요소 대신 리소스로 거의 항상 정의 하 고로 참조 리소스는 일반적으로 <ph id="ph2">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Note that this property affects visual appearance but does not report so in metadata.</source>
          <target state="translated">이 속성 시각적 모양에 영향을 미칩니다. 하지만 처럼 보고 되지 않습니다 메타 데이터에 참고 합니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</source>
          <target state="translated">시각적으로 유사한 변경은 이벤트 기반 및 모든 시간에 적용 되지 않을 수 이며 따라서 보고 하지 않아야 일반적으로 메타 데이터에는 visual 또는 레이아웃 정보가 때문입니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</source>
          <target state="translated">개념적으로 컨트롤에 적용 되는 포커스의 시각적 동작 요소에 일관 된 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</source>
          <target state="translated">일관성을 적용 하는 가장 적절 한 방법은 전체 테마를 작성 하는 경우에 포커스 시각적 스타일을 변경 하는 것입니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</source>
          <target state="translated">개별 스타일 및 테마의 일부가 아니라이 속성을 설정할 수는 없습니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>, and to do so in a way that does not visually interfere with any existing focus visual style.</source>
          <target state="translated">테마 전체에서 일관 된 의도 한 대로 되지 않는 요소 관련 동작을 하려는 경우 더 좋은 방법은를 사용 하 트리거 스타일의 개별 입력된 상태 속성 같은 <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>, 그렇게 하지 않는 방식으로 수행할 수 있습니다 시각적으로 기존 포커스 시각적 스타일에 방해가 됩니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>For more information on the design intention of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A&gt;</ph> and alternative focus properties, see <bpt id="p1">[</bpt>Styling for Focus in Controls, and FocusVisualStyle<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>.</source>
          <target state="translated">디자인 의도 대 한 자세한 내용은 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A&gt;</ph> 및 집중 속성을 참조 하십시오. 대체 <bpt id="p1">[</bpt>컨트롤과 FocusVisualStyle에 포커스에 대 한 스타일 지정<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 특성 사용</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Property Element Usage</source>
          <target state="translated">XAML 속성 요소 사용</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Values</source>
          <target state="translated">XAML 값</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>One of the following: , or .</source>
          <target state="translated">다음 중 하나:, 또는.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>XAML 리소스<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">요청 되는 스타일을 식별 하는 키입니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">기존 리소스를이 키는 한 <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Property element syntax is technically possible, but not recommended.</source>
          <target state="translated">속성 요소 구문은 지원 되지만 권장 하지는 않습니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>인라인 스타일 및 템플릿<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">사용 하 여 바인딩 참조 또는 <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> 가능 하지만 일반적이 지 않은 이기도 합니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>None</source>
          <target state="translated">없음</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Gets or sets a value indicating whether this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> should force the <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> to render the cursor as declared by this instance's <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> property.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>가 이 인스턴스의 <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> 속성에서 선언된 커서를 렌더링하도록 <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>에 명령할 것인지를 나타내는 값을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 요소 위에 있을 때 커서에 대한 이 인스턴스의 설정(모든 자식 요소 포함)을 사용하여 커서가 표시되도록 하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>The default value is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">기본값은 <ph id="ph1">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Setting this property to <ph id="ph1">`true`</ph> will override the cursor preferences established by child elements.</source>
          <target state="translated">이 속성을 설정 <ph id="ph1">`true`</ph> 자식 요소에서 설정한 커서 기본 설정이 재정의 됩니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Doing so in general application <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> might be confusing for the user, particularly if child elements are attempting to specify cursors.</source>
          <target state="translated">이렇게 하면 일반적 응용 프로그램 <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> 자식 요소는 커서를 지정 하려고 하는 경우에 특히 해당 사용자를 혼동 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> is more appropriate in control subclassing or compositing scenarios.</source>
          <target state="translated">설정 <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> 컨트롤 서브클래싱 또는 작성 시나리오에 더 적합 합니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>None</source>
          <target state="translated">없음</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>The following example forces the cursor while over the element.</source>
          <target state="translated">다음 예제에서는 요소 위에 있는 동안 커서를 강제로 수행 합니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ForceCursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>The target <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> from which to get the binding.</source>
          <target state="translated">바인딩을 가져올 대상 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> for the specified property's binding.</source>
          <target state="translated">지정된 속성의 바인딩에 대한 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph>을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> if the target is data bound; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">대상이 데이터 바인딩되어 있으면 <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph>을 반환하고, 그렇지 않으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>The following example retrieves a binding by querying a property.</source>
          <target state="translated">다음 예제에서는 속성을 쿼리하여 바인딩을 검색 합니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Returns an alternative logical parent for this element if there is no visual parent.</source>
          <target state="translated">시각적 부모가 없는 경우 이 요소에 대한 대체 논리 부모를 반환합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>In this case, a <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> parent is always the same value as the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Parent" /&gt;</ph> property.</source>
          <target state="translated">이 경우 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> 부모는 항상 <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Parent" /&gt;</ph> 속성과 동일한 값입니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Returns something other than <ph id="ph1">&lt;see langword="null" /&gt;</ph> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</source>
          <target state="translated">이 메서드의 WPF 프레임워크 수준 구현에 시각적 부모가 아닌 연결이 있을 때마다 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 이외의 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>The default implementation returns the expected single visual parent.</source>
          <target state="translated">기본 구현은 필요한 단일 시각적 부모를 반환합니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Custom implementations might return alternate parent relationships.</source>
          <target state="translated">사용자 지정 구현을 대체 부모 관계를 반환할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>Occurs when this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is initialized.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>가 초기화될 때 발생합니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>This coincides with cases where the value of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> property changes from <ph id="ph2">&lt;see langword="false" /&gt;</ph> (or undefined) to <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">이는 <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> 속성의 값이 <ph id="ph2">&lt;see langword="false" /&gt;</ph>(정의되지 않음)에서 <ph id="ph3">&lt;see langword="true" /&gt;</ph>로 변경되는 경우와 일치합니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>This event will be raised whenever the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.EndInit%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.OnInitialized%2A&gt;</ph> methods are called.</source>
          <target state="translated">이 이벤트가 될 때마다 발생는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.EndInit%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.OnInitialized%2A&gt;</ph> 메서드가 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>Calls to these methods could have been made by deliberate code, or by the <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> loading process.</source>
          <target state="translated">이러한 방법에 대 한 호출 수 있는 계획적 코드 또는 <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> 프로세스를 로드 합니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Gets or sets the context for input used by this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>에서 사용하는 입력에 대한 컨텍스트를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>The input scope, which modifies how input from alternative input methods is interpreted.</source>
          <target state="translated">대체 입력 메서드에서 입력이 해석되는 방법을 수정하는 입력 범위입니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>The default value is <ph id="ph1">&lt;see langword="null" /&gt;</ph> (which results in a default handling of commands).</source>
          <target state="translated">기본값은 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이며, 이 값을 사용하면 명령이 기본 처리됩니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>This dependency property inherits property values.</source>
          <target state="translated">속성 값이 종속성 속성을 상속 합니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">에 대 한 다른 값이 없는 자식 요소가 많은 경우 <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정 수는 <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Although a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax usage is listed and is syntactically allowed, setting this property in <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> is not common.</source>
          <target state="translated">하지만 한 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> 구문 사용 나열 되 고 구문이 허용 되는 경우이 속성을 설정할 <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> 이 일반적입니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.InputScopeProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.InputScope" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.InputScope" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source>Gets a value indicating whether this element has been initialized, either by being loaded as <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>, or by explicitly having its <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph> method called.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>로 로드하거나 해당 <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph> 메서드를 명시적으로 호출하여 이 요소를 초기화했는지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is initialized per the aforementioned loading or method calls; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">위의 로드 또는 메서드 호출을 통해 요소를 초기화했으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source>This property may also be <ph id="ph1">`true`</ph> if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</source>
          <target state="translated">두이 일 수도 <ph id="ph1">`true`</ph> 경우이 요소에 옮겨졌습니다 요소 트리 내에서 새 부모 요소가 있으며 따라서 요소가 다시 로드 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>Gets a value indicating whether this element has been loaded for presentation.</source>
          <target state="translated">표시를 위해 이 요소를 로드했는지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current element is attached to an element tree and has been rendered; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the element has never been attached to a loaded element tree.</source>
          <target state="translated">현재 요소가 요소 트리에 연결되어 있으며 렌더링되었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 요소가 로드된 요소 트리에 연결되지 않았으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>From a newly constructed instance, this property starts off <ph id="ph1">`false`</ph>, and remains <ph id="ph2">`true`</ph> once it is set to <ph id="ph3">`true`</ph>, even if subsequently removed by  code.</source>
          <target state="translated">새로 생성 된 인스턴스에서이 속성 설정을 시작할 <ph id="ph1">`false`</ph>, 상태를 유지 하 고 <ph id="ph2">`true`</ph> 로 설정한 후 <ph id="ph3">`true`</ph>이후에 코드에서 제거 하는 경우에 합니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>The following example code uses <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsLoaded%2A&gt;</ph> as a conditional check to assure that a function <ph id="ph2">`displayData`</ph> (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</source>
          <target state="translated">다음 예제 코드를 사용 하 여 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsLoaded%2A&gt;</ph> 함수 보증할 수 조건 검사 <ph id="ph2">`displayData`</ph> (표시 되지 않음)은 유효한 요소를 로드 한 주문형 처리기의 일환으로 작업할 수 페이지에 있습니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>That same logic is run as an event handler for <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>.</source>
          <target state="translated">동일한 논리에 대 한 이벤트 처리기로 실행 한다고 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Gets or sets localization/globalization language information that applies to an individual element.</source>
          <target state="translated">개별 요소에 적용되는 지역화/전역화 언어 정보를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The culture information for this element.</source>
          <target state="translated">이 요소에 대한 문화권 정보입니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The default value is an <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph> instance with its <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph> value set to the string "en-US".</source>
          <target state="translated">기본값은 해당 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph> 값이 "en-US" 문자열로 설정된 <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph> 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The string formats follow the RFC 3066 standard.</source>
          <target state="translated">문자열 형식의 RFC 3066 표준에 따라 합니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>For example, U.S. English is "en-US".</source>
          <target state="translated">예를 들어 미국 영어는 "EN-US"입니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph> for more information on the values and format.</source>
          <target state="translated">참조 <ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph> 값 및 형식에 대 한 자세한 내용은 합니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>This dependency property inherits property values.</source>
          <target state="translated">속성 값이 종속성 속성을 상속 합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">에 대 한 다른 값이 없는 자식 요소가 많은 경우 <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정 수는 <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.LanguageProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Language" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Language" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Occurs when the element is laid out, rendered, and ready for interaction.</source>
          <target state="translated">요소를 배치하고 렌더링하여 상호 작용할 준비가 되면 발생합니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">라우트된 이벤트를 직접 경로 따르지 않는, 에서만 발생 하는 동일한 요소 내에서 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">라우트된 이벤트에 다른 라우트된 이벤트 동작 지원 않는 직접: 액세스할 수 있는 처리기 컬렉션을 지원 하며으로 사용할 수는 <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> 스타일에서입니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Routed Event Information</source>
          <target state="translated">라우팅 이벤트 정보</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Routing strategy</source>
          <target state="translated">라우팅 전략</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct</source>
          <target state="translated">직접</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Delegate</source>
          <target state="translated">대리자</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Loaded" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Loaded" /&gt;</ph> <bpt id="p1">[</bpt>라우트된 이벤트 개요<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>를 식별합니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>Gets an enumerator for the logical child elements of this element.</source>
          <target state="translated">이 요소의 논리적 자식 요소에 대한 열거자를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>An enumerator for logical child elements of this element.</source>
          <target state="translated">이 요소의 논리적 자식 요소에 대한 열거자입니다.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>For more information on how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">사용 하는 방법에 대 한 자세한 내용은 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, 참조 <bpt id="p1">[</bpt>In WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>The direction that focus is to be moved, as a value of the enumeration.</source>
          <target state="translated">포커스를 이동할 방향(열거형의 값)입니다.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Moves the keyboard focus from this element to another element.</source>
          <target state="translated">키보드 포커스를 이 요소에서 다른 요소로 이동합니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if focus is moved successfully; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the target element in direction as specified does not exist.</source>
          <target state="translated">포커스가 이동되었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 를 반환하고, 지정된 방향에 대상 요소가 없으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Gets or sets the identifying name of the element.</source>
          <target state="translated">요소를 식별하는 이름을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">이 이름은 이벤트 처리기 코드 등의 프로그래밍 방식 코드 숨김 항목이 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> 구문 분석 중에 생성된 요소를 참조할 수 있도록 인스턴스 참조를 제공합니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The name of the element.</source>
          <target state="translated">요소의 이름을 나타내며</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The most common usage of this property is when specifying a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> element name in markup.</source>
          <target state="translated">이 속성의 가장 일반적인 사용법은 지정 하는 경우는 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> 태그에서 요소 이름입니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>This property essentially provides a WPF framework-level convenience property to set the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>x:Name Directive<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>.</source>
          <target state="translated">이 속성에는 기본적으로 설정 하는 WPF 프레임 워크 수준 편의 속성은 제공 된 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>X:name 지시문<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Getting a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>.</source>
          <target state="translated">가져오기는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> 코드에서은 코드에 적절 한 참조가 이미 있는 경우 방금 메서드를 호출할 수 있습니다 및 요소에 속성을 참조 하지 않으면 일반적으로 필요 하기 때문에 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">예외는 문자열에 오버 로드 된 의미가 경우, 예를 들어이에 해당 이름을 표시 하는 유용한 경우 <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Setting a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code if the original <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> was set from markup is also not recommended, and changing the property will not change the object reference.</source>
          <target state="translated">설정 된 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> 코드에서 경우 원래 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> 가 태그에서 설정도 권장 되지 않습니다 및 속성을 변경 해도 개체 참조가 변경 되지 것입니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Such object references are created only when the underlying namescopes are explicitly created during <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> loading.</source>
          <target state="translated">기본 이름 범위를 명시적으로 하는 동안 만든 경우에 이러한 개체 참조가 만들어집니다 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> 로드 합니다.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>You must specifically call <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> to make an effective change on the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> property of an already loaded element.</source>
          <target state="translated">명시적으로 호출 해야 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> 에 대 한 효과적인 변경 되도록는 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> 이미 로드 된 요소의 속성입니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>One notable case where setting <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from  code is important is for naming elements that storyboards will run against.</source>
          <target state="translated">해야 하는 대표적인에서는 설정 경우 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> 코드에서 storyboard 명명 요소에 대해 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Before you can register a name, might also need to instantiate and assign a <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> instance.</source>
          <target state="translated">이름을 등록할 수 있습니다, 전에 인스턴스화하고 할당 해야 할 수도 <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>See the Example section, or <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">예 섹션을 참조 하거나 <bpt id="p1">[</bpt>적기<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</source>
          <target state="translated">설정 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> 에서 코드 응용 프로그램을 제한 하지만 특히 여기서 응용 프로그램 페이지가 다시 로드 하 고 런타임 코드는 반드시 해당 코드 숨김 하지 탐색 모델을 사용 하는 경우에 일반적으로 더는 요소 이름으로 조회 각 페이지입니다.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The utility method <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A&gt;</ph>, which is available from any <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, can find any element by <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> in that element's logical tree recursively.</source>
          <target state="translated">유틸리티 메서드 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A&gt;</ph>에서 사용 하지 않는 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, 별로 모든 요소를 찾을 수 <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> 해당 요소의 논리적 트리에서 재귀적으로 합니다.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Or you can use the <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> static method of <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, which also takes the <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> string as an argument.</source>
          <target state="translated">또는 사용할 수 있습니다는 <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> 의 정적 메서드 <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, 또한를 사용 하는 <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> 인수로 문자열입니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Commonly used root elements (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> for example) implement the interface <ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">일반적으로 사용 되는 루트 요소 (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> 예를 들어) 인터페이스를 구현 <ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Implementations of this interface are expected to enforce that names be unambiguous within their scope.</source>
          <target state="translated">이 인터페이스의 구현 적용 이름이 해당 범위 내에서 모호한 것으로 예상 됩니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.NameProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Name" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Name" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">이벤트에 대한 데이터를 제공합니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">이 메서드는 기본 구현이 없습니다.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">상속의 중간 클래스가이 메서드를 구현 하는 경우에 기본 구현을 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">이 메서드는 다소 비슷합니다 <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> 이벤트 패턴에서 * 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">이 경우 일치 하는 이벤트 라우트된 이벤트가입니다.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</source>
          <target state="translated">On * 메서드의 구현 패턴 차이가 있는 라우트된 이벤트의 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 있습니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">따라서 구현을 고려할 이벤트 인수의 원본 속성을 갖습니다 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안).</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">서브 클래스 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">이벤트에 대한 이벤트 데이터입니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">이 메서드는 기본 구현이 없습니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">상속의 중간 클래스가이 메서드를 구현 하는 경우에 base ()를 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">이 메서드는 다소 비슷합니다 <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> 이벤트 패턴에서 * 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">이 경우 일치 하는 이벤트 라우트된 이벤트가입니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">On * 메서드의 구현 패턴 차이가 있는 라우트된 이벤트에 대 한 구현이 이벤트 인수는 소스를 수행 해야 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 계정에는 속성 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안).</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">서브 클래스 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">이벤트에 대한 이벤트 데이터입니다.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Class handler for the <ph id="ph1">&lt;see cref="E:System.Windows.ContentElement.GotFocus" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.ContentElement.GotFocus" /&gt;</ph> 이벤트에 대한 클래스 처리기입니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>This class handler sets appropriate focus behavior on this element if the event originated from this element.</source>
          <target state="translated">이 클래스 처리기는이 요소에서 이벤트가 생성 된 경우이 요소에 적절 한 포커스 동작을 설정 합니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>If the event's source was another element in the tree, the handler does nothing.</source>
          <target state="translated">이벤트의 소스 트리의 다른 요소를 한 경우 처리기는 아무 작업도 수행 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Override this method in order to change these default focusing behavior on your element.</source>
          <target state="translated">이러한 기본 요소에서 포커스 동작을 변경 하려면이 메서드를 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">이벤트에 대한 이벤트 데이터입니다.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Initialized" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Initialized" /&gt;</ph> 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>This method is invoked whenever <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">이 메서드는 <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph>가 <ph id="ph2">&lt;see langword="true" /&gt;</ph>로 설정될 때마다 호출됩니다.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>The default implementation of this virtual method raises the event as described earlier in this topic.</source>
          <target state="translated">이 항목의 앞부분에 설명 된 대로이 가상 메서드의 기본 구현에서 이벤트가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Overrides should call base() to preserve this behavior.</source>
          <target state="translated">재정의이 동작을 유지 하려면 base ()를 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsInitialized%2A&gt;</ph> property is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsInitialized%2A&gt;</ph> 속성은 읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Therefore, you cannot set it to force initialization behavior that way.</source>
          <target state="translated">따라서 이런 방식으로 초기화 동작을 강제 적용 하도록 설정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Initialization setting is intended to be done only by the <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> framework.</source>
          <target state="translated">초기화 설정은 에서만 수행할 수는 <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> 프레임 워크입니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The event data that describes the property that changed, including the old and new values.</source>
          <target state="translated">기존 값 및 새 값을 포함하여 변경된 속성을 설명하는 이벤트 데이터입니다.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked whenever the effective value of any dependency property on this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> has been updated.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>에서 종속성 속성의 유효 값이 업데이트될 때마다 호출됩니다.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The specific dependency property that changed is reported in the arguments parameter.</source>
          <target state="translated">변경된 특정 종속성 속성이 인수 매개 변수에서 보고됩니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Overrides <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph>를 재정의합니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is not intended to generally detect property changes or invalidations.</source>
          <target state="translated">일반적으로 속성 변경 내용 또는 무효화를 검색 하려면이 메서드를 사용 하는 것이 없습니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</source>
          <target state="translated">대신 것은 일반적인 무효화 패턴의 수정에 대 한 속성의 광범위 한 분류에 대 한 특정 정보가 알려져 있는 경우.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is potentially invoked many times during the life of an object.</source>
          <target state="translated">이 메서드는 개체의 수명 동안 여러 번 호출 될 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> functions for individual properties.</source>
          <target state="translated">따라서 특정 속성의 메타 데이터를 무시 하 고 다음 연결 성능을 향상 시킬 수 있습니다 <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> 개별 속성에 대 한 함수입니다.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>However, you would use this method if a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</source>
          <target state="translated">그러나, 사용이 메서드는 경우는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 많은 수의 값을 상호 연관 된 종속성 속성을 포함 하는 렌더링 동작 다시 실행 해야 다양 한 관련 속성 무효화의 경우와 같은 논리를 포함 하는 경우 또는 합니다.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Note that there is an identically named <ph id="ph1">`OnPropertyChanged`</ph> method with a different signature (the parameter type is <ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>) that can appear on a number of classes.</source>
          <target state="translated">같은 이름의 <ph id="ph1">`OnPropertyChanged`</ph> 를 다른 서명으로 메서드 (매개 변수 형식이 <ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>)는 다양 한 클래스에 나타날 수 있는 합니다.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>That <ph id="ph1">`OnPropertyChanged`</ph> is used for data object notifications, and is part of the contract for <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`OnPropertyChanged`</ph> 데이터 개체 알림에 사용 되 고에 대 한 계약의 일부인 <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Always call the base implementation, as the first operation in your implementation.</source>
          <target state="translated">항상 구현에서 첫 번째 작업으로 기본 구현을 호출 합니다.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Failure to do this will significantly disable the entire <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system, which causes incorrect values to be reported.</source>
          <target state="translated">이렇게 하지 않으면 전체 없게 되므로 <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> 속성 시스템에 잘못 된 값을 보고 합니다.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The old style.</source>
          <target state="translated">이전 스타일입니다.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The new style.</source>
          <target state="translated">새 스타일입니다.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Invoked when the style that is in use on this element changes.</source>
          <target state="translated">이 요소에서 사용 중인 스타일이 변경될 때 호출됩니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>This method has a default implementation that sets an internal flag noting the style changed condition.</source>
          <target state="translated">이 메서드는 스타일 변경 조건을 나타내는 내부 플래그를 설정 하는 기본 구현입니다.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Always call the base implementation, otherwise styles cannot be applied.</source>
          <target state="translated">항상 기본 구현을 호출, 그렇지 않으면 스타일을 적용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</source>
          <target state="translated">파생 된 클래스에 특수화 된 스타일 선택기 또는 스타일 값을 캐시 하는 경우이 메서드를 재정의 하는 것에 대 한 시나리오 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Theme changes will potentially invoke this method.</source>
          <target state="translated">테마 변경은 잠재적으로이 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">이벤트에 대한 데이터를 제공합니다.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">이 메서드는 기본 구현이 없습니다.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">상속의 중간 클래스가이 메서드를 구현 하는 경우에 base ()를 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">이 메서드는 다소 비슷합니다 <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> 이벤트 패턴에서 * 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">이 경우 일치 하는 이벤트 라우트된 이벤트가입니다.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">On * 메서드의 구현 패턴 차이가 있는 라우트된 이벤트에 대 한 구현이 이벤트 인수는 소스를 수행 해야 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 계정에는 속성 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안).</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">서브 클래스 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">이벤트에 대한 데이터를 제공합니다.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">이 메서드는 기본 구현이 없습니다.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">상속의 중간 클래스가이 메서드를 구현 하는 경우에 base ()를 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">이 메서드는 다소 비슷합니다 <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> 이벤트 패턴에서 * 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">이 경우 일치 하는 이벤트 라우트된 이벤트가입니다.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">On * 메서드의 구현 패턴 차이가 있는 라우트된 이벤트에 대 한 이벤트 인수는 소스를 구현 해야 합니다 하므로 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 계정에는 속성 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안).</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">서브 클래스 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Gets or sets a value indicating whether this element incorporates style properties from theme styles.</source>
          <target state="translated">이 요소가 테마 스타일에서 스타일 속성을 통합하는지 여부를 나타내는 값을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</source>
          <target state="translated">이 요소가 테마 스타일 속성을 사용하지 않으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>입니다. 이 경우 스타일에서 생성되는 모든 속성은 로컬 응용 프로그램 스타일에서 가져오며, 테마 스타일 속성은 적용되지 않습니다.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</source>
          <target state="translated">응용 프로그램 스타일이 먼저 적용된 다음 응용 프로그램 스타일에 구체적으로 설정되어 있지 않은 속성에 대해 테마 스타일이 적용되면 <ph id="ph1">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</source>
          <target state="translated">이 속성의 가장 일반적인 사용법은 테마 스타일을 제공 하는 스타일의 setter 내에서 간접적으로 사용 합니다.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Gets the parent in the logical tree for this element.</source>
          <target state="translated">논리적 트리에서 이 요소의 부모를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The logical parent for this element.</source>
          <target state="translated">이 요소의 논리적 부모입니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</source>
          <target state="translated">Note 요소의 논리적 부모 응용 프로그램 기능에 따라 변경 될 수 있습니다 및이 속성의 값을 유지 해도 해당 변경 내용을 반영 되지 것입니다.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>You typically should get the value immediately before you need it.</source>
          <target state="translated">일반적으로 필요한 직전 값을 가져올 해야 합니다.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>See <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept> for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>In WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept> 요소 검색에 이러한 방식을 사용 하는 것이 적절 한 논리 트리 및 시나리오 통과 하는 방법에 대 한 자세한 내용은 합니다.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</source>
          <target state="translated">속성 시스템에서는 다시 계산할 수 요소의 모든 속성 값, 부모가 때 일부 속성 논리 트리를 통해 값을 상속 하기 때문에 있습니다.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> that applies for bindings can also change when elements are reparented.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> 적용 되는 바인딩 요소는 부모가 때 변경도 수 있습니다.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</source>
          <target state="translated">요소의 부모는 일반적으로을 통해 변경할 컬렉션 조작, 전용을 사용 하 여 추가 또는 제거 메서드, 또는 요소의 콘텐츠 속성을 설정 하는 과정입니다.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The most typical scenario for using the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> property is to obtain a reference and then get various <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> property values from the parent.</source>
          <target state="translated">사용 하는 가장 일반적인 시나리오는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> 속성은 다양 한를 가져온 후 한 참조를 가져올를 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 부모 개체에서 속성 값입니다.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>For templates, the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> of the template eventually will be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">서식 파일에 대 한는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> 템플릿의 됩니다 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>To get past this point and extend into the logical tree where the template is actually applied, use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>.</source>
          <target state="translated">이 지점을 벗어나 템플릿을 실제로 적용 되는 논리 트리로 확장을 사용 하 여 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The following example checks to see whether the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> of a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is of a particular type.</source>
          <target state="translated">확인 하는 다음 예제 여부는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> 의 <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> 특정 형식입니다.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The direction for which a prospective focus change should be determined.</source>
          <target state="translated">예상 포커스 변경을 결정할 방향입니다.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</source>
          <target state="translated">제공된 포커스 이동 방향에 대해 이 요소를 기준으로 포커스를 받을 다음 요소를 결정하며 실제로 포커스를 이동하지는 않습니다.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>This method is sealed and cannot be overridden.</source>
          <target state="translated">이 메서드는 봉인되어 있으며 재정의할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The next element that focus would move to if focus were actually traversed.</source>
          <target state="translated">포커스를 실제로 이동하면 포커스가 이동할 다음 요소입니다.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>May return <ph id="ph1">&lt;see langword="null" /&gt;</ph> if focus cannot be moved relative to this element for the provided direction.</source>
          <target state="translated">제공된 방향에 대해 이 요소를 기준으로 포커스를 이동할 수 없는 경우 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이 반환될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.MoveFocus%2A&gt;</ph> is the related method that actually does move focus.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.MoveFocus%2A&gt;</ph> 실제로 포커스를 이동 하는 관련된 방법.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Specified one of the following directions in the <ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph>: <ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>, <ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph>에서 <ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>, <ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph> 중 한 방향을 지정합니다.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>These directions are not legal for <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph> (but they are legal for <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph>).</source>
          <target state="translated">이러한 방향은 <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph>에 사용할 수 없지만 <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph>에는 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Name to use for the specified name-object mapping.</source>
          <target state="translated">지정된 이름-개체 매핑에 사용할 이름입니다.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Object for the mapping.</source>
          <target state="translated">매핑을 위한 개체입니다.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Provides an accessor that simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> registration method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> 등록 메서드에 대한 액세스를 간소화하는 접근자를 제공합니다.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 호출에 대 한 편리한 메서드입니다 <ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>The implementation will check successive parent elements until it finds the applicable <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> implementation, which is found by finding an element that implements <ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">적용 가능한 될 때까지 구현 연속 된 부모 요소를 확인 합니다 <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> 구현 하는 요소를 검색 하 여 액세스할 수 있는 구현 <ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>For more information about namescopes, see <bpt id="p1">[</bpt>WPF XAML Namescopes<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</source>
          <target state="translated">네임 스페이스에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>WPF XAML 이름 범위<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Calling <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> is necessary in order to correctly hook up animation storyboards for applications when created in code.</source>
          <target state="translated">호출 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> 올바르게 코드에서 만들어진 경우 응용 프로그램에 대 한 애니메이션 스토리 보드를 연결 하기 위해 필요 합니다.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This is because one of the key storyboard properties, <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>, uses a run-time name lookup instead of being able to take a reference to a target element.</source>
          <target state="translated">속성을 스토리 보드 키 중 하나 때문에 이것이 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>, 대상 요소에 대 한 참조 하는 대신 런타임 이름 조회를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This is true even if that element is accessible by reference from the code.</source>
          <target state="translated">해당 요소는 코드에서 참조 하 여 액세스할 수 있는 경우에 마찬가지입니다.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>For more information on why you need to register names for storyboard targets, see <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">스토리 보드 대상에 대 한 이름을 등록 해야 이유에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>적기<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Animations for content elements are less common than animations on controls, the <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept> concentrates on control scenarios.</source>
          <target state="translated">콘텐츠 요소에 대 한 애니메이션 컨트롤에 보다 일반적이 지는 <bpt id="p1">[</bpt>적기<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept> 제어 시나리오에 대해 중점적으로 설명 합니다.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>The element to remove.</source>
          <target state="translated">제거할 요소입니다.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Removes the specified element from the logical tree for this element.</source>
          <target state="translated">지정된 요소를 이 요소의 논리적 트리에서 제거합니다.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>This <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> is mainly relevant for class deriving scenarios, when adding support for child collections.</source>
          <target state="translated">이 <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> 는 클래스를 파생 시키는 경우 자식 컬렉션에 대 한 지원을 추가 하는 경우에 주로 합니다.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Most <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes expose dedicated collections that are responsible for containment (for example, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> class; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> on the <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> class).</source>
          <target state="translated">대부분 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 포함에 대 한 역할을 하는 전용된 컬렉션을 노출 하는 파생 된 클래스 (예를 들어 <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> 에 <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> 클래스입니다. <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> 에 <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> 클래스).</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</source>
          <target state="translated">일반적으로 이러한 클래스에서 파생 논리 트리를 직접 조작 필요를 방지할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Gets or sets the current locally-defined resource dictionary.</source>
          <target state="translated">현재 로컬로 정의된 리소스 사전을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The current locally-defined resources.</source>
          <target state="translated">현재 로컬로 정의된 리소스입니다.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is a dictionary of resources, where resources within the dictionary are accessed by key.</source>
          <target state="translated">이 사전은 리소스 사전으로, 키를 사용하여 사전 내의 리소스에 액세스합니다.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Resource dictionaries that can be defined completely or partially in <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> are typically created as a property element, and are typically on the root element for any individual page or for the application.</source>
          <target state="translated">완전히 또는 부분적으로 정의할 수 있는 리소스 사전 <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> 개별 페이지 또는 응용 프로그램에 대 한 루트 요소에는 일반적으로 및 속성 요소로 일반적으로 만들어집니다.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</source>
          <target state="translated">이 수준에서 리소스 사전을 배치 쉽게 페이지의 개별 자식 요소 (또는 응용 프로그램의 경우에는 페이지)를 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</source>
          <target state="translated">대부분의 응용 프로그램 시나리오의 리소스 사전에서 개체 요소로 스타일을 정의 하는 것 권장 전체 스타일 리소스 자체 포함 될 수 있도록 외부 리소스로 정의 된 또는 (이 방법은 별도 디자이너를 사용 하면. 책임을 편집 해야 하는 물리적 파일을 구분 하 여 개발자 책임).</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Note that this property returns only the resource dictionary declared directly within that element.</source>
          <target state="translated">이 속성에서 반환 하는 리소스 사전에만 해당 요소 내부에서 직접 선언 참고 합니다.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</source>
          <target state="translated">이 자식 요소를 위쪽으로 재귀적으로 검색 되는 각 부모 요소에 정의 된 리소스에 액세스할 수 있는 실제 리소스 조회 프로세스와 다릅니다.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Resources can also be referenced by code from within the collection, but be aware that resources created in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> will definitely not be accessible until after <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> is raised by the element that declares the dictionary.</source>
          <target state="translated">리소스에서 리소스를 만들 수 있지만 컬렉션 내에서 코드에 의해 참조 될 수도 있습니다 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> 를 확실 하 게 액세스할 수 없는까지 후 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> 사전을 선언 하는 요소에 의해 발생 합니다.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>In fact, resources are parsed asynchronously, and not even the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> event is an assurance that you can reference a <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resource.</source>
          <target state="translated">리소스의 비동기적으로 구문 분석 되 고 아니더라도 실제로 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> 이벤트는 참조할 수 있는 보증은 <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> 리소스를 정의 합니다.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For this reason you should generally only access <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resources as part of run-time code, or through other <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> techniques such as styles or resource extension references for attribute values.</source>
          <target state="translated">따라서 일반적으로 액세스 해야 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> 또는 다른를 통해 런타임 코드의 일부로 정의 된 리소스 <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> 스타일이 나 특성 값에 대 한 리소스 확장 참조 하는 기법입니다.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>When you access resources through code, it is essentially equivalent to a  reference made from <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">기본적으로 해당에서 만든 참조 하는 코드를 통해 리소스에 액세스할 때 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The underlying <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> supports the methods required to add, remove, or query resources from within the collection by using code.</source>
          <target state="translated">내부 <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> 추가, 제거 또는 코드를 사용 하 여 컬렉션 내에서 리소스를 쿼리 하는 데 필요한 메서드를 지원 합니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> 속성은 완전히 리소스 컬렉션을 새로운 또는 다른 요소를 교체 하는 시나리오를 지원 하기 위해 설정할 수 <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Notice that the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax shown does not include an element for the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">에 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> 표시 된 구문에 대 한 요소를 포함 하지 않습니다는 <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</source>
          <target state="translated">이것이; 암시적 컬렉션 구문의 예 컬렉션 요소를 나타내는 태그를 생략할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The elements that are added as items to the collection are specified instead.</source>
          <target state="translated">컬렉션에 항목으로 추가 하는 요소 대신 지정 됩니다.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For more information about implicit collections and <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, see <bpt id="p1">[</bpt>XAML Syntax In Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</source>
          <target state="translated">암시적 컬렉션에 대 한 자세한 내용은 및 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, 참조 <bpt id="p1">[</bpt>XAML 구문에서 세부<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>One case where a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">한 가지 경우 여기서는 <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> 병합된 된 사전을 도입 하는 경우에서 많은 경우 일반적으로 해당 자식 요소가 없는 요소 이므로 명시적으로 지정 되어 <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For details, see <bpt id="p1">[</bpt>Merged Resource Dictionaries<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>자세한<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>XAML Property Element Usage</source>
          <target state="translated">XAML 속성 요소 사용</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>XAML Values</source>
          <target state="translated">XAML 값</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>One or more object elements, each of which defines a resource.</source>
          <target state="translated">하나 이상의 개체 요소를 각각 정의 하는 리소스입니다.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Each resource property element within each <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> must have a unique value for the <bpt id="p1">[</bpt>x:Key Directive<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>, which serves as the unique key when values are retrieved from the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">각 내에서 각 리소스 속성 요소 <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> 에 대 한 고유 값이 있어야는 <bpt id="p1">[</bpt>X:key 지시문<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>에서 값을 검색할 때 고유 키로 제공 되는 <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The following example establishes a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> collection on a <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> root element.</source>
          <target state="translated">다음 예에서는 설정는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> 컬렉션에는 <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> 루트 요소입니다.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source><ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> is a typical choice because it is one of the few <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> 전형적인 선택은 보시 이므로 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 페이지 루트 또는 응용 프로그램 에서처럼 더 높은 수준에서 루트 요소 및 리소스도 의미 있는 클래스는 일반적으로 저장 됩니다.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source>Attaches a binding to this element for the specified dependency property.</source>
          <target state="translated">지정된 종속성 속성에 대해 이 요소에 바인딩을 연결합니다.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Identifies the bound property.</source>
          <target state="translated">바인딩된 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The source property name or the path to the property used for the binding.</source>
          <target state="translated">바인딩에 사용할 소스 속성 이름 또는 속성의 경로입니다.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</source>
          <target state="translated">데이터 소스에 대한 경로 정규화로 제공된 소스 속성 이름을 기반으로 이 요소에 바인딩을 연결합니다.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">바인딩 상태를 기록합니다.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">이 반환 값은 오류 검사에 유용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>, and creates a new <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> based on the provided <ph id="ph4">`path`</ph> parameter.</source>
          <target state="translated">이 메서드는 호출에 대 한 편리한 메서드입니다 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>는 현재 인스턴스를 전달 하는 <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>, 새 및 <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> 제공 된 기준 <ph id="ph4">`path`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This signature is more convenient if you are establishing a simple default binding.</source>
          <target state="translated">이 서명은 단순한 기본 바인딩을 설정 하는 경우 더 편리 합니다.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>If you need to specify any binding properties to non-default conditions, or want to use a <ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>,you should use the <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph> signature.</source>
          <target state="translated">기본이 아닌 조건에 대 한 바인딩 속성을 지정 하거나 사용 하려는 해야 할 경우는 <ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>, 사용할지는 <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph> 서명 합니다.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new custom data object, establishing that object as <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, and setting the binding path to a property within it.</source>
          <target state="translated">다음 예제에서는 대 한 바인딩을 설정는 <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> 요소와 해당 개체는 새 사용자 지정 데이터 개체를 만들어 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, 바인딩 경로 내에 속성을 설정 합니다.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Identifies the bound property.</source>
          <target state="translated">바인딩된 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Represents a data binding.</source>
          <target state="translated">데이터 바인딩을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Attaches a binding to this element, based on the provided binding object.</source>
          <target state="translated">제공된 바인딩 개체를 기반으로 하여 이 요소에 바인딩을 연결합니다.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">바인딩 상태를 기록합니다.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">이 반환 값은 오류 검사에 유용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</source>
          <target state="translated">이 메서드는 호출에 대 한 편리한 메서드입니다 <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>는 현재 인스턴스를 전달 하는 <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> and setting the source to a newly built <ph id="ph3">`DateTime`</ph> object.</source>
          <target state="translated">다음 예제에서는 대 한 바인딩을 설정는 <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> 새 요소 <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> 새로 작성 하는 소스를 설정 하 고 <ph id="ph3">`DateTime`</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The property to which the resource is bound.</source>
          <target state="translated">리소스가 바인딩될 속성입니다.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The name of the resource.</source>
          <target state="translated">리소스의 이름입니다.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</source>
          <target state="translated">지정된 이름으로 리소스를 검색하고 지정된 속성에 대해 해당 리소스에 리소스 참조를 설정합니다.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>A resource reference is similar to the use of a <bpt id="p1">[</bpt>DynamicResource Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> in markup.</source>
          <target state="translated">리소스 참조는를 사용 하는 <bpt id="p1">[</bpt>DynamicResource 태그 확장<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> 태그에 있습니다.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</source>
          <target state="translated">리소스 참조는 런타임에 지연 기준 지정된 된 속성의 값을 제공 하는 내부 식을 작성 합니다.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</source>
          <target state="translated">내부 이벤트를 통해 변경 된 값을 표시 하는 리소스 사전 때마다 또는 현재 요소에 부모가 될 때마다 식이 다시 계산 됩니다 (부모 변경 변경 사전 조회 경로).</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">serialization 프로세스에서 이 클래스의 인스턴스에 있는 <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> 속성의 콘텐츠를 serialize해야 하는지 여부를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> 속성 값을 serialize해야 하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source>This will return <ph id="ph1">`true`</ph> so long as there is at least one keyed resource in the local <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>.</source>
          <target state="translated">이 반환 됩니다 <ph id="ph1">`true`</ph> 키가 지정 된 리소스를 하나 이상 로컬에서이 때만 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">serialization 프로세스에서 이 클래스의 인스턴스에 있는 <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> 속성의 콘텐츠를 serialize해야 하는지 여부를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> 속성 값을 serialize해야 하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source>This will return <ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> is locally set.</source>
          <target state="translated">이 반환 됩니다 <ph id="ph1">`true`</ph> 경우는 <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> 로컬로 설정 합니다.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>Occurs when any associated data source participating in a binding on this element changes.</source>
          <target state="translated">이 요소에서 바인딩에 관여되는 연결된 데이터 소스가 변경될 때 발생합니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>This event surfaces the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">이 이벤트 표면에서 <ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph> 의해 발생 하는 이벤트 <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> 이 요소와 연결 합니다.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 특성 사용</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Gets or sets the style to be used by this element.</source>
          <target state="translated">이 요소에서 사용할 스타일을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The applied, nondefault style for the element, if present.</source>
          <target state="translated">있는 경우 요소에 대해 적용된 기본값이 아닌 스타일입니다.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">그렇지 않으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The default for a default-constructed <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">기본 생성된 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>의 기본값은 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</source>
          <target state="translated">현재 스타일 종종 테마 설정 또는 일반적으로 리소스 페이지 또는 응용 프로그램 수준 (암시적 스타일)에 의해 해당 유형의 개체에 적용 된 스타일에서 기본 스타일을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</source>
          <target state="translated">이 속성은 설정 하거나 반환 하지 기본 (테마) 스타일 않지만 암시적 스타일 또는 명시적 스타일 반환 합니다.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</source>
          <target state="translated">암시적 또는 명시적 스타일의 경우 스타일 되었는지 여부를 리소스로 액세스할 로컬 정의 중요지 않습니다.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Setting the styles has some restrictions.</source>
          <target state="translated">스타일 정의는 몇 가지 제한 사항이 있습니다.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>You can reset the entire <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> property to a new <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> at any time, which will force a layout recomposition.</source>
          <target state="translated">전체를 다시 설정할 수 있습니다 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> 속성을 새 <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> 언제 든 지는 됩니다 언제 합니다.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>However, as soon as that style is placed in use by a loaded element, the <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> should be considered sealed.</source>
          <target state="translated">그러나 가능한 한 즉시 해당 스타일 로드 된 요소에서 사용 하 게 되는 <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> 고려해 야 봉인 합니다.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) causes an exception to be thrown.</source>
          <target state="translated">사용 중인 스타일의 개별 속성을 변경 하려고 (컬렉션 내에서 아무 것도 같은 <ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</source>
          <target state="translated">태그에 정의 된 스타일 (리소스)에 대 한 리소스 사전에서 로드 하거나 내에 포함 된 페이지가 (인라인 스타일)에 대 한 로드 사용 중인 것으로 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> is a dependency property with special precedence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> 특별 한 우선 순위가 종속성 속성이입니다.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The locally set style generally operates at the highest precedence in the property system.</source>
          <target state="translated">로컬로 설정 된 스타일은 일반적으로 가장 높은 우선 순위에서 속성 시스템 작동 합니다.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> 속성 시스템은 해당 유형을 지정 하는 다시 사용할 수 있는 리소스로 정의 된 암시적 스타일에 대 한 확인 로드 하는 동안이 시점에서 null입니다.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> property value.</source>
          <target state="translated">경우이 단계를 스타일은 여전히 null 하면 기본 (테마) 스타일의 스타일을 가져옵니다. 그러나 기본 스타일에 반환 되지 않습니다는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> 속성 값입니다.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>종속성 속성 값 우선 순위<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 특성 사용</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>XAML Values</source>
          <target state="translated">XAML 값</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>One of the following: , or .</source>
          <target state="translated">다음 중 하나:, 또는.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>XAML 리소스<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">요청 되는 스타일을 식별 하는 키입니다.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">기존 리소스를이 키는 한 <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Property element syntax is technically possible, but not recommended.</source>
          <target state="translated">속성 요소 구문은 지원 되지만 권장 하지는 않습니다.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>인라인 스타일 및 템플릿<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">사용 하 여 바인딩 참조 또는 <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> 가능 하지만 일반적이 지 않은 이기도 합니다.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The following example establishes a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> collection on a <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> root element and then references it as a resource as a specific style for a <ph id="ph3">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</source>
          <target state="translated">다음 예에서는 설정는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> 컬렉션에는 <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> 루트 요소 다음에 대 한 특정 스타일으로 리소스로 참조는 <ph id="ph3">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.StyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>The name of the requested ambient property.</source>
          <target state="translated">요청된 앰비언트 속성의 이름입니다.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>For a description of this member, see the <ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph> method.</source>
          <target state="translated">이 멤버에 대한 설명을 보려면 <ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph> 메서드를 참조하세요.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph> is available; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph>을 사용할 수 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Gets or sets an arbitrary object value that can be used to store custom information about this element.</source>
          <target state="translated">이 요소에 대한 사용자 지정 정보를 저장하는 데 사용할 수 있는 임의의 개체 값을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>The intended value.</source>
          <target state="translated">원하는 값입니다.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>This property has no default value.</source>
          <target state="translated">이 속성에는 기본값이 없습니다.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</source>
          <target state="translated">이 속성은 다른 Microsoft 프로그래밍 모델에서 응용 프로그램 또는 Windows Forms에 대 한 Visual Basic과 같은 태그 속성과 유사 합니다.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</source>
          <target state="translated">기존 응용 프로그램 개발자가 하위 클래스를 시작 하지 않고 모든 요소에 대 한 몇 가지 기본 사용자 지정 정보를 저장할 위치를 제공 하는 것이 됩니다.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>XAML Values</source>
          <target state="translated">XAML 값</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Because this property takes an object, you need to use the property element usage in order to set the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Tag%2A&gt;</ph> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</source>
          <target state="translated">속성 요소 사용 설정 하는 데 사용 해야 하는 하기 때문에이 속성 개체는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Tag%2A&gt;</ph> , 문자열 등의 알려진된 기본 제공 형식 변환기를 가진 개체가 아닌 다른 값으로 XAML에서 속성입니다.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</source>
          <target state="translated">이러한 방식으로 사용 되는 개체 일반적으로 표준 WPF 네임 스페이스에 포함 되지 않는 있으며 따라서 해야 네임 스페이스 매핑을 외부 네임 스페이스에 XAML 요소도 합니다.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>None</source>
          <target state="translated">없음</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.TagProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Tag" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Tag" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>Occurs when any associated target property participating in a binding on this element changes.</source>
          <target state="translated">이 요소의 바인딩에 참여하는 연결된 대상 속성이 변경되면 발생합니다.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>This event surfaces the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">이 이벤트 표면에서 <ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph> 의해 발생 하는 이벤트 <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> 이 요소와 연결 합니다.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</source>
          <target state="translated">이 일반적으로 해당 바인딩이 양방향 바인딩에 바인딩된 종속성 속성은 모든 유효성 검사 또는 속성이 지원 캐싱 체계 별로 이전 속성 값의 무효화 함을 의미 합니다.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>The event arguments of this event will inform you which bound property was changed.</source>
          <target state="translated">이 이벤트의 이벤트 인수는 어떤 바인딩된 속성이 변경 된에 알립니다.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 특성 사용</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Gets a reference to the template parent of this element.</source>
          <target state="translated">이 요소의 템플릿 부모에 대한 참조를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>This property is not relevant if the element was not created through a template.</source>
          <target state="translated">요소가 템플릿을 통해 만들어지지 않은 경우에는 이 속성이 관련이 없습니다.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>The element whose <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph><ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph> caused this element to be created.</source>
          <target state="translated">요소를 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph> <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph> 이 요소를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>This value is frequently <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 값은 대개 <ph id="ph1">&lt;see langword="null" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Templates are actually shared objects, where the contents of the template are created only once.</source>
          <target state="translated">템플릿은 실제로 공유 개체를 서식 파일의 내용을 한 번만 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</source>
          <target state="translated">따라서 서식 파일에서 생성 된 요소에 대 한 개체 참조를 가져오는 경우 명백한 논리적 트리 루트 페이지에 도달 하지 않도록 알 수 있습니다.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>In order to connect such a template reference to the page's logical tree, you should get the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> value and continue to navigate that element tree as desired.</source>
          <target state="translated">이러한 서식 파일 참조 페이지의 논리 트리를을 연결 하기 위해 얻어야는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> 값과 계속를 원하는 대로 해당 요소 트리를 탐색 합니다.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> will frequently be <ph id="ph2">`null`</ph> for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> 자주 <ph id="ph2">`null`</ph> 일반 개체에 대 한 일반적인 수단을 통해 응용 프로그램에서 페이지 확장 개체 참조를 얻은 경우 해당 요소 아마도 만들어지지 않아 템플릿에서 합니다.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Cases where <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> might not be <ph id="ph2">`null`</ph> would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</source>
          <target state="translated">인 사례 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> 하지 못할 <ph id="ph2">`null`</ph> 낮은 수준의 특정 입력 이벤트를 처리 하거나 템플릿에서 생성 되는 요소를 반환 했거나 열거자 작업 적중 테스트, 이벤트 등의 작업을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Gets or sets the tool-tip object that is displayed for this element in the <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>에서 이 요소에 대해 표시되는 도구 설명 개체를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The tooltip object.</source>
          <target state="translated">도구 설명 개체입니다.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>If the value of this property is of type <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>, then that is the tool-tip that will be used in the <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">이 속성의 값 형식인 경우 <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>, 다음에 사용 되는 도구 설명 되는 <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>If the value is of any other type, then that value will be used as the <bpt id="p1">*</bpt>content<ept id="p1">*</ept> for a <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> provided (constructed) by the system.</source>
          <target state="translated">값이 다른 형식의 경우 해당 값으로 사용 됩니다는 <bpt id="p1">*</bpt>콘텐츠<ept id="p1">*</ept> 에 대 한는 <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> 제공 (생성 된) 시스템에서 합니다.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>For more information see <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The service class provides attached properties that can be used to further customize a tool-tip.</source>
          <target state="translated">서비스 클래스는 추가로 도구 설명을 사용자 지정 하는 데 사용할 수 있는 연결 된 속성을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 특성 사용</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Property Element Usage</source>
          <target state="translated">XAML 속성 요소 사용</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Values</source>
          <target state="translated">XAML 값</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>A string that becomes the display text for the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>.</source>
          <target state="translated">에 대 한 표시 텍스트 되는 문자열은 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Some object, provided in object element form, that should be used as the content for the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> .</source>
          <target state="translated">에 대 한 내용으로 사용 해야 하는 개체 요소 형태에 제공 된 일부 개체는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 합니다.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Typically this would be a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or some other element that creates layout compositing for the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>, eventually containing text content within the compositing.</source>
          <target state="translated">됩니다는 <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> 또는 다른 요소에 대 한 레이아웃 합성을 만드는 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>를 포함 하는 텍스트 콘텐츠입니다.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>In this usage, the <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> element is created implicitly from the parsed <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, and the <bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept> content is set as its <ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">이 사용법에서는 <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> 요소가 만들어집니다 구문 분석 된에서 암시적으로 <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, 및 <bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept> 내용이 설정으로 해당 <ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> .../&gt;</source>
          <target state="translated"><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> .../&gt;</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Dependency Property Information</source>
          <target state="translated">종속성 속성 정보</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">로 메타 데이터 속성 설정 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>None</source>
          <target state="translated">없음</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The following example sets the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> property directly to a string.</source>
          <target state="translated">값을 설정 하는 다음 예제는 <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> 속성 문자열을 직접 합니다.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Occurs just before any tooltip on the element is closed.</source>
          <target state="translated">요소의 도구 설명을 닫기 직전에 발생합니다.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>To suppress closing the tooltip, handlers of the event should mark it as handled.</source>
          <target state="translated">도구 설명 닫기를 표시 하지 않으려면 이벤트의 처리기 것으로 표시 해야 처리 합니다.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>This event cannot be an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">이 이벤트는 <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> 스타일에서입니다.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</source>
          <target state="translated">이 이벤트의 식별자 필드에는 다시 이벤트를 추가/제거 메서드를 노출 하지 않는 서비스의 구현을 사용 하기 때문입니다.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Routed Event Information</source>
          <target state="translated">라우팅 이벤트 정보</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Routing strategy</source>
          <target state="translated">라우팅 전략</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Direct</source>
          <target state="translated">직접</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Delegate</source>
          <target state="translated">대리자</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> <bpt id="p1">[</bpt>라우트된 이벤트 개요<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>를 식별합니다.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Occurs when any tooltip on the element is opened.</source>
          <target state="translated">요소의 도구 설명이 열리면 발생합니다.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>To manually open tooltips, handlers of the events should mark the relevant event as handled.</source>
          <target state="translated">도구 설명을 열어야 하는 처리 된 것으로 이벤트의 처리기 관련 이벤트를 표시 해야 합니다.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Otherwise, the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> property will be used to automatically open a context menu.</source>
          <target state="translated">그렇지 않은 경우의 값은 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> 를 자동으로 상황에 맞는 메뉴를 열려면 속성을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> property and then open the new <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
          <target state="translated">이벤트를 처리 된을 효과적으로 기본 작업을 취소 하 고 수 값을 다시 설정 하는 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> 속성을 열고 새 <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Note that this event will not be raised if <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> is a null reference or otherwise unset.</source>
          <target state="translated">확인 하는 경우이 이벤트가 발생 하지 것입니다 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> 가 null 참조 또는 그렇지 않은 경우 해제 합니다.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>This event cannot be an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">이 이벤트는 <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> 스타일에서입니다.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</source>
          <target state="translated">이 이벤트의 식별자 필드에는 다시 이벤트를 추가/제거 메서드를 노출 하지 않는 서비스의 구현을 사용 하기 때문입니다.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Routed Event Information</source>
          <target state="translated">라우팅 이벤트 정보</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Routing strategy</source>
          <target state="translated">라우팅 전략</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Direct</source>
          <target state="translated">직접</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Delegate</source>
          <target state="translated">대리자</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> <bpt id="p1">[</bpt>라우트된 이벤트 개요<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>를 식별합니다.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ToolTip" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ToolTip" /&gt;</ph> 종속성 속성을 식별합니다.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Key identifier of the resource to be found.</source>
          <target state="translated">찾을 리소스의 키 식별자입니다.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Searches for a resource with the specified key, and returns that resource if found.</source>
          <target state="translated">지정된 키를 사용하여 리소스를 검색하고 해당 리소스를 반환합니다(있는 경우).</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The found resource.</source>
          <target state="translated">찾은 리소스입니다.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>If no resource was found, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">리소스가 없으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이 반환됩니다.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</source>
          <target state="translated">트리 수는 동일한 방식으로 논리적 트리를 사용 하 여 부모 트리를 검색 된 리소스 호출 하는 요소에 없는 경우 실행 시 키에 의해 동적 리소스 참조를 요청 하는 경우를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</source>
          <target state="translated">일반적으로 반환 값을 반환 되는 리소스 값으로 설정 하 려 했던 하는 속성의 형식 캐스팅 즉시 것입니다.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindResource%2A&gt;</ph> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindResource%2A&gt;</ph> 메서드가 비슷한 동작을 제외 하 고 제공 된 키와 리소스를 찾지 못하는 경우 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</source>
          <target state="translated">다음 예제에서는 태그에서 정의 된 대로 리소스를 찾아 특정 라우트된 이벤트에 대 한 응답에 있는 요소의 속성에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Occurs when the element is removed from an element tree of loaded elements.</source>
          <target state="translated">로드된 요소의 요소 트리에서 요소를 제거할 때 발생합니다.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">라우트된 이벤트를 직접 경로 따르지 않는, 에서만 발생 하는 동일한 요소 내에서 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">라우트된 이벤트에 다른 라우트된 이벤트 동작 지원 않는 직접: 액세스할 수 있는 처리기 컬렉션을 지원 하며으로 사용할 수는 <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> 스타일에서입니다.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Routed Event Information</source>
          <target state="translated">라우팅 이벤트 정보</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Identifier field</source>
          <target state="translated">식별자 필드</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Routing strategy</source>
          <target state="translated">라우팅 전략</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct</source>
          <target state="translated">직접</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Delegate</source>
          <target state="translated">대리자</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Unloaded" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Unloaded" /&gt;</ph> <bpt id="p1">[</bpt>라우트된 이벤트 개요<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>를 식별합니다.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>Name of the name-object pair to remove from the current scope.</source>
          <target state="translated">현재 범위에서 제거할 이름-개체 쌍의 이름입니다.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>Simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> de-registration method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> 등록 취소 메서드에 대한 액세스를 간소화합니다.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>You only need to un-register names if you intend to re-register another element with that same name.</source>
          <target state="translated">하기만 하면 등록을 취소할 이름에 동일한 이름 갖는 다른 요소의 하려는 경우.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle">
          <source>Reapplies the default style to the current <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">기본 스타일을 현재 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>에 다시 적용합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>