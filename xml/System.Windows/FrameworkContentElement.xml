<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="2a896-101"><see cref="T:System.Windows.FrameworkContentElement" />는 <see cref="T:System.Windows.ContentElement" /> 기본 클래스의 WPF 프레임워크 수준 구현 및 확장입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-101"><see cref="T:System.Windows.FrameworkContentElement" /> is the WPF framework-level implementation and expansion of the <see cref="T:System.Windows.ContentElement" /> base class.</span></span> <span data-ttu-id="2a896-102"><see cref="T:System.Windows.FrameworkContentElement" />는 데이터 바인딩, 스타일 지원 및 논리적 트리 도우미 API를 위한 데이터 컨텍스트, 스토리보드 및 추가 입력 API(도구 설명 및 상황에 맞는 메뉴 포함)에 대한 지원을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-102"><see cref="T:System.Windows.FrameworkContentElement" /> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-103"><xref:System.Windows.FrameworkContentElement> 고유한 렌더링 동작; 아직 정의 하지 않습니다. 실제 인스턴스화 <xref:System.Windows.FrameworkContentElement> 코드 또는 태그의 클래스 인스턴스 수는 있지만에 아무 것도 표시는 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 응용 프로그램 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-103"><xref:System.Windows.FrameworkContentElement> does not yet define its own rendering behavior; instantiating an actual <xref:System.Windows.FrameworkContentElement> class instance in code or markup is possible but displays nothing in a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="2a896-104">사용 하는 클래스에서 제공 되어야 렌더링 논리 <xref:System.Windows.FrameworkContentElement> 일부로 또는 콘텐츠 모델의 자식 요소 <xref:System.Windows.FrameworkContentElement> 파생 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-104">Rendering logic must be provided by classes that take <xref:System.Windows.FrameworkContentElement> child elements as part of their content model, or in <xref:System.Windows.FrameworkContentElement> derived classes.</span></span>  
  
 <span data-ttu-id="2a896-105"><xref:System.Windows.FrameworkContentElement> 동일한 의도적 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 으로 <xref:System.Windows.FrameworkElement>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-105"><xref:System.Windows.FrameworkContentElement> deliberately parallels many of the same [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] as <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="2a896-106">특정 참고 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 에 <xref:System.Windows.FrameworkElement> 체계가 없습니다는 <xref:System.Windows.FrameworkContentElement> 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-106">Note that certain [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] found on <xref:System.Windows.FrameworkElement> will not have a <xref:System.Windows.FrameworkContentElement> equivalent.</span></span> <span data-ttu-id="2a896-107">몇 가지는 <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 에 관련이 없는는 기 하 도형 표현 또는 레이아웃을와 같은 기능에는 한 <xref:System.Windows.FrameworkContentElement>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-107">Several of the <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] are for functionality such as geometry representation or layout, which are not relevant for a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 <span data-ttu-id="2a896-108">대부분의 기존 <xref:System.Windows.FrameworkContentElement> 파생된 클래스에서 섹션의 <xref:System.Windows.Documents> 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-108">The majority of existing <xref:System.Windows.FrameworkContentElement> derived classes will be found in the <xref:System.Windows.Documents> namespace.</span></span> <span data-ttu-id="2a896-109">파생된 클래스는 대부분 흐름 문서 모델에 대 한 요소를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-109">Many of these derived classes implement elements for the flow document model.</span></span> <span data-ttu-id="2a896-110">와 같은 특정 파생된 클래스 <xref:System.Windows.Documents.Hyperlink> 일부 컨트롤과 비슷한 기능이 같지만에서 파생 된 <xref:System.Windows.FrameworkContentElement> 컨트롤 형식 요소의 흐름 문서 모델에 참가할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-110">Certain derived classes such as <xref:System.Windows.Documents.Hyperlink> have some control-like functionality, but are derived from <xref:System.Windows.FrameworkContentElement> such that the control-like elements can still participate in the flow document model.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2a896-111"><see cref="T:System.Windows.FrameworkContentElement" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-111">Initializes a new instance of the <see cref="T:System.Windows.FrameworkContentElement" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child"><span data-ttu-id="2a896-112">추가될 자식 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-112">The child element to be added.</span></span></param>
        <summary><span data-ttu-id="2a896-113">이 요소의 자식으로 제공된 요소를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-113">Adds the provided element as a child of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-114">이 메서드는 논리적 트리를 다른 프로세스에 의해 반복 중일 때 한 번에 메서드를 호출 하면 예외를 throw 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-114">This method can throw an exception if called at a time when the logical tree is being iterated by another process.</span></span>  
  
 <span data-ttu-id="2a896-115">대부분 <xref:System.Windows.FrameworkContentElement> 포함에 대 한 역할을 하는 전용된 컬렉션을 노출 하는 파생 된 클래스 (예를 들어 <xref:System.Windows.Documents.Span.Inlines%2A> 에 <xref:System.Windows.Documents.Span> 클래스입니다. <xref:System.Windows.Documents.Section.Blocks%2A> 에 <xref:System.Windows.Documents.Section> 클래스).</span><span class="sxs-lookup"><span data-stu-id="2a896-115">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="2a896-116">일반적으로 이러한 클래스에서 파생 하는 경우 논리적 트리를 직접 조작 필요를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-116">You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</span></span> <span data-ttu-id="2a896-117">콘텐츠 요소에 대 한 논리 트리 사용은 특별 한 파서 또는 특수화 된 필요할 수 있는 고급 시나리오 <xref:System.Windows.FrameworkElement> 부모 렌더링 요소 (콘텐츠 호스트)로 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-117">Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <xref:System.Windows.FrameworkElement> that acts as the parent rendering element (content host).</span></span>  
  
 <span data-ttu-id="2a896-118">사용 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> 및 <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, 참조 [In WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-118">For more information about how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2a896-119">요소를 초기화하기 전에 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-119">Called before an element is initialized.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="2a896-120">요소 로드 프로세스 중에 요소를 초기화 하기 전에 수행 해야 하는 특수 한 처리를 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-120">Override this method to provide special handling that should occur before your element is initialized during the element loading process.</span></span>  
  
 <span data-ttu-id="2a896-121">(기본값) 기본 구현을 초기화를 추적 하기 위해 일부 내부 플래그를 설정 하기 때문에 구현에서 기본 구현을 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-121">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
 <span data-ttu-id="2a896-122">기본 구현 하는 경우 예외가 throw 됩니다 <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> 도달 하기 전에 같은 요소에 한 번 이상 라고 <see cref="M:System.Windows.FrameworkContentElement.EndInit" />합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-122">The base implementation will throw an exception if <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> is called more than one time on the same element prior to reaching <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span></span></para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2a896-123">제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-123">Begins the sequence of actions that are contained in the provided storyboard.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="2a896-124">시작할 Storyboard입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-124">The storyboard to begin.</span></span></param>
        <summary><span data-ttu-id="2a896-125">제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-125">Begins the sequence of actions that are contained in the provided storyboard.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-126">사용 하지 않는 서명을 위한는 `isControllable`, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 `false`, 연결 된 애니메이션 시간 표시 막대 clock "전체" 기간의 끝에 도달 하는 즉시 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-126">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="2a896-127">따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-127">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="2a896-128">애니메이션을 제어 또한을 사용 하려면 명명 된 인스턴스나 인스턴스로 코드에서 액세스할 수 있는 스토리 보드 되도록 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-128">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="2a896-129">시작할 Storyboard입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-129">The storyboard to begin.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="2a896-130">Storyboard에 설명되어 있는 속성에 이미 애니메이션이 적용되어 있는 경우에 사용할 동작을 설명하는 열거형의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-130">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</span></span></param>
        <summary><span data-ttu-id="2a896-131">속성에 이미 애니메이션이 적용되어 있는 경우 수행할 작업에 대해 지정된 옵션을 사용하여 제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-131">Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-132">사용 하지 않는 서명을 위한는 `isControllable`, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 `false`, 연결 된 애니메이션 시간 표시 막대 clock "전체" 기간의 끝에 도달 하는 즉시 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-132">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="2a896-133">따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-133">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="2a896-134">애니메이션을 제어 또한을 사용 하려면 명명 된 인스턴스나 인스턴스로 코드에서 액세스할 수 있는 스토리 보드 되도록 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-134">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="2a896-135">사용 하 여 HandoffBehavior 작성</span><span class="sxs-lookup"><span data-stu-id="2a896-135">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="2a896-136">적용 하는 경우는 <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, 또는 <xref:System.Windows.Media.Animation.AnimationClock> 를 사용 하 여 속성에는 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>있으면 모든 <xref:System.Windows.Media.Animation.Clock> 이전에 해당 속성과 연관 된 개체를 계속 시스템 리소스를 사용 하 고 타이밍 시스템 않습니다 시계를 자동으로 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-136">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</span></span>  
  
 <span data-ttu-id="2a896-137">사용 하 여 많은 수의 clock 적용할 때 성능 문제를 방지 하려면 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>를 완성 한 후 속성에서 구성 중인 clock를 제거 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-137">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="2a896-138">클록을 제거 하는 방법은 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-138">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="2a896-139">에서 제거 하려면 모든 clock 속성을 사용 하 여는 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 또는 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> 애니메이션된 된 개체의 메서드.</span><span class="sxs-lookup"><span data-stu-id="2a896-139">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="2a896-140">첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 `null` 를 두 번째입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-140">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="2a896-141">그러면 모든 애니메이션 클록 속성에서 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-141">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="2a896-142">특정을 제거 하려면 <xref:System.Windows.Media.Animation.AnimationClock> 클록 목록에서 사용 하 여는 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 속성의는 <xref:System.Windows.Media.Animation.AnimationClock> 검색 하는 <xref:System.Windows.Media.Animation.ClockController>, 호출는 <xref:System.Windows.Media.Animation.ClockController.Remove%2A> 의 메서드는 <xref:System.Windows.Media.Animation.ClockController>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-142">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="2a896-143">이 일반적으로 수행 된 <xref:System.Windows.Media.Animation.Clock.Completed> 클록에 대 한 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-143">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="2a896-144">유일한 루트 클록을 제어할 수 있는 참고는 <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> 자식 클록의 속성을 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-144">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="2a896-145">또한는 <xref:System.Windows.Media.Animation.Clock.Completed> 클록의 유효 기간이 무제한 인 경우 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-145">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="2a896-146">사용자를 호출 하는 시기를 결정 해야 경우 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-146">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="2a896-147">이것은 주로 수명이 긴 개체에 대한 애니메이션에서 문제가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-147">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="2a896-148">개체가 가비지 수집 된 경우 해당 clock도 연결이 끊어지고 가비지 수집.</span><span class="sxs-lookup"><span data-stu-id="2a896-148">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="2a896-149">클록 개체에 대 한 자세한 내용은 참조 [애니메이션 및 타이밍 시스템 개요](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-149">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="2a896-150">시작할 Storyboard입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-150">The storyboard to begin.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="2a896-151">스토리보드에 설명되어 있는 속성에 이미 애니메이션이 적용되어 있는 경우에 사용할 동작을 설명하는 열거형의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-151">A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</span></span></param>
        <param name="isControllable"><span data-ttu-id="2a896-152">애니메이션을 시작한 후 제어(일시 중지)할 수 있는지 여부를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-152">Declares whether the animation is controllable (can be paused) after it is started.</span></span></param>
        <summary><span data-ttu-id="2a896-153">애니메이션이 시작된 후 제어하기 위한 지정된 상태를 사용하여 제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-153">Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-154">사용 하지 않는 서명을 위한는 `isControllable`, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 `false`, 연결 된 애니메이션 시간 표시 막대 clock "전체" 기간의 끝에 도달 하는 즉시 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-154">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="2a896-155">따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-155">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="2a896-156">애니메이션을 제어 또한을 사용 하려면 명명 된 인스턴스나 인스턴스로 코드에서 액세스할 수 있는 스토리 보드 되도록 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-156">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="2a896-157">사용 하 여 HandoffBehavior 작성</span><span class="sxs-lookup"><span data-stu-id="2a896-157">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="2a896-158">적용 하는 경우는 <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, 또는 <xref:System.Windows.Media.Animation.AnimationClock> 를 사용 하 여 속성에는 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>있으면 모든 <xref:System.Windows.Media.Animation.Clock> 이전에 해당 속성과 연관 된 개체를 계속 시스템 리소스를 사용 하 고 타이밍 시스템 않습니다 이러한 clock를 자동으로 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-158">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</span></span>  
  
 <span data-ttu-id="2a896-159">사용 하 여 많은 수의 clock 적용할 때 성능 문제를 방지 하려면 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>를 완성 한 후 속성에서 구성 중인 clock를 제거 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-159">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="2a896-160">클록을 제거 하는 방법은 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-160">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="2a896-161">에서 제거 하려면 모든 clock 속성을 사용 하 여는 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 또는 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> 애니메이션된 된 개체의 메서드.</span><span class="sxs-lookup"><span data-stu-id="2a896-161">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="2a896-162">첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 `null` 를 두 번째입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-162">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="2a896-163">그러면 모든 애니메이션 클록 속성에서 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-163">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="2a896-164">특정을 제거 하려면 <xref:System.Windows.Media.Animation.AnimationClock> 클록 목록에서 사용 하 여는 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 속성의는 <xref:System.Windows.Media.Animation.AnimationClock> 검색 하는 <xref:System.Windows.Media.Animation.ClockController>, 호출는 <xref:System.Windows.Media.Animation.ClockController.Remove%2A> 의 메서드는 <xref:System.Windows.Media.Animation.ClockController>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-164">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="2a896-165">이 일반적으로 수행 된 <xref:System.Windows.Media.Animation.Clock.Completed> 클록에 대 한 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-165">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="2a896-166">유일한 루트 클록을 제어할 수 있는 참고는 <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> 자식 클록의 속성을 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-166">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="2a896-167">또한는 <xref:System.Windows.Media.Animation.Clock.Completed> 클록의 유효 기간이 무제한 인 경우 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-167">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="2a896-168">사용자를 호출 하는 시기를 결정 해야 경우 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-168">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="2a896-169">이것은 주로 수명이 긴 개체에 대한 애니메이션에서 문제가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-169">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="2a896-170">개체가 가비지 수집 된 경우 해당 clock도 연결이 끊어지고 가비지 수집.</span><span class="sxs-lookup"><span data-stu-id="2a896-170">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="2a896-171">클록 개체에 대 한 자세한 내용은 참조 [애니메이션 및 타이밍 시스템 개요](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-171">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-172">요소에 사용되는 <see cref="T:System.Windows.Data.BindingGroup" />을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-172">Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span></span></summary>
        <value><span data-ttu-id="2a896-173">요소에 사용되는 <see cref="T:System.Windows.Data.BindingGroup" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-173">The <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-174">A <xref:System.Windows.Data.BindingGroup> 개체의 여러 속성 값의 유효성 검사를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-174">A <xref:System.Windows.Data.BindingGroup> can be used to validate the values of multiple properties of an object.</span></span> <span data-ttu-id="2a896-175">예를 들어 응용 프로그램 주소를 입력 하 라는 메시지를 표시 하 고 다음 유형의 개체를 채웁니다 `Address`, 속성이 있는 `Street`, `City`, `ZipCode`, 및 `Country`, 값을 사용 하는 사용자 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-175">For example, suppose that an application prompts the user to enter an address and then populates an object of type `Address`, which has the properties `Street`, `City`, `ZipCode`, and `Country`, with the values that the user provided.</span></span> <span data-ttu-id="2a896-176">응용 프로그램에 4 개를 포함 하는 패널 <xref:System.Windows.Controls.TextBox> 개체의 속성 중 하나에 바인딩되는 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-176">The application has a panel that contains four <xref:System.Windows.Controls.TextBox> controls, each of which is bound to one of the object’s properties.</span></span> <span data-ttu-id="2a896-177">사용할 수 있습니다는 <xref:System.Windows.Controls.ValidationRule> 에 <xref:System.Windows.Data.BindingGroup> 유효성을 검사 하 여 `Address` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-177">You can use a <xref:System.Windows.Controls.ValidationRule> in a <xref:System.Windows.Data.BindingGroup> to validate the `Address` object.</span></span> <span data-ttu-id="2a896-178">예를 들어는 <xref:System.Windows.Controls.ValidationRule> 우편 번호 주소 국가 대 한 유효한 되는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-178">For example, the <xref:System.Windows.Controls.ValidationRule> can ensure that the zip code is valid for the country of the address.</span></span>  
  
 <span data-ttu-id="2a896-179">자식 요소를 상속 된 <xref:System.Windows.Data.BindingGroup> 다른 상속 가능한 속성 경우와 마찬가지로, 부모 요소 로부터 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-179">Child elements inherit the <xref:System.Windows.Data.BindingGroup> from their parent elements, just as with any other inheritable property.</span></span>  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-180">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-180">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-181">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-181">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|<span data-ttu-id="2a896-182">메타 데이터 속성이 **true**</span><span class="sxs-lookup"><span data-stu-id="2a896-182">Metadata properties set to **true**</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-183"><see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-183">Identifies the <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2a896-184">이 요소를 포함된 스크롤 가능한 영역 내에서 뷰에 표시하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-184">Attempts to bring this element into view, within any scrollable regions it is contained within.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-185">이 메서드를 호출 하면 호출 됩니다 <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> 요소가 포함 된 부모 스크롤 가능한 영역에서 (부모 수 있을 것을 <xref:System.Windows.FrameworkElement>이 아니라는 <xref:System.Windows.FrameworkContentElement>).</span><span class="sxs-lookup"><span data-stu-id="2a896-185">By calling this method, you effectively will call <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> on any parent scrollable area that contains the element (the parent may very well be a <xref:System.Windows.FrameworkElement>, not a <xref:System.Windows.FrameworkContentElement>).</span></span> <span data-ttu-id="2a896-186">이 요소는 스크롤 가능한 영역에 포함 되지 않은, 이벤트가 계속 되지만 아무런 영향을 주지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-186">If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-187">이 요소 내에서 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]를 통해 상황에 맞는 메뉴를 요청할 때마다 표시되는 상황에 맞는 메뉴 요소를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-187">Gets or sets the context menu element that should appear whenever the context menu is requested via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] from within this element.</span></span></summary>
        <value><span data-ttu-id="2a896-188">이 요소가 사용하는 상황에 맞는 메뉴입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-188">The context menu that this element uses.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-189">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-189">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-190">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-190">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|<span data-ttu-id="2a896-191">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-191">Metadata properties set to `true`</span></span>|<span data-ttu-id="2a896-192">없음</span><span class="sxs-lookup"><span data-stu-id="2a896-192">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2a896-193">다음 예제에서는 위치는 <xref:System.Windows.Controls.ContextMenu> 에 <xref:System.Windows.Documents.Paragraph>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-193">The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-194">요소의 상황에 맞는 메뉴를 닫기 직전에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-194">Occurs just before any context menu on the element is closed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-195">닫히지 않도록 하려면 상황에 맞는 메뉴는 이벤트 처리기로 표시 해야 처리.</span><span class="sxs-lookup"><span data-stu-id="2a896-195">To suppress closing context menus, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="2a896-196">이 이벤트로 사용 하는 <xref:System.Windows.EventTrigger> 스타일에서 기본 서비스 이벤트 식별자를 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-196">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 <span data-ttu-id="2a896-197">(때문에이 사용은 필수에서 이벤트를 구현 <xref:System.Windows.FrameworkContentElement> 있는지 노출 기본 서비스 이벤트 올바르게 매핑되지 않습니다는 <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> 트리거에 사용할 식별자)입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-197">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2a896-198">라우팅 이벤트 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-198">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-199">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-199">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|<span data-ttu-id="2a896-200">라우팅 전략</span><span class="sxs-lookup"><span data-stu-id="2a896-200">Routing strategy</span></span>|<span data-ttu-id="2a896-201">버블링</span><span class="sxs-lookup"><span data-stu-id="2a896-201">Bubbling</span></span>|  
|<span data-ttu-id="2a896-202">대리자</span><span class="sxs-lookup"><span data-stu-id="2a896-202">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 <span data-ttu-id="2a896-203">다음 예제에서는 명명 된 영역 위에 커서를 변경 하는 처리기를 구현 `DisplayArea` (표시 되지 않음).</span><span class="sxs-lookup"><span data-stu-id="2a896-203">The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown).</span></span> <span data-ttu-id="2a896-204">주석 힌트가 <xref:System.Windows.UIElement> 사용 뿐만 아니라 실제로이 예제와 동일한 경우 `DisplayArea` 된는 <xref:System.Windows.FrameworkContentElement>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-204">The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-205"><see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-205">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-206">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2a896-206">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2a896-207">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-207">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-208">요소의 상황에 맞는 메뉴를 열 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-208">Occurs when any context menu on the element is opened.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-209">상황에 맞는 메뉴를 열어야 하는 처리 된 것으로 이벤트의 처리기 관련 이벤트를 표시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-209">To manually open context menus, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="2a896-210">그렇지 않은 경우의 기존 값에서 <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> 를 자동으로 상황에 맞는 메뉴를 열려면 속성을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-210">Otherwise, the existing value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="2a896-211">이벤트를 처리 된을 효과적으로 기본 작업을 취소 하 고 수 값을 다시 설정 하는 <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> 속성을 열고 새 <xref:System.Windows.Controls.ContextMenu>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-211">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="2a896-212">그러나은 알고 있어야 하는 타이밍 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-212">However, there is a timing issue you should be aware of.</span></span> <span data-ttu-id="2a896-213">통해 상황에 맞는 메뉴를 완전히 바꾸기 위해는 <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> 처리기를 초기 상황에 맞는 메뉴 않아야 null 이거나 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-213">In order to completely replace the context menu through a <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> handler, the initial context menu must not be null / empty.</span></span> <span data-ttu-id="2a896-214">또는 이벤트를 처리 한 다음 수동으로 새 상황에 맞는 메뉴를 엽니다. 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-214">Alternatively, you might need to handle the event and then manually open a new context menu.</span></span> <span data-ttu-id="2a896-215">자세한 내용은 참조 [하는 방법: ContextMenuOpening 이벤트를 처리할](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-215">For details, see [How to: Handle the ContextMenuOpening Event](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span></span>  
  
 <span data-ttu-id="2a896-216">이 이벤트로 사용 하는 <xref:System.Windows.EventTrigger> 스타일에서 기본 서비스 이벤트 식별자를 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-216">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 <span data-ttu-id="2a896-217">(때문에이 사용은 필수에서 이벤트를 구현 <xref:System.Windows.FrameworkContentElement> 있는지 노출 기본 서비스 이벤트 올바르게 매핑되지 않습니다는 <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> 트리거에 사용할 식별자)입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-217">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2a896-218">라우팅 이벤트 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-218">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-219">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-219">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|<span data-ttu-id="2a896-220">라우팅 전략</span><span class="sxs-lookup"><span data-stu-id="2a896-220">Routing strategy</span></span>|<span data-ttu-id="2a896-221">버블링</span><span class="sxs-lookup"><span data-stu-id="2a896-221">Bubbling</span></span>|  
|<span data-ttu-id="2a896-222">대리자</span><span class="sxs-lookup"><span data-stu-id="2a896-222">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-223"><see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-223">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-224">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2a896-224">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2a896-225">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-225">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-226"><see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-226">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-227">마우스 포인터가 이 요소 위에 있을 때 표시되는 커서를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-227">Gets or sets the cursor that displays when the mouse pointer is over this element.</span></span></summary>
        <value><span data-ttu-id="2a896-228">표시할 커서입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-228">The cursor to display.</span></span> <span data-ttu-id="2a896-229">기본값은 이 종속성 속성마다 <see langword="null" />로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-229">The default value is defined as <see langword="null" /> per this dependency property.</span></span> <span data-ttu-id="2a896-230">그러나 런타임 시 실제 기본값은 다양한 요소에서 비롯됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-230">However, the practical default at run time will come from a variety of factors.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-231">이 속성을 설정할 때 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 형식 변환에 대 한 프로세서 사용의 <xref:System.Windows.Input.Cursor> 문자열을 평가 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-231">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor relies on type conversion for the <xref:System.Windows.Input.Cursor> class to evaluate the string.</span></span> <span data-ttu-id="2a896-232">제공 된 문자열에 <xref:System.Windows.Input.CursorType> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-232">The provided string should evaluate to a <xref:System.Windows.Input.CursorType> value.</span></span> <span data-ttu-id="2a896-233">자세한 내용은 <xref:System.Windows.Input.Cursor>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2a896-233">See <xref:System.Windows.Input.Cursor> for details.</span></span>  
  
 <span data-ttu-id="2a896-234">이 속성에서 설정한 커서가 여부 마우스 포인터가이 요소 위에 있을 때 표시 되지 것입니다의 값에 따라 결정 됩니다.는 <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-234">Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> property.</span></span> <span data-ttu-id="2a896-235">또한는 활성 끌기, 마우스 캡처, 컨트롤 및 등 내의 텍스트 편집 모드와 같은 이벤트 관련 고려 사항 보다 우선 순위가 높은 사용자가이 속성에 지정한 값 보다 커서를 적용도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-235">Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</span></span>  
  
 <span data-ttu-id="2a896-236">최종 기본적으로이 속성을 설정 하는 동작을 되돌리려면로 설정 `null` 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-236">To revert the behavior of setting this property to the eventual default, set it to `null` again.</span></span>  
  
 <span data-ttu-id="2a896-237">`null` 실제 커서 값의 결정 지연 시키고 다른 곳에서 가져올 기본값인 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-237">The `null` default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</span></span> <span data-ttu-id="2a896-238">위에 표시 된 기본 커서 모든 소스에서 프로그래밍 방식으로 값이 없는 경우는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 응용 프로그램에 화살표가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-238">If presented with no programmatic values from any source, the default cursor over a [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application will be an arrow.</span></span>  
  
 <span data-ttu-id="2a896-239">각 위로 마우스를 움직일은 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 발생 한 <xref:System.Windows.ContentElement.QueryCursor> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-239">Each movement of the mouse over a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application raises a <xref:System.Windows.ContentElement.QueryCursor> event.</span></span> <span data-ttu-id="2a896-240">이벤트 버블 및 경로 따라 모든 요소에는 이벤트를 처리 하 고이 이벤트의 인수를 통해 커서의 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-240">The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</span></span> <span data-ttu-id="2a896-241">이렇게 되 면 이벤트를 처리 하 고 인수에서 변경 된 값은 우선의 값은 <xref:System.Windows.FrameworkContentElement.Cursor%2A> 모든 수준에서 속성 하지 않는 한 <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-241">If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <xref:System.Windows.FrameworkContentElement.Cursor%2A> property at any level, unless <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> is set.</span></span>  
  
 <span data-ttu-id="2a896-242">사용자 지정 커서를 만들지, 경우에 일반적으로이 속성 값으로 설정 하면는 정적 속성의는 <xref:System.Windows.Input.Cursors> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-242">If not creating a custom cursor, typically you set this property to a static property value of the <xref:System.Windows.Input.Cursors> class.</span></span>  
  
 <span data-ttu-id="2a896-243">설정의 <xref:System.Windows.Input.Cursor> 사용자 지정 값으로 설정 되지 않은 부분 신뢰 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-243">Setting the <xref:System.Windows.Input.Cursor> to a custom value is not enabled in partial trust.</span></span> <span data-ttu-id="2a896-244">사용자 지정 커서에 대 한 자세한 내용은 참조 하십시오. [입력 개요](~/docs/framework/wpf/advanced/input-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-244">For more information on custom cursors, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-245">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-245">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-246">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-246">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|<span data-ttu-id="2a896-247">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-247">Metadata properties set to `true`</span></span>|<span data-ttu-id="2a896-248">없음</span><span class="sxs-lookup"><span data-stu-id="2a896-248">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2a896-249">다음 예제에서는 사용자 지정 값으로 커서를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-249">The following example sets the cursor to a custom value.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-250"><see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-250">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-251">데이터 바인딩에 참여할 때 요소에 대한 데이터 컨텍스트를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-251">Gets or sets the data context for an element when it participates in data binding.</span></span></summary>
        <value><span data-ttu-id="2a896-252">데이터 컨텍스트로 사용할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-252">The object to use as data context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-253">*데이터 컨텍스트* 정보 바인딩 뿐만 아니라 경로 같은 바인딩의 다른 특성에 사용 되는 바인딩 소스에 대 한 부모 요소 로부터 상속할 수 있도록 하는 개념은 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-253">*Data context* is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</span></span>  
  
 <span data-ttu-id="2a896-254">데이터 컨텍스트를 직접 설정할 수는 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 바인딩 해당 개체의 속성을 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-254">Data context can be set directly to a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] object, with the bindings evaluating to properties of that object.</span></span> <span data-ttu-id="2a896-255">또는 데이터 컨텍스트 설정할 수는 <xref:System.Windows.Data.DataSourceProvider> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-255">Alternatively, you can set the data context to a <xref:System.Windows.Data.DataSourceProvider> object.</span></span>  
  
 <span data-ttu-id="2a896-256">속성 값이 종속성 속성을 상속 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-256">This dependency property inherits property values.</span></span> <span data-ttu-id="2a896-257">에 대 한 다른 값이 없는 자식 요소가 많은 경우 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정 수는 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-257">If there are child elements with no other value for <xref:System.Windows.FrameworkContentElement.DataContext%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkContentElement.DataContext%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="2a896-258">다음 속성 중 하나를 사용할 수 있습니다 또는 <xref:System.Windows.Data.Binding> 바인딩 소스를 명시적으로 지정 하려면 클래스: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, 또는 <xref:System.Windows.Data.Binding.RelativeSource%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-258">Alternatively, you can use one of the following properties of the <xref:System.Windows.Data.Binding> class to specify the binding source explicitly: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, or <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span></span> <span data-ttu-id="2a896-259">자세한 내용은 참조 [하는 방법: 바인딩 소스를 지정](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-259">For more information, see [How to: Specify the Binding Source](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span></span>  
  
 <span data-ttu-id="2a896-260">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> 가장 일반적으로으로 설정 된 <xref:System.Windows.Data.Binding> 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-260">In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> is most commonly set to as a <xref:System.Windows.Data.Binding> declaration.</span></span> <span data-ttu-id="2a896-261">속성 요소 구문 또는 특성 구문 중 하나를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-261">You can use either property element syntax or attribute syntax.</span></span> <span data-ttu-id="2a896-262">특성 구문은이 페이지에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-262">Attribute syntax is shown in the example on this page.</span></span> <span data-ttu-id="2a896-263">설정할 수도 있습니다 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 코드에서입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-263">You can also set <xref:System.Windows.FrameworkContentElement.DataContext%2A> in code.</span></span>  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="2a896-264">XAML 속성 요소 사용</span><span class="sxs-lookup"><span data-stu-id="2a896-264">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2a896-265">XAML 특성 사용</span><span class="sxs-lookup"><span data-stu-id="2a896-265">XAML Attribute Usage</span></span>  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2a896-266">XAML 값</span><span class="sxs-lookup"><span data-stu-id="2a896-266">XAML Values</span></span>  
 <span data-ttu-id="2a896-267">*dataContextObject*</span><span class="sxs-lookup"><span data-stu-id="2a896-267">*dataContextObject*</span></span>  
 <span data-ttu-id="2a896-268">부모 요소 내에서 모든 바인딩에 대 한 데이터 컨텍스트 역할을 하는 직접 포함 된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-268">A directly embedded object that serves as data context for any bindings within the parent element.</span></span> <span data-ttu-id="2a896-269">이 개체는 일반적으로 <xref:System.Windows.Data.Binding> 또는 다른 <xref:System.Windows.Data.BindingBase> 하위 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-269">Typically, this object is a <xref:System.Windows.Data.Binding> or another <xref:System.Windows.Data.BindingBase> subclass.</span></span> <span data-ttu-id="2a896-270">또는 원시 데이터 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 개체 바인딩 나중에 정의 된 실제 바인딩은 여기서 배치 될 수 있습니다에 사용 되는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-270">Alternatively, raw data of any [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] object type intended for binding may be placed here, with the actual bindings defined later.</span></span>  
  
 <span data-ttu-id="2a896-271">*bindingUsage*</span><span class="sxs-lookup"><span data-stu-id="2a896-271">*bindingUsage*</span></span>  
 <span data-ttu-id="2a896-272">적절 한 데이터 컨텍스트로 계산 되는 바인딩 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-272">A binding usage that evaluates to an appropriate data context.</span></span> <span data-ttu-id="2a896-273">자세한 내용은 [Binding 태그 확장](~/docs/framework/wpf/advanced/binding-markup-extension.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2a896-273">For details, see [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span></span>  
  
 <span data-ttu-id="2a896-274">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="2a896-274">*resourceExtension*</span></span>  
 <span data-ttu-id="2a896-275">다음 중 하나: `StaticResource`, 또는 `DynamicResource`합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-275">One of the following: `StaticResource`, or `DynamicResource`.</span></span> <span data-ttu-id="2a896-276">리소스에는 개체로 정의 하는 원시 데이터를 참조할 때 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-276">This usage is used when referring to raw data defined as an object in resources.</span></span> <span data-ttu-id="2a896-277">참조 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-277">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="2a896-278">*contextResourceKey*</span><span class="sxs-lookup"><span data-stu-id="2a896-278">*contextResourceKey*</span></span>  
 <span data-ttu-id="2a896-279">내에서 요청 된 개체에 대 한 키 식별자는 <xref:System.Windows.ResourceDictionary>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-279">The key identifier for the object being requested from within a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-280">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-280">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-281">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-281">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|<span data-ttu-id="2a896-282">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-282">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="2a896-283">다음 예제에서는 대 한 바인딩을 설정는 <xref:System.Windows.Documents.Paragraph> 요소와 해당 개체는 새 사용자 지정 데이터 개체를 만들어 <xref:System.Windows.FrameworkContentElement.DataContext%2A>, 바인딩 경로 내에 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-283">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-284">이 요소의 데이터 컨텍스트가 변경될 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-284">Occurs when this element's data context changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-285">참조에 대 한 데이터 컨텍스트 및 데이터 바인딩에 설명은 [데이터 바인딩 개요](~/docs/framework/wpf/data/data-binding-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-285">For an explanation of data contexts and data binding, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2a896-286">요소의 경우 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 변경,이 요소에 모든 데이터 바인딩 속성은 영향을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-286">When an element's <xref:System.Windows.FrameworkContentElement.DataContext%2A> changes, all data-bound properties on this element are potentially affected.</span></span> <span data-ttu-id="2a896-287">이 모든 요소는 데이터 컨텍스트를 상속 하는 현재 요소의 하위 요소를 서로 그리고 현재 요소 자체에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-287">This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</span></span> <span data-ttu-id="2a896-288">이러한 모든 바인딩은 다시 새 해석 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 바인딩에 새 값을 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-288">All such bindings re-interpret the new <xref:System.Windows.FrameworkContentElement.DataContext%2A> to reflect the new value in bindings.</span></span> <span data-ttu-id="2a896-289">이러한 변경의 발생을 기준으로 하는 순서는 보장 되지 않습니다는 <xref:System.Windows.FrameworkContentElement.DataContextChanged> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-289">There is no guarantee made about the order of these changes relative to the raising of the <xref:System.Windows.FrameworkContentElement.DataContextChanged> event.</span></span>  <span data-ttu-id="2a896-290">혼합 또는 이벤트 이후에 변경 이벤트 전에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-290">The changes can occur before the event, after the event, or in any mixture.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-291"><see cref="P:System.Windows.FrameworkContentElement.DataContext" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-291">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-292">테마에서 이 컨트롤에 대해 스타일 템플릿을 찾는 데 사용할 키를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-292">Gets or sets the key to use to find the style template for this control in themes.</span></span></summary>
        <value><span data-ttu-id="2a896-293">스타일 키입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-293">The style key.</span></span> <span data-ttu-id="2a896-294">테마 스타일 조회의 일부로 올바르게 사용하려면 이 값은 스타일을 지정할 요소의 <see cref="T:System.Type" />이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-294">To work correctly as part of theme style lookup, this value is expected to be the <see cref="T:System.Type" /> of the element being styled.</span></span> <span data-ttu-id="2a896-295"><see langword="null" /> 특정 사례에 대해 허용 된 값이입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-295"><see langword="null" /> is an accepted value for a certain case.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-296">이 속성은 일반적으로 직접 setter 통해 설정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-296">This property is typically not set through any of its direct setters.</span></span> <span data-ttu-id="2a896-297">대신, 새 하위 클래스를 만들 때마다이 종속성 속성의 유형별 메타 데이터를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-297">Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</span></span> <span data-ttu-id="2a896-298">때 하면 하위 클래스, 호출의 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 에 대해 메서드는 <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> 제어 하위 클래스의 정적 생성자 내에서 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-298">When you subclass, call the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method against the <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identifier, within the static constructor of the control subclass.</span></span>  
  
 <span data-ttu-id="2a896-299">예를 들어, 인라인 클래스와 같은 <xref:System.Windows.Documents.Bold> 재정의 외에 거의 구현 권한이 실제로 <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> 메타 데이터에 해당 정적 생성자 및 여러 인스턴스 생성자를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-299">For instance, an inline class such as <xref:System.Windows.Documents.Bold> actually has very little implementation beyond overriding the <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadata in its static constructor, and exposing several instance constructors.</span></span> <span data-ttu-id="2a896-300">팩트로 묶인 요소는 <xref:System.Windows.Documents.Bold> 이득 태그는 <xref:System.Windows.Documents.TextElement.FontWeight%2A> 속성 <xref:System.Windows.FontWeights.Bold%2A> 의 기본값을 설정 하 여 참조 되는 테마 스타일 내에서 구현 되 <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> 를 `typeof(Bold)`합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-300">The fact that elements surrounded by the <xref:System.Windows.Documents.Bold> tag gain a <xref:System.Windows.Documents.TextElement.FontWeight%2A> property of <xref:System.Windows.FontWeights.Bold%2A> is implemented within the theme style that was referenced by setting the default value of <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> to `typeof(Bold)`.</span></span>  
  
 <span data-ttu-id="2a896-301">테마 스타일을 사용 하지 않도록 신중 하 게 컨트롤을 하려는 경우 설정의 <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> 속성을 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-301">If you want your element or control to deliberately not use theme styles, set the <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> property to `true`.</span></span>  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-302">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-302">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-303">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-303">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|<span data-ttu-id="2a896-304">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-304">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-305"><see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-305">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2a896-306">요소를 초기화한 후에 바로 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-306">Called immediately after an element is initialized.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-307">요소를 로드 프로세스 중 요소를 초기화 하는 경우 수행 해야 하는 특수 처리를 제공 하려면이 메서드를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-307">Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</span></span>  
  
 <span data-ttu-id="2a896-308">(기본값) 기본 구현을 초기화를 추적 하기 위해 일부 내부 플래그를 설정 하기 때문에 구현에서 기본 구현을 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-308">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
 <span data-ttu-id="2a896-309">경우 <xref:System.Windows.FrameworkContentElement.BeginInit%2A> 가 이전에 호출, 기본 구현에서 발생 된 <xref:System.Windows.FrameworkContentElement.Initialized> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-309">If <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was previously called, the base implementation will raise the <xref:System.Windows.FrameworkContentElement.Initialized> event.</span></span> <span data-ttu-id="2a896-310">그렇지 않은 경우, <xref:System.Windows.FrameworkContentElement.BeginInit%2A> 를 호출 하지 않았습니다 수 없는 또는 되었는지를 확인할 <xref:System.Windows.FrameworkContentElement.BeginInit%2A> 가 호출 된 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-310">Otherwise, if <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was not called or it could not be determined whether <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was called, the event is not raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2a896-311">검색할 요소의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-311">Name of the element to search for.</span></span></param>
        <summary><span data-ttu-id="2a896-312">제공된 식별자 이름의 요소를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-312">Finds an element that has the provided identifier name.</span></span></summary>
        <returns><span data-ttu-id="2a896-313">요청한 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-313">The requested element.</span></span> <span data-ttu-id="2a896-314">일치하는 요소를 찾을 수 없으면 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-314">May be <see langword="null" /> if no matching element was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-315">이 요소에 자식 요소가 있으면 이러한 자식 요소는 요청 된 명명 된 요소에 대 한 모든 검색 결과 재귀적으로.</span><span class="sxs-lookup"><span data-stu-id="2a896-315">If this element has child elements, these child elements are all searched recursively for the requested named element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2a896-316">내에서 참조 된 이름으로 검색 되는 요소에 속성을 설정 하는 다음 예제에서는 <xref:System.Windows.Documents.FlowDocument> 페이지에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-316">The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="2a896-317">찾을 리소스의 키 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-317">Key identifier of the resource to be found.</span></span></param>
        <summary><span data-ttu-id="2a896-318">지정된 키를 사용하여 리소스를 검색하고, 요청된 리소스가 없으면 예외를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-318">Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</span></span></summary>
        <returns><span data-ttu-id="2a896-319">찾은 리소스이거나, 일치하는 리소스가 없는 경우 <see langword="null" />입니다. <see langword="null" />인 경우 예외가 throw될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-319">The found resource, or <see langword="null" /> if no matching resource was found (but will also throw an exception if <see langword="null" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2a896-320">이 메서드를 찾을 수 없는 키에 대 한를 호출 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-320">If you call this method for a key that cannot be found, an exception is thrown.</span></span> <span data-ttu-id="2a896-321">대신 호출 해야이 있는 경우 예외를 처리 하지 않을 경우 <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-321">If you do not want to handle exceptions for this case, you should instead call <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span></span> <span data-ttu-id="2a896-322"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> 반환 `null` 리소스가 발견 되 고 예외를 throw 하지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="2a896-322"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> returns `null` when no resource is found, and does not throw an exception.</span></span>  
  
 <span data-ttu-id="2a896-323">호출 하는 요소에는 리소스를 찾을 수 없습니다, 논리적 트리를 사용 하 여 부모 트리를 검색 하는 경우는 트리 수와 동일한 방식으로 리소스는 이상인 경우 검색된 실행 시 키에 의해 요청 된.</span><span class="sxs-lookup"><span data-stu-id="2a896-323">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="2a896-324">일반적으로 반환 값을 반환 되는 리소스 값으로 설정 하 려 했던 하는 속성의 형식 캐스팅 즉시 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-324">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2a896-325">다음 예제에서는 태그에서 정의 된 대로 리소스를 찾아 특정 라우트된 이벤트에 대 한 응답에 있는 요소의 속성에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-325">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><span data-ttu-id="2a896-326">요청된 리소스 키가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="2a896-326">The requested resource key was not found.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2a896-327"><paramref name="resourceKey" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="2a896-327"><paramref name="resourceKey" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-328">키보드 포커스를 캡처할 때 이 요소에 적용되는 모양, 효과 또는 기타 스타일 특성을 사용자 지정할 수 있는 개체를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-328">Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</span></span></summary>
        <value><span data-ttu-id="2a896-329">포커스에 적용하려는 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-329">The desired style to apply on focus.</span></span> <span data-ttu-id="2a896-330">종속성 속성에 선언되어 있는 기본값은 빈 정적 <see cref="T:System.Windows.Style" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-330">The default value as declared in the dependency property is an empty static <see cref="T:System.Windows.Style" />.</span></span> <span data-ttu-id="2a896-331">그러나 런타임 시 유효 값은 대체로(항상 그렇지는 않음) 컨트롤에 대한 테마 지원에서 제공되는 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-331">However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-332">이 속성을 설정할 때 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]스타일은 인라인 요소 대신 리소스로 거의 항상 정의 하 고로 참조 리소스는 일반적으로 <xref:System.Windows.StaticResourceExtension>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-332">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <xref:System.Windows.StaticResourceExtension>.</span></span>  
  
 <span data-ttu-id="2a896-333">이 속성 시각적 모양에 영향을 미칩니다. 하지만 처럼 보고 되지 않습니다 메타 데이터에 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-333">Note that this property affects visual appearance but does not report so in metadata.</span></span> <span data-ttu-id="2a896-334">시각적으로 유사한 변경은 이벤트 기반 및 모든 시간에 적용 되지 않을 수 이며 따라서 보고 하지 않아야 일반적으로 메타 데이터에는 visual 또는 레이아웃 정보가 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-334">This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</span></span>  
  
 <span data-ttu-id="2a896-335">개념적으로 컨트롤에 적용 되는 포커스의 시각적 동작 요소에 일관 된 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-335">Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</span></span> <span data-ttu-id="2a896-336">일관성을 적용 하는 가장 적절 한 방법은 전체 테마를 작성 하는 경우에 포커스 시각적 스타일을 변경 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-336">The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</span></span> <span data-ttu-id="2a896-337">개별 스타일 및 테마의 일부가 아니라이 속성을 설정할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-337">Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</span></span> <span data-ttu-id="2a896-338">테마 전체에서 일관 된 의도 한 대로 되지 않는 요소 관련 동작을 하려는 경우 더 좋은 방법은를 사용 하 트리거 스타일의 개별 입력된 상태 속성 같은 <xref:System.Windows.UIElement.IsFocused%2A> 또는 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, 그렇게 하지 않는 방식으로 수행할 수 있습니다 시각적으로 기존 포커스 시각적 스타일에 방해가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-338">If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <xref:System.Windows.UIElement.IsFocused%2A> or <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, and to do so in a way that does not visually interfere with any existing focus visual style.</span></span> <span data-ttu-id="2a896-339">디자인 의도 대 한 자세한 내용은 <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> 및 집중 속성을 참조 하십시오. 대체 [컨트롤과 FocusVisualStyle에 포커스에 대 한 스타일 지정](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-339">For more information on the design intention of <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> and alternative focus properties, see [Styling for Focus in Controls, and FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span></span>  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2a896-340">XAML 특성 사용</span><span class="sxs-lookup"><span data-stu-id="2a896-340">XAML Attribute Usage</span></span>  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="2a896-341">XAML 속성 요소 사용</span><span class="sxs-lookup"><span data-stu-id="2a896-341">XAML Property Element Usage</span></span>  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2a896-342">XAML 값</span><span class="sxs-lookup"><span data-stu-id="2a896-342">XAML Values</span></span>  
 <span data-ttu-id="2a896-343">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="2a896-343">*resourceExtension*</span></span>  
 <span data-ttu-id="2a896-344">다음 중 하나:, 또는.</span><span class="sxs-lookup"><span data-stu-id="2a896-344">One of the following: , or .</span></span> <span data-ttu-id="2a896-345">참조 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-345">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="2a896-346">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="2a896-346">*styleResourceKey*</span></span>  
 <span data-ttu-id="2a896-347">요청 되는 스타일을 식별 하는 키입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-347">The key that identifies the style being requested.</span></span> <span data-ttu-id="2a896-348">기존 리소스를이 키는 한 <xref:System.Windows.ResourceDictionary>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-348">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2a896-349">속성 요소 구문은 지원 되지만 권장 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-349">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="2a896-350">참조 [인라인 스타일 및 템플릿](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-350">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="2a896-351">사용 하 여 바인딩 참조 또는 <xref:System.Windows.Data.Binding> 가능 하지만 일반적이 지 않은 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-351">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-352">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-352">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-353">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-353">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|<span data-ttu-id="2a896-354">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-354">Metadata properties set to `true`</span></span>|<span data-ttu-id="2a896-355">없음</span><span class="sxs-lookup"><span data-stu-id="2a896-355">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-356"><see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-356">Identifies the <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-357">이 <see cref="T:System.Windows.FrameworkContentElement" />가 이 인스턴스의 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 속성에서 선언된 커서를 렌더링하도록 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]에 명령할 것인지를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-357">Gets or sets a value indicating whether this <see cref="T:System.Windows.FrameworkContentElement" /> should force the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] to render the cursor as declared by this instance's <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> property.</span></span></summary>
        <value>
          <span data-ttu-id="2a896-358">이 요소 위에 있을 때 커서에 대한 이 인스턴스의 설정(모든 자식 요소 포함)을 사용하여 커서가 표시되도록 하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-358"><see langword="true" /> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <see langword="false" />.</span></span> <span data-ttu-id="2a896-359">기본값은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-359">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-360">이 속성을 설정 `true` 자식 요소에서 설정한 커서 기본 설정이 재정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-360">Setting this property to `true` will override the cursor preferences established by child elements.</span></span> <span data-ttu-id="2a896-361">이렇게 하면 일반적 응용 프로그램 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 자식 요소는 커서를 지정 하려고 하는 경우에 특히 해당 사용자를 혼동 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-361">Doing so in general application [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] might be confusing for the user, particularly if child elements are attempting to specify cursors.</span></span> <span data-ttu-id="2a896-362">설정 <xref:System.Windows.FrameworkElement.ForceCursor%2A> 컨트롤 서브클래싱 또는 작성 시나리오에 더 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-362">Setting <xref:System.Windows.FrameworkElement.ForceCursor%2A> is more appropriate in control subclassing or compositing scenarios.</span></span>  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-363">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-363">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-364">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-364">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|<span data-ttu-id="2a896-365">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-365">Metadata properties set to `true`</span></span>|<span data-ttu-id="2a896-366">없음</span><span class="sxs-lookup"><span data-stu-id="2a896-366">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2a896-367">다음 예제에서는 요소 위에 있는 동안 커서를 강제로 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-367">The following example forces the cursor while over the element.</span></span>  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-368"><see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-368">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="2a896-369">바인딩을 가져올 대상 <see cref="T:System.Windows.DependencyProperty" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-369">The target <see cref="T:System.Windows.DependencyProperty" /> from which to get the binding.</span></span></param>
        <summary><span data-ttu-id="2a896-370">지정된 속성의 바인딩에 대한 <see cref="T:System.Windows.Data.BindingExpression" />을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-370">Gets the <see cref="T:System.Windows.Data.BindingExpression" /> for the specified property's binding.</span></span></summary>
        <returns><span data-ttu-id="2a896-371">대상이 데이터 바인딩되어 있으면 <see cref="T:System.Windows.Data.BindingExpression" />을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-371">Returns a <see cref="T:System.Windows.Data.BindingExpression" /> if the target is data bound; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2a896-372">다음 예제에서는 속성을 쿼리하여 바인딩을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-372">The following example retrieves a binding by querying a property.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2a896-373">시각적 부모가 없는 경우 이 요소에 대한 대체 논리 부모를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-373">Returns an alternative logical parent for this element if there is no visual parent.</span></span> <span data-ttu-id="2a896-374">이 경우 <see cref="T:System.Windows.FrameworkContentElement" /> 부모는 항상 <see cref="P:System.Windows.FrameworkContentElement.Parent" /> 속성과 동일한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-374">In this case, a <see cref="T:System.Windows.FrameworkContentElement" /> parent is always the same value as the <see cref="P:System.Windows.FrameworkContentElement.Parent" /> property.</span></span></summary>
        <returns><span data-ttu-id="2a896-375">이 메서드의 WPF 프레임워크 수준 구현에 시각적 부모가 아닌 연결이 있을 때마다 <see langword="null" /> 이외의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-375">Returns something other than <see langword="null" /> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-376">기본 구현은 필요한 단일 시각적 부모를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-376">The default implementation returns the expected single visual parent.</span></span> <span data-ttu-id="2a896-377">사용자 지정 구현을 대체 부모 관계를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-377">Custom implementations might return alternate parent relationships.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-378">이 <see cref="T:System.Windows.FrameworkContentElement" />가 초기화될 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-378">Occurs when this <see cref="T:System.Windows.FrameworkContentElement" /> is initialized.</span></span> <span data-ttu-id="2a896-379">이는 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 속성의 값이 <see langword="false" />(정의되지 않음)에서 <see langword="true" />로 변경되는 경우와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-379">This coincides with cases where the value of the <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> property changes from <see langword="false" /> (or undefined) to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-380">이 이벤트가 될 때마다 발생는 <xref:System.Windows.FrameworkContentElement.EndInit%2A> 또는 <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-380">This event will be raised whenever the <xref:System.Windows.FrameworkContentElement.EndInit%2A> or <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> methods are called.</span></span> <span data-ttu-id="2a896-381">이러한 방법에 대 한 호출 수 있는 계획적 코드 또는 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 프로세스를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-381">Calls to these methods could have been made by deliberate code, or by the [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] loading process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-382">이 <see cref="T:System.Windows.FrameworkContentElement" />에서 사용하는 입력에 대한 컨텍스트를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-382">Gets or sets the context for input used by this <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></summary>
        <value><span data-ttu-id="2a896-383">대체 입력 메서드에서 입력이 해석되는 방법을 수정하는 입력 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-383">The input scope, which modifies how input from alternative input methods is interpreted.</span></span> <span data-ttu-id="2a896-384">기본값은 <see langword="null" />이며, 이 값을 사용하면 명령이 기본 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-384">The default value is <see langword="null" /> (which results in a default handling of commands).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-385">속성 값이 종속성 속성을 상속 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-385">This dependency property inherits property values.</span></span> <span data-ttu-id="2a896-386">에 대 한 다른 값이 없는 자식 요소가 많은 경우 <xref:System.Windows.FrameworkElement.InputScope%2A> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정 수는 <xref:System.Windows.FrameworkElement.InputScope%2A> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-386">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.InputScope%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.InputScope%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="2a896-387">하지만 한 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문 사용 나열 되 고 구문이 허용 되는 경우이 속성을 설정할 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-387">Although a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax usage is listed and is syntactically allowed, setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] is not common.</span></span>  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-388">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-388">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-389">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-389">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|<span data-ttu-id="2a896-390">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-390">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-391"><see cref="P:System.Windows.FrameworkContentElement.InputScope" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-391">Identifies the <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-392">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]로 로드하거나 해당 <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> 메서드를 명시적으로 호출하여 이 요소를 초기화했는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-392">Gets a value indicating whether this element has been initialized, either by being loaded as [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], or by explicitly having its <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> method called.</span></span></summary>
        <value>
          <span data-ttu-id="2a896-393">위의 로드 또는 메서드 호출을 통해 요소를 초기화했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-393"><see langword="true" /> if the element is initialized per the aforementioned loading or method calls; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-394">두이 일 수도 `true` 경우이 요소에 옮겨졌습니다 요소 트리 내에서 새 부모 요소가 있으며 따라서 요소가 다시 로드 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-394">This property may also be `true` if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-395">표시를 위해 이 요소를 로드했는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-395">Gets a value indicating whether this element has been loaded for presentation.</span></span></summary>
        <value>
          <span data-ttu-id="2a896-396">현재 요소가 요소 트리에 연결되어 있으며 렌더링되었으면 <see langword="true" />이고, 요소가 로드된 요소 트리에 연결되지 않았으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-396"><see langword="true" /> if the current element is attached to an element tree and has been rendered; <see langword="false" /> if the element has never been attached to a loaded element tree.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-397">새로 생성 된 인스턴스에서이 속성 설정을 시작할 `false`, 상태를 유지 하 고 `true` 로 설정한 후 `true`이후에 코드에서 제거 하는 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-397">From a newly constructed instance, this property starts off `false`, and remains `true` once it is set to `true`, even if subsequently removed by  code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2a896-398">다음 예제 코드를 사용 하 여 <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> 함수 보증할 수 조건 검사 `displayData` (표시 되지 않음)은 유효한 요소를 로드 한 주문형 처리기의 일환으로 작업할 수 페이지에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-398">The following example code uses <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</span></span> <span data-ttu-id="2a896-399">동일한 논리에 대 한 이벤트 처리기로 실행 한다고 <xref:System.Windows.FrameworkContentElement.Loaded>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-399">That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-400">개별 요소에 적용되는 지역화/전역화 언어 정보를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-400">Gets or sets localization/globalization language information that applies to an individual element.</span></span></summary>
        <value><span data-ttu-id="2a896-401">이 요소에 대한 문화권 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-401">The culture information for this element.</span></span> <span data-ttu-id="2a896-402">기본값은 해당 <see cref="T:System.Windows.Markup.XmlLanguage" /> 값이 "en-US" 문자열로 설정된 <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-402">The default value is an <see cref="T:System.Windows.Markup.XmlLanguage" /> instance with its <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> value set to the string "en-US".</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-403">문자열 형식의 RFC 3066 표준에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-403">The string formats follow the RFC 3066 standard.</span></span> <span data-ttu-id="2a896-404">예를 들어 미국 영어는 "EN-US"입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-404">For example, U.S. English is "en-US".</span></span> <span data-ttu-id="2a896-405">참조 <xref:System.Windows.Markup.XmlLanguage> 값 및 형식에 대 한 자세한 내용은 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-405">See <xref:System.Windows.Markup.XmlLanguage> for more information on the values and format.</span></span>  
  
 <span data-ttu-id="2a896-406">속성 값이 종속성 속성을 상속 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-406">This dependency property inherits property values.</span></span> <span data-ttu-id="2a896-407">에 대 한 다른 값이 없는 자식 요소가 많은 경우 <xref:System.Windows.FrameworkElement.Language%2A> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정 수는 <xref:System.Windows.FrameworkElement.Language%2A> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-407">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.Language%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.Language%2A> value of the nearest parent element with this value assigned.</span></span>  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-408">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-408">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-409">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-409">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|<span data-ttu-id="2a896-410">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-410">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-411"><see cref="P:System.Windows.FrameworkContentElement.Language" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-411">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Language" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-412">요소를 배치하고 렌더링하여 상호 작용할 준비가 되면 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-412">Occurs when the element is laid out, rendered, and ready for interaction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-413">라우트된 이벤트를 직접 경로 따르지 않는, 에서만 발생 하는 동일한 요소 내에서 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-413">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="2a896-414">라우트된 이벤트에 다른 라우트된 이벤트 동작 지원 않는 직접: 액세스할 수 있는 처리기 컬렉션을 지원 하며으로 사용할 수는 <xref:System.Windows.EventTrigger> 스타일에서입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-414">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2a896-415">라우팅 이벤트 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-415">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-416">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-416">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|<span data-ttu-id="2a896-417">라우팅 전략</span><span class="sxs-lookup"><span data-stu-id="2a896-417">Routing strategy</span></span>|<span data-ttu-id="2a896-418">직접</span><span class="sxs-lookup"><span data-stu-id="2a896-418">Direct</span></span>|  
|<span data-ttu-id="2a896-419">대리자</span><span class="sxs-lookup"><span data-stu-id="2a896-419">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-420"><see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-420">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-421">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2a896-421">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2a896-422">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-422">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-423">이 요소의 논리적 자식 요소에 대한 열거자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-423">Gets an enumerator for the logical child elements of this element.</span></span></summary>
        <value><span data-ttu-id="2a896-424">이 요소의 논리적 자식 요소에 대한 열거자입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-424">An enumerator for logical child elements of this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-425">사용 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> 및 <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, 참조 [In WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-425">For more information on how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="2a896-426">포커스를 이동할 방향(열거형의 값)입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-426">The direction that focus is to be moved, as a value of the enumeration.</span></span></param>
        <summary><span data-ttu-id="2a896-427">키보드 포커스를 이 요소에서 다른 요소로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-427">Moves the keyboard focus from this element to another element.</span></span></summary>
        <returns><span data-ttu-id="2a896-428">포커스가 이동되었으면 <see langword="true" /> 를 반환하고, 지정된 방향에 대상 요소가 없으면 <see langword="false" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-428">Returns <see langword="true" /> if focus is moved successfully; <see langword="false" /> if the target element in direction as specified does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-429">요소를 식별하는 이름을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-429">Gets or sets the identifying name of the element.</span></span> <span data-ttu-id="2a896-430">이 이름은 이벤트 처리기 코드 등의 프로그래밍 방식 코드 숨김 항목이 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문 분석 중에 생성된 요소를 참조할 수 있도록 인스턴스 참조를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-430">The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span></summary>
        <value><span data-ttu-id="2a896-431">요소의 이름을 나타내며</span><span class="sxs-lookup"><span data-stu-id="2a896-431">The name of the element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-432">이 속성의 가장 일반적인 사용법은 지정 하는 경우는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 태그에서 요소 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-432">The most common usage of this property is when specifying a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element name in markup.</span></span>  
  
 <span data-ttu-id="2a896-433">이 속성에는 기본적으로 설정 하는 WPF 프레임 워크 수준 편의 속성은 제공 된 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name 지시문](~/docs/framework/xaml-services/x-name-directive.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-433">This property essentially provides a WPF framework-level convenience property to set the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name Directive](~/docs/framework/xaml-services/x-name-directive.md).</span></span>  
  
 <span data-ttu-id="2a896-434">가져오기는 <xref:System.Windows.FrameworkContentElement.Name%2A> 코드에서은 코드에 적절 한 참조가 이미 있는 경우 방금 메서드를 호출할 수 있습니다 및 요소에 속성을 참조 하지 않으면 일반적으로 필요 하기 때문에 <xref:System.Windows.FrameworkContentElement.Name%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-434">Getting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <xref:System.Windows.FrameworkContentElement.Name%2A>.</span></span> <span data-ttu-id="2a896-435">예외는 문자열에 오버 로드 된 의미가 경우, 예를 들어이에 해당 이름을 표시 하는 유용한 경우 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-435">An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="2a896-436">설정 된 <xref:System.Windows.FrameworkContentElement.Name%2A> 코드에서 경우 원래 <xref:System.Windows.FrameworkContentElement.Name%2A> 가 태그에서 설정도 권장 되지 않습니다 및 속성을 변경 해도 개체 참조가 변경 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-436">Setting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code if the original <xref:System.Windows.FrameworkContentElement.Name%2A> was set from markup is also not recommended, and changing the property will not change the object reference.</span></span> <span data-ttu-id="2a896-437">기본 이름 범위를 명시적으로 하는 동안 만든 경우에 이러한 개체 참조가 만들어집니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-437">Such object references are created only when the underlying namescopes are explicitly created during [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] loading.</span></span>  
  
 <span data-ttu-id="2a896-438">명시적으로 호출 해야 <xref:System.Windows.FrameworkContentElement.RegisterName%2A> 에 대 한 효과적인 변경 되도록는 <xref:System.Windows.FrameworkContentElement.Name%2A> 이미 로드 된 요소의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-438">You must specifically call <xref:System.Windows.FrameworkContentElement.RegisterName%2A> to make an effective change on the <xref:System.Windows.FrameworkContentElement.Name%2A> property of an already loaded element.</span></span>  
  
 <span data-ttu-id="2a896-439">해야 하는 대표적인에서는 설정 경우 <xref:System.Windows.FrameworkContentElement.Name%2A> 코드에서 storyboard 명명 요소에 대해 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-439">One notable case where setting <xref:System.Windows.FrameworkContentElement.Name%2A> from  code is important is for naming elements that storyboards will run against.</span></span> <span data-ttu-id="2a896-440">이름을 등록할 수 있습니다, 전에 인스턴스화하고 할당 해야 할 수도 <xref:System.Windows.NameScope> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="2a896-440">Before you can register a name, might also need to instantiate and assign a <xref:System.Windows.NameScope> instance.</span></span> <span data-ttu-id="2a896-441">예 섹션을 참조 하거나 [적기](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-441">See the Example section, or [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="2a896-442">설정 <xref:System.Windows.FrameworkContentElement.Name%2A> 에서 코드 응용 프로그램을 제한 하지만 특히 여기서 응용 프로그램 페이지가 다시 로드 하 고 런타임 코드는 반드시 해당 코드 숨김 하지 탐색 모델을 사용 하는 경우에 일반적으로 더는 요소 이름으로 조회 각 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-442">Setting <xref:System.Windows.FrameworkContentElement.Name%2A> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</span></span> <span data-ttu-id="2a896-443">유틸리티 메서드 <xref:System.Windows.FrameworkContentElement.FindName%2A>에서 사용 하지 않는 <xref:System.Windows.FrameworkContentElement>, 별로 모든 요소를 찾을 수 <xref:System.Windows.FrameworkContentElement.Name%2A> 해당 요소의 논리적 트리에서 재귀적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-443">The utility method <xref:System.Windows.FrameworkContentElement.FindName%2A>, which is available from any <xref:System.Windows.FrameworkContentElement>, can find any element by <xref:System.Windows.FrameworkContentElement.Name%2A> in that element's logical tree recursively.</span></span> <span data-ttu-id="2a896-444">또는 사용할 수 있습니다는 <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> 의 정적 메서드 <xref:System.Windows.LogicalTreeHelper>, 또한를 사용 하는 <xref:System.Windows.FrameworkContentElement.Name%2A> 인수로 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-444">Or you can use the <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> static method of <xref:System.Windows.LogicalTreeHelper>, which also takes the <xref:System.Windows.FrameworkContentElement.Name%2A> string as an argument.</span></span>  
  
 <span data-ttu-id="2a896-445">일반적으로 사용 되는 루트 요소 (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> 예를 들어) 인터페이스를 구현 <xref:System.Windows.Markup.INameScope>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-445">Commonly used root elements (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> for example) implement the interface <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="2a896-446">이 인터페이스의 구현 적용 이름이 해당 범위 내에서 모호한 것으로 예상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-446">Implementations of this interface are expected to enforce that names be unambiguous within their scope.</span></span>  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-447">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-447">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-448">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-448">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|<span data-ttu-id="2a896-449">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-449">Metadata properties set to `true`</span></span>|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-450"><see cref="P:System.Windows.FrameworkContentElement.Name" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-450">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Name" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="2a896-451">이벤트에 대한 데이터를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-451">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="2a896-452"><see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-452">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="2a896-453">이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-453">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-454">이 메서드는 기본 구현이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-454">This method has no default implementation.</span></span> <span data-ttu-id="2a896-455">상속의 중간 클래스가이 메서드를 구현 하는 경우에 기본 구현을 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-455">You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="2a896-456">이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 \* 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-456">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="2a896-457">이 경우 일치 하는 이벤트 라우트된 이벤트가입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-457">In this case the matching event is a routed event.</span></span> <span data-ttu-id="2a896-458">On \* 메서드의 구현 패턴 차이가 있는 라우트된 이벤트의 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-458">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="2a896-459">따라서 구현을 고려할 이벤트 인수의 원본 속성을 갖습니다 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안).</span><span class="sxs-lookup"><span data-stu-id="2a896-459">Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="2a896-460">서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-460">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="2a896-461">이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-461">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="2a896-462">이벤트에 대한 이벤트 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-462">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="2a896-463"><see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-463">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="2a896-464">이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-464">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-465">이 메서드는 기본 구현이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-465">This method has no default implementation.</span></span> <span data-ttu-id="2a896-466">상속의 중간 클래스가이 메서드를 구현 하는 경우에 base ()를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-466">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="2a896-467">이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 \* 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-467">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="2a896-468">이 경우 일치 하는 이벤트 라우트된 이벤트가입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-468">In this case the matching event is a routed event.</span></span> <span data-ttu-id="2a896-469">On \* 메서드의 구현 패턴 차이가 있는 라우트된 이벤트에 대 한 구현이 이벤트 인수는 소스를 수행 해야 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 계정에는 속성 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안).</span><span class="sxs-lookup"><span data-stu-id="2a896-469">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="2a896-470">서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-470">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="2a896-471">이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-471">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="2a896-472">이벤트에 대한 이벤트 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-472">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="2a896-473"><see cref="E:System.Windows.ContentElement.GotFocus" /> 이벤트에 대한 클래스 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-473">Class handler for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-474">이 클래스 처리기는이 요소에서 이벤트가 생성 된 경우이 요소에 적절 한 포커스 동작을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-474">This class handler sets appropriate focus behavior on this element if the event originated from this element.</span></span> <span data-ttu-id="2a896-475">이벤트의 소스 트리의 다른 요소를 한 경우 처리기는 아무 작업도 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-475">If the event's source was another element in the tree, the handler does nothing.</span></span>  
  
 <span data-ttu-id="2a896-476">이러한 기본 요소에서 포커스 동작을 변경 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-476">Override this method in order to change these default focusing behavior on your element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="2a896-477">이벤트에 대한 이벤트 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-477">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="2a896-478"><see cref="E:System.Windows.FrameworkContentElement.Initialized" /> 이벤트를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-478">Raises the <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> event.</span></span> <span data-ttu-id="2a896-479">이 메서드는 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" />가 <see langword="true" />로 설정될 때마다 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-479">This method is invoked whenever <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> is set to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-480">이 항목의 앞부분에 설명 된 대로이 가상 메서드의 기본 구현에서 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-480">The default implementation of this virtual method raises the event as described earlier in this topic.</span></span> <span data-ttu-id="2a896-481">재정의이 동작을 유지 하려면 base ()를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-481">Overrides should call base() to preserve this behavior.</span></span>  
  
 <span data-ttu-id="2a896-482"><xref:System.Windows.FrameworkContentElement.IsInitialized%2A> 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-482">Note that the <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> property is read-only.</span></span> <span data-ttu-id="2a896-483">따라서 이런 방식으로 초기화 동작을 강제 적용 하도록 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-483">Therefore, you cannot set it to force initialization behavior that way.</span></span> <span data-ttu-id="2a896-484">초기화 설정은 에서만 수행할 수는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 프레임 워크입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-484">Initialization setting is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="2a896-485">기존 값 및 새 값을 포함하여 변경된 속성을 설명하는 이벤트 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-485">The event data that describes the property that changed, including the old and new values.</span></span></param>
        <summary><span data-ttu-id="2a896-486">이 <see cref="T:System.Windows.FrameworkContentElement" />에서 종속성 속성의 유효 값이 업데이트될 때마다 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-486">Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.FrameworkContentElement" /> has been updated.</span></span> <span data-ttu-id="2a896-487">변경된 특정 종속성 속성이 인수 매개 변수에서 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-487">The specific dependency property that changed is reported in the arguments parameter.</span></span> <span data-ttu-id="2a896-488"><see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-488">Overrides <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-489">일반적으로 속성 변경 내용 또는 무효화를 검색 하려면이 메서드를 사용 하는 것이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-489">This method is not intended to generally detect property changes or invalidations.</span></span> <span data-ttu-id="2a896-490">대신 것은 일반적인 무효화 패턴의 수정에 대 한 속성의 광범위 한 분류에 대 한 특정 정보가 알려져 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="2a896-490">It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</span></span>  
  
 <span data-ttu-id="2a896-491">이 메서드는 개체의 수명 동안 여러 번 호출 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-491">This method is potentially invoked many times during the life of an object.</span></span> <span data-ttu-id="2a896-492">따라서 특정 속성의 메타 데이터를 무시 하 고 다음 연결 성능을 향상 시킬 수 있습니다 <xref:System.Windows.CoerceValueCallback> 또는 <xref:System.Windows.PropertyChangedCallback> 개별 속성에 대 한 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-492">Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <xref:System.Windows.CoerceValueCallback> or <xref:System.Windows.PropertyChangedCallback> functions for individual properties.</span></span> <span data-ttu-id="2a896-493">그러나, 사용이 메서드는 경우는 <xref:System.Windows.FrameworkContentElement> 많은 수의 값을 상호 연관 된 종속성 속성을 포함 하는 렌더링 동작 다시 실행 해야 다양 한 관련 속성 무효화의 경우와 같은 논리를 포함 하는 경우 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-493">However, you would use this method if a <xref:System.Windows.FrameworkContentElement> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</span></span>  
  
 <span data-ttu-id="2a896-494">같은 이름의 `OnPropertyChanged` 를 다른 서명으로 메서드 (매개 변수 형식이 <xref:System.ComponentModel.PropertyChangedEventArgs>)는 다양 한 클래스에 나타날 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-494">Note that there is an identically named `OnPropertyChanged` method with a different signature (the parameter type is <xref:System.ComponentModel.PropertyChangedEventArgs>) that can appear on a number of classes.</span></span> <span data-ttu-id="2a896-495">`OnPropertyChanged` 데이터 개체 알림에 사용 되 고에 대 한 계약의 일부인 <xref:System.ComponentModel.INotifyPropertyChanged>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-495">That `OnPropertyChanged` is used for data object notifications, and is part of the contract for <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="2a896-496">항상 구현에서 첫 번째 작업으로 기본 구현을 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-496">Always call the base implementation, as the first operation in your implementation.</span></span> <span data-ttu-id="2a896-497">이렇게 하지 않으면 전체 없게 되므로 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 속성 시스템에 잘못 된 값을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-497">Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, which causes incorrect values to be reported.</span></span></para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle"><span data-ttu-id="2a896-498">이전 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-498">The old style.</span></span></param>
        <param name="newStyle"><span data-ttu-id="2a896-499">새 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-499">The new style.</span></span></param>
        <summary><span data-ttu-id="2a896-500">이 요소에서 사용 중인 스타일이 변경될 때 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-500">Invoked when the style that is in use on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-501">이 메서드는 스타일 변경 조건을 나타내는 내부 플래그를 설정 하는 기본 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-501">This method has a default implementation that sets an internal flag noting the style changed condition.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="2a896-502">항상 기본 구현을 호출, 그렇지 않으면 스타일을 적용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-502">Always call the base implementation, otherwise styles cannot be applied.</span></span> <span data-ttu-id="2a896-503">파생 된 클래스에 특수화 된 스타일 선택기 또는 스타일 값을 캐시 하는 경우이 메서드를 재정의 하는 것에 대 한 시나리오 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-503">Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</span></span> <span data-ttu-id="2a896-504">테마 변경은 잠재적으로이 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-504">Theme changes will potentially invoke this method.</span></span></para>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="2a896-505">이벤트에 대한 데이터를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-505">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="2a896-506"><see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-506">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="2a896-507">이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-507">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-508">이 메서드는 기본 구현이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-508">This method has no default implementation.</span></span> <span data-ttu-id="2a896-509">상속의 중간 클래스가이 메서드를 구현 하는 경우에 base ()를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-509">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="2a896-510">이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 \* 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-510">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="2a896-511">이 경우 일치 하는 이벤트 라우트된 이벤트가입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-511">In this case the matching event is a routed event.</span></span> <span data-ttu-id="2a896-512">On \* 메서드의 구현 패턴 차이가 있는 라우트된 이벤트에 대 한 구현이 이벤트 인수는 소스를 수행 해야 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 계정에는 속성 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안).</span><span class="sxs-lookup"><span data-stu-id="2a896-512">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="2a896-513">서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-513">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="2a896-514">이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-514">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="2a896-515">이벤트에 대한 데이터를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-515">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="2a896-516"><see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-516">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="2a896-517">이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-517">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-518">이 메서드는 기본 구현이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-518">This method has no default implementation.</span></span> <span data-ttu-id="2a896-519">상속의 중간 클래스가이 메서드를 구현 하는 경우에 base ()를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-519">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="2a896-520">이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 \* 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-520">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="2a896-521">이 경우 일치 하는 이벤트 라우트된 이벤트가입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-521">In this case the matching event is a routed event.</span></span> <span data-ttu-id="2a896-522">On \* 메서드의 구현 패턴 차이가 있는 라우트된 이벤트에 대 한 이벤트 인수는 소스를 구현 해야 합니다 하므로 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 계정에는 속성 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안).</span><span class="sxs-lookup"><span data-stu-id="2a896-522">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="2a896-523">서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-523">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="2a896-524">이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-524">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-525">이 요소가 테마 스타일에서 스타일 속성을 통합하는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-525">Gets or sets a value indicating whether this element incorporates style properties from theme styles.</span></span></summary>
        <value>
          <span data-ttu-id="2a896-526">이 요소가 테마 스타일 속성을 사용하지 않으면 <see langword="true" />입니다. 이 경우 스타일에서 생성되는 모든 속성은 로컬 응용 프로그램 스타일에서 가져오며, 테마 스타일 속성은 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-526"><see langword="true" /> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</span></span> <span data-ttu-id="2a896-527">응용 프로그램 스타일이 먼저 적용된 다음 응용 프로그램 스타일에 구체적으로 설정되어 있지 않은 속성에 대해 테마 스타일이 적용되면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-527"><see langword="false" /> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-528">이 속성의 가장 일반적인 사용법은 테마 스타일을 제공 하는 스타일의 setter 내에서 간접적으로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-528">The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</span></span>  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-529">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-529">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-530">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-530">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|<span data-ttu-id="2a896-531">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-531">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-532"><see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-532">Identifies the <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-533">논리적 트리에서 이 요소의 부모를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-533">Gets the parent in the logical tree for this element.</span></span></summary>
        <value><span data-ttu-id="2a896-534">이 요소의 논리적 부모입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-534">The logical parent for this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-535">Note 요소의 논리적 부모 응용 프로그램 기능에 따라 변경 될 수 있습니다 및이 속성의 값을 유지 해도 해당 변경 내용을 반영 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-535">Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</span></span> <span data-ttu-id="2a896-536">일반적으로 필요한 직전 값을 가져올 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-536">You typically should get the value immediately before you need it.</span></span>  
  
 <span data-ttu-id="2a896-537">참조 [In WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) 요소 검색에 이러한 방식을 사용 하는 것이 적절 한 논리 트리 및 시나리오 통과 하는 방법에 대 한 자세한 내용은 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-537">See [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</span></span>  
  
 <span data-ttu-id="2a896-538">속성 시스템에서는 다시 계산할 수 요소의 모든 속성 값, 부모가 때 일부 속성 논리 트리를 통해 값을 상속 하기 때문에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-538">The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</span></span> <span data-ttu-id="2a896-539"><xref:System.Windows.FrameworkContentElement.DataContext%2A> 적용 되는 바인딩 요소는 부모가 때 변경도 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-539">The <xref:System.Windows.FrameworkContentElement.DataContext%2A> that applies for bindings can also change when elements are reparented.</span></span>  
  
 <span data-ttu-id="2a896-540">요소의 부모는 일반적으로을 통해 변경할 컬렉션 조작, 전용을 사용 하 여 추가 또는 제거 메서드, 또는 요소의 콘텐츠 속성을 설정 하는 과정입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-540">Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</span></span>  
  
 <span data-ttu-id="2a896-541">사용 하는 가장 일반적인 시나리오는 <xref:System.Windows.FrameworkContentElement.Parent%2A> 속성은 다양 한를 가져온 후 한 참조를 가져올를 <xref:System.Windows.FrameworkContentElement> 부모 개체에서 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-541">The most typical scenario for using the <xref:System.Windows.FrameworkContentElement.Parent%2A> property is to obtain a reference and then get various <xref:System.Windows.FrameworkContentElement> property values from the parent.</span></span> <span data-ttu-id="2a896-542">서식 파일에 대 한는 <xref:System.Windows.FrameworkContentElement.Parent%2A> 템플릿의 됩니다 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-542">For templates, the <xref:System.Windows.FrameworkContentElement.Parent%2A> of the template eventually will be `null`.</span></span> <span data-ttu-id="2a896-543">이 지점을 벗어나 템플릿을 실제로 적용 되는 논리 트리로 확장을 사용 하 여 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-543">To get past this point and extend into the logical tree where the template is actually applied, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2a896-544">확인 하는 다음 예제 여부는 <xref:System.Windows.FrameworkContentElement.Parent%2A> 의 <xref:System.Windows.Documents.TextPointer> 특정 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-544">The following example checks to see whether the <xref:System.Windows.FrameworkContentElement.Parent%2A> of a <xref:System.Windows.Documents.TextPointer> is of a particular type.</span></span>  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="2a896-545">예상 포커스 변경을 결정할 방향입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-545">The direction for which a prospective focus change should be determined.</span></span></param>
        <summary><span data-ttu-id="2a896-546">제공된 포커스 이동 방향에 대해 이 요소를 기준으로 포커스를 받을 다음 요소를 결정하며 실제로 포커스를 이동하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-546">Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</span></span> <span data-ttu-id="2a896-547">이 메서드는 봉인되어 있으며 재정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-547">This method is sealed and cannot be overridden.</span></span></summary>
        <returns><span data-ttu-id="2a896-548">포커스를 실제로 이동하면 포커스가 이동할 다음 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-548">The next element that focus would move to if focus were actually traversed.</span></span> <span data-ttu-id="2a896-549">제공된 방향에 대해 이 요소를 기준으로 포커스를 이동할 수 없는 경우 <see langword="null" />이 반환될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-549">May return <see langword="null" /> if focus cannot be moved relative to this element for the provided direction.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-550"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> 실제로 포커스를 이동 하는 관련된 방법.</span><span class="sxs-lookup"><span data-stu-id="2a896-550"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> is the related method that actually does move focus.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="2a896-551"><see cref="T:System.Windows.Input.TraversalRequest" />에서 <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /> 중 한 방향을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-551">Specified one of the following directions in the <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span></span> <span data-ttu-id="2a896-552">이러한 방향은 <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />에 사용할 수 없지만 <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />에는 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-552">These directions are not legal for <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (but they are legal for <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2a896-553">지정된 이름-개체 매핑에 사용할 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-553">Name to use for the specified name-object mapping.</span></span></param>
        <param name="scopedElement"><span data-ttu-id="2a896-554">매핑을 위한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-554">Object for the mapping.</span></span></param>
        <summary><span data-ttu-id="2a896-555"><see cref="T:System.Windows.NameScope" /> 등록 메서드에 대한 액세스를 간소화하는 접근자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-555">Provides an accessor that simplifies access to the <see cref="T:System.Windows.NameScope" /> registration method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-556">이 메서드는 호출에 대 한 편리한 메서드입니다 <xref:System.Windows.NameScope.RegisterName%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-556">This method is a convenience method for calling <xref:System.Windows.NameScope.RegisterName%2A>.</span></span> <span data-ttu-id="2a896-557">적용 가능한 될 때까지 구현 연속 된 부모 요소를 확인 합니다 <xref:System.Windows.NameScope> 구현 하는 요소를 검색 하 여 액세스할 수 있는 구현 <xref:System.Windows.Markup.INameScope>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-557">The implementation will check successive parent elements until it finds the applicable <xref:System.Windows.NameScope> implementation, which is found by finding an element that implements <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="2a896-558">네임 스페이스에 대 한 자세한 내용은 참조 [WPF XAML 이름 범위](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-558">For more information about namescopes, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="2a896-559">호출 <xref:System.Windows.FrameworkContentElement.RegisterName%2A> 올바르게 코드에서 만들어진 경우 응용 프로그램에 대 한 애니메이션 스토리 보드를 연결 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-559">Calling <xref:System.Windows.FrameworkContentElement.RegisterName%2A> is necessary in order to correctly hook up animation storyboards for applications when created in code.</span></span> <span data-ttu-id="2a896-560">속성을 스토리 보드 키 중 하나 때문에 이것이 <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, 대상 요소에 대 한 참조 하는 대신 런타임 이름 조회를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-560">This is because one of the key storyboard properties, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, uses a run-time name lookup instead of being able to take a reference to a target element.</span></span> <span data-ttu-id="2a896-561">해당 요소는 코드에서 참조 하 여 액세스할 수 있는 경우에 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-561">This is true even if that element is accessible by reference from the code.</span></span> <span data-ttu-id="2a896-562">스토리 보드 대상에 대 한 이름을 등록 해야 이유에 대 한 자세한 내용은 참조 하십시오. [적기](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-562">For more information on why you need to register names for storyboard targets, see [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span> <span data-ttu-id="2a896-563">콘텐츠 요소에 대 한 애니메이션 컨트롤에 보다 일반적이 지는 [적기](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) 제어 시나리오에 대해 중점적으로 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-563">Animations for content elements are less common than animations on controls, the [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) concentrates on control scenarios.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child"><span data-ttu-id="2a896-564">제거할 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-564">The element to remove.</span></span></param>
        <summary><span data-ttu-id="2a896-565">지정된 요소를 이 요소의 논리적 트리에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-565">Removes the specified element from the logical tree for this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-566">이 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 는 클래스를 파생 시키는 경우 자식 컬렉션에 대 한 지원을 추가 하는 경우에 주로 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-566">This [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is mainly relevant for class deriving scenarios, when adding support for child collections.</span></span>  
  
 <span data-ttu-id="2a896-567">대부분 <xref:System.Windows.FrameworkContentElement> 포함에 대 한 역할을 하는 전용된 컬렉션을 노출 하는 파생 된 클래스 (예를 들어 <xref:System.Windows.Documents.Span.Inlines%2A> 에 <xref:System.Windows.Documents.Span> 클래스입니다. <xref:System.Windows.Documents.Section.Blocks%2A> 에 <xref:System.Windows.Documents.Section> 클래스).</span><span class="sxs-lookup"><span data-stu-id="2a896-567">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="2a896-568">일반적으로 이러한 클래스에서 파생 논리 트리를 직접 조작 필요를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-568">Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-569">현재 로컬로 정의된 리소스 사전을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-569">Gets or sets the current locally-defined resource dictionary.</span></span></summary>
        <value><span data-ttu-id="2a896-570">현재 로컬로 정의된 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-570">The current locally-defined resources.</span></span> <span data-ttu-id="2a896-571">이 사전은 리소스 사전으로, 키를 사용하여 사전 내의 리소스에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-571">This is a dictionary of resources, where resources within the dictionary are accessed by key.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-572">완전히 또는 부분적으로 정의할 수 있는 리소스 사전 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 개별 페이지 또는 응용 프로그램에 대 한 루트 요소에는 일반적으로 및 속성 요소로 일반적으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-572">Resource dictionaries that can be defined completely or partially in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] are typically created as a property element, and are typically on the root element for any individual page or for the application.</span></span> <span data-ttu-id="2a896-573">이 수준에서 리소스 사전을 배치 쉽게 페이지의 개별 자식 요소 (또는 응용 프로그램의 경우에는 페이지)를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-573">Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</span></span> <span data-ttu-id="2a896-574">대부분의 응용 프로그램 시나리오의 리소스 사전에서 개체 요소로 스타일을 정의 하는 것 권장 전체 스타일 리소스 자체 포함 될 수 있도록 외부 리소스로 정의 된 또는 (이 방법은 별도 디자이너를 사용 하면. 책임을 편집 해야 하는 물리적 파일을 구분 하 여 개발자 책임).</span><span class="sxs-lookup"><span data-stu-id="2a896-574">In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</span></span>  
  
 <span data-ttu-id="2a896-575">이 속성에서 반환 하는 리소스 사전에만 해당 요소 내부에서 직접 선언 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-575">Note that this property returns only the resource dictionary declared directly within that element.</span></span> <span data-ttu-id="2a896-576">이 자식 요소를 위쪽으로 재귀적으로 검색 되는 각 부모 요소에 정의 된 리소스에 액세스할 수 있는 실제 리소스 조회 프로세스와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-576">This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</span></span>  
  
 <span data-ttu-id="2a896-577">리소스에서 리소스를 만들 수 있지만 컬렉션 내에서 코드에 의해 참조 될 수도 있습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 를 확실 하 게 액세스할 수 없는까지 후 <xref:System.Windows.FrameworkContentElement.Loaded> 사전을 선언 하는 요소에 의해 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-577">Resources can also be referenced by code from within the collection, but be aware that resources created in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] will definitely not be accessible until after <xref:System.Windows.FrameworkContentElement.Loaded> is raised by the element that declares the dictionary.</span></span> <span data-ttu-id="2a896-578">리소스의 비동기적으로 구문 분석 되 고 아니더라도 실제로 <xref:System.Windows.FrameworkContentElement.Loaded> 이벤트는 참조할 수 있는 보증은 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 리소스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-578">In fact, resources are parsed asynchronously, and not even the <xref:System.Windows.FrameworkContentElement.Loaded> event is an assurance that you can reference a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resource.</span></span> <span data-ttu-id="2a896-579">따라서 일반적으로 액세스 해야 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 또는 다른를 통해 런타임 코드의 일부로 정의 된 리소스 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 스타일이 나 특성 값에 대 한 리소스 확장 참조 하는 기법입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-579">For this reason you should generally only access [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resources as part of run-time code, or through other [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques such as styles or resource extension references for attribute values.</span></span> <span data-ttu-id="2a896-580">기본적으로 해당에서 만든 참조 하는 코드를 통해 리소스에 액세스할 때 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-580">When you access resources through code, it is essentially equivalent to a  reference made from [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="2a896-581">내부 <xref:System.Windows.ResourceDictionary> 추가, 제거 또는 코드를 사용 하 여 컬렉션 내에서 리소스를 쿼리 하는 데 필요한 메서드를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-581">The underlying <xref:System.Windows.ResourceDictionary> supports the methods required to add, remove, or query resources from within the collection by using code.</span></span> <span data-ttu-id="2a896-582"><xref:System.Windows.FrameworkContentElement.Resources%2A> 속성은 완전히 리소스 컬렉션을 새로운 또는 다른 요소를 교체 하는 시나리오를 지원 하기 위해 설정할 수 <xref:System.Windows.ResourceDictionary>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-582">The <xref:System.Windows.FrameworkContentElement.Resources%2A> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="2a896-583">에 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 표시 된 구문에 대 한 요소를 포함 하지 않습니다는 <xref:System.Windows.ResourceDictionary>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-583">Notice that the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax shown does not include an element for the <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="2a896-584">이것이; 암시적 컬렉션 구문의 예 컬렉션 요소를 나타내는 태그를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-584">This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</span></span> <span data-ttu-id="2a896-585">컬렉션에 항목으로 추가 하는 요소 대신 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-585">The elements that are added as items to the collection are specified instead.</span></span> <span data-ttu-id="2a896-586">암시적 컬렉션에 대 한 자세한 내용은 및 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], 참조 [XAML 구문에서 세부](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-586">For more information about implicit collections and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], see [XAML Syntax In Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="2a896-587">한 가지 경우 여기서는 <xref:System.Windows.ResourceDictionary> 병합된 된 사전을 도입 하는 경우에서 많은 경우 일반적으로 해당 자식 요소가 없는 요소 이므로 명시적으로 지정 되어 <xref:System.Windows.ResourceDictionary>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-587">One case where a <xref:System.Windows.ResourceDictionary> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="2a896-588">자세한 내용은 참조 [자세한](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-588">For details, see [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span></span>  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="2a896-589">XAML 속성 요소 사용</span><span class="sxs-lookup"><span data-stu-id="2a896-589">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2a896-590">XAML 값</span><span class="sxs-lookup"><span data-stu-id="2a896-590">XAML Values</span></span>  
 <span data-ttu-id="2a896-591">*oneOrMoreResourceElements*</span><span class="sxs-lookup"><span data-stu-id="2a896-591">*oneOrMoreResourceElements*</span></span>  
 <span data-ttu-id="2a896-592">하나 이상의 개체 요소를 각각 정의 하는 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-592">One or more object elements, each of which defines a resource.</span></span> <span data-ttu-id="2a896-593">각 내에서 각 리소스 속성 요소 <xref:System.Windows.ResourceDictionary> 에 대 한 고유 값이 있어야는 [X:key 지시문](~/docs/framework/xaml-services/x-key-directive.md)에서 값을 검색할 때 고유 키로 제공 되는 <xref:System.Windows.ResourceDictionary>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-593">Each resource property element within each <xref:System.Windows.ResourceDictionary> must have a unique value for the [x:Key Directive](~/docs/framework/xaml-services/x-key-directive.md), which serves as the unique key when values are retrieved from the <xref:System.Windows.ResourceDictionary>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2a896-594">다음 예에서는 설정는 <xref:System.Windows.FrameworkContentElement.Resources%2A> 컬렉션에는 <xref:System.Windows.Documents.FlowDocument> 루트 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-594">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element.</span></span> <span data-ttu-id="2a896-595"><xref:System.Windows.Documents.FlowDocument> 전형적인 선택은 보시 이므로 <xref:System.Windows.FrameworkContentElement> 페이지 루트 또는 응용 프로그램 에서처럼 더 높은 수준에서 루트 요소 및 리소스도 의미 있는 클래스는 일반적으로 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-595"><xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2a896-596">지정된 종속성 속성에 대해 이 요소에 바인딩을 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-596">Attaches a binding to this element for the specified dependency property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="2a896-597">바인딩된 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-597">Identifies the bound property.</span></span></param>
        <param name="path"><span data-ttu-id="2a896-598">바인딩에 사용할 소스 속성 이름 또는 속성의 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-598">The source property name or the path to the property used for the binding.</span></span></param>
        <summary><span data-ttu-id="2a896-599">데이터 소스에 대한 경로 정규화로 제공된 소스 속성 이름을 기반으로 이 요소에 바인딩을 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-599">Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</span></span></summary>
        <returns><span data-ttu-id="2a896-600">바인딩 상태를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-600">Records the conditions of the binding.</span></span> <span data-ttu-id="2a896-601">이 반환 값은 오류 검사에 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-601">This return value can be useful for error checking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-602">이 메서드는 호출에 대 한 편리한 메서드입니다 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>는 현재 인스턴스를 전달 하는 <xref:System.Windows.DependencyObject>, 새 및 <xref:System.Windows.Data.Binding> 제공 된 기준 `path` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-602">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>, and creates a new <xref:System.Windows.Data.Binding> based on the provided `path` parameter.</span></span> <span data-ttu-id="2a896-603">이 서명은 단순한 기본 바인딩을 설정 하는 경우 더 편리 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-603">This signature is more convenient if you are establishing a simple default binding.</span></span> <span data-ttu-id="2a896-604">기본이 아닌 조건에 대 한 바인딩 속성을 지정 하거나 사용 하려는 해야 할 경우는 <xref:System.Windows.Data.MultiBinding> 또는 <xref:System.Windows.Data.PriorityBinding>, 사용할지는 <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> 서명 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-604">If you need to specify any binding properties to non-default conditions, or want to use a <xref:System.Windows.Data.MultiBinding> or <xref:System.Windows.Data.PriorityBinding>,you should use the <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2a896-605">다음 예제에서는 대 한 바인딩을 설정는 <xref:System.Windows.Documents.Paragraph> 요소와 해당 개체는 새 사용자 지정 데이터 개체를 만들어 <xref:System.Windows.FrameworkContentElement.DataContext%2A>, 바인딩 경로 내에 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-605">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="2a896-606">바인딩된 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-606">Identifies the bound property.</span></span></param>
        <param name="binding"><span data-ttu-id="2a896-607">데이터 바인딩을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-607">Represents a data binding.</span></span></param>
        <summary><span data-ttu-id="2a896-608">제공된 바인딩 개체를 기반으로 하여 이 요소에 바인딩을 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-608">Attaches a binding to this element, based on the provided binding object.</span></span></summary>
        <returns><span data-ttu-id="2a896-609">바인딩 상태를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-609">Records the conditions of the binding.</span></span> <span data-ttu-id="2a896-610">이 반환 값은 오류 검사에 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-610">This return value can be useful for error checking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-611">이 메서드는 호출에 대 한 편리한 메서드입니다 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>는 현재 인스턴스를 전달 하는 <xref:System.Windows.DependencyObject>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-611">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2a896-612">다음 예제에서는 대 한 바인딩을 설정는 <xref:System.Windows.Documents.Paragraph> 새 요소 <xref:System.Windows.Data.Binding> 새로 작성 하는 소스를 설정 하 고 `DateTime` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-612">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="2a896-613">리소스가 바인딩될 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-613">The property to which the resource is bound.</span></span></param>
        <param name="name"><span data-ttu-id="2a896-614">리소스의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-614">The name of the resource.</span></span></param>
        <summary><span data-ttu-id="2a896-615">지정된 이름으로 리소스를 검색하고 지정된 속성에 대해 해당 리소스에 리소스 참조를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-615">Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-616">리소스 참조는를 사용 하는 [DynamicResource 태그 확장](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) 태그에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-616">A resource reference is similar to the use of a [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) in markup.</span></span> <span data-ttu-id="2a896-617">리소스 참조는 런타임에 지연 기준 지정된 된 속성의 값을 제공 하는 내부 식을 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-617">The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</span></span> <span data-ttu-id="2a896-618">내부 이벤트를 통해 변경 된 값을 표시 하는 리소스 사전 때마다 또는 현재 요소에 부모가 될 때마다 식이 다시 계산 됩니다 (부모 변경 변경 사전 조회 경로).</span><span class="sxs-lookup"><span data-stu-id="2a896-618">The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2a896-619">serialization 프로세스에서 이 클래스의 인스턴스에 있는 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 속성의 콘텐츠를 serialize해야 하는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-619">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property on instances of this class.</span></span></summary>
        <returns>
          <span data-ttu-id="2a896-620"><see cref="P:System.Windows.FrameworkContentElement.Resources" /> 속성 값을 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-620"><see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-621">이 반환 됩니다 `true` 키가 지정 된 리소스를 하나 이상 로컬에서이 때만 <xref:System.Windows.FrameworkContentElement.Resources%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-621">This will return `true` so long as there is at least one keyed resource in the local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2a896-622">serialization 프로세스에서 이 클래스의 인스턴스에 있는 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 속성의 콘텐츠를 serialize해야 하는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-622">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property on instances of this class.</span></span></summary>
        <returns>
          <span data-ttu-id="2a896-623"><see cref="P:System.Windows.FrameworkContentElement.Style" /> 속성 값을 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-623"><see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-624">이 반환 됩니다 `true` 경우는 <xref:System.Windows.Style> 로컬로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-624">This will return `true` if the <xref:System.Windows.Style> is locally set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-625">이 요소에서 바인딩에 관여되는 연결된 데이터 소스가 변경될 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-625">Occurs when any associated data source participating in a binding on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-626">이 이벤트 표면에서 <xref:System.Windows.Data.Binding.SourceUpdated> 의해 발생 하는 이벤트 <xref:System.Windows.Data.Binding> 이 요소와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-626">This event surfaces the <xref:System.Windows.Data.Binding.SourceUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span>  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2a896-627">XAML 특성 사용</span><span class="sxs-lookup"><span data-stu-id="2a896-627">XAML Attribute Usage</span></span>  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-628">이 요소에서 사용할 스타일을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-628">Gets or sets the style to be used by this element.</span></span></summary>
        <value><span data-ttu-id="2a896-629">있는 경우 요소에 대해 적용된 기본값이 아닌 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-629">The applied, nondefault style for the element, if present.</span></span> <span data-ttu-id="2a896-630">그렇지 않으면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-630">Otherwise, <see langword="null" />.</span></span> <span data-ttu-id="2a896-631">기본 생성된 <see cref="T:System.Windows.FrameworkContentElement" />의 기본값은 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-631">The default for a default-constructed <see cref="T:System.Windows.FrameworkContentElement" /> is <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-632">현재 스타일 종종 테마 설정 또는 일반적으로 리소스 페이지 또는 응용 프로그램 수준 (암시적 스타일)에 의해 해당 유형의 개체에 적용 된 스타일에서 기본 스타일을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-632">The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</span></span> <span data-ttu-id="2a896-633">이 속성은 설정 하거나 반환 하지 기본 (테마) 스타일 않지만 암시적 스타일 또는 명시적 스타일 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-633">This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</span></span> <span data-ttu-id="2a896-634">암시적 또는 명시적 스타일의 경우 스타일 되었는지 여부를 리소스로 액세스할 로컬 정의 중요지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-634">In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</span></span>  
  
 <span data-ttu-id="2a896-635">스타일 정의는 몇 가지 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-635">Setting the styles has some restrictions.</span></span> <span data-ttu-id="2a896-636">전체를 다시 설정할 수 있습니다 <xref:System.Windows.FrameworkContentElement.Style%2A> 속성을 새 <xref:System.Windows.Style> 언제 든 지는 됩니다 언제 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-636">You can reset the entire <xref:System.Windows.FrameworkContentElement.Style%2A> property to a new <xref:System.Windows.Style> at any time, which will force a layout recomposition.</span></span> <span data-ttu-id="2a896-637">그러나 가능한 한 즉시 해당 스타일 로드 된 요소에서 사용 하 게 되는 <xref:System.Windows.Style> 고려해 야 봉인 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-637">However, as soon as that style is placed in use by a loaded element, the <xref:System.Windows.Style> should be considered sealed.</span></span> <span data-ttu-id="2a896-638">사용 중인 스타일의 개별 속성을 변경 하려고 (컬렉션 내에서 아무 것도 같은 <xref:System.Windows.Style.Setters%2A>) 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-638">Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <xref:System.Windows.Style.Setters%2A>) causes an exception to be thrown.</span></span> <span data-ttu-id="2a896-639">태그에 정의 된 스타일 (리소스)에 대 한 리소스 사전에서 로드 하거나 내에 포함 된 페이지가 (인라인 스타일)에 대 한 로드 사용 중인 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-639">A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</span></span>  
  
 <span data-ttu-id="2a896-640"><xref:System.Windows.FrameworkContentElement.Style%2A> 특별 한 우선 순위가 종속성 속성이입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-640"><xref:System.Windows.FrameworkContentElement.Style%2A> is a dependency property with special precedence.</span></span> <span data-ttu-id="2a896-641">로컬로 설정 된 스타일은 일반적으로 가장 높은 우선 순위에서 속성 시스템 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-641">The locally set style generally operates at the highest precedence in the property system.</span></span> <span data-ttu-id="2a896-642">경우는 <xref:System.Windows.FrameworkContentElement.Style%2A> 속성 시스템은 해당 유형을 지정 하는 다시 사용할 수 있는 리소스로 정의 된 암시적 스타일에 대 한 확인 로드 하는 동안이 시점에서 null입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-642">If the <xref:System.Windows.FrameworkContentElement.Style%2A> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</span></span> <span data-ttu-id="2a896-643">경우이 단계를 스타일은 여전히 null 하면 기본 (테마) 스타일의 스타일을 가져옵니다. 그러나 기본 스타일에 반환 되지 않습니다는 <xref:System.Windows.FrameworkContentElement.Style%2A> 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-643">If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <xref:System.Windows.FrameworkContentElement.Style%2A> property value.</span></span> <span data-ttu-id="2a896-644">참조 [종속성 속성 값 우선 순위](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-644">See [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2a896-645">XAML 특성 사용</span><span class="sxs-lookup"><span data-stu-id="2a896-645">XAML Attribute Usage</span></span>  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2a896-646">XAML 값</span><span class="sxs-lookup"><span data-stu-id="2a896-646">XAML Values</span></span>  
 <span data-ttu-id="2a896-647">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="2a896-647">*resourceExtension*</span></span>  
 <span data-ttu-id="2a896-648">다음 중 하나:, 또는.</span><span class="sxs-lookup"><span data-stu-id="2a896-648">One of the following: , or .</span></span> <span data-ttu-id="2a896-649">참조 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-649">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="2a896-650">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="2a896-650">*styleResourceKey*</span></span>  
 <span data-ttu-id="2a896-651">요청 되는 스타일을 식별 하는 키입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-651">The key that identifies the style being requested.</span></span> <span data-ttu-id="2a896-652">기존 리소스를이 키는 한 <xref:System.Windows.ResourceDictionary>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-652">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2a896-653">속성 요소 구문은 지원 되지만 권장 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-653">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="2a896-654">참조 [인라인 스타일 및 템플릿](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-654">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="2a896-655">사용 하 여 바인딩 참조 또는 <xref:System.Windows.Data.Binding> 가능 하지만 일반적이 지 않은 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-655">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-656">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-656">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-657">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-657">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|<span data-ttu-id="2a896-658">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-658">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="2a896-659">다음 예에서는 설정는 <xref:System.Windows.FrameworkContentElement.Resources%2A> 컬렉션에는 <xref:System.Windows.Documents.FlowDocument> 루트 요소 다음에 대 한 특정 스타일으로 리소스로 참조는 <xref:System.Windows.Documents.Paragraph>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-659">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-660"><see cref="P:System.Windows.FrameworkContentElement.Style" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-660">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Style" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName"><span data-ttu-id="2a896-661">요청된 앰비언트 속성의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-661">The name of the requested ambient property.</span></span></param>
        <summary><span data-ttu-id="2a896-662">이 멤버에 대한 설명을 보려면 <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2a896-662">For a description of this member, see the <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> method.</span></span></summary>
        <returns>
          <span data-ttu-id="2a896-663"><paramref name="propertyName" />을 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-663"><see langword="true" /> if <paramref name="propertyName" /> is available; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-664">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="2a896-664">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="2a896-665"><xref:System.Windows.FrameworkContentElement> 인스턴스가 <xref:System.Windows.Markup.IQueryAmbient> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-665">It can be used only when the <xref:System.Windows.FrameworkContentElement> instance is cast to an <xref:System.Windows.Markup.IQueryAmbient> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-666">이 요소에 대한 사용자 지정 정보를 저장하는 데 사용할 수 있는 임의의 개체 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-666">Gets or sets an arbitrary object value that can be used to store custom information about this element.</span></span></summary>
        <value><span data-ttu-id="2a896-667">원하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-667">The intended value.</span></span> <span data-ttu-id="2a896-668">이 속성에는 기본값이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-668">This property has no default value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-669">이 속성은 다른 Microsoft 프로그래밍 모델에서 응용 프로그램 또는 Windows Forms에 대 한 Visual Basic과 같은 태그 속성과 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-669">This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</span></span> <span data-ttu-id="2a896-670">기존 응용 프로그램 개발자가 하위 클래스를 시작 하지 않고 모든 요소에 대 한 몇 가지 기본 사용자 지정 정보를 저장할 위치를 제공 하는 것이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-670">It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</span></span>  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2a896-671">XAML 값</span><span class="sxs-lookup"><span data-stu-id="2a896-671">XAML Values</span></span>  
 <span data-ttu-id="2a896-672">속성 요소 사용 설정 하는 데 사용 해야 하는 하기 때문에이 속성 개체는 <xref:System.Windows.FrameworkContentElement.Tag%2A> , 문자열 등의 알려진된 기본 제공 형식 변환기를 가진 개체가 아닌 다른 값으로 XAML에서 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-672">Because this property takes an object, you need to use the property element usage in order to set the <xref:System.Windows.FrameworkContentElement.Tag%2A> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</span></span> <span data-ttu-id="2a896-673">이러한 방식으로 사용 되는 개체 일반적으로 표준 WPF 네임 스페이스에 포함 되지 않는 있으며 따라서 해야 네임 스페이스 매핑을 외부 네임 스페이스에 XAML 요소도 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-673">Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</span></span>  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-674">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-674">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-675">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-675">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|<span data-ttu-id="2a896-676">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-676">Metadata properties set to `true`</span></span>|<span data-ttu-id="2a896-677">없음</span><span class="sxs-lookup"><span data-stu-id="2a896-677">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-678"><see cref="P:System.Windows.FrameworkContentElement.Tag" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-678">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Tag" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-679">이 요소의 바인딩에 참여하는 연결된 대상 속성이 변경되면 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-679">Occurs when any associated target property participating in a binding on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-680">이 이벤트 표면에서 <xref:System.Windows.Data.Binding.TargetUpdated> 의해 발생 하는 이벤트 <xref:System.Windows.Data.Binding> 이 요소와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-680">This event surfaces the <xref:System.Windows.Data.Binding.TargetUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span> <span data-ttu-id="2a896-681">이 일반적으로 해당 바인딩이 양방향 바인딩에 바인딩된 종속성 속성은 모든 유효성 검사 또는 속성이 지원 캐싱 체계 별로 이전 속성 값의 무효화 함을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-681">This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</span></span>  
  
 <span data-ttu-id="2a896-682">이 이벤트의 이벤트 인수는 어떤 바인딩된 속성이 변경 된에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-682">The event arguments of this event will inform you which bound property was changed.</span></span>  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2a896-683">XAML 특성 사용</span><span class="sxs-lookup"><span data-stu-id="2a896-683">XAML Attribute Usage</span></span>  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-684">이 요소의 템플릿 부모에 대한 참조를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-684">Gets a reference to the template parent of this element.</span></span> <span data-ttu-id="2a896-685">요소가 템플릿을 통해 만들어지지 않은 경우에는 이 속성이 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-685">This property is not relevant if the element was not created through a template.</span></span></summary>
        <value><span data-ttu-id="2a896-686">요소를 <see cref="T:System.Windows.FrameworkTemplate" /> <see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> 이 요소를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-686">The element whose <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> caused this element to be created.</span></span> <span data-ttu-id="2a896-687">이 값은 대개 <see langword="null" />합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-687">This value is frequently <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-688">템플릿은 실제로 공유 개체를 서식 파일의 내용을 한 번만 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-688">Templates are actually shared objects, where the contents of the template are created only once.</span></span> <span data-ttu-id="2a896-689">따라서 서식 파일에서 생성 된 요소에 대 한 개체 참조를 가져오는 경우 명백한 논리적 트리 루트 페이지에 도달 하지 않도록 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-689">Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</span></span> <span data-ttu-id="2a896-690">이러한 서식 파일 참조 페이지의 논리 트리를을 연결 하기 위해 얻어야는 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 값과 계속를 원하는 대로 해당 요소 트리를 탐색 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-690">In order to connect such a template reference to the page's logical tree, you should get the <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> value and continue to navigate that element tree as desired.</span></span>  
  
 <span data-ttu-id="2a896-691"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 자주 `null` 일반 개체에 대 한 일반적인 수단을 통해 응용 프로그램에서 페이지 확장 개체 참조를 얻은 경우 해당 요소 아마도 만들어지지 않아 템플릿에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-691"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> will frequently be `null` for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</span></span> <span data-ttu-id="2a896-692">인 사례 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 하지 못할 `null` 낮은 수준의 특정 입력 이벤트를 처리 하거나 템플릿에서 생성 되는 요소를 반환 했거나 열거자 작업 적중 테스트, 이벤트 등의 작업을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-692">Cases where <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> might not be `null` would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-693">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]에서 이 요소에 대해 표시되는 도구 설명 개체를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-693">Gets or sets the tool-tip object that is displayed for this element in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span></summary>
        <value><span data-ttu-id="2a896-694">도구 설명 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-694">The tooltip object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-695">이 속성의 값 형식인 경우 <xref:System.Windows.Controls.ToolTip>, 다음에 사용 되는 도구 설명 되는 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-695">If the value of this property is of type <xref:System.Windows.Controls.ToolTip>, then that is the tool-tip that will be used in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  <span data-ttu-id="2a896-696">값이 다른 형식의 경우 해당 값으로 사용 됩니다는 *콘텐츠* 에 대 한는 <xref:System.Windows.Controls.ToolTip> 제공 (생성 된) 시스템에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-696">If the value is of any other type, then that value will be used as the *content* for a <xref:System.Windows.Controls.ToolTip> provided (constructed) by the system.</span></span> <span data-ttu-id="2a896-697">자세한 내용은 <xref:System.Windows.Controls.ToolTipService>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2a896-697">For more information see <xref:System.Windows.Controls.ToolTipService>.</span></span> <span data-ttu-id="2a896-698">서비스 클래스는 추가로 도구 설명을 사용자 지정 하는 데 사용할 수 있는 연결 된 속성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-698">The service class provides attached properties that can be used to further customize a tool-tip.</span></span>  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2a896-699">XAML 특성 사용</span><span class="sxs-lookup"><span data-stu-id="2a896-699">XAML Attribute Usage</span></span>  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="2a896-700">XAML 속성 요소 사용</span><span class="sxs-lookup"><span data-stu-id="2a896-700">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2a896-701">XAML 값</span><span class="sxs-lookup"><span data-stu-id="2a896-701">XAML Values</span></span>  
 <span data-ttu-id="2a896-702">*toolTipContent*</span><span class="sxs-lookup"><span data-stu-id="2a896-702">*toolTipContent*</span></span>  
 <span data-ttu-id="2a896-703">에 대 한 표시 텍스트 되는 문자열은 <xref:System.Windows.FrameworkContentElement.ToolTip%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-703">A string that becomes the display text for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span></span>  
  
 <span data-ttu-id="2a896-704">*toolTipObjectContent*</span><span class="sxs-lookup"><span data-stu-id="2a896-704">*toolTipObjectContent*</span></span>  
 <span data-ttu-id="2a896-705">에 대 한 내용으로 사용 해야 하는 개체 요소 형태에 제공 된 일부 개체는 <xref:System.Windows.FrameworkContentElement> 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-705">Some object, provided in object element form, that should be used as the content for the <xref:System.Windows.FrameworkContentElement> .</span></span> <span data-ttu-id="2a896-706">됩니다는 <xref:System.Windows.FrameworkElement> 또는 다른 요소에 대 한 레이아웃 합성을 만드는 <xref:System.Windows.FrameworkContentElement.ToolTip%2A>를 포함 하는 텍스트 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-706">Typically this would be a <xref:System.Windows.FrameworkElement> or some other element that creates layout compositing for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, eventually containing text content within the compositing.</span></span> <span data-ttu-id="2a896-707">이 사용법에서는 <xref:System.Windows.Controls.ToolTip> 요소가 만들어집니다 구문 분석 된에서 암시적으로 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], 및 *toolTipObjectContent* 내용이 설정으로 해당 <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-707">In this usage, the <xref:System.Windows.Controls.ToolTip> element is created implicitly from the parsed [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], and the *toolTipObjectContent* content is set as its <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="2a896-708"><`ToolTip` .../></span><span class="sxs-lookup"><span data-stu-id="2a896-708"><`ToolTip` .../></span></span>  
 <span data-ttu-id="2a896-709"><xref:System.Windows.Controls.ToolTip>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2a896-709">See <xref:System.Windows.Controls.ToolTip>.</span></span>  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2a896-710">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-710">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-711">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-711">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|<span data-ttu-id="2a896-712">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="2a896-712">Metadata properties set to `true`</span></span>|<span data-ttu-id="2a896-713">없음</span><span class="sxs-lookup"><span data-stu-id="2a896-713">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2a896-714">값을 설정 하는 다음 예제는 <xref:System.Windows.FrameworkElement.ToolTip%2A> 속성 문자열을 직접 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-714">The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.</span></span>  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-715">요소의 도구 설명을 닫기 직전에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-715">Occurs just before any tooltip on the element is closed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-716">도구 설명 닫기를 표시 하지 않으려면 이벤트의 처리기 것으로 표시 해야 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-716">To suppress closing the tooltip, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="2a896-717">이 이벤트는 <xref:System.Windows.EventTrigger> 스타일에서입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-717">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="2a896-718">이 이벤트의 식별자 필드에는 다시 이벤트를 추가/제거 메서드를 노출 하지 않는 서비스의 구현을 사용 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-718">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2a896-719">라우팅 이벤트 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-719">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-720">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-720">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|<span data-ttu-id="2a896-721">라우팅 전략</span><span class="sxs-lookup"><span data-stu-id="2a896-721">Routing strategy</span></span>|<span data-ttu-id="2a896-722">직접</span><span class="sxs-lookup"><span data-stu-id="2a896-722">Direct</span></span>|  
|<span data-ttu-id="2a896-723">대리자</span><span class="sxs-lookup"><span data-stu-id="2a896-723">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-724"><see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-724">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-725">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2a896-725">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2a896-726">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-726">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-727">요소의 도구 설명이 열리면 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-727">Occurs when any tooltip on the element is opened.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-728">도구 설명을 열어야 하는 처리 된 것으로 이벤트의 처리기 관련 이벤트를 표시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-728">To manually open tooltips, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="2a896-729">그렇지 않은 경우의 값은 <xref:System.Windows.FrameworkContentElement.ToolTip%2A> 를 자동으로 상황에 맞는 메뉴를 열려면 속성을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-729">Otherwise, the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="2a896-730">이벤트를 처리 된을 효과적으로 기본 작업을 취소 하 고 수 값을 다시 설정 하는 <xref:System.Windows.FrameworkContentElement.ToolTip%2A> 속성을 열고 새 <xref:System.Windows.Controls.ContextMenu>합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-730">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="2a896-731">확인 하는 경우이 이벤트가 발생 하지 것입니다 <xref:System.Windows.FrameworkContentElement.ToolTip%2A> 가 null 참조 또는 그렇지 않은 경우 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-731">Note that this event will not be raised if <xref:System.Windows.FrameworkContentElement.ToolTip%2A> is a null reference or otherwise unset.</span></span>  
  
 <span data-ttu-id="2a896-732">이 이벤트는 <xref:System.Windows.EventTrigger> 스타일에서입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-732">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="2a896-733">이 이벤트의 식별자 필드에는 다시 이벤트를 추가/제거 메서드를 노출 하지 않는 서비스의 구현을 사용 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-733">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2a896-734">라우팅 이벤트 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-734">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-735">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-735">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|<span data-ttu-id="2a896-736">라우팅 전략</span><span class="sxs-lookup"><span data-stu-id="2a896-736">Routing strategy</span></span>|<span data-ttu-id="2a896-737">직접</span><span class="sxs-lookup"><span data-stu-id="2a896-737">Direct</span></span>|  
|<span data-ttu-id="2a896-738">대리자</span><span class="sxs-lookup"><span data-stu-id="2a896-738">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-739"><see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-739">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-740">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2a896-740">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2a896-741">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-741">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-742"><see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> 종속성 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-742">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="2a896-743">찾을 리소스의 키 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-743">Key identifier of the resource to be found.</span></span></param>
        <summary><span data-ttu-id="2a896-744">지정된 키를 사용하여 리소스를 검색하고 해당 리소스를 반환합니다(있는 경우).</span><span class="sxs-lookup"><span data-stu-id="2a896-744">Searches for a resource with the specified key, and returns that resource if found.</span></span></summary>
        <returns><span data-ttu-id="2a896-745">찾은 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-745">The found resource.</span></span> <span data-ttu-id="2a896-746">리소스가 없으면 <see langword="null" />이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-746">If no resource was found, <see langword="null" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-747">트리 수는 동일한 방식으로 논리적 트리를 사용 하 여 부모 트리를 검색 된 리소스 호출 하는 요소에 없는 경우 실행 시 키에 의해 동적 리소스 참조를 요청 하는 경우를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-747">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="2a896-748">일반적으로 반환 값을 반환 되는 리소스 값으로 설정 하 려 했던 하는 속성의 형식 캐스팅 즉시 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-748">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
 <span data-ttu-id="2a896-749"><xref:System.Windows.FrameworkContentElement.FindResource%2A> 메서드가 비슷한 동작을 제외 하 고 제공 된 키와 리소스를 찾지 못하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-749">The <xref:System.Windows.FrameworkContentElement.FindResource%2A> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2a896-750">다음 예제에서는 태그에서 정의 된 대로 리소스를 찾아 특정 라우트된 이벤트에 대 한 응답에 있는 요소의 속성에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-750">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-751">로드된 요소의 요소 트리에서 요소를 제거할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-751">Occurs when the element is removed from an element tree of loaded elements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-752">라우트된 이벤트를 직접 경로 따르지 않는, 에서만 발생 하는 동일한 요소 내에서 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-752">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="2a896-753">라우트된 이벤트에 다른 라우트된 이벤트 동작 지원 않는 직접: 액세스할 수 있는 처리기 컬렉션을 지원 하며으로 사용할 수는 <xref:System.Windows.EventTrigger> 스타일에서입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-753">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2a896-754">라우팅 이벤트 정보</span><span class="sxs-lookup"><span data-stu-id="2a896-754">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2a896-755">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="2a896-755">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|<span data-ttu-id="2a896-756">라우팅 전략</span><span class="sxs-lookup"><span data-stu-id="2a896-756">Routing strategy</span></span>|<span data-ttu-id="2a896-757">직접</span><span class="sxs-lookup"><span data-stu-id="2a896-757">Direct</span></span>|  
|<span data-ttu-id="2a896-758">대리자</span><span class="sxs-lookup"><span data-stu-id="2a896-758">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2a896-759"><see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-759">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-760">이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2a896-760">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2a896-761">식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-761">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2a896-762">현재 범위에서 제거할 이름-개체 쌍의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-762">Name of the name-object pair to remove from the current scope.</span></span></param>
        <summary><span data-ttu-id="2a896-763"><see cref="T:System.Windows.NameScope" /> 등록 취소 메서드에 대한 액세스를 간소화합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-763">Simplifies access to the <see cref="T:System.Windows.NameScope" /> de-registration method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2a896-764">하기만 하면 등록을 취소할 이름에 동일한 이름 갖는 다른 요소의 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="2a896-764">You only need to un-register names if you intend to re-register another element with that same name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2a896-765">기본 스타일을 현재 <see cref="T:System.Windows.FrameworkContentElement" />에 다시 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="2a896-765">Reapplies the default style to the current <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>