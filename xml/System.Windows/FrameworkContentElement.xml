<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="615425e7a431643682b3286cc26cb17aa80cb9d4" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33660308" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see cref="T:System.Windows.FrameworkContentElement" />는 <see cref="T:System.Windows.ContentElement" /> 기본 클래스의 WPF 프레임워크 수준 구현 및 확장입니다. <see cref="T:System.Windows.FrameworkContentElement" />는 데이터 바인딩, 스타일 지원 및 논리적 트리 도우미 API를 위한 데이터 컨텍스트, 스토리보드 및 추가 입력 API(도구 설명 및 상황에 맞는 메뉴 포함)에 대한 지원을 추가합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> 고유한 렌더링 동작; 아직 정의 하지 않습니다. 실제 인스턴스화 <xref:System.Windows.FrameworkContentElement> 코드 또는 태그의 클래스 인스턴스 수는 있지만에 아무 것도 표시는 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 응용 프로그램 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]합니다. 사용 하는 클래스에서 제공 되어야 렌더링 논리 <xref:System.Windows.FrameworkContentElement> 일부로 또는 콘텐츠 모델의 자식 요소 <xref:System.Windows.FrameworkContentElement> 파생 클래스입니다.  
  
 <xref:System.Windows.FrameworkContentElement> 동일한 의도적 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 으로 <xref:System.Windows.FrameworkElement>합니다. 특정 참고 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 에 <xref:System.Windows.FrameworkElement> 체계가 없습니다는 <xref:System.Windows.FrameworkContentElement> 해당 합니다. 몇 가지는 <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 에 관련이 없는는 기 하 도형 표현 또는 레이아웃을와 같은 기능에는 한 <xref:System.Windows.FrameworkContentElement>합니다.  
  
 대부분의 기존 <xref:System.Windows.FrameworkContentElement> 파생된 클래스에서 섹션의 <xref:System.Windows.Documents> 네임 스페이스입니다. 파생된 클래스는 대부분 흐름 문서 모델에 대 한 요소를 구현합니다. 와 같은 특정 파생된 클래스 <xref:System.Windows.Documents.Hyperlink> 일부 컨트롤과 비슷한 기능이 같지만에서 파생 된 <xref:System.Windows.FrameworkContentElement> 컨트롤 형식 요소의 흐름 문서 모델에 참가할 수 있도록 합니다.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.FrameworkContentElement" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">추가될 자식 요소입니다.</param>
        <summary>이 요소의 자식으로 제공된 요소를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 논리적 트리를 다른 프로세스에 의해 반복 중일 때 한 번에 메서드를 호출 하면 예외를 throw 수 있습니다.  
  
 대부분 <xref:System.Windows.FrameworkContentElement> 포함에 대 한 역할을 하는 전용된 컬렉션을 노출 하는 파생 된 클래스 (예를 들어 <xref:System.Windows.Documents.Span.Inlines%2A> 에 <xref:System.Windows.Documents.Span> 클래스입니다. <xref:System.Windows.Documents.Section.Blocks%2A> 에 <xref:System.Windows.Documents.Section> 클래스). 일반적으로 이러한 클래스에서 파생 하는 경우 논리적 트리를 직접 조작 필요를 방지할 수 있습니다. 콘텐츠 요소에 대 한 논리 트리 사용은 특별 한 파서 또는 특수화 된 필요할 수 있는 고급 시나리오 <xref:System.Windows.FrameworkElement> 부모 렌더링 요소 (콘텐츠 호스트)로 역할을 합니다.  
  
 사용 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> 및 <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, 참조 [In WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>요소를 초기화하기 전에 호출됩니다.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>요소 로드 프로세스 중에 요소를 초기화 하기 전에 수행 해야 하는 특수 한 처리를 제공 하려면이 메서드를 재정의 합니다.  
  
 (기본값) 기본 구현을 초기화를 추적 하기 위해 일부 내부 플래그를 설정 하기 때문에 구현에서 기본 구현을 호출 해야 합니다.  
  
 기본 구현 하는 경우 예외가 throw 됩니다 <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> 도달 하기 전에 같은 요소에 한 번 이상 라고 <see cref="M:System.Windows.FrameworkContentElement.EndInit" />합니다.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">시작할 Storyboard입니다.</param>
        <summary>제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하지 않는 서명을 위한는 `isControllable`, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 `false`, 연결 된 애니메이션 시간 표시 막대 clock "전체" 기간의 끝에 도달 하는 즉시 제거 됩니다. 따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다. 애니메이션을 제어 또한을 사용 하려면 명명 된 인스턴스나 인스턴스로 코드에서 액세스할 수 있는 스토리 보드 되도록 note 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">시작할 Storyboard입니다.</param>
        <param name="handoffBehavior">Storyboard에 설명되어 있는 속성에 이미 애니메이션이 적용되어 있는 경우에 사용할 동작을 설명하는 열거형의 값입니다.</param>
        <summary>속성에 이미 애니메이션이 적용되어 있는 경우 수행할 작업에 대해 지정된 옵션을 사용하여 제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하지 않는 서명을 위한는 `isControllable`, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 `false`, 연결 된 애니메이션 시간 표시 막대 clock "전체" 기간의 끝에 도달 하는 즉시 제거 됩니다. 따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다. 애니메이션을 제어 또한을 사용 하려면 명명 된 인스턴스나 인스턴스로 코드에서 액세스할 수 있는 스토리 보드 되도록 note 합니다.  
  
## <a name="using-the-compose-handoffbehavior"></a>사용 하 여 HandoffBehavior 작성  
 적용 하는 경우는 <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, 또는 <xref:System.Windows.Media.Animation.AnimationClock> 를 사용 하 여 속성에는 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>있으면 모든 <xref:System.Windows.Media.Animation.Clock> 이전에 해당 속성과 연관 된 개체를 계속 시스템 리소스를 사용 하 고 타이밍 시스템 않습니다 시계를 자동으로 제거 하지 않습니다.  
  
 사용 하 여 많은 수의 clock 적용할 때 성능 문제를 방지 하려면 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>를 완성 한 후 속성에서 구성 중인 clock를 제거 해야 합니다. 클록을 제거 하는 방법은 여러 가지가 있습니다.  
  
-   에서 제거 하려면 모든 clock 속성을 사용 하 여는 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 또는 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> 애니메이션된 된 개체의 메서드. 첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 `null` 를 두 번째입니다. 그러면 모든 애니메이션 클록 속성에서 제거 됩니다.  
  
-   특정을 제거 하려면 <xref:System.Windows.Media.Animation.AnimationClock> 클록 목록에서 사용 하 여는 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 속성의는 <xref:System.Windows.Media.Animation.AnimationClock> 검색 하는 <xref:System.Windows.Media.Animation.ClockController>, 호출는 <xref:System.Windows.Media.Animation.ClockController.Remove%2A> 의 메서드는 <xref:System.Windows.Media.Animation.ClockController>합니다. 이 일반적으로 수행 된 <xref:System.Windows.Media.Animation.Clock.Completed> 클록에 대 한 이벤트 처리기입니다. 유일한 루트 클록을 제어할 수 있는 참고는 <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> 자식 클록의 속성을 반환 `null`합니다. 또한는 <xref:System.Windows.Media.Animation.Clock.Completed> 클록의 유효 기간이 무제한 인 경우 이벤트가 발생 하지 않습니다.  사용자를 호출 하는 시기를 결정 해야 경우 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>합니다.  
  
 이것은 주로 수명이 긴 개체에 대한 애니메이션에서 문제가 됩니다.  개체가 가비지 수집 된 경우 해당 clock도 연결이 끊어지고 가비지 수집.  
  
 클록 개체에 대 한 자세한 내용은 참조 [애니메이션 및 타이밍 시스템 개요](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">시작할 Storyboard입니다.</param>
        <param name="handoffBehavior">스토리보드에 설명되어 있는 속성에 이미 애니메이션이 적용되어 있는 경우에 사용할 동작을 설명하는 열거형의 값입니다.</param>
        <param name="isControllable">애니메이션을 시작한 후 제어(일시 중지)할 수 있는지 여부를 선언합니다.</param>
        <summary>애니메이션이 시작된 후 제어하기 위한 지정된 상태를 사용하여 제공된 Storyboard에 포함된 작업 시퀀스를 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하지 않는 서명을 위한는 `isControllable`, 매개 변수를 해당 매개 변수에 지정 된 경우 또는 `false`, 연결 된 애니메이션 시간 표시 막대 clock "전체" 기간의 끝에 도달 하는 즉시 제거 됩니다. 따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다. 애니메이션을 제어 또한을 사용 하려면 명명 된 인스턴스나 인스턴스로 코드에서 액세스할 수 있는 스토리 보드 되도록 note 합니다.  
  
## <a name="using-the-compose-handoffbehavior"></a>사용 하 여 HandoffBehavior 작성  
 적용 하는 경우는 <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, 또는 <xref:System.Windows.Media.Animation.AnimationClock> 를 사용 하 여 속성에는 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>있으면 모든 <xref:System.Windows.Media.Animation.Clock> 이전에 해당 속성과 연관 된 개체를 계속 시스템 리소스를 사용 하 고 타이밍 시스템 않습니다 이러한 clock를 자동으로 제거 하지 않습니다.  
  
 사용 하 여 많은 수의 clock 적용할 때 성능 문제를 방지 하려면 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>를 완성 한 후 속성에서 구성 중인 clock를 제거 해야 합니다. 클록을 제거 하는 방법은 여러 가지가 있습니다.  
  
-   에서 제거 하려면 모든 clock 속성을 사용 하 여는 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 또는 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> 애니메이션된 된 개체의 메서드. 첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 `null` 를 두 번째입니다. 그러면 모든 애니메이션 클록 속성에서 제거 됩니다.  
  
-   특정을 제거 하려면 <xref:System.Windows.Media.Animation.AnimationClock> 클록 목록에서 사용 하 여는 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 속성의는 <xref:System.Windows.Media.Animation.AnimationClock> 검색 하는 <xref:System.Windows.Media.Animation.ClockController>, 호출는 <xref:System.Windows.Media.Animation.ClockController.Remove%2A> 의 메서드는 <xref:System.Windows.Media.Animation.ClockController>합니다. 이 일반적으로 수행 된 <xref:System.Windows.Media.Animation.Clock.Completed> 클록에 대 한 이벤트 처리기입니다. 유일한 루트 클록을 제어할 수 있는 참고는 <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> 자식 클록의 속성을 반환 `null`합니다. 또한는 <xref:System.Windows.Media.Animation.Clock.Completed> 클록의 유효 기간이 무제한 인 경우 이벤트가 발생 하지 않습니다.  사용자를 호출 하는 시기를 결정 해야 경우 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>합니다.  
  
 이것은 주로 수명이 긴 개체에 대한 애니메이션에서 문제가 됩니다.  개체가 가비지 수집 된 경우 해당 clock도 연결이 끊어지고 가비지 수집.  
  
 클록 개체에 대 한 자세한 내용은 참조 [애니메이션 및 타이밍 시스템 개요](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소에 사용되는 <see cref="T:System.Windows.Data.BindingGroup" />을 가져오거나 설정합니다.</summary>
        <value>요소에 사용되는 <see cref="T:System.Windows.Data.BindingGroup" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Data.BindingGroup> 개체의 여러 속성 값의 유효성 검사를 사용할 수 있습니다. 예를 들어 응용 프로그램 주소를 입력 하 라는 메시지를 표시 하 고 다음 유형의 개체를 채웁니다 `Address`, 속성이 있는 `Street`, `City`, `ZipCode`, 및 `Country`, 값을 사용 하는 사용자 제공 됩니다. 응용 프로그램에 4 개를 포함 하는 패널 <xref:System.Windows.Controls.TextBox> 개체의 속성 중 하나에 바인딩되는 컨트롤입니다. 사용할 수 있습니다는 <xref:System.Windows.Controls.ValidationRule> 에 <xref:System.Windows.Data.BindingGroup> 유효성을 검사 하 여 `Address` 개체입니다. 예를 들어는 <xref:System.Windows.Controls.ValidationRule> 우편 번호 주소 국가 대 한 유효한 되는지 확인할 수 있습니다.  
  
 자식 요소를 상속 된 <xref:System.Windows.Data.BindingGroup> 다른 상속 가능한 속성 경우와 마찬가지로, 부모 요소 로부터 합니다.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|메타 데이터 속성이 **true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 요소를 포함된 스크롤 가능한 영역 내에서 뷰에 표시하려고 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하면 호출 됩니다 <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> 요소가 포함 된 부모 스크롤 가능한 영역에서 (부모 수 있을 것을 <xref:System.Windows.FrameworkElement>이 아니라는 <xref:System.Windows.FrameworkContentElement>). 이 요소는 스크롤 가능한 영역에 포함 되지 않은, 이벤트가 계속 되지만 아무런 영향을 주지 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소 내에서 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]를 통해 상황에 맞는 메뉴를 요청할 때마다 표시되는 상황에 맞는 메뉴 요소를 가져오거나 설정합니다.</summary>
        <value>이 요소가 사용하는 상황에 맞는 메뉴입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 위치는 <xref:System.Windows.Controls.ContextMenu> 에 <xref:System.Windows.Documents.Paragraph>합니다.  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소의 상황에 맞는 메뉴를 닫기 직전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 닫히지 않도록 하려면 상황에 맞는 메뉴는 이벤트 처리기로 표시 해야 처리.  
  
 이 이벤트로 사용 하는 <xref:System.Windows.EventTrigger> 스타일에서 기본 서비스 이벤트 식별자를 참조 해야 합니다.  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (때문에이 사용은 필수에서 이벤트를 구현 <xref:System.Windows.FrameworkContentElement> 있는지 노출 기본 서비스 이벤트 올바르게 매핑되지 않습니다는 <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> 트리거에 사용할 식별자)입니다.  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|라우팅 전략|버블링|  
|대리자|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 다음 예제에서는 명명 된 영역 위에 커서를 변경 하는 처리기를 구현 `DisplayArea` (표시 되지 않음). 주석 힌트가 <xref:System.Windows.UIElement> 사용 뿐만 아니라 실제로이 예제와 동일한 경우 `DisplayArea` 된는 <xref:System.Windows.FrameworkContentElement>합니다.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소의 상황에 맞는 메뉴를 열 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상황에 맞는 메뉴를 열어야 하는 처리 된 것으로 이벤트의 처리기 관련 이벤트를 표시 해야 합니다. 그렇지 않은 경우의 기존 값에서 <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> 를 자동으로 상황에 맞는 메뉴를 열려면 속성을 사용 합니다. 이벤트를 처리 된을 효과적으로 기본 작업을 취소 하 고 수 값을 다시 설정 하는 <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> 속성을 열고 새 <xref:System.Windows.Controls.ContextMenu>합니다. 그러나은 알고 있어야 하는 타이밍 문제입니다. 통해 상황에 맞는 메뉴를 완전히 바꾸기 위해는 <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> 처리기를 초기 상황에 맞는 메뉴 않아야 null 이거나 비어 있습니다. 또는 이벤트를 처리 한 다음 수동으로 새 상황에 맞는 메뉴를 엽니다. 해야 합니다. 자세한 내용은 참조 [하는 방법: ContextMenuOpening 이벤트를 처리할](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)합니다.  
  
 이 이벤트로 사용 하는 <xref:System.Windows.EventTrigger> 스타일에서 기본 서비스 이벤트 식별자를 참조 해야 합니다.  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (때문에이 사용은 필수에서 이벤트를 구현 <xref:System.Windows.FrameworkContentElement> 있는지 노출 기본 서비스 이벤트 올바르게 매핑되지 않습니다는 <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> 트리거에 사용할 식별자)입니다.  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|라우팅 전략|버블링|  
|대리자|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스 포인터가 이 요소 위에 있을 때 표시되는 커서를 가져오거나 설정합니다.</summary>
        <value>표시할 커서입니다. 기본값은 이 종속성 속성마다 <see langword="null" />로 정의됩니다. 그러나 런타임 시 실제 기본값은 다양한 요소에서 비롯됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정할 때 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 형식 변환에 대 한 프로세서 사용의 <xref:System.Windows.Input.Cursor> 문자열을 평가 하는 클래스입니다. 제공 된 문자열에 <xref:System.Windows.Input.CursorType> 값입니다. 자세한 내용은 <xref:System.Windows.Input.Cursor>를 참조하세요.  
  
 이 속성에서 설정한 커서가 여부 마우스 포인터가이 요소 위에 있을 때 표시 되지 것입니다의 값에 따라 결정 됩니다.는 <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> 속성입니다. 또한는 활성 끌기, 마우스 캡처, 컨트롤 및 등 내의 텍스트 편집 모드와 같은 이벤트 관련 고려 사항 보다 우선 순위가 높은 사용자가이 속성에 지정한 값 보다 커서를 적용도 됩니다.  
  
 최종 기본적으로이 속성을 설정 하는 동작을 되돌리려면로 설정 `null` 다시 합니다.  
  
 `null` 실제 커서 값의 결정 지연 시키고 다른 곳에서 가져올 기본값인 의미 합니다. 위에 표시 된 기본 커서 모든 소스에서 프로그래밍 방식으로 값이 없는 경우는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 응용 프로그램에 화살표가 됩니다.  
  
 각 위로 마우스를 움직일은 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 발생 한 <xref:System.Windows.ContentElement.QueryCursor> 이벤트입니다. 이벤트 버블 및 경로 따라 모든 요소에는 이벤트를 처리 하 고이 이벤트의 인수를 통해 커서의 값을 설정할 수 있습니다. 이렇게 되 면 이벤트를 처리 하 고 인수에서 변경 된 값은 우선의 값은 <xref:System.Windows.FrameworkContentElement.Cursor%2A> 모든 수준에서 속성 하지 않는 한 <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> 설정 됩니다.  
  
 사용자 지정 커서를 만들지, 경우에 일반적으로이 속성 값으로 설정 하면는 정적 속성의는 <xref:System.Windows.Input.Cursors> 클래스입니다.  
  
 설정의 <xref:System.Windows.Input.Cursor> 사용자 지정 값으로 설정 되지 않은 부분 신뢰 합니다. 사용자 지정 커서에 대 한 자세한 내용은 참조 하십시오. [입력 개요](~/docs/framework/wpf/advanced/input-overview.md)합니다.  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 사용자 지정 값으로 커서를 설정합니다.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>데이터 바인딩에 참여할 때 요소에 대한 데이터 컨텍스트를 가져오거나 설정합니다.</summary>
        <value>데이터 컨텍스트로 사용할 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *데이터 컨텍스트* 정보 바인딩 뿐만 아니라 경로 같은 바인딩의 다른 특성에 사용 되는 바인딩 소스에 대 한 부모 요소 로부터 상속할 수 있도록 하는 개념은 합니다.  
  
 데이터 컨텍스트를 직접 설정할 수는 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 바인딩 해당 개체의 속성을 사용 하 여 개체입니다. 또는 데이터 컨텍스트 설정할 수는 <xref:System.Windows.Data.DataSourceProvider> 개체입니다.  
  
 속성 값이 종속성 속성을 상속 합니다. 에 대 한 다른 값이 없는 자식 요소가 많은 경우 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정 수는 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.  
  
 다음 속성 중 하나를 사용할 수 있습니다 또는 <xref:System.Windows.Data.Binding> 바인딩 소스를 명시적으로 지정 하려면 클래스: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, 또는 <xref:System.Windows.Data.Binding.RelativeSource%2A>합니다. 자세한 내용은 참조 [하는 방법: 바인딩 소스를 지정](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)합니다.  
  
 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> 가장 일반적으로으로 설정 된 <xref:System.Windows.Data.Binding> 선언 합니다. 속성 요소 구문 또는 특성 구문 중 하나를 사용할 수 있습니다. 특성 구문은이 페이지에 표시 됩니다. 설정할 수도 있습니다 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 코드에서입니다.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>XAML 속성 요소 사용  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML 값  
 *dataContextObject*  
 부모 요소 내에서 모든 바인딩에 대 한 데이터 컨텍스트 역할을 하는 직접 포함 된 개체입니다. 이 개체는 일반적으로 <xref:System.Windows.Data.Binding> 또는 다른 <xref:System.Windows.Data.BindingBase> 하위 클래스입니다. 또는 원시 데이터 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 개체 바인딩 나중에 정의 된 실제 바인딩은 여기서 배치 될 수 있습니다에 사용 되는 형식입니다.  
  
 *bindingUsage*  
 적절 한 데이터 컨텍스트로 계산 되는 바인딩 사용 합니다. 자세한 내용은 [Binding 태그 확장](~/docs/framework/wpf/advanced/binding-markup-extension.md)을 참조하세요.  
  
 *resourceExtension*  
 다음 중 하나: `StaticResource`, 또는 `DynamicResource`합니다. 리소스에는 개체로 정의 하는 원시 데이터를 참조할 때 사용 됩니다. 참조 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)합니다.  
  
 *contextResourceKey*  
 내에서 요청 된 개체에 대 한 키 식별자는 <xref:System.Windows.ResourceDictionary>합니다.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 대 한 바인딩을 설정는 <xref:System.Windows.Documents.Paragraph> 요소와 해당 개체는 새 사용자 지정 데이터 개체를 만들어 <xref:System.Windows.FrameworkContentElement.DataContext%2A>, 바인딩 경로 내에 속성을 설정 합니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소의 데이터 컨텍스트가 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조에 대 한 데이터 컨텍스트 및 데이터 바인딩에 설명은 [데이터 바인딩 개요](~/docs/framework/wpf/data/data-binding-overview.md)합니다.  
  
> [!IMPORTANT]
>  요소의 경우 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 변경,이 요소에 모든 데이터 바인딩 속성은 영향을 받을 수 있습니다. 이 모든 요소는 데이터 컨텍스트를 상속 하는 현재 요소의 하위 요소를 서로 그리고 현재 요소 자체에 적용 됩니다. 이러한 모든 바인딩은 다시 새 해석 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 바인딩에 새 값을 반영 합니다. 이러한 변경의 발생을 기준으로 하는 순서는 보장 되지 않습니다는 <xref:System.Windows.FrameworkContentElement.DataContextChanged> 이벤트입니다.  혼합 또는 이벤트 이후에 변경 이벤트 전에 발생할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>테마에서 이 컨트롤에 대해 스타일 템플릿을 찾는 데 사용할 키를 가져오거나 설정합니다.</summary>
        <value>스타일 키입니다. 테마 스타일 조회의 일부로 올바르게 사용하려면 이 값은 스타일을 지정할 요소의 <see cref="T:System.Type" />이어야 합니다. <see langword="null" /> 특정 사례에 대해 허용 된 값이입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 일반적으로 직접 setter 통해 설정 되지 않습니다. 대신, 새 하위 클래스를 만들 때마다이 종속성 속성의 유형별 메타 데이터를 재정의 합니다. 때 하면 하위 클래스, 호출의 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 에 대해 메서드는 <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> 제어 하위 클래스의 정적 생성자 내에서 식별자입니다.  
  
 예를 들어, 인라인 클래스와 같은 <xref:System.Windows.Documents.Bold> 재정의 외에 거의 구현 권한이 실제로 <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> 메타 데이터에 해당 정적 생성자 및 여러 인스턴스 생성자를 노출 합니다. 팩트로 묶인 요소는 <xref:System.Windows.Documents.Bold> 이득 태그는 <xref:System.Windows.Documents.TextElement.FontWeight%2A> 속성 <xref:System.Windows.FontWeights.Bold%2A> 의 기본값을 설정 하 여 참조 되는 테마 스타일 내에서 구현 되 <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> 를 `typeof(Bold)`합니다.  
  
 테마 스타일을 사용 하지 않도록 신중 하 게 컨트롤을 하려는 경우 설정의 <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> 속성을 `true`합니다.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>요소를 초기화한 후에 바로 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소를 로드 프로세스 중 요소를 초기화 하는 경우 수행 해야 하는 특수 처리를 제공 하려면이 메서드를 구현 합니다.  
  
 (기본값) 기본 구현을 초기화를 추적 하기 위해 일부 내부 플래그를 설정 하기 때문에 구현에서 기본 구현을 호출 해야 합니다.  
  
 경우 <xref:System.Windows.FrameworkContentElement.BeginInit%2A> 가 이전에 호출, 기본 구현에서 발생 된 <xref:System.Windows.FrameworkContentElement.Initialized> 이벤트입니다. 그렇지 않은 경우, <xref:System.Windows.FrameworkContentElement.BeginInit%2A> 를 호출 하지 않았습니다 수 없는 또는 되었는지를 확인할 <xref:System.Windows.FrameworkContentElement.BeginInit%2A> 가 호출 된 이벤트가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">검색할 요소의 이름입니다.</param>
        <summary>제공된 식별자 이름의 요소를 찾습니다.</summary>
        <returns>요청한 요소입니다. 일치하는 요소를 찾을 수 없으면 <see langword="null" />일 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 요소에 자식 요소가 있으면 이러한 자식 요소는 요청 된 명명 된 요소에 대 한 모든 검색 결과 재귀적으로.  
  
   
  
## Examples  
 내에서 참조 된 이름으로 검색 되는 요소에 속성을 설정 하는 다음 예제에서는 <xref:System.Windows.Documents.FlowDocument> 페이지에 있습니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">찾을 리소스의 키 식별자입니다.</param>
        <summary>지정된 키를 사용하여 리소스를 검색하고, 요청된 리소스가 없으면 예외를 발생시킵니다.</summary>
        <returns>찾은 리소스이거나, 일치하는 리소스가 없는 경우 <see langword="null" />입니다. <see langword="null" />인 경우 예외가 throw될 수도 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  이 메서드를 찾을 수 없는 키에 대 한를 호출 하면 예외가 throw 됩니다. 대신 호출 해야이 있는 경우 예외를 처리 하지 않을 경우 <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>합니다. <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> 반환 `null` 리소스가 발견 되 고 예외를 throw 하지 않는 경우.  
  
 호출 하는 요소에는 리소스를 찾을 수 없습니다, 논리적 트리를 사용 하 여 부모 트리를 검색 하는 경우는 트리 수와 동일한 방식으로 리소스는 이상인 경우 검색된 실행 시 키에 의해 요청 된.  
  
 일반적으로 반환 값을 반환 되는 리소스 값으로 설정 하 려 했던 하는 속성의 형식 캐스팅 즉시 것입니다.  
  
   
  
## Examples  
 다음 예제에서는 태그에서 정의 된 대로 리소스를 찾아 특정 라우트된 이벤트에 대 한 응답에 있는 요소의 속성에 적용 됩니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">요청된 리소스 키가 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>키보드 포커스를 캡처할 때 이 요소에 적용되는 모양, 효과 또는 기타 스타일 특성을 사용자 지정할 수 있는 개체를 가져오거나 설정합니다.</summary>
        <value>포커스에 적용하려는 스타일입니다. 종속성 속성에 선언되어 있는 기본값은 빈 정적 <see cref="T:System.Windows.Style" />입니다. 그러나 런타임 시 유효 값은 대체로(항상 그렇지는 않음) 컨트롤에 대한 테마 지원에서 제공되는 스타일입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정할 때 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]스타일은 인라인 요소 대신 리소스로 거의 항상 정의 하 고로 참조 리소스는 일반적으로 <xref:System.Windows.StaticResourceExtension>합니다.  
  
 이 속성 시각적 모양에 영향을 미칩니다. 하지만 처럼 보고 되지 않습니다 메타 데이터에 참고 합니다. 시각적으로 유사한 변경은 이벤트 기반 및 모든 시간에 적용 되지 않을 수 이며 따라서 보고 하지 않아야 일반적으로 메타 데이터에는 visual 또는 레이아웃 정보가 때문입니다.  
  
 개념적으로 컨트롤에 적용 되는 포커스의 시각적 동작 요소에 일관 된 있어야 합니다. 일관성을 적용 하는 가장 적절 한 방법은 전체 테마를 작성 하는 경우에 포커스 시각적 스타일을 변경 하는 것입니다. 개별 스타일 및 테마의 일부가 아니라이 속성을 설정할 수는 없습니다. 테마 전체에서 일관 된 의도 한 대로 되지 않는 요소 관련 동작을 하려는 경우 더 좋은 방법은를 사용 하 트리거 스타일의 개별 입력된 상태 속성 같은 <xref:System.Windows.UIElement.IsFocused%2A> 또는 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, 그렇게 하지 않는 방식으로 수행할 수 있습니다 시각적으로 기존 포커스 시각적 스타일에 방해가 됩니다. 디자인 의도 대 한 자세한 내용은 <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> 및 집중 속성을 참조 하십시오. 대체 [컨트롤과 FocusVisualStyle에 포커스에 대 한 스타일 지정](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)합니다.  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>XAML 속성 요소 사용  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML 값  
 *resourceExtension*  
 다음 중 하나:, 또는. 참조 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)합니다.  
  
 *styleResourceKey*  
 요청 되는 스타일을 식별 하는 키입니다. 기존 리소스를이 키는 한 <xref:System.Windows.ResourceDictionary>합니다.  
  
> [!NOTE]
>  속성 요소 구문은 지원 되지만 권장 하지는 않습니다. 참조 [인라인 스타일 및 템플릿](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)합니다.  사용 하 여 바인딩 참조 또는 <xref:System.Windows.Data.Binding> 가능 하지만 일반적이 지 않은 이기도 합니다.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Windows.FrameworkContentElement" />가 이 인스턴스의 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 속성에서 선언된 커서를 렌더링하도록 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]에 명령할 것인지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          이 요소 위에 있을 때 커서에 대한 이 인스턴스의 설정(모든 자식 요소 포함)을 사용하여 커서가 표시되도록 하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정 `true` 자식 요소에서 설정한 커서 기본 설정이 재정의 됩니다. 이렇게 하면 일반적 응용 프로그램 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 자식 요소는 커서를 지정 하려고 하는 경우에 특히 해당 사용자를 혼동 될 수 있습니다. 설정 <xref:System.Windows.FrameworkElement.ForceCursor%2A> 컨트롤 서브클래싱 또는 작성 시나리오에 더 적합 합니다.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 요소 위에 있는 동안 커서를 강제로 수행 합니다.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">바인딩을 가져올 대상 <see cref="T:System.Windows.DependencyProperty" />입니다.</param>
        <summary>지정된 속성의 바인딩에 대한 <see cref="T:System.Windows.Data.BindingExpression" />을 가져옵니다.</summary>
        <returns>대상이 데이터 바인딩되어 있으면 <see cref="T:System.Windows.Data.BindingExpression" />을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 속성을 쿼리하여 바인딩을 검색 합니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>시각적 부모가 없는 경우 이 요소에 대한 대체 논리 부모를 반환합니다. 이 경우 <see cref="T:System.Windows.FrameworkContentElement" /> 부모는 항상 <see cref="P:System.Windows.FrameworkContentElement.Parent" /> 속성과 동일한 값입니다.</summary>
        <returns>이 메서드의 WPF 프레임워크 수준 구현에 시각적 부모가 아닌 연결이 있을 때마다 <see langword="null" /> 이외의 값을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 구현은 필요한 단일 시각적 부모를 반환합니다. 사용자 지정 구현을 대체 부모 관계를 반환할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Windows.FrameworkContentElement" />가 초기화될 때 발생합니다. 이는 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 속성의 값이 <see langword="false" />(정의되지 않음)에서 <see langword="true" />로 변경되는 경우와 일치합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트가 될 때마다 발생는 <xref:System.Windows.FrameworkContentElement.EndInit%2A> 또는 <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> 메서드가 호출 됩니다. 이러한 방법에 대 한 호출 수 있는 계획적 코드 또는 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 프로세스를 로드 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Windows.FrameworkContentElement" />에서 사용하는 입력에 대한 컨텍스트를 가져오거나 설정합니다.</summary>
        <value>대체 입력 메서드에서 입력이 해석되는 방법을 수정하는 입력 범위입니다. 기본값은 <see langword="null" />이며, 이 값을 사용하면 명령이 기본 처리됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 값이 종속성 속성을 상속 합니다. 에 대 한 다른 값이 없는 자식 요소가 많은 경우 <xref:System.Windows.FrameworkElement.InputScope%2A> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정 수는 <xref:System.Windows.FrameworkElement.InputScope%2A> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.  
  
 하지만 한 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문 사용 나열 되 고 구문이 허용 되는 경우이 속성을 설정할 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 이 일반적입니다.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]로 로드하거나 해당 <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> 메서드를 명시적으로 호출하여 이 요소를 초기화했는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          위의 로드 또는 메서드 호출을 통해 요소를 초기화했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두이 일 수도 `true` 경우이 요소에 옮겨졌습니다 요소 트리 내에서 새 부모 요소가 있으며 따라서 요소가 다시 로드 되도록 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>표시를 위해 이 요소를 로드했는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 요소가 요소 트리에 연결되어 있으며 렌더링되었으면 <see langword="true" />이고, 요소가 로드된 요소 트리에 연결되지 않았으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새로 생성 된 인스턴스에서이 속성 설정을 시작할 `false`, 상태를 유지 하 고 `true` 로 설정한 후 `true`이후에 코드에서 제거 하는 경우에 합니다.  
  
   
  
## Examples  
 다음 예제 코드를 사용 하 여 <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> 함수 보증할 수 조건 검사 `displayData` (표시 되지 않음)은 유효한 요소를 로드 한 주문형 처리기의 일환으로 작업할 수 페이지에 있습니다. 동일한 논리에 대 한 이벤트 처리기로 실행 한다고 <xref:System.Windows.FrameworkContentElement.Loaded>합니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개별 요소에 적용되는 지역화/전역화 언어 정보를 가져오거나 설정합니다.</summary>
        <value>이 요소에 대한 문화권 정보입니다. 기본값은 해당 <see cref="T:System.Windows.Markup.XmlLanguage" /> 값이 "en-US" 문자열로 설정된 <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문자열 형식의 RFC 3066 표준에 따라 합니다. 예를 들어 미국 영어는 "EN-US"입니다. 참조 <xref:System.Windows.Markup.XmlLanguage> 값 및 형식에 대 한 자세한 내용은 합니다.  
  
 속성 값이 종속성 속성을 상속 합니다. 에 대 한 다른 값이 없는 자식 요소가 많은 경우 <xref:System.Windows.FrameworkElement.Language%2A> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정 수는 <xref:System.Windows.FrameworkElement.Language%2A> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.Language" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소를 배치하고 렌더링하여 상호 작용할 준비가 되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 라우트된 이벤트를 직접 경로 따르지 않는, 에서만 발생 하는 동일한 요소 내에서 처리 됩니다. 라우트된 이벤트에 다른 라우트된 이벤트 동작 지원 않는 직접: 액세스할 수 있는 처리기 컬렉션을 지원 하며으로 사용할 수는 <xref:System.Windows.EventTrigger> 스타일에서입니다.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|라우팅 전략|직접|  
|대리자|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소의 논리적 자식 요소에 대한 열거자를 가져옵니다.</summary>
        <value>이 요소의 논리적 자식 요소에 대한 열거자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> 및 <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, 참조 [In WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">포커스를 이동할 방향(열거형의 값)입니다.</param>
        <summary>키보드 포커스를 이 요소에서 다른 요소로 이동합니다.</summary>
        <returns>포커스가 이동되었으면 <see langword="true" /> 를 반환하고, 지정된 방향에 대상 요소가 없으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소를 식별하는 이름을 가져오거나 설정합니다. 이 이름은 이벤트 처리기 코드 등의 프로그래밍 방식 코드 숨김 항목이 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문 분석 중에 생성된 요소를 참조할 수 있도록 인스턴스 참조를 제공합니다.</summary>
        <value>요소의 이름을 나타내며</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 가장 일반적인 사용법은 지정 하는 경우는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 태그에서 요소 이름입니다.  
  
 이 속성에는 기본적으로 설정 하는 WPF 프레임 워크 수준 편의 속성은 제공 된 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name 지시문](~/docs/framework/xaml-services/x-name-directive.md)합니다.  
  
 가져오기는 <xref:System.Windows.FrameworkContentElement.Name%2A> 코드에서은 코드에 적절 한 참조가 이미 있는 경우 방금 메서드를 호출할 수 있습니다 및 요소에 속성을 참조 하지 않으면 일반적으로 필요 하기 때문에 <xref:System.Windows.FrameworkContentElement.Name%2A>합니다. 예외는 문자열에 오버 로드 된 의미가 경우, 예를 들어이에 해당 이름을 표시 하는 유용한 경우 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]합니다. 설정 된 <xref:System.Windows.FrameworkContentElement.Name%2A> 코드에서 경우 원래 <xref:System.Windows.FrameworkContentElement.Name%2A> 가 태그에서 설정도 권장 되지 않습니다 및 속성을 변경 해도 개체 참조가 변경 되지 것입니다. 기본 이름 범위를 명시적으로 하는 동안 만든 경우에 이러한 개체 참조가 만들어집니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 로드 합니다.  
  
 명시적으로 호출 해야 <xref:System.Windows.FrameworkContentElement.RegisterName%2A> 에 대 한 효과적인 변경 되도록는 <xref:System.Windows.FrameworkContentElement.Name%2A> 이미 로드 된 요소의 속성입니다.  
  
 해야 하는 대표적인에서는 설정 경우 <xref:System.Windows.FrameworkContentElement.Name%2A> 코드에서 storyboard 명명 요소에 대해 실행 됩니다. 이름을 등록할 수 있습니다, 전에 인스턴스화하고 할당 해야 할 수도 <xref:System.Windows.NameScope> 인스턴스. 예 섹션을 참조 하거나 [적기](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)합니다.  
  
 설정 <xref:System.Windows.FrameworkContentElement.Name%2A> 에서 코드 응용 프로그램을 제한 하지만 특히 여기서 응용 프로그램 페이지가 다시 로드 하 고 런타임 코드는 반드시 해당 코드 숨김 하지 탐색 모델을 사용 하는 경우에 일반적으로 더는 요소 이름으로 조회 각 페이지입니다. 유틸리티 메서드 <xref:System.Windows.FrameworkContentElement.FindName%2A>에서 사용 하지 않는 <xref:System.Windows.FrameworkContentElement>, 별로 모든 요소를 찾을 수 <xref:System.Windows.FrameworkContentElement.Name%2A> 해당 요소의 논리적 트리에서 재귀적으로 합니다. 또는 사용할 수 있습니다는 <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> 의 정적 메서드 <xref:System.Windows.LogicalTreeHelper>, 또한를 사용 하는 <xref:System.Windows.FrameworkContentElement.Name%2A> 인수로 문자열입니다.  
  
 일반적으로 사용 되는 루트 요소 (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> 예를 들어) 인터페이스를 구현 <xref:System.Windows.Markup.INameScope>합니다. 이 인터페이스의 구현 적용 이름이 해당 범위 내에서 모호한 것으로 예상 됩니다.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.Name" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대한 데이터를 제공합니다.</param>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다. 이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 구현이 없습니다. 상속의 중간 클래스가이 메서드를 구현 하는 경우에 기본 구현을 호출 해야 합니다.  
  
 이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 * 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다. 이 경우 일치 하는 이벤트 라우트된 이벤트가입니다. On * 메서드의 구현 패턴 차이가 있는 라우트된 이벤트의 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 있습니다. 따라서 구현을 고려할 이벤트 인수의 원본 속성을 갖습니다 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안). 서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다. 이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대한 이벤트 데이터입니다.</param>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다. 이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 구현이 없습니다. 상속의 중간 클래스가이 메서드를 구현 하는 경우에 base ()를 호출 해야 합니다.  
  
 이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 * 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다. 이 경우 일치 하는 이벤트 라우트된 이벤트가입니다. On * 메서드의 구현 패턴 차이가 있는 라우트된 이벤트에 대 한 구현이 이벤트 인수는 소스를 수행 해야 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 계정에는 속성 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안). 서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다. 이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대한 이벤트 데이터입니다.</param>
        <summary>
          <see cref="E:System.Windows.ContentElement.GotFocus" /> 이벤트에 대한 클래스 처리기입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스 처리기는이 요소에서 이벤트가 생성 된 경우이 요소에 적절 한 포커스 동작을 설정 합니다. 이벤트의 소스 트리의 다른 요소를 한 경우 처리기는 아무 작업도 수행 하지 않습니다.  
  
 이러한 기본 요소에서 포커스 동작을 변경 하려면이 메서드를 재정의 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대한 이벤트 데이터입니다.</param>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> 이벤트를 발생시킵니다. 이 메서드는 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" />가 <see langword="true" />로 설정될 때마다 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 항목의 앞부분에 설명 된 대로이 가상 메서드의 기본 구현에서 이벤트가 발생 합니다. 재정의이 동작을 유지 하려면 base ()를 호출 해야 합니다.  
  
 <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> 속성은 읽기 전용입니다. 따라서 이런 방식으로 초기화 동작을 강제 적용 하도록 설정할 수 없습니다. 초기화 설정은 에서만 수행할 수는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 프레임 워크입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">기존 값 및 새 값을 포함하여 변경된 속성을 설명하는 이벤트 데이터입니다.</param>
        <summary>이 <see cref="T:System.Windows.FrameworkContentElement" />에서 종속성 속성의 유효 값이 업데이트될 때마다 호출됩니다. 변경된 특정 종속성 속성이 인수 매개 변수에서 보고됩니다. <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />를 재정의합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 속성 변경 내용 또는 무효화를 검색 하려면이 메서드를 사용 하는 것이 없습니다. 대신 것은 일반적인 무효화 패턴의 수정에 대 한 속성의 광범위 한 분류에 대 한 특정 정보가 알려져 있는 경우.  
  
 이 메서드는 개체의 수명 동안 여러 번 호출 될 수도 있습니다. 따라서 특정 속성의 메타 데이터를 무시 하 고 다음 연결 성능을 향상 시킬 수 있습니다 <xref:System.Windows.CoerceValueCallback> 또는 <xref:System.Windows.PropertyChangedCallback> 개별 속성에 대 한 함수입니다. 그러나, 사용이 메서드는 경우는 <xref:System.Windows.FrameworkContentElement> 많은 수의 값을 상호 연관 된 종속성 속성을 포함 하는 렌더링 동작 다시 실행 해야 다양 한 관련 속성 무효화의 경우와 같은 논리를 포함 하는 경우 또는 합니다.  
  
 같은 이름의 `OnPropertyChanged` 를 다른 서명으로 메서드 (매개 변수 형식이 <xref:System.ComponentModel.PropertyChangedEventArgs>)는 다양 한 클래스에 나타날 수 있는 합니다. `OnPropertyChanged` 데이터 개체 알림에 사용 되 고에 대 한 계약의 일부인 <xref:System.ComponentModel.INotifyPropertyChanged>합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>항상 구현에서 첫 번째 작업으로 기본 구현을 호출 합니다. 이렇게 하지 않으면 전체 없게 되므로 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 속성 시스템에 잘못 된 값을 보고 합니다.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">이전 스타일입니다.</param>
        <param name="newStyle">새 스타일입니다.</param>
        <summary>이 요소에서 사용 중인 스타일이 변경될 때 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 스타일 변경 조건을 나타내는 내부 플래그를 설정 하는 기본 구현입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>항상 기본 구현을 호출, 그렇지 않으면 스타일을 적용할 수 없습니다. 파생 된 클래스에 특수화 된 스타일 선택기 또는 스타일 값을 캐시 하는 경우이 메서드를 재정의 하는 것에 대 한 시나리오 포함 될 수 있습니다. 테마 변경은 잠재적으로이 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대한 데이터를 제공합니다.</param>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다. 이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 구현이 없습니다. 상속의 중간 클래스가이 메서드를 구현 하는 경우에 base ()를 호출 해야 합니다.  
  
 이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 * 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다. 이 경우 일치 하는 이벤트 라우트된 이벤트가입니다. On * 메서드의 구현 패턴 차이가 있는 라우트된 이벤트에 대 한 구현이 이벤트 인수는 소스를 수행 해야 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 계정에는 속성 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안). 서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다. 이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대한 데이터를 제공합니다.</param>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> 라우트된 이벤트가 해당 경로에서 이 클래스에 도달할 때마다 호출됩니다. 이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 구현이 없습니다. 상속의 중간 클래스가이 메서드를 구현 하는 경우에 base ()를 호출 해야 합니다.  
  
 이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 * 방법: 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 파생된 클래스에서 일치 하는 이벤트를 처리 하는 방법을 제공 합니다. 이 경우 일치 하는 이벤트 라우트된 이벤트가입니다. On * 메서드의 구현 패턴 차이가 있는 라우트된 이벤트에 대 한 이벤트 인수는 소스를 구현 해야 합니다 하므로 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 계정에는 속성 (및 다시 대부분의 경우에서 이벤트를 발생 시키면 안). 서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다. 이벤트의 인수를 사용 하 여 의도적으로 사용 이벤트를 경로 단축할 수 있습니다는 한 가지 잠재적인 시나리오입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소가 테마 스타일에서 스타일 속성을 통합하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          이 요소가 테마 스타일 속성을 사용하지 않으면 <see langword="true" />입니다. 이 경우 스타일에서 생성되는 모든 속성은 로컬 응용 프로그램 스타일에서 가져오며, 테마 스타일 속성은 적용되지 않습니다. 응용 프로그램 스타일이 먼저 적용된 다음 응용 프로그램 스타일에 구체적으로 설정되어 있지 않은 속성에 대해 테마 스타일이 적용되면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 가장 일반적인 사용법은 테마 스타일을 제공 하는 스타일의 setter 내에서 간접적으로 사용 합니다.  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>논리적 트리에서 이 요소의 부모를 가져옵니다.</summary>
        <value>이 요소의 논리적 부모입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Note 요소의 논리적 부모 응용 프로그램 기능에 따라 변경 될 수 있습니다 및이 속성의 값을 유지 해도 해당 변경 내용을 반영 되지 것입니다. 일반적으로 필요한 직전 값을 가져올 해야 합니다.  
  
 참조 [In WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) 요소 검색에 이러한 방식을 사용 하는 것이 적절 한 논리 트리 및 시나리오 통과 하는 방법에 대 한 자세한 내용은 합니다.  
  
 속성 시스템에서는 다시 계산할 수 요소의 모든 속성 값, 부모가 때 일부 속성 논리 트리를 통해 값을 상속 하기 때문에 있습니다. <xref:System.Windows.FrameworkContentElement.DataContext%2A> 적용 되는 바인딩 요소는 부모가 때 변경도 수 있습니다.  
  
 요소의 부모는 일반적으로을 통해 변경할 컬렉션 조작, 전용을 사용 하 여 추가 또는 제거 메서드, 또는 요소의 콘텐츠 속성을 설정 하는 과정입니다.  
  
 사용 하는 가장 일반적인 시나리오는 <xref:System.Windows.FrameworkContentElement.Parent%2A> 속성은 다양 한를 가져온 후 한 참조를 가져올를 <xref:System.Windows.FrameworkContentElement> 부모 개체에서 속성 값입니다. 서식 파일에 대 한는 <xref:System.Windows.FrameworkContentElement.Parent%2A> 템플릿의 됩니다 `null`합니다. 이 지점을 벗어나 템플릿을 실제로 적용 되는 논리 트리로 확장을 사용 하 여 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>합니다.  
  
   
  
## Examples  
 확인 하는 다음 예제 여부는 <xref:System.Windows.FrameworkContentElement.Parent%2A> 의 <xref:System.Windows.Documents.TextPointer> 특정 형식입니다.  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">예상 포커스 변경을 결정할 방향입니다.</param>
        <summary>제공된 포커스 이동 방향에 대해 이 요소를 기준으로 포커스를 받을 다음 요소를 결정하며 실제로 포커스를 이동하지는 않습니다. 이 메서드는 봉인되어 있으며 재정의할 수 없습니다.</summary>
        <returns>포커스를 실제로 이동하면 포커스가 이동할 다음 요소입니다. 제공된 방향에 대해 이 요소를 기준으로 포커스를 이동할 수 없는 경우 <see langword="null" />이 반환될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> 실제로 포커스를 이동 하는 관련된 방법.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="T:System.Windows.Input.TraversalRequest" />에서 <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /> 중 한 방향을 지정합니다. 이러한 방향은 <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />에 사용할 수 없지만 <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />에는 사용할 수 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">지정된 이름-개체 매핑에 사용할 이름입니다.</param>
        <param name="scopedElement">매핑을 위한 개체입니다.</param>
        <summary>
          <see cref="T:System.Windows.NameScope" /> 등록 메서드에 대한 액세스를 간소화하는 접근자를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 호출에 대 한 편리한 메서드입니다 <xref:System.Windows.NameScope.RegisterName%2A>합니다. 적용 가능한 될 때까지 구현 연속 된 부모 요소를 확인 합니다 <xref:System.Windows.NameScope> 구현 하는 요소를 검색 하 여 액세스할 수 있는 구현 <xref:System.Windows.Markup.INameScope>합니다. 네임 스페이스에 대 한 자세한 내용은 참조 [WPF XAML 이름 범위](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)합니다.  
  
 호출 <xref:System.Windows.FrameworkContentElement.RegisterName%2A> 올바르게 코드에서 만들어진 경우 응용 프로그램에 대 한 애니메이션 스토리 보드를 연결 하기 위해 필요 합니다. 속성을 스토리 보드 키 중 하나 때문에 이것이 <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, 대상 요소에 대 한 참조 하는 대신 런타임 이름 조회를 사용 합니다. 해당 요소는 코드에서 참조 하 여 액세스할 수 있는 경우에 마찬가지입니다. 스토리 보드 대상에 대 한 이름을 등록 해야 이유에 대 한 자세한 내용은 참조 하십시오. [적기](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)합니다. 콘텐츠 요소에 대 한 애니메이션 컨트롤에 보다 일반적이 지는 [적기](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) 제어 시나리오에 대해 중점적으로 설명 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">제거할 요소입니다.</param>
        <summary>지정된 요소를 이 요소의 논리적 트리에서 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 는 클래스를 파생 시키는 경우 자식 컬렉션에 대 한 지원을 추가 하는 경우에 주로 합니다.  
  
 대부분 <xref:System.Windows.FrameworkContentElement> 포함에 대 한 역할을 하는 전용된 컬렉션을 노출 하는 파생 된 클래스 (예를 들어 <xref:System.Windows.Documents.Span.Inlines%2A> 에 <xref:System.Windows.Documents.Span> 클래스입니다. <xref:System.Windows.Documents.Section.Blocks%2A> 에 <xref:System.Windows.Documents.Section> 클래스). 일반적으로 이러한 클래스에서 파생 논리 트리를 직접 조작 필요를 방지할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 로컬로 정의된 리소스 사전을 가져오거나 설정합니다.</summary>
        <value>현재 로컬로 정의된 리소스입니다. 이 사전은 리소스 사전으로, 키를 사용하여 사전 내의 리소스에 액세스합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 완전히 또는 부분적으로 정의할 수 있는 리소스 사전 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 개별 페이지 또는 응용 프로그램에 대 한 루트 요소에는 일반적으로 및 속성 요소로 일반적으로 만들어집니다. 이 수준에서 리소스 사전을 배치 쉽게 페이지의 개별 자식 요소 (또는 응용 프로그램의 경우에는 페이지)를 찾을 수 있습니다. 대부분의 응용 프로그램 시나리오의 리소스 사전에서 개체 요소로 스타일을 정의 하는 것 권장 전체 스타일 리소스 자체 포함 될 수 있도록 외부 리소스로 정의 된 또는 (이 방법은 별도 디자이너를 사용 하면. 책임을 편집 해야 하는 물리적 파일을 구분 하 여 개발자 책임).  
  
 이 속성에서 반환 하는 리소스 사전에만 해당 요소 내부에서 직접 선언 참고 합니다. 이 자식 요소를 위쪽으로 재귀적으로 검색 되는 각 부모 요소에 정의 된 리소스에 액세스할 수 있는 실제 리소스 조회 프로세스와 다릅니다.  
  
 리소스에서 리소스를 만들 수 있지만 컬렉션 내에서 코드에 의해 참조 될 수도 있습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 를 확실 하 게 액세스할 수 없는까지 후 <xref:System.Windows.FrameworkContentElement.Loaded> 사전을 선언 하는 요소에 의해 발생 합니다. 리소스의 비동기적으로 구문 분석 되 고 아니더라도 실제로 <xref:System.Windows.FrameworkContentElement.Loaded> 이벤트는 참조할 수 있는 보증은 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 리소스를 정의 합니다. 따라서 일반적으로 액세스 해야 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 또는 다른를 통해 런타임 코드의 일부로 정의 된 리소스 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 스타일이 나 특성 값에 대 한 리소스 확장 참조 하는 기법입니다. 기본적으로 해당에서 만든 참조 하는 코드를 통해 리소스에 액세스할 때 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 내부 <xref:System.Windows.ResourceDictionary> 추가, 제거 또는 코드를 사용 하 여 컬렉션 내에서 리소스를 쿼리 하는 데 필요한 메서드를 지원 합니다. <xref:System.Windows.FrameworkContentElement.Resources%2A> 속성은 완전히 리소스 컬렉션을 새로운 또는 다른 요소를 교체 하는 시나리오를 지원 하기 위해 설정할 수 <xref:System.Windows.ResourceDictionary>합니다.  
  
 에 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 표시 된 구문에 대 한 요소를 포함 하지 않습니다는 <xref:System.Windows.ResourceDictionary>합니다. 이것이; 암시적 컬렉션 구문의 예 컬렉션 요소를 나타내는 태그를 생략할 수 있습니다. 컬렉션에 항목으로 추가 하는 요소 대신 지정 됩니다. 암시적 컬렉션에 대 한 자세한 내용은 및 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], 참조 [XAML 구문에서 세부](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)합니다. 한 가지 경우 여기서는 <xref:System.Windows.ResourceDictionary> 병합된 된 사전을 도입 하는 경우에서 많은 경우 일반적으로 해당 자식 요소가 없는 요소 이므로 명시적으로 지정 되어 <xref:System.Windows.ResourceDictionary>합니다. 자세한 내용은 참조 [자세한](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)합니다.  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>XAML 속성 요소 사용  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML 값  
 *oneOrMoreResourceElements*  
 하나 이상의 개체 요소를 각각 정의 하는 리소스입니다. 각 내에서 각 리소스 속성 요소 <xref:System.Windows.ResourceDictionary> 에 대 한 고유 값이 있어야는 [X:key 지시문](~/docs/framework/xaml-services/x-key-directive.md)에서 값을 검색할 때 고유 키로 제공 되는 <xref:System.Windows.ResourceDictionary>합니다.  
  
   
  
## Examples  
 다음 예에서는 설정는 <xref:System.Windows.FrameworkContentElement.Resources%2A> 컬렉션에는 <xref:System.Windows.Documents.FlowDocument> 루트 요소입니다. <xref:System.Windows.Documents.FlowDocument> 전형적인 선택은 보시 이므로 <xref:System.Windows.FrameworkContentElement> 페이지 루트 또는 응용 프로그램 에서처럼 더 높은 수준에서 루트 요소 및 리소스도 의미 있는 클래스는 일반적으로 저장 됩니다.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 종속성 속성에 대해 이 요소에 바인딩을 연결합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">바인딩된 속성을 식별합니다.</param>
        <param name="path">바인딩에 사용할 소스 속성 이름 또는 속성의 경로입니다.</param>
        <summary>데이터 소스에 대한 경로 정규화로 제공된 소스 속성 이름을 기반으로 이 요소에 바인딩을 연결합니다.</summary>
        <returns>바인딩 상태를 기록합니다. 이 반환 값은 오류 검사에 유용할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 호출에 대 한 편리한 메서드입니다 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>는 현재 인스턴스를 전달 하는 <xref:System.Windows.DependencyObject>, 새 및 <xref:System.Windows.Data.Binding> 제공 된 기준 `path` 매개 변수입니다. 이 서명은 단순한 기본 바인딩을 설정 하는 경우 더 편리 합니다. 기본이 아닌 조건에 대 한 바인딩 속성을 지정 하거나 사용 하려는 해야 할 경우는 <xref:System.Windows.Data.MultiBinding> 또는 <xref:System.Windows.Data.PriorityBinding>, 사용할지는 <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> 서명 합니다.  
  
   
  
## Examples  
 다음 예제에서는 대 한 바인딩을 설정는 <xref:System.Windows.Documents.Paragraph> 요소와 해당 개체는 새 사용자 지정 데이터 개체를 만들어 <xref:System.Windows.FrameworkContentElement.DataContext%2A>, 바인딩 경로 내에 속성을 설정 합니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">바인딩된 속성을 식별합니다.</param>
        <param name="binding">데이터 바인딩을 나타냅니다.</param>
        <summary>제공된 바인딩 개체를 기반으로 하여 이 요소에 바인딩을 연결합니다.</summary>
        <returns>바인딩 상태를 기록합니다. 이 반환 값은 오류 검사에 유용할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 호출에 대 한 편리한 메서드입니다 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>는 현재 인스턴스를 전달 하는 <xref:System.Windows.DependencyObject>합니다.  
  
   
  
## Examples  
 다음 예제에서는 대 한 바인딩을 설정는 <xref:System.Windows.Documents.Paragraph> 새 요소 <xref:System.Windows.Data.Binding> 새로 작성 하는 소스를 설정 하 고 `DateTime` 개체입니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">리소스가 바인딩될 속성입니다.</param>
        <param name="name">리소스의 이름입니다.</param>
        <summary>지정된 이름으로 리소스를 검색하고 지정된 속성에 대해 해당 리소스에 리소스 참조를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 리소스 참조는를 사용 하는 [DynamicResource 태그 확장](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) 태그에 있습니다. 리소스 참조는 런타임에 지연 기준 지정된 된 속성의 값을 제공 하는 내부 식을 작성 합니다. 내부 이벤트를 통해 변경 된 값을 표시 하는 리소스 사전 때마다 또는 현재 요소에 부모가 될 때마다 식이 다시 계산 됩니다 (부모 변경 변경 사전 조회 경로).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>serialization 프로세스에서 이 클래스의 인스턴스에 있는 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 속성의 콘텐츠를 serialize해야 하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 속성 값을 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 반환 됩니다 `true` 키가 지정 된 리소스를 하나 이상 로컬에서이 때만 <xref:System.Windows.FrameworkContentElement.Resources%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>serialization 프로세스에서 이 클래스의 인스턴스에 있는 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 속성의 콘텐츠를 serialize해야 하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <see cref="P:System.Windows.FrameworkContentElement.Style" /> 속성 값을 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 반환 됩니다 `true` 경우는 <xref:System.Windows.Style> 로컬로 설정 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소에서 바인딩에 관여되는 연결된 데이터 소스가 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트 표면에서 <xref:System.Windows.Data.Binding.SourceUpdated> 의해 발생 하는 이벤트 <xref:System.Windows.Data.Binding> 이 요소와 연결 합니다.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소에서 사용할 스타일을 가져오거나 설정합니다.</summary>
        <value>있는 경우 요소에 대해 적용된 기본값이 아닌 스타일입니다. 그렇지 않으면 <see langword="null" />입니다. 기본 생성된 <see cref="T:System.Windows.FrameworkContentElement" />의 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 스타일 종종 테마 설정 또는 일반적으로 리소스 페이지 또는 응용 프로그램 수준 (암시적 스타일)에 의해 해당 유형의 개체에 적용 된 스타일에서 기본 스타일을 제공 합니다. 이 속성은 설정 하거나 반환 하지 기본 (테마) 스타일 않지만 암시적 스타일 또는 명시적 스타일 반환 합니다. 암시적 또는 명시적 스타일의 경우 스타일 되었는지 여부를 리소스로 액세스할 로컬 정의 중요지 않습니다.  
  
 스타일 정의는 몇 가지 제한 사항이 있습니다. 전체를 다시 설정할 수 있습니다 <xref:System.Windows.FrameworkContentElement.Style%2A> 속성을 새 <xref:System.Windows.Style> 언제 든 지는 됩니다 언제 합니다. 그러나 가능한 한 즉시 해당 스타일 로드 된 요소에서 사용 하 게 되는 <xref:System.Windows.Style> 고려해 야 봉인 합니다. 사용 중인 스타일의 개별 속성을 변경 하려고 (컬렉션 내에서 아무 것도 같은 <xref:System.Windows.Style.Setters%2A>) 예외를 throw 합니다. 태그에 정의 된 스타일 (리소스)에 대 한 리소스 사전에서 로드 하거나 내에 포함 된 페이지가 (인라인 스타일)에 대 한 로드 사용 중인 것으로 간주 됩니다.  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> 특별 한 우선 순위가 종속성 속성이입니다. 로컬로 설정 된 스타일은 일반적으로 가장 높은 우선 순위에서 속성 시스템 작동 합니다. 경우는 <xref:System.Windows.FrameworkContentElement.Style%2A> 속성 시스템은 해당 유형을 지정 하는 다시 사용할 수 있는 리소스로 정의 된 암시적 스타일에 대 한 확인 로드 하는 동안이 시점에서 null입니다. 경우이 단계를 스타일은 여전히 null 하면 기본 (테마) 스타일의 스타일을 가져옵니다. 그러나 기본 스타일에 반환 되지 않습니다는 <xref:System.Windows.FrameworkContentElement.Style%2A> 속성 값입니다. 참조 [종속성 속성 값 우선 순위](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)합니다.  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML 값  
 *resourceExtension*  
 다음 중 하나:, 또는. 참조 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)합니다.  
  
 *styleResourceKey*  
 요청 되는 스타일을 식별 하는 키입니다. 기존 리소스를이 키는 한 <xref:System.Windows.ResourceDictionary>합니다.  
  
> [!NOTE]
>  속성 요소 구문은 지원 되지만 권장 하지는 않습니다. 참조 [인라인 스타일 및 템플릿](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)합니다.  사용 하 여 바인딩 참조 또는 <xref:System.Windows.Data.Binding> 가능 하지만 일반적이 지 않은 이기도 합니다.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예에서는 설정는 <xref:System.Windows.FrameworkContentElement.Resources%2A> 컬렉션에는 <xref:System.Windows.Documents.FlowDocument> 루트 요소 다음에 대 한 특정 스타일으로 리소스로 참조는 <xref:System.Windows.Documents.Paragraph>합니다.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.Style" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">요청된 앰비언트 속성의 이름입니다.</param>
        <summary>이 멤버에 대한 설명을 보려면 <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> 메서드를 참조하세요.</summary>
        <returns>
          <paramref name="propertyName" />을 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.FrameworkContentElement> 인스턴스가 <xref:System.Windows.Markup.IQueryAmbient> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소에 대한 사용자 지정 정보를 저장하는 데 사용할 수 있는 임의의 개체 값을 가져오거나 설정합니다.</summary>
        <value>원하는 값입니다. 이 속성에는 기본값이 없습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 다른 Microsoft 프로그래밍 모델에서 응용 프로그램 또는 Windows Forms에 대 한 Visual Basic과 같은 태그 속성과 유사 합니다. 기존 응용 프로그램 개발자가 하위 클래스를 시작 하지 않고 모든 요소에 대 한 몇 가지 기본 사용자 지정 정보를 저장할 위치를 제공 하는 것이 됩니다.  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>XAML 값  
 속성 요소 사용 설정 하는 데 사용 해야 하는 하기 때문에이 속성 개체는 <xref:System.Windows.FrameworkContentElement.Tag%2A> , 문자열 등의 알려진된 기본 제공 형식 변환기를 가진 개체가 아닌 다른 값으로 XAML에서 속성입니다. 이러한 방식으로 사용 되는 개체 일반적으로 표준 WPF 네임 스페이스에 포함 되지 않는 있으며 따라서 해야 네임 스페이스 매핑을 외부 네임 스페이스에 XAML 요소도 합니다.  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.Tag" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소의 바인딩에 참여하는 연결된 대상 속성이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트 표면에서 <xref:System.Windows.Data.Binding.TargetUpdated> 의해 발생 하는 이벤트 <xref:System.Windows.Data.Binding> 이 요소와 연결 합니다. 이 일반적으로 해당 바인딩이 양방향 바인딩에 바인딩된 종속성 속성은 모든 유효성 검사 또는 속성이 지원 캐싱 체계 별로 이전 속성 값의 무효화 함을 의미 합니다.  
  
 이 이벤트의 이벤트 인수는 어떤 바인딩된 속성이 변경 된에 알립니다.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소의 템플릿 부모에 대한 참조를 가져옵니다. 요소가 템플릿을 통해 만들어지지 않은 경우에는 이 속성이 관련이 없습니다.</summary>
        <value>요소를 <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> 이 요소를 만들 수 있습니다. 이 값은 대개 <see langword="null" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 템플릿은 실제로 공유 개체를 서식 파일의 내용을 한 번만 생성 됩니다. 따라서 서식 파일에서 생성 된 요소에 대 한 개체 참조를 가져오는 경우 명백한 논리적 트리 루트 페이지에 도달 하지 않도록 알 수 있습니다. 이러한 서식 파일 참조 페이지의 논리 트리를을 연결 하기 위해 얻어야는 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 값과 계속를 원하는 대로 해당 요소 트리를 탐색 합니다.  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 자주 `null` 일반 개체에 대 한 일반적인 수단을 통해 응용 프로그램에서 페이지 확장 개체 참조를 얻은 경우 해당 요소 아마도 만들어지지 않아 템플릿에서 합니다. 인 사례 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 하지 못할 `null` 낮은 수준의 특정 입력 이벤트를 처리 하거나 템플릿에서 생성 되는 요소를 반환 했거나 열거자 작업 적중 테스트, 이벤트 등의 작업을 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]에서 이 요소에 대해 표시되는 도구 설명 개체를 가져오거나 설정합니다.</summary>
        <value>도구 설명 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 값 형식인 경우 <xref:System.Windows.Controls.ToolTip>, 다음에 사용 되는 도구 설명 되는 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]합니다.  값이 다른 형식의 경우 해당 값으로 사용 됩니다는 *콘텐츠* 에 대 한는 <xref:System.Windows.Controls.ToolTip> 제공 (생성 된) 시스템에서 합니다. 자세한 내용은 <xref:System.Windows.Controls.ToolTipService>을 참조하세요. 서비스 클래스는 추가로 도구 설명을 사용자 지정 하는 데 사용할 수 있는 연결 된 속성을 제공 합니다.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>XAML 속성 요소 사용  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML 값  
 *toolTipContent*  
 에 대 한 표시 텍스트 되는 문자열은 <xref:System.Windows.FrameworkContentElement.ToolTip%2A>합니다.  
  
 *toolTipObjectContent*  
 에 대 한 내용으로 사용 해야 하는 개체 요소 형태에 제공 된 일부 개체는 <xref:System.Windows.FrameworkContentElement> 합니다. 됩니다는 <xref:System.Windows.FrameworkElement> 또는 다른 요소에 대 한 레이아웃 합성을 만드는 <xref:System.Windows.FrameworkContentElement.ToolTip%2A>를 포함 하는 텍스트 콘텐츠입니다. 이 사용법에서는 <xref:System.Windows.Controls.ToolTip> 요소가 만들어집니다 구문 분석 된에서 암시적으로 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], 및 *toolTipObjectContent* 내용이 설정으로 해당 <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> 속성입니다.  
  
 <`ToolTip` .../>  
 <xref:System.Windows.Controls.ToolTip>을 참조하세요.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 값을 설정 하는 다음 예제는 <xref:System.Windows.FrameworkElement.ToolTip%2A> 속성 문자열을 직접 합니다.  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소의 도구 설명을 닫기 직전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 도구 설명 닫기를 표시 하지 않으려면 이벤트의 처리기 것으로 표시 해야 처리 합니다.  
  
 이 이벤트는 <xref:System.Windows.EventTrigger> 스타일에서입니다. 이 이벤트의 식별자 필드에는 다시 이벤트를 추가/제거 메서드를 노출 하지 않는 서비스의 구현을 사용 하기 때문입니다.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|라우팅 전략|직접|  
|대리자|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소의 도구 설명이 열리면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 도구 설명을 열어야 하는 처리 된 것으로 이벤트의 처리기 관련 이벤트를 표시 해야 합니다. 그렇지 않은 경우의 값은 <xref:System.Windows.FrameworkContentElement.ToolTip%2A> 를 자동으로 상황에 맞는 메뉴를 열려면 속성을 사용 합니다. 이벤트를 처리 된을 효과적으로 기본 작업을 취소 하 고 수 값을 다시 설정 하는 <xref:System.Windows.FrameworkContentElement.ToolTip%2A> 속성을 열고 새 <xref:System.Windows.Controls.ContextMenu>합니다. 확인 하는 경우이 이벤트가 발생 하지 것입니다 <xref:System.Windows.FrameworkContentElement.ToolTip%2A> 가 null 참조 또는 그렇지 않은 경우 해제 합니다.  
  
 이 이벤트는 <xref:System.Windows.EventTrigger> 스타일에서입니다. 이 이벤트의 식별자 필드에는 다시 이벤트를 추가/제거 메서드를 노출 하지 않는 서비스의 구현을 사용 하기 때문입니다.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|라우팅 전략|직접|  
|대리자|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">찾을 리소스의 키 식별자입니다.</param>
        <summary>지정된 키를 사용하여 리소스를 검색하고 해당 리소스를 반환합니다(있는 경우).</summary>
        <returns>찾은 리소스입니다. 리소스가 없으면 <see langword="null" />이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 트리 수는 동일한 방식으로 논리적 트리를 사용 하 여 부모 트리를 검색 된 리소스 호출 하는 요소에 없는 경우 실행 시 키에 의해 동적 리소스 참조를 요청 하는 경우를 검색 합니다.  
  
 일반적으로 반환 값을 반환 되는 리소스 값으로 설정 하 려 했던 하는 속성의 형식 캐스팅 즉시 것입니다.  
  
 <xref:System.Windows.FrameworkContentElement.FindResource%2A> 메서드가 비슷한 동작을 제외 하 고 제공 된 키와 리소스를 찾지 못하는 경우 예외가 throw 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 태그에서 정의 된 대로 리소스를 찾아 특정 라우트된 이벤트에 대 한 응답에 있는 요소의 속성에 적용 됩니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>로드된 요소의 요소 트리에서 요소를 제거할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 라우트된 이벤트를 직접 경로 따르지 않는, 에서만 발생 하는 동일한 요소 내에서 처리 됩니다. 라우트된 이벤트에 다른 라우트된 이벤트 동작 지원 않는 직접: 액세스할 수 있는 처리기 컬렉션을 지원 하며으로 사용할 수는 <xref:System.Windows.EventTrigger> 스타일에서입니다.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|라우팅 전략|직접|  
|대리자|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">현재 범위에서 제거할 이름-개체 쌍의 이름입니다.</param>
        <summary>
          <see cref="T:System.Windows.NameScope" /> 등록 취소 메서드에 대한 액세스를 간소화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하기만 하면 등록을 취소할 이름에 동일한 이름 갖는 다른 요소의 하려는 경우.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>기본 스타일을 현재 <see cref="T:System.Windows.FrameworkContentElement" />에 다시 적용합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>